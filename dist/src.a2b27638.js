// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"node_modules/three/build/three.module.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AlwaysStencilFunc = exports.AlwaysDepth = exports.AlphaFormat = exports.AdditiveBlending = exports.AdditiveAnimationBlendMode = exports.AddOperation = exports.AddEquation = exports.ACESFilmicToneMapping = void 0;
exports.AmbientLight = AmbientLight;
exports.AmbientLightProbe = AmbientLightProbe;
exports.AnimationClip = AnimationClip;
exports.AnimationLoader = AnimationLoader;
exports.AnimationMixer = AnimationMixer;
exports.AnimationObjectGroup = AnimationObjectGroup;
exports.AnimationUtils = void 0;
exports.ArcCurve = ArcCurve;
exports.ArrayCamera = ArrayCamera;
exports.AudioListener = exports.AudioContext = exports.AudioAnalyser = exports.Audio = exports.ArrowHelper = void 0;
exports.AudioLoader = AudioLoader;
exports.AxesHelper = void 0;
exports.AxisHelper = AxisHelper;
exports.BasicShadowMap = exports.BasicDepthPacking = exports.BackSide = void 0;
exports.BinaryTextureLoader = BinaryTextureLoader;
exports.Bone = Bone;
exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
exports.BoundingBoxHelper = BoundingBoxHelper;
exports.BoxHelper = exports.BoxGeometry = exports.BoxBufferGeometry = exports.Box3Helper = exports.Box3 = exports.Box2 = void 0;
exports.BufferAttribute = BufferAttribute;
exports.BufferGeometry = BufferGeometry;
exports.BufferGeometryLoader = BufferGeometryLoader;
exports.Cache = exports.ByteType = void 0;
exports.Camera = Camera;
exports.CameraHelper = void 0;
exports.CanvasRenderer = CanvasRenderer;
exports.CanvasTexture = CanvasTexture;
exports.CatmullRomCurve3 = CatmullRomCurve3;
exports.Clock = exports.ClampToEdgeWrapping = exports.CircleGeometry = exports.CircleBufferGeometry = exports.CineonToneMapping = void 0;
exports.ClosedSplineCurve3 = ClosedSplineCurve3;
exports.Color = void 0;
exports.ColorKeyframeTrack = ColorKeyframeTrack;
exports.CompressedTexture = CompressedTexture;
exports.CompressedTextureLoader = CompressedTextureLoader;
exports.ConeGeometry = exports.ConeBufferGeometry = void 0;
exports.CubeCamera = CubeCamera;
exports.CubeRefractionMapping = exports.CubeReflectionMapping = void 0;
exports.CubeTexture = CubeTexture;
exports.CubeTextureLoader = CubeTextureLoader;
exports.CubeUVRefractionMapping = exports.CubeUVReflectionMapping = void 0;
exports.CubicBezierCurve = CubicBezierCurve;
exports.CubicBezierCurve3 = CubicBezierCurve3;
exports.CubicInterpolant = CubicInterpolant;
exports.CullFaceNone = exports.CullFaceFrontBack = exports.CullFaceFront = exports.CullFaceBack = void 0;
exports.Curve = Curve;
exports.CurvePath = CurvePath;
exports.Cylindrical = exports.CylinderGeometry = exports.CylinderBufferGeometry = exports.CustomToneMapping = exports.CustomBlending = void 0;
exports.DataTexture = DataTexture;
exports.DataTexture2DArray = DataTexture2DArray;
exports.DataTexture3D = DataTexture3D;
exports.DataTextureLoader = DataTextureLoader;
exports.DepthStencilFormat = exports.DepthFormat = exports.DefaultLoadingManager = exports.DecrementWrapStencilOp = exports.DecrementStencilOp = exports.DataUtils = void 0;
exports.DepthTexture = DepthTexture;
exports.DirectionalLight = DirectionalLight;
exports.DirectionalLightHelper = void 0;
exports.DiscreteInterpolant = DiscreteInterpolant;
exports.DstColorFactor = exports.DstAlphaFactor = exports.DoubleSide = exports.DodecahedronGeometry = exports.DodecahedronBufferGeometry = void 0;
exports.DynamicBufferAttribute = DynamicBufferAttribute;
exports.EdgesGeometry = exports.DynamicReadUsage = exports.DynamicDrawUsage = exports.DynamicCopyUsage = void 0;
exports.EdgesHelper = EdgesHelper;
exports.EllipseCurve = EllipseCurve;
exports.Euler = exports.EquirectangularRefractionMapping = exports.EquirectangularReflectionMapping = exports.EqualStencilFunc = exports.EqualDepth = void 0;
exports.EventDispatcher = EventDispatcher;
exports.Face3 = exports.ExtrudeGeometry = exports.ExtrudeBufferGeometry = void 0;
exports.Face4 = Face4;
exports.FaceColors = void 0;
exports.FileLoader = FileLoader;
exports.FlatShading = void 0;
exports.Float16BufferAttribute = Float16BufferAttribute;
exports.Float32Attribute = Float32Attribute;
exports.Float32BufferAttribute = Float32BufferAttribute;
exports.Float64Attribute = Float64Attribute;
exports.Float64BufferAttribute = Float64BufferAttribute;
exports.Font = exports.FogExp2 = exports.Fog = exports.FloatType = void 0;
exports.FontLoader = FontLoader;
exports.Frustum = exports.FrontSide = void 0;
exports.GLBufferAttribute = GLBufferAttribute;
exports.GridHelper = exports.GreaterStencilFunc = exports.GreaterEqualStencilFunc = exports.GreaterEqualDepth = exports.GreaterDepth = exports.GeometryUtils = exports.GammaEncoding = exports.GLSL3 = exports.GLSL1 = void 0;
exports.Group = Group;
exports.HalfFloatType = void 0;
exports.HemisphereLight = HemisphereLight;
exports.HemisphereLightHelper = void 0;
exports.HemisphereLightProbe = HemisphereLightProbe;
exports.IcosahedronGeometry = exports.IcosahedronBufferGeometry = void 0;
exports.ImageBitmapLoader = ImageBitmapLoader;
exports.ImageLoader = ImageLoader;
exports.ImageUtils = void 0;
exports.ImmediateRenderObject = ImmediateRenderObject;
exports.IncrementWrapStencilOp = exports.IncrementStencilOp = void 0;
exports.InstancedBufferAttribute = InstancedBufferAttribute;
exports.InstancedBufferGeometry = InstancedBufferGeometry;
exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
exports.InstancedMesh = InstancedMesh;
exports.Int16Attribute = Int16Attribute;
exports.Int16BufferAttribute = Int16BufferAttribute;
exports.Int32Attribute = Int32Attribute;
exports.Int32BufferAttribute = Int32BufferAttribute;
exports.Int8Attribute = Int8Attribute;
exports.Int8BufferAttribute = Int8BufferAttribute;
exports.IntType = void 0;
exports.InterleavedBuffer = InterleavedBuffer;
exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
exports.Interpolant = Interpolant;
exports.InvertStencilOp = exports.InterpolateSmooth = exports.InterpolateLinear = exports.InterpolateDiscrete = void 0;
exports.JSONLoader = JSONLoader;
exports.KeepStencilOp = void 0;
exports.KeyframeTrack = KeyframeTrack;
exports.LOD = LOD;
exports.Layers = exports.LatheGeometry = exports.LatheBufferGeometry = void 0;
exports.LensFlare = LensFlare;
exports.LessStencilFunc = exports.LessEqualStencilFunc = exports.LessEqualDepth = exports.LessDepth = void 0;
exports.Light = Light;
exports.LightProbe = LightProbe;
exports.Line = Line;
exports.Line3 = void 0;
exports.LineBasicMaterial = LineBasicMaterial;
exports.LineCurve = LineCurve;
exports.LineCurve3 = LineCurve3;
exports.LineDashedMaterial = LineDashedMaterial;
exports.LineLoop = LineLoop;
exports.LinePieces = void 0;
exports.LineSegments = LineSegments;
exports.LinearFilter = exports.LinearEncoding = exports.LineStrip = void 0;
exports.LinearInterpolant = LinearInterpolant;
exports.LinearToneMapping = exports.LinearMipmapNearestFilter = exports.LinearMipmapLinearFilter = exports.LinearMipMapNearestFilter = exports.LinearMipMapLinearFilter = void 0;
exports.Loader = Loader;
exports.LoaderUtils = void 0;
exports.LoadingManager = LoadingManager;
exports.MOUSE = exports.LuminanceFormat = exports.LuminanceAlphaFormat = exports.LoopRepeat = exports.LoopPingPong = exports.LoopOnce = exports.LogLuvEncoding = void 0;
exports.Material = Material;
exports.MaterialLoader = MaterialLoader;
exports.MaxEquation = exports.Matrix4 = exports.Matrix3 = exports.MathUtils = exports.Math = void 0;
exports.Mesh = Mesh;
exports.MeshBasicMaterial = MeshBasicMaterial;
exports.MeshDepthMaterial = MeshDepthMaterial;
exports.MeshDistanceMaterial = MeshDistanceMaterial;
exports.MeshFaceMaterial = MeshFaceMaterial;
exports.MeshLambertMaterial = MeshLambertMaterial;
exports.MeshMatcapMaterial = MeshMatcapMaterial;
exports.MeshNormalMaterial = MeshNormalMaterial;
exports.MeshPhongMaterial = MeshPhongMaterial;
exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
exports.MeshStandardMaterial = MeshStandardMaterial;
exports.MeshToonMaterial = MeshToonMaterial;
exports.MixOperation = exports.MirroredRepeatWrapping = exports.MinEquation = void 0;
exports.MultiMaterial = MultiMaterial;
exports.NotEqualStencilFunc = exports.NotEqualDepth = exports.NormalBlending = exports.NormalAnimationBlendMode = exports.NoToneMapping = exports.NoColors = exports.NoBlending = exports.NeverStencilFunc = exports.NeverDepth = exports.NearestMipmapNearestFilter = exports.NearestMipmapLinearFilter = exports.NearestMipMapNearestFilter = exports.NearestMipMapLinearFilter = exports.NearestFilter = exports.MultiplyOperation = exports.MultiplyBlending = void 0;
exports.NumberKeyframeTrack = NumberKeyframeTrack;
exports.Object3D = Object3D;
exports.OneMinusSrcColorFactor = exports.OneMinusSrcAlphaFactor = exports.OneMinusDstColorFactor = exports.OneMinusDstAlphaFactor = exports.OneFactor = exports.OctahedronGeometry = exports.OctahedronBufferGeometry = exports.ObjectSpaceNormalMap = exports.ObjectLoader = void 0;
exports.OrthographicCamera = OrthographicCamera;
exports.PMREMGenerator = exports.PCFSoftShadowMap = exports.PCFShadowMap = void 0;
exports.ParametricGeometry = exports.ParametricBufferGeometry = ParametricGeometry;
exports.Particle = Particle;
exports.ParticleBasicMaterial = ParticleBasicMaterial;
exports.ParticleSystem = ParticleSystem;
exports.ParticleSystemMaterial = ParticleSystemMaterial;
exports.Path = Path;
exports.PerspectiveCamera = PerspectiveCamera;
exports.PlaneHelper = exports.PlaneGeometry = exports.PlaneBufferGeometry = exports.Plane = void 0;
exports.PointCloud = PointCloud;
exports.PointCloudMaterial = PointCloudMaterial;
exports.PointLight = PointLight;
exports.PointLightHelper = void 0;
exports.Points = Points;
exports.PointsMaterial = PointsMaterial;
exports.PositionalAudio = exports.PolyhedronGeometry = exports.PolyhedronBufferGeometry = exports.PolarGridHelper = void 0;
exports.PropertyBinding = PropertyBinding;
exports.PropertyMixer = PropertyMixer;
exports.QuadraticBezierCurve = QuadraticBezierCurve;
exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;
exports.Quaternion = void 0;
exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
exports.RGBAFormat = exports.RGBADepthPacking = exports.REVISION = void 0;
exports.RGIntegerFormat = exports.RGFormat = exports.RGB_S3TC_DXT1_Format = exports.RGB_PVRTC_4BPPV1_Format = exports.RGB_PVRTC_2BPPV1_Format = exports.RGB_ETC2_Format = exports.RGB_ETC1_Format = exports.RGBM7Encoding = exports.RGBM16Encoding = exports.RGBIntegerFormat = exports.RGBFormat = exports.RGBEFormat = exports.RGBEEncoding = exports.RGBDEncoding = exports.RGBA_S3TC_DXT5_Format = exports.RGBA_S3TC_DXT3_Format = exports.RGBA_S3TC_DXT1_Format = exports.RGBA_PVRTC_4BPPV1_Format = exports.RGBA_PVRTC_2BPPV1_Format = exports.RGBA_ETC2_EAC_Format = exports.RGBA_BPTC_Format = exports.RGBA_ASTC_8x8_Format = exports.RGBA_ASTC_8x6_Format = exports.RGBA_ASTC_8x5_Format = exports.RGBA_ASTC_6x6_Format = exports.RGBA_ASTC_6x5_Format = exports.RGBA_ASTC_5x5_Format = exports.RGBA_ASTC_5x4_Format = exports.RGBA_ASTC_4x4_Format = exports.RGBA_ASTC_12x12_Format = exports.RGBA_ASTC_12x10_Format = exports.RGBA_ASTC_10x8_Format = exports.RGBA_ASTC_10x6_Format = exports.RGBA_ASTC_10x5_Format = exports.RGBA_ASTC_10x10_Format = exports.RGBAIntegerFormat = void 0;
exports.RawShaderMaterial = RawShaderMaterial;
exports.Ray = void 0;
exports.Raycaster = Raycaster;
exports.RectAreaLight = RectAreaLight;
exports.ShaderLib = exports.ShaderChunk = exports.SceneUtils = exports.Scene = exports.SRGB8_ALPHA8_ASTC_8x8_Format = exports.SRGB8_ALPHA8_ASTC_8x6_Format = exports.SRGB8_ALPHA8_ASTC_8x5_Format = exports.SRGB8_ALPHA8_ASTC_6x6_Format = exports.SRGB8_ALPHA8_ASTC_6x5_Format = exports.SRGB8_ALPHA8_ASTC_5x5_Format = exports.SRGB8_ALPHA8_ASTC_5x4_Format = exports.SRGB8_ALPHA8_ASTC_4x4_Format = exports.SRGB8_ALPHA8_ASTC_12x12_Format = exports.SRGB8_ALPHA8_ASTC_12x10_Format = exports.SRGB8_ALPHA8_ASTC_10x8_Format = exports.SRGB8_ALPHA8_ASTC_10x6_Format = exports.SRGB8_ALPHA8_ASTC_10x5_Format = exports.SRGB8_ALPHA8_ASTC_10x10_Format = exports.RingGeometry = exports.RingBufferGeometry = exports.ReverseSubtractEquation = exports.ReplaceStencilOp = exports.RepeatWrapping = exports.ReinhardToneMapping = exports.RedIntegerFormat = exports.RedFormat = void 0;
exports.ShaderMaterial = ShaderMaterial;
exports.ShadowMaterial = ShadowMaterial;
exports.Shape = Shape;
exports.ShapeGeometry = exports.ShapeBufferGeometry = void 0;
exports.ShapePath = ShapePath;
exports.ShortType = exports.ShapeUtils = void 0;
exports.Skeleton = Skeleton;
exports.SkeletonHelper = void 0;
exports.SkinnedMesh = SkinnedMesh;
exports.SphericalHarmonics3 = exports.Spherical = exports.SphereGeometry = exports.SphereBufferGeometry = exports.Sphere = exports.SmoothShading = void 0;
exports.Spline = Spline;
exports.SplineCurve = SplineCurve;
exports.SplineCurve3 = SplineCurve3;
exports.SpotLight = SpotLight;
exports.SpotLightHelper = void 0;
exports.Sprite = Sprite;
exports.SpriteMaterial = SpriteMaterial;
exports.StaticReadUsage = exports.StaticDrawUsage = exports.StaticCopyUsage = exports.SrcColorFactor = exports.SrcAlphaSaturateFactor = exports.SrcAlphaFactor = void 0;
exports.StereoCamera = StereoCamera;
exports.StreamReadUsage = exports.StreamDrawUsage = exports.StreamCopyUsage = void 0;
exports.StringKeyframeTrack = StringKeyframeTrack;
exports.TextGeometry = exports.TextBufferGeometry = exports.TetrahedronGeometry = exports.TetrahedronBufferGeometry = exports.TangentSpaceNormalMap = exports.TOUCH = exports.SubtractiveBlending = exports.SubtractEquation = void 0;
exports.Texture = Texture;
exports.TextureLoader = TextureLoader;
exports.UVMapping = exports.TubeGeometry = exports.TubeBufferGeometry = exports.TrianglesDrawMode = exports.TriangleStripDrawMode = exports.TriangleFanDrawMode = exports.Triangle = exports.TorusKnotGeometry = exports.TorusKnotBufferGeometry = exports.TorusGeometry = exports.TorusBufferGeometry = void 0;
exports.Uint16Attribute = Uint16Attribute;
exports.Uint16BufferAttribute = Uint16BufferAttribute;
exports.Uint32Attribute = Uint32Attribute;
exports.Uint32BufferAttribute = Uint32BufferAttribute;
exports.Uint8Attribute = Uint8Attribute;
exports.Uint8BufferAttribute = Uint8BufferAttribute;
exports.Uint8ClampedAttribute = Uint8ClampedAttribute;
exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;
exports.Vector4 = exports.Vector3 = exports.Vector2 = exports.VSMShadowMap = exports.UnsignedShortType = exports.UnsignedShort565Type = exports.UnsignedShort5551Type = exports.UnsignedShort4444Type = exports.UnsignedIntType = exports.UnsignedInt248Type = exports.UnsignedByteType = exports.UniformsUtils = exports.UniformsLib = exports.Uniform = void 0;
exports.VectorKeyframeTrack = VectorKeyframeTrack;
exports.Vertex = Vertex;
exports.VertexColors = void 0;
exports.VideoTexture = VideoTexture;
exports.WebGL1Renderer = WebGL1Renderer;
exports.WebGLRenderTarget = exports.WebGLMultisampleRenderTarget = exports.WebGLCubeRenderTarget = void 0;
exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
exports.WebGLRenderer = WebGLRenderer;
exports.WebGLUtils = WebGLUtils;
exports.WireframeGeometry = void 0;
exports.WireframeHelper = WireframeHelper;
exports.WrapAroundEnding = void 0;
exports.XHRLoader = XHRLoader;
exports.sRGBEncoding = exports.ZeroStencilOp = exports.ZeroSlopeEnding = exports.ZeroFactor = exports.ZeroCurvatureEnding = void 0;
// threejs.org/license
const REVISION = '125';
exports.REVISION = REVISION;
const MOUSE = {
  LEFT: 0,
  MIDDLE: 1,
  RIGHT: 2,
  ROTATE: 0,
  DOLLY: 1,
  PAN: 2
};
exports.MOUSE = MOUSE;
const TOUCH = {
  ROTATE: 0,
  PAN: 1,
  DOLLY_PAN: 2,
  DOLLY_ROTATE: 3
};
exports.TOUCH = TOUCH;
const CullFaceNone = 0;
exports.CullFaceNone = CullFaceNone;
const CullFaceBack = 1;
exports.CullFaceBack = CullFaceBack;
const CullFaceFront = 2;
exports.CullFaceFront = CullFaceFront;
const CullFaceFrontBack = 3;
exports.CullFaceFrontBack = CullFaceFrontBack;
const BasicShadowMap = 0;
exports.BasicShadowMap = BasicShadowMap;
const PCFShadowMap = 1;
exports.PCFShadowMap = PCFShadowMap;
const PCFSoftShadowMap = 2;
exports.PCFSoftShadowMap = PCFSoftShadowMap;
const VSMShadowMap = 3;
exports.VSMShadowMap = VSMShadowMap;
const FrontSide = 0;
exports.FrontSide = FrontSide;
const BackSide = 1;
exports.BackSide = BackSide;
const DoubleSide = 2;
exports.DoubleSide = DoubleSide;
const FlatShading = 1;
exports.FlatShading = FlatShading;
const SmoothShading = 2;
exports.SmoothShading = SmoothShading;
const NoBlending = 0;
exports.NoBlending = NoBlending;
const NormalBlending = 1;
exports.NormalBlending = NormalBlending;
const AdditiveBlending = 2;
exports.AdditiveBlending = AdditiveBlending;
const SubtractiveBlending = 3;
exports.SubtractiveBlending = SubtractiveBlending;
const MultiplyBlending = 4;
exports.MultiplyBlending = MultiplyBlending;
const CustomBlending = 5;
exports.CustomBlending = CustomBlending;
const AddEquation = 100;
exports.AddEquation = AddEquation;
const SubtractEquation = 101;
exports.SubtractEquation = SubtractEquation;
const ReverseSubtractEquation = 102;
exports.ReverseSubtractEquation = ReverseSubtractEquation;
const MinEquation = 103;
exports.MinEquation = MinEquation;
const MaxEquation = 104;
exports.MaxEquation = MaxEquation;
const ZeroFactor = 200;
exports.ZeroFactor = ZeroFactor;
const OneFactor = 201;
exports.OneFactor = OneFactor;
const SrcColorFactor = 202;
exports.SrcColorFactor = SrcColorFactor;
const OneMinusSrcColorFactor = 203;
exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
const SrcAlphaFactor = 204;
exports.SrcAlphaFactor = SrcAlphaFactor;
const OneMinusSrcAlphaFactor = 205;
exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
const DstAlphaFactor = 206;
exports.DstAlphaFactor = DstAlphaFactor;
const OneMinusDstAlphaFactor = 207;
exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
const DstColorFactor = 208;
exports.DstColorFactor = DstColorFactor;
const OneMinusDstColorFactor = 209;
exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
const SrcAlphaSaturateFactor = 210;
exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
const NeverDepth = 0;
exports.NeverDepth = NeverDepth;
const AlwaysDepth = 1;
exports.AlwaysDepth = AlwaysDepth;
const LessDepth = 2;
exports.LessDepth = LessDepth;
const LessEqualDepth = 3;
exports.LessEqualDepth = LessEqualDepth;
const EqualDepth = 4;
exports.EqualDepth = EqualDepth;
const GreaterEqualDepth = 5;
exports.GreaterEqualDepth = GreaterEqualDepth;
const GreaterDepth = 6;
exports.GreaterDepth = GreaterDepth;
const NotEqualDepth = 7;
exports.NotEqualDepth = NotEqualDepth;
const MultiplyOperation = 0;
exports.MultiplyOperation = MultiplyOperation;
const MixOperation = 1;
exports.MixOperation = MixOperation;
const AddOperation = 2;
exports.AddOperation = AddOperation;
const NoToneMapping = 0;
exports.NoToneMapping = NoToneMapping;
const LinearToneMapping = 1;
exports.LinearToneMapping = LinearToneMapping;
const ReinhardToneMapping = 2;
exports.ReinhardToneMapping = ReinhardToneMapping;
const CineonToneMapping = 3;
exports.CineonToneMapping = CineonToneMapping;
const ACESFilmicToneMapping = 4;
exports.ACESFilmicToneMapping = ACESFilmicToneMapping;
const CustomToneMapping = 5;
exports.CustomToneMapping = CustomToneMapping;
const UVMapping = 300;
exports.UVMapping = UVMapping;
const CubeReflectionMapping = 301;
exports.CubeReflectionMapping = CubeReflectionMapping;
const CubeRefractionMapping = 302;
exports.CubeRefractionMapping = CubeRefractionMapping;
const EquirectangularReflectionMapping = 303;
exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
const EquirectangularRefractionMapping = 304;
exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
const CubeUVReflectionMapping = 306;
exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
const CubeUVRefractionMapping = 307;
exports.CubeUVRefractionMapping = CubeUVRefractionMapping;
const RepeatWrapping = 1000;
exports.RepeatWrapping = RepeatWrapping;
const ClampToEdgeWrapping = 1001;
exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
const MirroredRepeatWrapping = 1002;
exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
const NearestFilter = 1003;
exports.NearestFilter = NearestFilter;
const NearestMipmapNearestFilter = 1004;
exports.NearestMipmapNearestFilter = NearestMipmapNearestFilter;
const NearestMipMapNearestFilter = 1004;
exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
const NearestMipmapLinearFilter = 1005;
exports.NearestMipmapLinearFilter = NearestMipmapLinearFilter;
const NearestMipMapLinearFilter = 1005;
exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
const LinearFilter = 1006;
exports.LinearFilter = LinearFilter;
const LinearMipmapNearestFilter = 1007;
exports.LinearMipmapNearestFilter = LinearMipmapNearestFilter;
const LinearMipMapNearestFilter = 1007;
exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
const LinearMipmapLinearFilter = 1008;
exports.LinearMipmapLinearFilter = LinearMipmapLinearFilter;
const LinearMipMapLinearFilter = 1008;
exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
const UnsignedByteType = 1009;
exports.UnsignedByteType = UnsignedByteType;
const ByteType = 1010;
exports.ByteType = ByteType;
const ShortType = 1011;
exports.ShortType = ShortType;
const UnsignedShortType = 1012;
exports.UnsignedShortType = UnsignedShortType;
const IntType = 1013;
exports.IntType = IntType;
const UnsignedIntType = 1014;
exports.UnsignedIntType = UnsignedIntType;
const FloatType = 1015;
exports.FloatType = FloatType;
const HalfFloatType = 1016;
exports.HalfFloatType = HalfFloatType;
const UnsignedShort4444Type = 1017;
exports.UnsignedShort4444Type = UnsignedShort4444Type;
const UnsignedShort5551Type = 1018;
exports.UnsignedShort5551Type = UnsignedShort5551Type;
const UnsignedShort565Type = 1019;
exports.UnsignedShort565Type = UnsignedShort565Type;
const UnsignedInt248Type = 1020;
exports.UnsignedInt248Type = UnsignedInt248Type;
const AlphaFormat = 1021;
exports.AlphaFormat = AlphaFormat;
const RGBFormat = 1022;
exports.RGBFormat = RGBFormat;
const RGBAFormat = 1023;
exports.RGBAFormat = RGBAFormat;
const LuminanceFormat = 1024;
exports.LuminanceFormat = LuminanceFormat;
const LuminanceAlphaFormat = 1025;
exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
const RGBEFormat = RGBAFormat;
exports.RGBEFormat = RGBEFormat;
const DepthFormat = 1026;
exports.DepthFormat = DepthFormat;
const DepthStencilFormat = 1027;
exports.DepthStencilFormat = DepthStencilFormat;
const RedFormat = 1028;
exports.RedFormat = RedFormat;
const RedIntegerFormat = 1029;
exports.RedIntegerFormat = RedIntegerFormat;
const RGFormat = 1030;
exports.RGFormat = RGFormat;
const RGIntegerFormat = 1031;
exports.RGIntegerFormat = RGIntegerFormat;
const RGBIntegerFormat = 1032;
exports.RGBIntegerFormat = RGBIntegerFormat;
const RGBAIntegerFormat = 1033;
exports.RGBAIntegerFormat = RGBAIntegerFormat;
const RGB_S3TC_DXT1_Format = 33776;
exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
const RGBA_S3TC_DXT1_Format = 33777;
exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
const RGBA_S3TC_DXT3_Format = 33778;
exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
const RGBA_S3TC_DXT5_Format = 33779;
exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
const RGB_PVRTC_4BPPV1_Format = 35840;
exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
const RGB_PVRTC_2BPPV1_Format = 35841;
exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
const RGBA_PVRTC_4BPPV1_Format = 35842;
exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
const RGBA_PVRTC_2BPPV1_Format = 35843;
exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
const RGB_ETC1_Format = 36196;
exports.RGB_ETC1_Format = RGB_ETC1_Format;
const RGB_ETC2_Format = 37492;
exports.RGB_ETC2_Format = RGB_ETC2_Format;
const RGBA_ETC2_EAC_Format = 37496;
exports.RGBA_ETC2_EAC_Format = RGBA_ETC2_EAC_Format;
const RGBA_ASTC_4x4_Format = 37808;
exports.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format;
const RGBA_ASTC_5x4_Format = 37809;
exports.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format;
const RGBA_ASTC_5x5_Format = 37810;
exports.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format;
const RGBA_ASTC_6x5_Format = 37811;
exports.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format;
const RGBA_ASTC_6x6_Format = 37812;
exports.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format;
const RGBA_ASTC_8x5_Format = 37813;
exports.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format;
const RGBA_ASTC_8x6_Format = 37814;
exports.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format;
const RGBA_ASTC_8x8_Format = 37815;
exports.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format;
const RGBA_ASTC_10x5_Format = 37816;
exports.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format;
const RGBA_ASTC_10x6_Format = 37817;
exports.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format;
const RGBA_ASTC_10x8_Format = 37818;
exports.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format;
const RGBA_ASTC_10x10_Format = 37819;
exports.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format;
const RGBA_ASTC_12x10_Format = 37820;
exports.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format;
const RGBA_ASTC_12x12_Format = 37821;
exports.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format;
const RGBA_BPTC_Format = 36492;
exports.RGBA_BPTC_Format = RGBA_BPTC_Format;
const SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
exports.SRGB8_ALPHA8_ASTC_4x4_Format = SRGB8_ALPHA8_ASTC_4x4_Format;
const SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
exports.SRGB8_ALPHA8_ASTC_5x4_Format = SRGB8_ALPHA8_ASTC_5x4_Format;
const SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
exports.SRGB8_ALPHA8_ASTC_5x5_Format = SRGB8_ALPHA8_ASTC_5x5_Format;
const SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
exports.SRGB8_ALPHA8_ASTC_6x5_Format = SRGB8_ALPHA8_ASTC_6x5_Format;
const SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
exports.SRGB8_ALPHA8_ASTC_6x6_Format = SRGB8_ALPHA8_ASTC_6x6_Format;
const SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
exports.SRGB8_ALPHA8_ASTC_8x5_Format = SRGB8_ALPHA8_ASTC_8x5_Format;
const SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
exports.SRGB8_ALPHA8_ASTC_8x6_Format = SRGB8_ALPHA8_ASTC_8x6_Format;
const SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
exports.SRGB8_ALPHA8_ASTC_8x8_Format = SRGB8_ALPHA8_ASTC_8x8_Format;
const SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
exports.SRGB8_ALPHA8_ASTC_10x5_Format = SRGB8_ALPHA8_ASTC_10x5_Format;
const SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
exports.SRGB8_ALPHA8_ASTC_10x6_Format = SRGB8_ALPHA8_ASTC_10x6_Format;
const SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
exports.SRGB8_ALPHA8_ASTC_10x8_Format = SRGB8_ALPHA8_ASTC_10x8_Format;
const SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
exports.SRGB8_ALPHA8_ASTC_10x10_Format = SRGB8_ALPHA8_ASTC_10x10_Format;
const SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
exports.SRGB8_ALPHA8_ASTC_12x10_Format = SRGB8_ALPHA8_ASTC_12x10_Format;
const SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
exports.SRGB8_ALPHA8_ASTC_12x12_Format = SRGB8_ALPHA8_ASTC_12x12_Format;
const LoopOnce = 2200;
exports.LoopOnce = LoopOnce;
const LoopRepeat = 2201;
exports.LoopRepeat = LoopRepeat;
const LoopPingPong = 2202;
exports.LoopPingPong = LoopPingPong;
const InterpolateDiscrete = 2300;
exports.InterpolateDiscrete = InterpolateDiscrete;
const InterpolateLinear = 2301;
exports.InterpolateLinear = InterpolateLinear;
const InterpolateSmooth = 2302;
exports.InterpolateSmooth = InterpolateSmooth;
const ZeroCurvatureEnding = 2400;
exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
const ZeroSlopeEnding = 2401;
exports.ZeroSlopeEnding = ZeroSlopeEnding;
const WrapAroundEnding = 2402;
exports.WrapAroundEnding = WrapAroundEnding;
const NormalAnimationBlendMode = 2500;
exports.NormalAnimationBlendMode = NormalAnimationBlendMode;
const AdditiveAnimationBlendMode = 2501;
exports.AdditiveAnimationBlendMode = AdditiveAnimationBlendMode;
const TrianglesDrawMode = 0;
exports.TrianglesDrawMode = TrianglesDrawMode;
const TriangleStripDrawMode = 1;
exports.TriangleStripDrawMode = TriangleStripDrawMode;
const TriangleFanDrawMode = 2;
exports.TriangleFanDrawMode = TriangleFanDrawMode;
const LinearEncoding = 3000;
exports.LinearEncoding = LinearEncoding;
const sRGBEncoding = 3001;
exports.sRGBEncoding = sRGBEncoding;
const GammaEncoding = 3007;
exports.GammaEncoding = GammaEncoding;
const RGBEEncoding = 3002;
exports.RGBEEncoding = RGBEEncoding;
const LogLuvEncoding = 3003;
exports.LogLuvEncoding = LogLuvEncoding;
const RGBM7Encoding = 3004;
exports.RGBM7Encoding = RGBM7Encoding;
const RGBM16Encoding = 3005;
exports.RGBM16Encoding = RGBM16Encoding;
const RGBDEncoding = 3006;
exports.RGBDEncoding = RGBDEncoding;
const BasicDepthPacking = 3200;
exports.BasicDepthPacking = BasicDepthPacking;
const RGBADepthPacking = 3201;
exports.RGBADepthPacking = RGBADepthPacking;
const TangentSpaceNormalMap = 0;
exports.TangentSpaceNormalMap = TangentSpaceNormalMap;
const ObjectSpaceNormalMap = 1;
exports.ObjectSpaceNormalMap = ObjectSpaceNormalMap;
const ZeroStencilOp = 0;
exports.ZeroStencilOp = ZeroStencilOp;
const KeepStencilOp = 7680;
exports.KeepStencilOp = KeepStencilOp;
const ReplaceStencilOp = 7681;
exports.ReplaceStencilOp = ReplaceStencilOp;
const IncrementStencilOp = 7682;
exports.IncrementStencilOp = IncrementStencilOp;
const DecrementStencilOp = 7683;
exports.DecrementStencilOp = DecrementStencilOp;
const IncrementWrapStencilOp = 34055;
exports.IncrementWrapStencilOp = IncrementWrapStencilOp;
const DecrementWrapStencilOp = 34056;
exports.DecrementWrapStencilOp = DecrementWrapStencilOp;
const InvertStencilOp = 5386;
exports.InvertStencilOp = InvertStencilOp;
const NeverStencilFunc = 512;
exports.NeverStencilFunc = NeverStencilFunc;
const LessStencilFunc = 513;
exports.LessStencilFunc = LessStencilFunc;
const EqualStencilFunc = 514;
exports.EqualStencilFunc = EqualStencilFunc;
const LessEqualStencilFunc = 515;
exports.LessEqualStencilFunc = LessEqualStencilFunc;
const GreaterStencilFunc = 516;
exports.GreaterStencilFunc = GreaterStencilFunc;
const NotEqualStencilFunc = 517;
exports.NotEqualStencilFunc = NotEqualStencilFunc;
const GreaterEqualStencilFunc = 518;
exports.GreaterEqualStencilFunc = GreaterEqualStencilFunc;
const AlwaysStencilFunc = 519;
exports.AlwaysStencilFunc = AlwaysStencilFunc;
const StaticDrawUsage = 35044;
exports.StaticDrawUsage = StaticDrawUsage;
const DynamicDrawUsage = 35048;
exports.DynamicDrawUsage = DynamicDrawUsage;
const StreamDrawUsage = 35040;
exports.StreamDrawUsage = StreamDrawUsage;
const StaticReadUsage = 35045;
exports.StaticReadUsage = StaticReadUsage;
const DynamicReadUsage = 35049;
exports.DynamicReadUsage = DynamicReadUsage;
const StreamReadUsage = 35041;
exports.StreamReadUsage = StreamReadUsage;
const StaticCopyUsage = 35046;
exports.StaticCopyUsage = StaticCopyUsage;
const DynamicCopyUsage = 35050;
exports.DynamicCopyUsage = DynamicCopyUsage;
const StreamCopyUsage = 35042;
exports.StreamCopyUsage = StreamCopyUsage;
const GLSL1 = '100';
exports.GLSL1 = GLSL1;
const GLSL3 = '300 es';

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */
exports.GLSL3 = GLSL3;
function EventDispatcher() {}
Object.assign(EventDispatcher.prototype, {
  addEventListener: function (type, listener) {
    if (this._listeners === undefined) this._listeners = {};
    const listeners = this._listeners;
    if (listeners[type] === undefined) {
      listeners[type] = [];
    }
    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
  },
  hasEventListener: function (type, listener) {
    if (this._listeners === undefined) return false;
    const listeners = this._listeners;
    return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
  },
  removeEventListener: function (type, listener) {
    if (this._listeners === undefined) return;
    const listeners = this._listeners;
    const listenerArray = listeners[type];
    if (listenerArray !== undefined) {
      const index = listenerArray.indexOf(listener);
      if (index !== -1) {
        listenerArray.splice(index, 1);
      }
    }
  },
  dispatchEvent: function (event) {
    if (this._listeners === undefined) return;
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];
    if (listenerArray !== undefined) {
      event.target = this;

      // Make a copy, in case listeners are removed while iterating.
      const array = listenerArray.slice(0);
      for (let i = 0, l = array.length; i < l; i++) {
        array[i].call(this, event);
      }
    }
  }
});
const _lut = [];
for (let i = 0; i < 256; i++) {
  _lut[i] = (i < 16 ? '0' : '') + i.toString(16);
}
let _seed = 1234567;
const MathUtils = {
  DEG2RAD: Math.PI / 180,
  RAD2DEG: 180 / Math.PI,
  generateUUID: function () {
    // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

    const d0 = Math.random() * 0xffffffff | 0;
    const d1 = Math.random() * 0xffffffff | 0;
    const d2 = Math.random() * 0xffffffff | 0;
    const d3 = Math.random() * 0xffffffff | 0;
    const uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' + _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' + _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] + _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff];

    // .toUpperCase() here flattens concatenated strings to save heap memory space.
    return uuid.toUpperCase();
  },
  clamp: function (value, min, max) {
    return Math.max(min, Math.min(max, value));
  },
  // compute euclidian modulo of m % n
  // https://en.wikipedia.org/wiki/Modulo_operation

  euclideanModulo: function (n, m) {
    return (n % m + m) % m;
  },
  // Linear mapping from range <a1, a2> to range <b1, b2>

  mapLinear: function (x, a1, a2, b1, b2) {
    return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
  },
  // https://en.wikipedia.org/wiki/Linear_interpolation

  lerp: function (x, y, t) {
    return (1 - t) * x + t * y;
  },
  // http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/

  damp: function (x, y, lambda, dt) {
    return MathUtils.lerp(x, y, 1 - Math.exp(-lambda * dt));
  },
  // https://www.desmos.com/calculator/vcsjnyz7x4

  pingpong: function (x, length = 1) {
    return length - Math.abs(MathUtils.euclideanModulo(x, length * 2) - length);
  },
  // http://en.wikipedia.org/wiki/Smoothstep

  smoothstep: function (x, min, max) {
    if (x <= min) return 0;
    if (x >= max) return 1;
    x = (x - min) / (max - min);
    return x * x * (3 - 2 * x);
  },
  smootherstep: function (x, min, max) {
    if (x <= min) return 0;
    if (x >= max) return 1;
    x = (x - min) / (max - min);
    return x * x * x * (x * (x * 6 - 15) + 10);
  },
  // Random integer from <low, high> interval

  randInt: function (low, high) {
    return low + Math.floor(Math.random() * (high - low + 1));
  },
  // Random float from <low, high> interval

  randFloat: function (low, high) {
    return low + Math.random() * (high - low);
  },
  // Random float from <-range/2, range/2> interval

  randFloatSpread: function (range) {
    return range * (0.5 - Math.random());
  },
  // Deterministic pseudo-random float in the interval [ 0, 1 ]

  seededRandom: function (s) {
    if (s !== undefined) _seed = s % 2147483647;

    // Park-Miller algorithm

    _seed = _seed * 16807 % 2147483647;
    return (_seed - 1) / 2147483646;
  },
  degToRad: function (degrees) {
    return degrees * MathUtils.DEG2RAD;
  },
  radToDeg: function (radians) {
    return radians * MathUtils.RAD2DEG;
  },
  isPowerOfTwo: function (value) {
    return (value & value - 1) === 0 && value !== 0;
  },
  ceilPowerOfTwo: function (value) {
    return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
  },
  floorPowerOfTwo: function (value) {
    return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
  },
  setQuaternionFromProperEuler: function (q, a, b, c, order) {
    // Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

    // rotations are applied to the axes in the order specified by 'order'
    // rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
    // angles are in radians

    const cos = Math.cos;
    const sin = Math.sin;
    const c2 = cos(b / 2);
    const s2 = sin(b / 2);
    const c13 = cos((a + c) / 2);
    const s13 = sin((a + c) / 2);
    const c1_3 = cos((a - c) / 2);
    const s1_3 = sin((a - c) / 2);
    const c3_1 = cos((c - a) / 2);
    const s3_1 = sin((c - a) / 2);
    switch (order) {
      case 'XYX':
        q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
        break;
      case 'YZY':
        q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
        break;
      case 'ZXZ':
        q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
        break;
      case 'XZX':
        q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
        break;
      case 'YXY':
        q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
        break;
      case 'ZYZ':
        q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
        break;
      default:
        console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order);
    }
  }
};
exports.MathUtils = exports.Math = MathUtils;
class Vector2 {
  constructor(x = 0, y = 0) {
    Object.defineProperty(this, 'isVector2', {
      value: true
    });
    this.x = x;
    this.y = y;
  }
  get width() {
    return this.x;
  }
  set width(value) {
    this.x = value;
  }
  get height() {
    return this.y;
  }
  set height(value) {
    this.y = value;
  }
  set(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y) {
    this.y = y;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      default:
        throw new Error('index is out of range: ' + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error('index is out of range: ' + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    return this;
  }
  add(v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
      return this.addVectors(v, w);
    }
    this.x += v.x;
    this.y += v.y;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    return this;
  }
  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    return this;
  }
  sub(v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
      return this.subVectors(v, w);
    }
    this.x -= v.x;
    this.y -= v.y;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    return this;
  }
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  applyMatrix3(m) {
    const x = this.x,
      y = this.y;
    const e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6];
    this.y = e[1] * x + e[4] * y + e[7];
    return this;
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    return this;
  }
  clamp(min, max) {
    // assumes min < max, componentwise

    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y;
  }
  cross(v) {
    return this.x * v.y - this.y * v.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    // computes the angle in radians with respect to the positive x-axis

    const angle = Math.atan2(-this.y, -this.x) + Math.PI;
    return angle;
  }
  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }
  distanceToSquared(v) {
    const dx = this.x - v.x,
      dy = this.y - v.y;
    return dx * dx + dy * dy;
  }
  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    return this;
  }
  equals(v) {
    return v.x === this.x && v.y === this.y;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    return array;
  }
  fromBufferAttribute(attribute, index, offset) {
    if (offset !== undefined) {
      console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');
    }
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    return this;
  }
  rotateAround(center, angle) {
    const c = Math.cos(angle),
      s = Math.sin(angle);
    const x = this.x - center.x;
    const y = this.y - center.y;
    this.x = x * c - y * s + center.x;
    this.y = x * s + y * c + center.y;
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    return this;
  }
}
exports.Vector2 = Vector2;
class Matrix3 {
  constructor() {
    Object.defineProperty(this, 'isMatrix3', {
      value: true
    });
    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    if (arguments.length > 0) {
      console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');
    }
  }
  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    const te = this.elements;
    te[0] = n11;
    te[1] = n21;
    te[2] = n31;
    te[3] = n12;
    te[4] = n22;
    te[5] = n32;
    te[6] = n13;
    te[7] = n23;
    te[8] = n33;
    return this;
  }
  identity() {
    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
    return this;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
  copy(m) {
    const te = this.elements;
    const me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrix3Column(this, 0);
    yAxis.setFromMatrix3Column(this, 1);
    zAxis.setFromMatrix3Column(this, 2);
    return this;
  }
  setFromMatrix4(m) {
    const me = m.elements;
    this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
    return this;
  }
  multiply(m) {
    return this.multiplyMatrices(this, m);
  }
  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }
  multiplyMatrices(a, b) {
    const ae = a.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0],
      a12 = ae[3],
      a13 = ae[6];
    const a21 = ae[1],
      a22 = ae[4],
      a23 = ae[7];
    const a31 = ae[2],
      a32 = ae[5],
      a33 = ae[8];
    const b11 = be[0],
      b12 = be[3],
      b13 = be[6];
    const b21 = be[1],
      b22 = be[4],
      b23 = be[7];
    const b31 = be[2],
      b32 = be[5],
      b33 = be[8];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te[3] = a11 * b12 + a12 * b22 + a13 * b32;
    te[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te[4] = a21 * b12 + a22 * b22 + a23 * b32;
    te[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te[5] = a31 * b12 + a32 * b22 + a33 * b32;
    te[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  }
  multiplyScalar(s) {
    const te = this.elements;
    te[0] *= s;
    te[3] *= s;
    te[6] *= s;
    te[1] *= s;
    te[4] *= s;
    te[7] *= s;
    te[2] *= s;
    te[5] *= s;
    te[8] *= s;
    return this;
  }
  determinant() {
    const te = this.elements;
    const a = te[0],
      b = te[1],
      c = te[2],
      d = te[3],
      e = te[4],
      f = te[5],
      g = te[6],
      h = te[7],
      i = te[8];
    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
  }
  invert() {
    const te = this.elements,
      n11 = te[0],
      n21 = te[1],
      n31 = te[2],
      n12 = te[3],
      n22 = te[4],
      n32 = te[5],
      n13 = te[6],
      n23 = te[7],
      n33 = te[8],
      t11 = n33 * n22 - n32 * n23,
      t12 = n32 * n13 - n33 * n12,
      t13 = n23 * n12 - n22 * n13,
      det = n11 * t11 + n21 * t12 + n31 * t13;
    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n31 * n23 - n33 * n21) * detInv;
    te[2] = (n32 * n21 - n31 * n22) * detInv;
    te[3] = t12 * detInv;
    te[4] = (n33 * n11 - n31 * n13) * detInv;
    te[5] = (n31 * n12 - n32 * n11) * detInv;
    te[6] = t13 * detInv;
    te[7] = (n21 * n13 - n23 * n11) * detInv;
    te[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  }
  transpose() {
    let tmp;
    const m = this.elements;
    tmp = m[1];
    m[1] = m[3];
    m[3] = tmp;
    tmp = m[2];
    m[2] = m[6];
    m[6] = tmp;
    tmp = m[5];
    m[5] = m[7];
    m[7] = tmp;
    return this;
  }
  getNormalMatrix(matrix4) {
    return this.setFromMatrix4(matrix4).copy(this).invert().transpose();
  }
  transposeIntoArray(r) {
    const m = this.elements;
    r[0] = m[0];
    r[1] = m[3];
    r[2] = m[6];
    r[3] = m[1];
    r[4] = m[4];
    r[5] = m[7];
    r[6] = m[2];
    r[7] = m[5];
    r[8] = m[8];
    return this;
  }
  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
    const c = Math.cos(rotation);
    const s = Math.sin(rotation);
    this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
    return this;
  }
  scale(sx, sy) {
    const te = this.elements;
    te[0] *= sx;
    te[3] *= sx;
    te[6] *= sx;
    te[1] *= sy;
    te[4] *= sy;
    te[7] *= sy;
    return this;
  }
  rotate(theta) {
    const c = Math.cos(theta);
    const s = Math.sin(theta);
    const te = this.elements;
    const a11 = te[0],
      a12 = te[3],
      a13 = te[6];
    const a21 = te[1],
      a22 = te[4],
      a23 = te[7];
    te[0] = c * a11 + s * a21;
    te[3] = c * a12 + s * a22;
    te[6] = c * a13 + s * a23;
    te[1] = -s * a11 + c * a21;
    te[4] = -s * a12 + c * a22;
    te[7] = -s * a13 + c * a23;
    return this;
  }
  translate(tx, ty) {
    const te = this.elements;
    te[0] += tx * te[2];
    te[3] += tx * te[5];
    te[6] += tx * te[8];
    te[1] += ty * te[2];
    te[4] += ty * te[5];
    te[7] += ty * te[8];
    return this;
  }
  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;
    for (let i = 0; i < 9; i++) {
      if (te[i] !== me[i]) return false;
    }
    return true;
  }
  fromArray(array, offset = 0) {
    for (let i = 0; i < 9; i++) {
      this.elements[i] = array[i + offset];
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    return array;
  }
}
exports.Matrix3 = Matrix3;
let _canvas;
const ImageUtils = {
  getDataURL: function (image) {
    if (/^data:/i.test(image.src)) {
      return image.src;
    }
    if (typeof HTMLCanvasElement == 'undefined') {
      return image.src;
    }
    let canvas;
    if (image instanceof HTMLCanvasElement) {
      canvas = image;
    } else {
      if (_canvas === undefined) _canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
      _canvas.width = image.width;
      _canvas.height = image.height;
      const context = _canvas.getContext('2d');
      if (image instanceof ImageData) {
        context.putImageData(image, 0, 0);
      } else {
        context.drawImage(image, 0, 0, image.width, image.height);
      }
      canvas = _canvas;
    }
    if (canvas.width > 2048 || canvas.height > 2048) {
      return canvas.toDataURL('image/jpeg', 0.6);
    } else {
      return canvas.toDataURL('image/png');
    }
  }
};
exports.ImageUtils = ImageUtils;
let textureId = 0;
function Texture(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding) {
  Object.defineProperty(this, 'id', {
    value: textureId++
  });
  this.uuid = MathUtils.generateUUID();
  this.name = '';
  this.image = image;
  this.mipmaps = [];
  this.mapping = mapping;
  this.wrapS = wrapS;
  this.wrapT = wrapT;
  this.magFilter = magFilter;
  this.minFilter = minFilter;
  this.anisotropy = anisotropy;
  this.format = format;
  this.internalFormat = null;
  this.type = type;
  this.offset = new Vector2(0, 0);
  this.repeat = new Vector2(1, 1);
  this.center = new Vector2(0, 0);
  this.rotation = 0;
  this.matrixAutoUpdate = true;
  this.matrix = new Matrix3();
  this.generateMipmaps = true;
  this.premultiplyAlpha = false;
  this.flipY = true;
  this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

  // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
  //
  // Also changing the encoding after already used by a Material will not automatically make the Material
  // update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
  this.encoding = encoding;
  this.version = 0;
  this.onUpdate = null;
}
Texture.DEFAULT_IMAGE = undefined;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: Texture,
  isTexture: true,
  updateMatrix: function () {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (source) {
    this.name = source.name;
    this.image = source.image;
    this.mipmaps = source.mipmaps.slice(0);
    this.mapping = source.mapping;
    this.wrapS = source.wrapS;
    this.wrapT = source.wrapT;
    this.magFilter = source.magFilter;
    this.minFilter = source.minFilter;
    this.anisotropy = source.anisotropy;
    this.format = source.format;
    this.internalFormat = source.internalFormat;
    this.type = source.type;
    this.offset.copy(source.offset);
    this.repeat.copy(source.repeat);
    this.center.copy(source.center);
    this.rotation = source.rotation;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrix.copy(source.matrix);
    this.generateMipmaps = source.generateMipmaps;
    this.premultiplyAlpha = source.premultiplyAlpha;
    this.flipY = source.flipY;
    this.unpackAlignment = source.unpackAlignment;
    this.encoding = source.encoding;
    return this;
  },
  toJSON: function (meta) {
    const isRootObject = meta === undefined || typeof meta === 'string';
    if (!isRootObject && meta.textures[this.uuid] !== undefined) {
      return meta.textures[this.uuid];
    }
    const output = {
      metadata: {
        version: 4.5,
        type: 'Texture',
        generator: 'Texture.toJSON'
      },
      uuid: this.uuid,
      name: this.name,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    if (this.image !== undefined) {
      // TODO: Move to THREE.Image

      const image = this.image;
      if (image.uuid === undefined) {
        image.uuid = MathUtils.generateUUID(); // UGH
      }

      if (!isRootObject && meta.images[image.uuid] === undefined) {
        let url;
        if (Array.isArray(image)) {
          // process array of images e.g. CubeTexture

          url = [];
          for (let i = 0, l = image.length; i < l; i++) {
            // check cube texture with data textures

            if (image[i].isDataTexture) {
              url.push(serializeImage(image[i].image));
            } else {
              url.push(serializeImage(image[i]));
            }
          }
        } else {
          // process single image

          url = serializeImage(image);
        }
        meta.images[image.uuid] = {
          uuid: image.uuid,
          url: url
        };
      }
      output.image = image.uuid;
    }
    if (!isRootObject) {
      meta.textures[this.uuid] = output;
    }
    return output;
  },
  dispose: function () {
    this.dispatchEvent({
      type: 'dispose'
    });
  },
  transformUv: function (uv) {
    if (this.mapping !== UVMapping) return uv;
    uv.applyMatrix3(this.matrix);
    if (uv.x < 0 || uv.x > 1) {
      switch (this.wrapS) {
        case RepeatWrapping:
          uv.x = uv.x - Math.floor(uv.x);
          break;
        case ClampToEdgeWrapping:
          uv.x = uv.x < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.x) % 2) === 1) {
            uv.x = Math.ceil(uv.x) - uv.x;
          } else {
            uv.x = uv.x - Math.floor(uv.x);
          }
          break;
      }
    }
    if (uv.y < 0 || uv.y > 1) {
      switch (this.wrapT) {
        case RepeatWrapping:
          uv.y = uv.y - Math.floor(uv.y);
          break;
        case ClampToEdgeWrapping:
          uv.y = uv.y < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.y) % 2) === 1) {
            uv.y = Math.ceil(uv.y) - uv.y;
          } else {
            uv.y = uv.y - Math.floor(uv.y);
          }
          break;
      }
    }
    if (this.flipY) {
      uv.y = 1 - uv.y;
    }
    return uv;
  }
});
Object.defineProperty(Texture.prototype, 'needsUpdate', {
  set: function (value) {
    if (value === true) this.version++;
  }
});
function serializeImage(image) {
  if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
    // default images

    return ImageUtils.getDataURL(image);
  } else {
    if (image.data) {
      // images of DataTexture

      return {
        data: Array.prototype.slice.call(image.data),
        width: image.width,
        height: image.height,
        type: image.data.constructor.name
      };
    } else {
      console.warn('THREE.Texture: Unable to serialize Texture.');
      return {};
    }
  }
}
class Vector4 {
  constructor(x = 0, y = 0, z = 0, w = 1) {
    Object.defineProperty(this, 'isVector4', {
      value: true
    });
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }
  get width() {
    return this.z;
  }
  set width(value) {
    this.z = value;
  }
  get height() {
    return this.w;
  }
  set height(value) {
    this.w = value;
  }
  set(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    this.w = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y) {
    this.y = y;
    return this;
  }
  setZ(z) {
    this.z = z;
    return this;
  }
  setW(w) {
    this.w = w;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      case 3:
        this.w = value;
        break;
      default:
        throw new Error('index is out of range: ' + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error('index is out of range: ' + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    this.w = v.w !== undefined ? v.w : 1;
    return this;
  }
  add(v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
      return this.addVectors(v, w);
    }
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    this.w += v.w;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    this.z += s;
    this.w += s;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    this.w = a.w + b.w;
    return this;
  }
  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    this.w += v.w * s;
    return this;
  }
  sub(v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
      return this.subVectors(v, w);
    }
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    this.w -= v.w;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    this.w -= s;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    this.w = a.w - b.w;
    return this;
  }
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    this.w *= v.w;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;
    return this;
  }
  applyMatrix4(m) {
    const x = this.x,
      y = this.y,
      z = this.z,
      w = this.w;
    const e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
    this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
    this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
    this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  setAxisAngleFromQuaternion(q) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

    // q is assumed to be normalized

    this.w = 2 * Math.acos(q.w);
    const s = Math.sqrt(1 - q.w * q.w);
    if (s < 0.0001) {
      this.x = 1;
      this.y = 0;
      this.z = 0;
    } else {
      this.x = q.x / s;
      this.y = q.y / s;
      this.z = q.z / s;
    }
    return this;
  }
  setAxisAngleFromRotationMatrix(m) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    let angle, x, y, z; // variables for result
    const epsilon = 0.01,
      // margin to allow for rounding errors
      epsilon2 = 0.1,
      // margin to distinguish between 0 and 180 degrees

      te = m.elements,
      m11 = te[0],
      m12 = te[4],
      m13 = te[8],
      m21 = te[1],
      m22 = te[5],
      m23 = te[9],
      m31 = te[2],
      m32 = te[6],
      m33 = te[10];
    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
      // singularity found
      // first check for identity matrix which must have +1 for all terms
      // in leading diagonal and zero in other terms

      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
        // this singularity is identity matrix so angle = 0

        this.set(1, 0, 0, 0);
        return this; // zero angle, arbitrary axis
      }

      // otherwise this singularity is angle = 180

      angle = Math.PI;
      const xx = (m11 + 1) / 2;
      const yy = (m22 + 1) / 2;
      const zz = (m33 + 1) / 2;
      const xy = (m12 + m21) / 4;
      const xz = (m13 + m31) / 4;
      const yz = (m23 + m32) / 4;
      if (xx > yy && xx > zz) {
        // m11 is the largest diagonal term

        if (xx < epsilon) {
          x = 0;
          y = 0.707106781;
          z = 0.707106781;
        } else {
          x = Math.sqrt(xx);
          y = xy / x;
          z = xz / x;
        }
      } else if (yy > zz) {
        // m22 is the largest diagonal term

        if (yy < epsilon) {
          x = 0.707106781;
          y = 0;
          z = 0.707106781;
        } else {
          y = Math.sqrt(yy);
          x = xy / y;
          z = yz / y;
        }
      } else {
        // m33 is the largest diagonal term so base result on this

        if (zz < epsilon) {
          x = 0.707106781;
          y = 0.707106781;
          z = 0;
        } else {
          z = Math.sqrt(zz);
          x = xz / z;
          y = yz / z;
        }
      }
      this.set(x, y, z, angle);
      return this; // return 180 deg rotation
    }

    // as we have reached here there are no singularities so we can handle normally

    let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize

    if (Math.abs(s) < 0.001) s = 1;

    // prevent divide by zero, should not happen if matrix is orthogonal and should be
    // caught by singularity test above, but I've left it in just in case

    this.x = (m32 - m23) / s;
    this.y = (m13 - m31) / s;
    this.z = (m21 - m12) / s;
    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
    return this;
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    this.w = Math.min(this.w, v.w);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    this.w = Math.max(this.w, v.w);
    return this;
  }
  clamp(min, max) {
    // assumes min < max, componentwise

    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    this.w = Math.max(min.w, Math.min(max.w, this.w));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    this.w = Math.max(minVal, Math.min(maxVal, this.w));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    this.w += (v.w - this.w) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    this.w = v1.w + (v2.w - v1.w) * alpha;
    return this;
  }
  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    this.w = array[offset + 3];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    array[offset + 3] = this.w;
    return array;
  }
  fromBufferAttribute(attribute, index, offset) {
    if (offset !== undefined) {
      console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');
    }
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    this.w = attribute.getW(index);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    this.w = Math.random();
    return this;
  }
}

/*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/
exports.Vector4 = Vector4;
class WebGLRenderTarget extends EventDispatcher {
  constructor(width, height, options) {
    super();
    Object.defineProperty(this, 'isWebGLRenderTarget', {
      value: true
    });
    this.width = width;
    this.height = height;
    this.scissor = new Vector4(0, 0, width, height);
    this.scissorTest = false;
    this.viewport = new Vector4(0, 0, width, height);
    options = options || {};
    this.texture = new Texture(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
    this.texture.image = {};
    this.texture.image.width = width;
    this.texture.image.height = height;
    this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
    this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
    this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
    this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;
    this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
  }
  setSize(width, height) {
    if (this.width !== width || this.height !== height) {
      this.width = width;
      this.height = height;
      this.texture.image.width = width;
      this.texture.image.height = height;
      this.dispose();
    }
    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.width = source.width;
    this.height = source.height;
    this.viewport.copy(source.viewport);
    this.texture = source.texture.clone();
    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;
    this.depthTexture = source.depthTexture;
    return this;
  }
  dispose() {
    this.dispatchEvent({
      type: 'dispose'
    });
  }
}
exports.WebGLRenderTarget = WebGLRenderTarget;
class WebGLMultisampleRenderTarget extends WebGLRenderTarget {
  constructor(width, height, options) {
    super(width, height, options);
    Object.defineProperty(this, 'isWebGLMultisampleRenderTarget', {
      value: true
    });
    this.samples = 4;
  }
  copy(source) {
    super.copy.call(this, source);
    this.samples = source.samples;
    return this;
  }
}
exports.WebGLMultisampleRenderTarget = WebGLMultisampleRenderTarget;
class Quaternion {
  constructor(x = 0, y = 0, z = 0, w = 1) {
    Object.defineProperty(this, 'isQuaternion', {
      value: true
    });
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
  }
  static slerp(qa, qb, qm, t) {
    return qm.copy(qa).slerp(qb, t);
  }
  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
    // fuzz-free, array-based Quaternion SLERP operation

    let x0 = src0[srcOffset0 + 0],
      y0 = src0[srcOffset0 + 1],
      z0 = src0[srcOffset0 + 2],
      w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1 + 0],
      y1 = src1[srcOffset1 + 1],
      z1 = src1[srcOffset1 + 2],
      w1 = src1[srcOffset1 + 3];
    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      let s = 1 - t;
      const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
        dir = cos >= 0 ? 1 : -1,
        sqrSin = 1 - cos * cos;

      // Skip the Slerp for tiny steps to avoid numeric problems:
      if (sqrSin > Number.EPSILON) {
        const sin = Math.sqrt(sqrSin),
          len = Math.atan2(sin, cos * dir);
        s = Math.sin(s * len) / sin;
        t = Math.sin(t * len) / sin;
      }
      const tDir = t * dir;
      x0 = x0 * s + x1 * tDir;
      y0 = y0 * s + y1 * tDir;
      z0 = z0 * s + z1 * tDir;
      w0 = w0 * s + w1 * tDir;

      // Normalize in case we just did a lerp:
      if (s === 1 - t) {
        const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
        x0 *= f;
        y0 *= f;
        z0 *= f;
        w0 *= f;
      }
    }
    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w0;
  }
  static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
    const x0 = src0[srcOffset0];
    const y0 = src0[srcOffset0 + 1];
    const z0 = src0[srcOffset0 + 2];
    const w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1];
    const y1 = src1[srcOffset1 + 1];
    const z1 = src1[srcOffset1 + 2];
    const w1 = src1[srcOffset1 + 3];
    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
    return dst;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(value) {
    this._w = value;
    this._onChangeCallback();
  }
  set(x, y, z, w) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(quaternion) {
    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;
    this._onChangeCallback();
    return this;
  }
  setFromEuler(euler, update) {
    if (!(euler && euler.isEuler)) {
      throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');
    }
    const x = euler._x,
      y = euler._y,
      z = euler._z,
      order = euler._order;

    // http://www.mathworks.com/matlabcentral/fileexchange/
    // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
    //	content/SpinCalc.m

    const cos = Math.cos;
    const sin = Math.sin;
    const c1 = cos(x / 2);
    const c2 = cos(y / 2);
    const c3 = cos(z / 2);
    const s1 = sin(x / 2);
    const s2 = sin(y / 2);
    const s3 = sin(z / 2);
    switch (order) {
      case 'XYZ':
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case 'YXZ':
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case 'ZXY':
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case 'ZYX':
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case 'YZX':
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case 'XZY':
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      default:
        console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order);
    }
    if (update !== false) this._onChangeCallback();
    return this;
  }
  setFromAxisAngle(axis, angle) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

    // assumes axis is normalized

    const halfAngle = angle / 2,
      s = Math.sin(halfAngle);
    this._x = axis.x * s;
    this._y = axis.y * s;
    this._z = axis.z * s;
    this._w = Math.cos(halfAngle);
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    const te = m.elements,
      m11 = te[0],
      m12 = te[4],
      m13 = te[8],
      m21 = te[1],
      m22 = te[5],
      m23 = te[9],
      m31 = te[2],
      m32 = te[6],
      m33 = te[10],
      trace = m11 + m22 + m33;
    if (trace > 0) {
      const s = 0.5 / Math.sqrt(trace + 1.0);
      this._w = 0.25 / s;
      this._x = (m32 - m23) * s;
      this._y = (m13 - m31) * s;
      this._z = (m21 - m12) * s;
    } else if (m11 > m22 && m11 > m33) {
      const s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
      this._w = (m32 - m23) / s;
      this._x = 0.25 * s;
      this._y = (m12 + m21) / s;
      this._z = (m13 + m31) / s;
    } else if (m22 > m33) {
      const s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
      this._w = (m13 - m31) / s;
      this._x = (m12 + m21) / s;
      this._y = 0.25 * s;
      this._z = (m23 + m32) / s;
    } else {
      const s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
      this._w = (m21 - m12) / s;
      this._x = (m13 + m31) / s;
      this._y = (m23 + m32) / s;
      this._z = 0.25 * s;
    }
    this._onChangeCallback();
    return this;
  }
  setFromUnitVectors(vFrom, vTo) {
    // assumes direction vectors vFrom and vTo are normalized

    const EPS = 0.000001;
    let r = vFrom.dot(vTo) + 1;
    if (r < EPS) {
      r = 0;
      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
        this._x = -vFrom.y;
        this._y = vFrom.x;
        this._z = 0;
        this._w = r;
      } else {
        this._x = 0;
        this._y = -vFrom.z;
        this._z = vFrom.y;
        this._w = r;
      }
    } else {
      // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
      this._w = r;
    }
    return this.normalize();
  }
  angleTo(q) {
    return 2 * Math.acos(Math.abs(MathUtils.clamp(this.dot(q), -1, 1)));
  }
  rotateTowards(q, step) {
    const angle = this.angleTo(q);
    if (angle === 0) return this;
    const t = Math.min(1, step / angle);
    this.slerp(q, t);
    return this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    // quaternion is assumed to have unit length

    return this.conjugate();
  }
  conjugate() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this._onChangeCallback();
    return this;
  }
  dot(v) {
    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let l = this.length();
    if (l === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l = 1 / l;
      this._x = this._x * l;
      this._y = this._y * l;
      this._z = this._z * l;
      this._w = this._w * l;
    }
    this._onChangeCallback();
    return this;
  }
  multiply(q, p) {
    if (p !== undefined) {
      console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
      return this.multiplyQuaternions(q, p);
    }
    return this.multiplyQuaternions(this, q);
  }
  premultiply(q) {
    return this.multiplyQuaternions(q, this);
  }
  multiplyQuaternions(a, b) {
    // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

    const qax = a._x,
      qay = a._y,
      qaz = a._z,
      qaw = a._w;
    const qbx = b._x,
      qby = b._y,
      qbz = b._z,
      qbw = b._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    this._onChangeCallback();
    return this;
  }
  slerp(qb, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(qb);
    const x = this._x,
      y = this._y,
      z = this._z,
      w = this._w;

    // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

    let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
    if (cosHalfTheta < 0) {
      this._w = -qb._w;
      this._x = -qb._x;
      this._y = -qb._y;
      this._z = -qb._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb);
    }
    if (cosHalfTheta >= 1.0) {
      this._w = w;
      this._x = x;
      this._y = y;
      this._z = z;
      return this;
    }
    const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;
    if (sqrSinHalfTheta <= Number.EPSILON) {
      const s = 1 - t;
      this._w = s * w + t * this._w;
      this._x = s * x + t * this._x;
      this._y = s * y + t * this._y;
      this._z = s * z + t * this._z;
      this.normalize();
      this._onChangeCallback();
      return this;
    }
    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
      ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
    this._w = w * ratioA + this._w * ratioB;
    this._x = x * ratioA + this._x * ratioB;
    this._y = y * ratioA + this._y * ratioB;
    this._z = z * ratioA + this._z * ratioB;
    this._onChangeCallback();
    return this;
  }
  equals(quaternion) {
    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  }
  fromArray(array, offset = 0) {
    this._x = array[offset];
    this._y = array[offset + 1];
    this._z = array[offset + 2];
    this._w = array[offset + 3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._w;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this._x = attribute.getX(index);
    this._y = attribute.getY(index);
    this._z = attribute.getZ(index);
    this._w = attribute.getW(index);
    return this;
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {}
}
exports.Quaternion = Quaternion;
class Vector3 {
  constructor(x = 0, y = 0, z = 0) {
    Object.defineProperty(this, 'isVector3', {
      value: true
    });
    this.x = x;
    this.y = y;
    this.z = z;
  }
  set(x, y, z) {
    if (z === undefined) z = this.z; // sprite.scale.set(x,y)

    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y) {
    this.y = y;
    return this;
  }
  setZ(z) {
    this.z = z;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      default:
        throw new Error('index is out of range: ' + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error('index is out of range: ' + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    return this;
  }
  add(v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
      return this.addVectors(v, w);
    }
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    this.z += s;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    return this;
  }
  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    return this;
  }
  sub(v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
      return this.subVectors(v, w);
    }
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    return this;
  }
  multiply(v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
      return this.multiplyVectors(v, w);
    }
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }
  multiplyVectors(a, b) {
    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;
    return this;
  }
  applyEuler(euler) {
    if (!(euler && euler.isEuler)) {
      console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');
    }
    return this.applyQuaternion(_quaternion.setFromEuler(euler));
  }
  applyAxisAngle(axis, angle) {
    return this.applyQuaternion(_quaternion.setFromAxisAngle(axis, angle));
  }
  applyMatrix3(m) {
    const x = this.x,
      y = this.y,
      z = this.z;
    const e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6] * z;
    this.y = e[1] * x + e[4] * y + e[7] * z;
    this.z = e[2] * x + e[5] * y + e[8] * z;
    return this;
  }
  applyNormalMatrix(m) {
    return this.applyMatrix3(m).normalize();
  }
  applyMatrix4(m) {
    const x = this.x,
      y = this.y,
      z = this.z;
    const e = m.elements;
    const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
    return this;
  }
  applyQuaternion(q) {
    const x = this.x,
      y = this.y,
      z = this.z;
    const qx = q.x,
      qy = q.y,
      qz = q.z,
      qw = q.w;

    // calculate quat * vector

    const ix = qw * x + qy * z - qz * y;
    const iy = qw * y + qz * x - qx * z;
    const iz = qw * z + qx * y - qy * x;
    const iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat

    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return this;
  }
  project(camera) {
    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
  }
  unproject(camera) {
    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
  }
  transformDirection(m) {
    // input: THREE.Matrix4 affine matrix
    // vector interpreted as a direction

    const x = this.x,
      y = this.y,
      z = this.z;
    const e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z;
    this.y = e[1] * x + e[5] * y + e[9] * z;
    this.z = e[2] * x + e[6] * y + e[10] * z;
    return this.normalize();
  }
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    return this;
  }
  clamp(min, max) {
    // assumes min < max, componentwise

    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  }

  // TODO lengthSquared?

  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    return this;
  }
  cross(v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
      return this.crossVectors(v, w);
    }
    return this.crossVectors(this, v);
  }
  crossVectors(a, b) {
    const ax = a.x,
      ay = a.y,
      az = a.z;
    const bx = b.x,
      by = b.y,
      bz = b.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  }
  projectOnVector(v) {
    const denominator = v.lengthSq();
    if (denominator === 0) return this.set(0, 0, 0);
    const scalar = v.dot(this) / denominator;
    return this.copy(v).multiplyScalar(scalar);
  }
  projectOnPlane(planeNormal) {
    _vector.copy(this).projectOnVector(planeNormal);
    return this.sub(_vector);
  }
  reflect(normal) {
    // reflect incident vector off plane orthogonal to normal
    // normal is assumed to have unit length

    return this.sub(_vector.copy(normal).multiplyScalar(2 * this.dot(normal)));
  }
  angleTo(v) {
    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
    if (denominator === 0) return Math.PI / 2;
    const theta = this.dot(v) / denominator;

    // clamp, to handle numerical problems

    return Math.acos(MathUtils.clamp(theta, -1, 1));
  }
  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }
  distanceToSquared(v) {
    const dx = this.x - v.x,
      dy = this.y - v.y,
      dz = this.z - v.z;
    return dx * dx + dy * dy + dz * dz;
  }
  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
  }
  setFromSpherical(s) {
    return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
  }
  setFromSphericalCoords(radius, phi, theta) {
    const sinPhiRadius = Math.sin(phi) * radius;
    this.x = sinPhiRadius * Math.sin(theta);
    this.y = Math.cos(phi) * radius;
    this.z = sinPhiRadius * Math.cos(theta);
    return this;
  }
  setFromCylindrical(c) {
    return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
  }
  setFromCylindricalCoords(radius, theta, y) {
    this.x = radius * Math.sin(theta);
    this.y = y;
    this.z = radius * Math.cos(theta);
    return this;
  }
  setFromMatrixPosition(m) {
    const e = m.elements;
    this.x = e[12];
    this.y = e[13];
    this.z = e[14];
    return this;
  }
  setFromMatrixScale(m) {
    const sx = this.setFromMatrixColumn(m, 0).length();
    const sy = this.setFromMatrixColumn(m, 1).length();
    const sz = this.setFromMatrixColumn(m, 2).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  }
  setFromMatrixColumn(m, index) {
    return this.fromArray(m.elements, index * 4);
  }
  setFromMatrix3Column(m, index) {
    return this.fromArray(m.elements, index * 3);
  }
  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    return array;
  }
  fromBufferAttribute(attribute, index, offset) {
    if (offset !== undefined) {
      console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');
    }
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    return this;
  }
}
exports.Vector3 = Vector3;
const _vector = /*@__PURE__*/new Vector3();
const _quaternion = /*@__PURE__*/new Quaternion();
class Box3 {
  constructor(min, max) {
    Object.defineProperty(this, 'isBox3', {
      value: true
    });
    this.min = min !== undefined ? min : new Vector3(+Infinity, +Infinity, +Infinity);
    this.max = max !== undefined ? max : new Vector3(-Infinity, -Infinity, -Infinity);
  }
  set(min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  }
  setFromArray(array) {
    let minX = +Infinity;
    let minY = +Infinity;
    let minZ = +Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;
    for (let i = 0, l = array.length; i < l; i += 3) {
      const x = array[i];
      const y = array[i + 1];
      const z = array[i + 2];
      if (x < minX) minX = x;
      if (y < minY) minY = y;
      if (z < minZ) minZ = z;
      if (x > maxX) maxX = x;
      if (y > maxY) maxY = y;
      if (z > maxZ) maxZ = z;
    }
    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  }
  setFromBufferAttribute(attribute) {
    let minX = +Infinity;
    let minY = +Infinity;
    let minZ = +Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;
    for (let i = 0, l = attribute.count; i < l; i++) {
      const x = attribute.getX(i);
      const y = attribute.getY(i);
      const z = attribute.getZ(i);
      if (x < minX) minX = x;
      if (y < minY) minY = y;
      if (z < minZ) minZ = z;
      if (x > maxX) maxX = x;
      if (y > maxY) maxY = y;
      if (z > maxZ) maxZ = z;
    }
    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  }
  setFromPoints(points) {
    this.makeEmpty();
    for (let i = 0, il = points.length; i < il; i++) {
      this.expandByPoint(points[i]);
    }
    return this;
  }
  setFromCenterAndSize(center, size) {
    const halfSize = _vector$1.copy(size).multiplyScalar(0.5);
    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }
  setFromObject(object) {
    this.makeEmpty();
    return this.expandByObject(object);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }
  makeEmpty() {
    this.min.x = this.min.y = this.min.z = +Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  }
  isEmpty() {
    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(target) {
    if (target === undefined) {
      console.warn('THREE.Box3: .getCenter() target is now required');
      target = new Vector3();
    }
    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(target) {
    if (target === undefined) {
      console.warn('THREE.Box3: .getSize() target is now required');
      target = new Vector3();
    }
    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
  }
  expandByPoint(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  }
  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }
  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }
  expandByObject(object) {
    // Computes the world-axis-aligned bounding box of an object (including its children),
    // accounting for both the object's, and children's, world transforms

    object.updateWorldMatrix(false, false);
    const geometry = object.geometry;
    if (geometry !== undefined) {
      if (geometry.boundingBox === null) {
        geometry.computeBoundingBox();
      }
      _box.copy(geometry.boundingBox);
      _box.applyMatrix4(object.matrixWorld);
      this.union(_box);
    }
    const children = object.children;
    for (let i = 0, l = children.length; i < l; i++) {
      this.expandByObject(children[i]);
    }
    return this;
  }
  containsPoint(point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
  }
  containsBox(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
  }
  getParameter(point, target) {
    // This can potentially have a divide by zero if the box
    // has a size dimension of 0.

    if (target === undefined) {
      console.warn('THREE.Box3: .getParameter() target is now required');
      target = new Vector3();
    }
    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
  }
  intersectsBox(box) {
    // using 6 splitting planes to rule out intersections.
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
  }
  intersectsSphere(sphere) {
    // Find the point on the AABB closest to the sphere center.
    this.clampPoint(sphere.center, _vector$1);

    // If that point is inside the sphere, the AABB and sphere intersect.
    return _vector$1.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
  }
  intersectsPlane(plane) {
    // We compute the minimum and maximum dot product values. If those values
    // are on the same side (back or front) of the plane, then there is no intersection.

    let min, max;
    if (plane.normal.x > 0) {
      min = plane.normal.x * this.min.x;
      max = plane.normal.x * this.max.x;
    } else {
      min = plane.normal.x * this.max.x;
      max = plane.normal.x * this.min.x;
    }
    if (plane.normal.y > 0) {
      min += plane.normal.y * this.min.y;
      max += plane.normal.y * this.max.y;
    } else {
      min += plane.normal.y * this.max.y;
      max += plane.normal.y * this.min.y;
    }
    if (plane.normal.z > 0) {
      min += plane.normal.z * this.min.z;
      max += plane.normal.z * this.max.z;
    } else {
      min += plane.normal.z * this.max.z;
      max += plane.normal.z * this.min.z;
    }
    return min <= -plane.constant && max >= -plane.constant;
  }
  intersectsTriangle(triangle) {
    if (this.isEmpty()) {
      return false;
    }

    // compute box center and extents
    this.getCenter(_center);
    _extents.subVectors(this.max, _center);

    // translate triangle to aabb origin
    _v0.subVectors(triangle.a, _center);
    _v1.subVectors(triangle.b, _center);
    _v2.subVectors(triangle.c, _center);

    // compute edge vectors for triangle
    _f0.subVectors(_v1, _v0);
    _f1.subVectors(_v2, _v1);
    _f2.subVectors(_v0, _v2);

    // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
    // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
    // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
    let axes = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];
    if (!satForAxes(axes, _v0, _v1, _v2, _extents)) {
      return false;
    }

    // test 3 face normals from the aabb
    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    if (!satForAxes(axes, _v0, _v1, _v2, _extents)) {
      return false;
    }

    // finally testing the face normal of the triangle
    // use already existing triangle edge vectors here
    _triangleNormal.crossVectors(_f0, _f1);
    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
    return satForAxes(axes, _v0, _v1, _v2, _extents);
  }
  clampPoint(point, target) {
    if (target === undefined) {
      console.warn('THREE.Box3: .clampPoint() target is now required');
      target = new Vector3();
    }
    return target.copy(point).clamp(this.min, this.max);
  }
  distanceToPoint(point) {
    const clampedPoint = _vector$1.copy(point).clamp(this.min, this.max);
    return clampedPoint.sub(point).length();
  }
  getBoundingSphere(target) {
    if (target === undefined) {
      console.error('THREE.Box3: .getBoundingSphere() target is now required');
      //target = new Sphere(); // removed to avoid cyclic dependency
    }

    this.getCenter(target.center);
    target.radius = this.getSize(_vector$1).length() * 0.5;
    return target;
  }
  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max);

    // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
    if (this.isEmpty()) this.makeEmpty();
    return this;
  }
  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }
  applyMatrix4(matrix) {
    // transform of empty box is an empty box.
    if (this.isEmpty()) return this;

    // NOTE: I am using a binary pattern to specify all 2^3 combinations below
    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000
    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001
    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010
    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011
    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100
    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101
    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110
    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111

    this.setFromPoints(_points);
    return this;
  }
  translate(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  }
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
}
exports.Box3 = Box3;
function satForAxes(axes, v0, v1, v2, extents) {
  for (let i = 0, j = axes.length - 3; i <= j; i += 3) {
    _testAxis.fromArray(axes, i);
    // project the aabb onto the seperating axis
    const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
    // project all 3 vertices of the triangle onto the seperating axis
    const p0 = v0.dot(_testAxis);
    const p1 = v1.dot(_testAxis);
    const p2 = v2.dot(_testAxis);
    // actual test, basically see if either of the most extreme of the triangle points intersects r
    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
      // points of the projected triangle are outside the projected half-length of the aabb
      // the axis is seperating and we can exit
      return false;
    }
  }
  return true;
}
const _points = [/*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3()];
const _vector$1 = /*@__PURE__*/new Vector3();
const _box = /*@__PURE__*/new Box3();

// triangle centered vertices

const _v0 = /*@__PURE__*/new Vector3();
const _v1 = /*@__PURE__*/new Vector3();
const _v2 = /*@__PURE__*/new Vector3();

// triangle edge vectors

const _f0 = /*@__PURE__*/new Vector3();
const _f1 = /*@__PURE__*/new Vector3();
const _f2 = /*@__PURE__*/new Vector3();
const _center = /*@__PURE__*/new Vector3();
const _extents = /*@__PURE__*/new Vector3();
const _triangleNormal = /*@__PURE__*/new Vector3();
const _testAxis = /*@__PURE__*/new Vector3();
const _box$1 = /*@__PURE__*/new Box3();
class Sphere {
  constructor(center, radius) {
    this.center = center !== undefined ? center : new Vector3();
    this.radius = radius !== undefined ? radius : -1;
  }
  set(center, radius) {
    this.center.copy(center);
    this.radius = radius;
    return this;
  }
  setFromPoints(points, optionalCenter) {
    const center = this.center;
    if (optionalCenter !== undefined) {
      center.copy(optionalCenter);
    } else {
      _box$1.setFromPoints(points).getCenter(center);
    }
    let maxRadiusSq = 0;
    for (let i = 0, il = points.length; i < il; i++) {
      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
    }
    this.radius = Math.sqrt(maxRadiusSq);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    this.center.set(0, 0, 0);
    this.radius = -1;
    return this;
  }
  containsPoint(point) {
    return point.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(point) {
    return point.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(sphere) {
    const radiusSum = this.radius + sphere.radius;
    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
  }
  intersectsBox(box) {
    return box.intersectsSphere(this);
  }
  intersectsPlane(plane) {
    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(point, target) {
    const deltaLengthSq = this.center.distanceToSquared(point);
    if (target === undefined) {
      console.warn('THREE.Sphere: .clampPoint() target is now required');
      target = new Vector3();
    }
    target.copy(point);
    if (deltaLengthSq > this.radius * this.radius) {
      target.sub(this.center).normalize();
      target.multiplyScalar(this.radius).add(this.center);
    }
    return target;
  }
  getBoundingBox(target) {
    if (target === undefined) {
      console.warn('THREE.Sphere: .getBoundingBox() target is now required');
      target = new Box3();
    }
    if (this.isEmpty()) {
      // Empty sphere produces empty bounding box
      target.makeEmpty();
      return target;
    }
    target.set(this.center, this.center);
    target.expandByScalar(this.radius);
    return target;
  }
  applyMatrix4(matrix) {
    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();
    return this;
  }
  translate(offset) {
    this.center.add(offset);
    return this;
  }
  equals(sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  }
}
exports.Sphere = Sphere;
const _vector$2 = /*@__PURE__*/new Vector3();
const _segCenter = /*@__PURE__*/new Vector3();
const _segDir = /*@__PURE__*/new Vector3();
const _diff = /*@__PURE__*/new Vector3();
const _edge1 = /*@__PURE__*/new Vector3();
const _edge2 = /*@__PURE__*/new Vector3();
const _normal = /*@__PURE__*/new Vector3();
class Ray {
  constructor(origin, direction) {
    this.origin = origin !== undefined ? origin : new Vector3();
    this.direction = direction !== undefined ? direction : new Vector3(0, 0, -1);
  }
  set(origin, direction) {
    this.origin.copy(origin);
    this.direction.copy(direction);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(ray) {
    this.origin.copy(ray.origin);
    this.direction.copy(ray.direction);
    return this;
  }
  at(t, target) {
    if (target === undefined) {
      console.warn('THREE.Ray: .at() target is now required');
      target = new Vector3();
    }
    return target.copy(this.direction).multiplyScalar(t).add(this.origin);
  }
  lookAt(v) {
    this.direction.copy(v).sub(this.origin).normalize();
    return this;
  }
  recast(t) {
    this.origin.copy(this.at(t, _vector$2));
    return this;
  }
  closestPointToPoint(point, target) {
    if (target === undefined) {
      console.warn('THREE.Ray: .closestPointToPoint() target is now required');
      target = new Vector3();
    }
    target.subVectors(point, this.origin);
    const directionDistance = target.dot(this.direction);
    if (directionDistance < 0) {
      return target.copy(this.origin);
    }
    return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
  }
  distanceToPoint(point) {
    return Math.sqrt(this.distanceSqToPoint(point));
  }
  distanceSqToPoint(point) {
    const directionDistance = _vector$2.subVectors(point, this.origin).dot(this.direction);

    // point behind the ray

    if (directionDistance < 0) {
      return this.origin.distanceToSquared(point);
    }
    _vector$2.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
    return _vector$2.distanceToSquared(point);
  }
  distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
    // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
    // It returns the min distance between the ray and the segment
    // defined by v0 and v1
    // It can also set two optional targets :
    // - The closest point on the ray
    // - The closest point on the segment

    _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
    _segDir.copy(v1).sub(v0).normalize();
    _diff.copy(this.origin).sub(_segCenter);
    const segExtent = v0.distanceTo(v1) * 0.5;
    const a01 = -this.direction.dot(_segDir);
    const b0 = _diff.dot(this.direction);
    const b1 = -_diff.dot(_segDir);
    const c = _diff.lengthSq();
    const det = Math.abs(1 - a01 * a01);
    let s0, s1, sqrDist, extDet;
    if (det > 0) {
      // The ray and segment are not parallel.

      s0 = a01 * b1 - b0;
      s1 = a01 * b0 - b1;
      extDet = segExtent * det;
      if (s0 >= 0) {
        if (s1 >= -extDet) {
          if (s1 <= extDet) {
            // region 0
            // Minimum at interior points of ray and segment.

            const invDet = 1 / det;
            s0 *= invDet;
            s1 *= invDet;
            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
          } else {
            // region 1

            s1 = segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        } else {
          // region 5

          s1 = -segExtent;
          s0 = Math.max(0, -(a01 * s1 + b0));
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
      } else {
        if (s1 <= -extDet) {
          // region 4

          s0 = Math.max(0, -(-a01 * segExtent + b0));
          s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        } else if (s1 <= extDet) {
          // region 3

          s0 = 0;
          s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = s1 * (s1 + 2 * b1) + c;
        } else {
          // region 2

          s0 = Math.max(0, -(a01 * segExtent + b0));
          s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
      }
    } else {
      // Ray and segment are parallel.

      s1 = a01 > 0 ? -segExtent : segExtent;
      s0 = Math.max(0, -(a01 * s1 + b0));
      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
    }
    if (optionalPointOnRay) {
      optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
    }
    if (optionalPointOnSegment) {
      optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
    }
    return sqrDist;
  }
  intersectSphere(sphere, target) {
    _vector$2.subVectors(sphere.center, this.origin);
    const tca = _vector$2.dot(this.direction);
    const d2 = _vector$2.dot(_vector$2) - tca * tca;
    const radius2 = sphere.radius * sphere.radius;
    if (d2 > radius2) return null;
    const thc = Math.sqrt(radius2 - d2);

    // t0 = first intersect point - entrance on front of sphere
    const t0 = tca - thc;

    // t1 = second intersect point - exit point on back of sphere
    const t1 = tca + thc;

    // test to see if both t0 and t1 are behind the ray - if so, return null
    if (t0 < 0 && t1 < 0) return null;

    // test to see if t0 is behind the ray:
    // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
    // in order to always return an intersect point that is in front of the ray.
    if (t0 < 0) return this.at(t1, target);

    // else t0 is in front of the ray, so return the first collision point scaled by t0
    return this.at(t0, target);
  }
  intersectsSphere(sphere) {
    return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
  }
  distanceToPlane(plane) {
    const denominator = plane.normal.dot(this.direction);
    if (denominator === 0) {
      // line is coplanar, return origin
      if (plane.distanceToPoint(this.origin) === 0) {
        return 0;
      }

      // Null is preferable to undefined since undefined means.... it is undefined

      return null;
    }
    const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;

    // Return if the ray never intersects the plane

    return t >= 0 ? t : null;
  }
  intersectPlane(plane, target) {
    const t = this.distanceToPlane(plane);
    if (t === null) {
      return null;
    }
    return this.at(t, target);
  }
  intersectsPlane(plane) {
    // check if the ray lies on the plane first

    const distToPoint = plane.distanceToPoint(this.origin);
    if (distToPoint === 0) {
      return true;
    }
    const denominator = plane.normal.dot(this.direction);
    if (denominator * distToPoint < 0) {
      return true;
    }

    // ray origin is behind the plane (and is pointing behind it)

    return false;
  }
  intersectBox(box, target) {
    let tmin, tmax, tymin, tymax, tzmin, tzmax;
    const invdirx = 1 / this.direction.x,
      invdiry = 1 / this.direction.y,
      invdirz = 1 / this.direction.z;
    const origin = this.origin;
    if (invdirx >= 0) {
      tmin = (box.min.x - origin.x) * invdirx;
      tmax = (box.max.x - origin.x) * invdirx;
    } else {
      tmin = (box.max.x - origin.x) * invdirx;
      tmax = (box.min.x - origin.x) * invdirx;
    }
    if (invdiry >= 0) {
      tymin = (box.min.y - origin.y) * invdiry;
      tymax = (box.max.y - origin.y) * invdiry;
    } else {
      tymin = (box.max.y - origin.y) * invdiry;
      tymax = (box.min.y - origin.y) * invdiry;
    }
    if (tmin > tymax || tymin > tmax) return null;

    // These lines also handle the case where tmin or tmax is NaN
    // (result of 0 * Infinity). x !== x returns true if x is NaN

    if (tymin > tmin || tmin !== tmin) tmin = tymin;
    if (tymax < tmax || tmax !== tmax) tmax = tymax;
    if (invdirz >= 0) {
      tzmin = (box.min.z - origin.z) * invdirz;
      tzmax = (box.max.z - origin.z) * invdirz;
    } else {
      tzmin = (box.max.z - origin.z) * invdirz;
      tzmax = (box.min.z - origin.z) * invdirz;
    }
    if (tmin > tzmax || tzmin > tmax) return null;
    if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
    if (tzmax < tmax || tmax !== tmax) tmax = tzmax;

    //return point closest to the ray (positive side)

    if (tmax < 0) return null;
    return this.at(tmin >= 0 ? tmin : tmax, target);
  }
  intersectsBox(box) {
    return this.intersectBox(box, _vector$2) !== null;
  }
  intersectTriangle(a, b, c, backfaceCulling, target) {
    // Compute the offset origin, edges, and normal.

    // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

    _edge1.subVectors(b, a);
    _edge2.subVectors(c, a);
    _normal.crossVectors(_edge1, _edge2);

    // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
    // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
    //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
    //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
    //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
    let DdN = this.direction.dot(_normal);
    let sign;
    if (DdN > 0) {
      if (backfaceCulling) return null;
      sign = 1;
    } else if (DdN < 0) {
      sign = -1;
      DdN = -DdN;
    } else {
      return null;
    }
    _diff.subVectors(this.origin, a);
    const DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2));

    // b1 < 0, no intersection
    if (DdQxE2 < 0) {
      return null;
    }
    const DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff));

    // b2 < 0, no intersection
    if (DdE1xQ < 0) {
      return null;
    }

    // b1+b2 > 1, no intersection
    if (DdQxE2 + DdE1xQ > DdN) {
      return null;
    }

    // Line intersects triangle, check if ray does.
    const QdN = -sign * _diff.dot(_normal);

    // t < 0, no intersection
    if (QdN < 0) {
      return null;
    }

    // Ray intersects triangle.
    return this.at(QdN / DdN, target);
  }
  applyMatrix4(matrix4) {
    this.origin.applyMatrix4(matrix4);
    this.direction.transformDirection(matrix4);
    return this;
  }
  equals(ray) {
    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
  }
}
exports.Ray = Ray;
class Matrix4 {
  constructor() {
    Object.defineProperty(this, 'isMatrix4', {
      value: true
    });
    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    if (arguments.length > 0) {
      console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');
    }
  }
  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    const te = this.elements;
    te[0] = n11;
    te[4] = n12;
    te[8] = n13;
    te[12] = n14;
    te[1] = n21;
    te[5] = n22;
    te[9] = n23;
    te[13] = n24;
    te[2] = n31;
    te[6] = n32;
    te[10] = n33;
    te[14] = n34;
    te[3] = n41;
    te[7] = n42;
    te[11] = n43;
    te[15] = n44;
    return this;
  }
  identity() {
    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }
  clone() {
    return new Matrix4().fromArray(this.elements);
  }
  copy(m) {
    const te = this.elements;
    const me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    te[9] = me[9];
    te[10] = me[10];
    te[11] = me[11];
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    te[15] = me[15];
    return this;
  }
  copyPosition(m) {
    const te = this.elements,
      me = m.elements;
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    return this;
  }
  setFromMatrix3(m) {
    const me = m.elements;
    this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  }
  makeBasis(xAxis, yAxis, zAxis) {
    this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
    return this;
  }
  extractRotation(m) {
    // this method does not support reflection matrices

    const te = this.elements;
    const me = m.elements;
    const scaleX = 1 / _v1$1.setFromMatrixColumn(m, 0).length();
    const scaleY = 1 / _v1$1.setFromMatrixColumn(m, 1).length();
    const scaleZ = 1 / _v1$1.setFromMatrixColumn(m, 2).length();
    te[0] = me[0] * scaleX;
    te[1] = me[1] * scaleX;
    te[2] = me[2] * scaleX;
    te[3] = 0;
    te[4] = me[4] * scaleY;
    te[5] = me[5] * scaleY;
    te[6] = me[6] * scaleY;
    te[7] = 0;
    te[8] = me[8] * scaleZ;
    te[9] = me[9] * scaleZ;
    te[10] = me[10] * scaleZ;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  makeRotationFromEuler(euler) {
    if (!(euler && euler.isEuler)) {
      console.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
    }
    const te = this.elements;
    const x = euler.x,
      y = euler.y,
      z = euler.z;
    const a = Math.cos(x),
      b = Math.sin(x);
    const c = Math.cos(y),
      d = Math.sin(y);
    const e = Math.cos(z),
      f = Math.sin(z);
    if (euler.order === 'XYZ') {
      const ae = a * e,
        af = a * f,
        be = b * e,
        bf = b * f;
      te[0] = c * e;
      te[4] = -c * f;
      te[8] = d;
      te[1] = af + be * d;
      te[5] = ae - bf * d;
      te[9] = -b * c;
      te[2] = bf - ae * d;
      te[6] = be + af * d;
      te[10] = a * c;
    } else if (euler.order === 'YXZ') {
      const ce = c * e,
        cf = c * f,
        de = d * e,
        df = d * f;
      te[0] = ce + df * b;
      te[4] = de * b - cf;
      te[8] = a * d;
      te[1] = a * f;
      te[5] = a * e;
      te[9] = -b;
      te[2] = cf * b - de;
      te[6] = df + ce * b;
      te[10] = a * c;
    } else if (euler.order === 'ZXY') {
      const ce = c * e,
        cf = c * f,
        de = d * e,
        df = d * f;
      te[0] = ce - df * b;
      te[4] = -a * f;
      te[8] = de + cf * b;
      te[1] = cf + de * b;
      te[5] = a * e;
      te[9] = df - ce * b;
      te[2] = -a * d;
      te[6] = b;
      te[10] = a * c;
    } else if (euler.order === 'ZYX') {
      const ae = a * e,
        af = a * f,
        be = b * e,
        bf = b * f;
      te[0] = c * e;
      te[4] = be * d - af;
      te[8] = ae * d + bf;
      te[1] = c * f;
      te[5] = bf * d + ae;
      te[9] = af * d - be;
      te[2] = -d;
      te[6] = b * c;
      te[10] = a * c;
    } else if (euler.order === 'YZX') {
      const ac = a * c,
        ad = a * d,
        bc = b * c,
        bd = b * d;
      te[0] = c * e;
      te[4] = bd - ac * f;
      te[8] = bc * f + ad;
      te[1] = f;
      te[5] = a * e;
      te[9] = -b * e;
      te[2] = -d * e;
      te[6] = ad * f + bc;
      te[10] = ac - bd * f;
    } else if (euler.order === 'XZY') {
      const ac = a * c,
        ad = a * d,
        bc = b * c,
        bd = b * d;
      te[0] = c * e;
      te[4] = -f;
      te[8] = d * e;
      te[1] = ac * f + bd;
      te[5] = a * e;
      te[9] = ad * f - bc;
      te[2] = bc * f - ad;
      te[6] = b * e;
      te[10] = bd * f + ac;
    }

    // bottom row
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;

    // last column
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  makeRotationFromQuaternion(q) {
    return this.compose(_zero, q, _one);
  }
  lookAt(eye, target, up) {
    const te = this.elements;
    _z.subVectors(eye, target);
    if (_z.lengthSq() === 0) {
      // eye and target are in the same position

      _z.z = 1;
    }
    _z.normalize();
    _x.crossVectors(up, _z);
    if (_x.lengthSq() === 0) {
      // up and z are parallel

      if (Math.abs(up.z) === 1) {
        _z.x += 0.0001;
      } else {
        _z.z += 0.0001;
      }
      _z.normalize();
      _x.crossVectors(up, _z);
    }
    _x.normalize();
    _y.crossVectors(_z, _x);
    te[0] = _x.x;
    te[4] = _y.x;
    te[8] = _z.x;
    te[1] = _x.y;
    te[5] = _y.y;
    te[9] = _z.y;
    te[2] = _x.z;
    te[6] = _y.z;
    te[10] = _z.z;
    return this;
  }
  multiply(m, n) {
    if (n !== undefined) {
      console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
      return this.multiplyMatrices(m, n);
    }
    return this.multiplyMatrices(this, m);
  }
  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }
  multiplyMatrices(a, b) {
    const ae = a.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0],
      a12 = ae[4],
      a13 = ae[8],
      a14 = ae[12];
    const a21 = ae[1],
      a22 = ae[5],
      a23 = ae[9],
      a24 = ae[13];
    const a31 = ae[2],
      a32 = ae[6],
      a33 = ae[10],
      a34 = ae[14];
    const a41 = ae[3],
      a42 = ae[7],
      a43 = ae[11],
      a44 = ae[15];
    const b11 = be[0],
      b12 = be[4],
      b13 = be[8],
      b14 = be[12];
    const b21 = be[1],
      b22 = be[5],
      b23 = be[9],
      b24 = be[13];
    const b31 = be[2],
      b32 = be[6],
      b33 = be[10],
      b34 = be[14];
    const b41 = be[3],
      b42 = be[7],
      b43 = be[11],
      b44 = be[15];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  }
  multiplyScalar(s) {
    const te = this.elements;
    te[0] *= s;
    te[4] *= s;
    te[8] *= s;
    te[12] *= s;
    te[1] *= s;
    te[5] *= s;
    te[9] *= s;
    te[13] *= s;
    te[2] *= s;
    te[6] *= s;
    te[10] *= s;
    te[14] *= s;
    te[3] *= s;
    te[7] *= s;
    te[11] *= s;
    te[15] *= s;
    return this;
  }
  determinant() {
    const te = this.elements;
    const n11 = te[0],
      n12 = te[4],
      n13 = te[8],
      n14 = te[12];
    const n21 = te[1],
      n22 = te[5],
      n23 = te[9],
      n24 = te[13];
    const n31 = te[2],
      n32 = te[6],
      n33 = te[10],
      n34 = te[14];
    const n41 = te[3],
      n42 = te[7],
      n43 = te[11],
      n44 = te[15];

    //TODO: make this more efficient
    //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  }
  transpose() {
    const te = this.elements;
    let tmp;
    tmp = te[1];
    te[1] = te[4];
    te[4] = tmp;
    tmp = te[2];
    te[2] = te[8];
    te[8] = tmp;
    tmp = te[6];
    te[6] = te[9];
    te[9] = tmp;
    tmp = te[3];
    te[3] = te[12];
    te[12] = tmp;
    tmp = te[7];
    te[7] = te[13];
    te[13] = tmp;
    tmp = te[11];
    te[11] = te[14];
    te[14] = tmp;
    return this;
  }
  setPosition(x, y, z) {
    const te = this.elements;
    if (x.isVector3) {
      te[12] = x.x;
      te[13] = x.y;
      te[14] = x.z;
    } else {
      te[12] = x;
      te[13] = y;
      te[14] = z;
    }
    return this;
  }
  invert() {
    // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
    const te = this.elements,
      n11 = te[0],
      n21 = te[1],
      n31 = te[2],
      n41 = te[3],
      n12 = te[4],
      n22 = te[5],
      n32 = te[6],
      n42 = te[7],
      n13 = te[8],
      n23 = te[9],
      n33 = te[10],
      n43 = te[11],
      n14 = te[12],
      n24 = te[13],
      n34 = te[14],
      n44 = te[15],
      t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
      t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
      t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
      t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te[4] = t12 * detInv;
    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te[8] = t13 * detInv;
    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te[12] = t14 * detInv;
    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  }
  scale(v) {
    const te = this.elements;
    const x = v.x,
      y = v.y,
      z = v.z;
    te[0] *= x;
    te[4] *= y;
    te[8] *= z;
    te[1] *= x;
    te[5] *= y;
    te[9] *= z;
    te[2] *= x;
    te[6] *= y;
    te[10] *= z;
    te[3] *= x;
    te[7] *= y;
    te[11] *= z;
    return this;
  }
  getMaxScaleOnAxis() {
    const te = this.elements;
    const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
    const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
    const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  }
  makeTranslation(x, y, z) {
    this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
    return this;
  }
  makeRotationX(theta) {
    const c = Math.cos(theta),
      s = Math.sin(theta);
    this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationY(theta) {
    const c = Math.cos(theta),
      s = Math.sin(theta);
    this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationZ(theta) {
    const c = Math.cos(theta),
      s = Math.sin(theta);
    this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationAxis(axis, angle) {
    // Based on http://www.gamedev.net/reference/articles/article1199.asp

    const c = Math.cos(angle);
    const s = Math.sin(angle);
    const t = 1 - c;
    const x = axis.x,
      y = axis.y,
      z = axis.z;
    const tx = t * x,
      ty = t * y;
    this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
    return this;
  }
  makeScale(x, y, z) {
    this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
    return this;
  }
  makeShear(x, y, z) {
    this.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1);
    return this;
  }
  compose(position, quaternion, scale) {
    const te = this.elements;
    const x = quaternion._x,
      y = quaternion._y,
      z = quaternion._z,
      w = quaternion._w;
    const x2 = x + x,
      y2 = y + y,
      z2 = z + z;
    const xx = x * x2,
      xy = x * y2,
      xz = x * z2;
    const yy = y * y2,
      yz = y * z2,
      zz = z * z2;
    const wx = w * x2,
      wy = w * y2,
      wz = w * z2;
    const sx = scale.x,
      sy = scale.y,
      sz = scale.z;
    te[0] = (1 - (yy + zz)) * sx;
    te[1] = (xy + wz) * sx;
    te[2] = (xz - wy) * sx;
    te[3] = 0;
    te[4] = (xy - wz) * sy;
    te[5] = (1 - (xx + zz)) * sy;
    te[6] = (yz + wx) * sy;
    te[7] = 0;
    te[8] = (xz + wy) * sz;
    te[9] = (yz - wx) * sz;
    te[10] = (1 - (xx + yy)) * sz;
    te[11] = 0;
    te[12] = position.x;
    te[13] = position.y;
    te[14] = position.z;
    te[15] = 1;
    return this;
  }
  decompose(position, quaternion, scale) {
    const te = this.elements;
    let sx = _v1$1.set(te[0], te[1], te[2]).length();
    const sy = _v1$1.set(te[4], te[5], te[6]).length();
    const sz = _v1$1.set(te[8], te[9], te[10]).length();

    // if determine is negative, we need to invert one scale
    const det = this.determinant();
    if (det < 0) sx = -sx;
    position.x = te[12];
    position.y = te[13];
    position.z = te[14];

    // scale the rotation part
    _m1.copy(this);
    const invSX = 1 / sx;
    const invSY = 1 / sy;
    const invSZ = 1 / sz;
    _m1.elements[0] *= invSX;
    _m1.elements[1] *= invSX;
    _m1.elements[2] *= invSX;
    _m1.elements[4] *= invSY;
    _m1.elements[5] *= invSY;
    _m1.elements[6] *= invSY;
    _m1.elements[8] *= invSZ;
    _m1.elements[9] *= invSZ;
    _m1.elements[10] *= invSZ;
    quaternion.setFromRotationMatrix(_m1);
    scale.x = sx;
    scale.y = sy;
    scale.z = sz;
    return this;
  }
  makePerspective(left, right, top, bottom, near, far) {
    if (far === undefined) {
      console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');
    }
    const te = this.elements;
    const x = 2 * near / (right - left);
    const y = 2 * near / (top - bottom);
    const a = (right + left) / (right - left);
    const b = (top + bottom) / (top - bottom);
    const c = -(far + near) / (far - near);
    const d = -2 * far * near / (far - near);
    te[0] = x;
    te[4] = 0;
    te[8] = a;
    te[12] = 0;
    te[1] = 0;
    te[5] = y;
    te[9] = b;
    te[13] = 0;
    te[2] = 0;
    te[6] = 0;
    te[10] = c;
    te[14] = d;
    te[3] = 0;
    te[7] = 0;
    te[11] = -1;
    te[15] = 0;
    return this;
  }
  makeOrthographic(left, right, top, bottom, near, far) {
    const te = this.elements;
    const w = 1.0 / (right - left);
    const h = 1.0 / (top - bottom);
    const p = 1.0 / (far - near);
    const x = (right + left) * w;
    const y = (top + bottom) * h;
    const z = (far + near) * p;
    te[0] = 2 * w;
    te[4] = 0;
    te[8] = 0;
    te[12] = -x;
    te[1] = 0;
    te[5] = 2 * h;
    te[9] = 0;
    te[13] = -y;
    te[2] = 0;
    te[6] = 0;
    te[10] = -2 * p;
    te[14] = -z;
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[15] = 1;
    return this;
  }
  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;
    for (let i = 0; i < 16; i++) {
      if (te[i] !== me[i]) return false;
    }
    return true;
  }
  fromArray(array, offset = 0) {
    for (let i = 0; i < 16; i++) {
      this.elements[i] = array[i + offset];
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    array[offset + 9] = te[9];
    array[offset + 10] = te[10];
    array[offset + 11] = te[11];
    array[offset + 12] = te[12];
    array[offset + 13] = te[13];
    array[offset + 14] = te[14];
    array[offset + 15] = te[15];
    return array;
  }
}
exports.Matrix4 = Matrix4;
const _v1$1 = /*@__PURE__*/new Vector3();
const _m1 = /*@__PURE__*/new Matrix4();
const _zero = /*@__PURE__*/new Vector3(0, 0, 0);
const _one = /*@__PURE__*/new Vector3(1, 1, 1);
const _x = /*@__PURE__*/new Vector3();
const _y = /*@__PURE__*/new Vector3();
const _z = /*@__PURE__*/new Vector3();
class Euler {
  constructor(x = 0, y = 0, z = 0, order = Euler.DefaultOrder) {
    Object.defineProperty(this, 'isEuler', {
      value: true
    });
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(value) {
    this._order = value;
    this._onChangeCallback();
  }
  set(x, y, z, order) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order || this._order;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m, order, update) {
    const clamp = MathUtils.clamp;

    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    const te = m.elements;
    const m11 = te[0],
      m12 = te[4],
      m13 = te[8];
    const m21 = te[1],
      m22 = te[5],
      m23 = te[9];
    const m31 = te[2],
      m32 = te[6],
      m33 = te[10];
    order = order || this._order;
    switch (order) {
      case 'XYZ':
        this._y = Math.asin(clamp(m13, -1, 1));
        if (Math.abs(m13) < 0.9999999) {
          this._x = Math.atan2(-m23, m33);
          this._z = Math.atan2(-m12, m11);
        } else {
          this._x = Math.atan2(m32, m22);
          this._z = 0;
        }
        break;
      case 'YXZ':
        this._x = Math.asin(-clamp(m23, -1, 1));
        if (Math.abs(m23) < 0.9999999) {
          this._y = Math.atan2(m13, m33);
          this._z = Math.atan2(m21, m22);
        } else {
          this._y = Math.atan2(-m31, m11);
          this._z = 0;
        }
        break;
      case 'ZXY':
        this._x = Math.asin(clamp(m32, -1, 1));
        if (Math.abs(m32) < 0.9999999) {
          this._y = Math.atan2(-m31, m33);
          this._z = Math.atan2(-m12, m22);
        } else {
          this._y = 0;
          this._z = Math.atan2(m21, m11);
        }
        break;
      case 'ZYX':
        this._y = Math.asin(-clamp(m31, -1, 1));
        if (Math.abs(m31) < 0.9999999) {
          this._x = Math.atan2(m32, m33);
          this._z = Math.atan2(m21, m11);
        } else {
          this._x = 0;
          this._z = Math.atan2(-m12, m22);
        }
        break;
      case 'YZX':
        this._z = Math.asin(clamp(m21, -1, 1));
        if (Math.abs(m21) < 0.9999999) {
          this._x = Math.atan2(-m23, m22);
          this._y = Math.atan2(-m31, m11);
        } else {
          this._x = 0;
          this._y = Math.atan2(m13, m33);
        }
        break;
      case 'XZY':
        this._z = Math.asin(-clamp(m12, -1, 1));
        if (Math.abs(m12) < 0.9999999) {
          this._x = Math.atan2(m32, m22);
          this._y = Math.atan2(m13, m11);
        } else {
          this._x = Math.atan2(-m23, m33);
          this._y = 0;
        }
        break;
      default:
        console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order);
    }
    this._order = order;
    if (update !== false) this._onChangeCallback();
    return this;
  }
  setFromQuaternion(q, order, update) {
    _matrix.makeRotationFromQuaternion(q);
    return this.setFromRotationMatrix(_matrix, order, update);
  }
  setFromVector3(v, order) {
    return this.set(v.x, v.y, v.z, order || this._order);
  }
  reorder(newOrder) {
    // WARNING: this discards revolution information -bhouston

    _quaternion$1.setFromEuler(this);
    return this.setFromQuaternion(_quaternion$1, newOrder);
  }
  equals(euler) {
    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  }
  fromArray(array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    if (array[3] !== undefined) this._order = array[3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._order;
    return array;
  }
  toVector3(optionalResult) {
    if (optionalResult) {
      return optionalResult.set(this._x, this._y, this._z);
    } else {
      return new Vector3(this._x, this._y, this._z);
    }
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {}
}
exports.Euler = Euler;
Euler.DefaultOrder = 'XYZ';
Euler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];
const _matrix = /*@__PURE__*/new Matrix4();
const _quaternion$1 = /*@__PURE__*/new Quaternion();
class Layers {
  constructor() {
    this.mask = 1 | 0;
  }
  set(channel) {
    this.mask = 1 << channel | 0;
  }
  enable(channel) {
    this.mask |= 1 << channel | 0;
  }
  enableAll() {
    this.mask = 0xffffffff | 0;
  }
  toggle(channel) {
    this.mask ^= 1 << channel | 0;
  }
  disable(channel) {
    this.mask &= ~(1 << channel | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(layers) {
    return (this.mask & layers.mask) !== 0;
  }
}
exports.Layers = Layers;
let _object3DId = 0;
const _v1$2 = new Vector3();
const _q1 = new Quaternion();
const _m1$1 = new Matrix4();
const _target = new Vector3();
const _position = new Vector3();
const _scale = new Vector3();
const _quaternion$2 = new Quaternion();
const _xAxis = new Vector3(1, 0, 0);
const _yAxis = new Vector3(0, 1, 0);
const _zAxis = new Vector3(0, 0, 1);
const _addedEvent = {
  type: 'added'
};
const _removedEvent = {
  type: 'removed'
};
function Object3D() {
  Object.defineProperty(this, 'id', {
    value: _object3DId++
  });
  this.uuid = MathUtils.generateUUID();
  this.name = '';
  this.type = 'Object3D';
  this.parent = null;
  this.children = [];
  this.up = Object3D.DefaultUp.clone();
  const position = new Vector3();
  const rotation = new Euler();
  const quaternion = new Quaternion();
  const scale = new Vector3(1, 1, 1);
  function onRotationChange() {
    quaternion.setFromEuler(rotation, false);
  }
  function onQuaternionChange() {
    rotation.setFromQuaternion(quaternion, undefined, false);
  }
  rotation._onChange(onRotationChange);
  quaternion._onChange(onQuaternionChange);
  Object.defineProperties(this, {
    position: {
      configurable: true,
      enumerable: true,
      value: position
    },
    rotation: {
      configurable: true,
      enumerable: true,
      value: rotation
    },
    quaternion: {
      configurable: true,
      enumerable: true,
      value: quaternion
    },
    scale: {
      configurable: true,
      enumerable: true,
      value: scale
    },
    modelViewMatrix: {
      value: new Matrix4()
    },
    normalMatrix: {
      value: new Matrix3()
    }
  });
  this.matrix = new Matrix4();
  this.matrixWorld = new Matrix4();
  this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
  this.matrixWorldNeedsUpdate = false;
  this.layers = new Layers();
  this.visible = true;
  this.castShadow = false;
  this.receiveShadow = false;
  this.frustumCulled = true;
  this.renderOrder = 0;
  this.animations = [];
  this.userData = {};
}
Object3D.DefaultUp = new Vector3(0, 1, 0);
Object3D.DefaultMatrixAutoUpdate = true;
Object3D.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: Object3D,
  isObject3D: true,
  onBeforeRender: function () {},
  onAfterRender: function () {},
  applyMatrix4: function (matrix) {
    if (this.matrixAutoUpdate) this.updateMatrix();
    this.matrix.premultiply(matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  },
  applyQuaternion: function (q) {
    this.quaternion.premultiply(q);
    return this;
  },
  setRotationFromAxisAngle: function (axis, angle) {
    // assumes axis is normalized

    this.quaternion.setFromAxisAngle(axis, angle);
  },
  setRotationFromEuler: function (euler) {
    this.quaternion.setFromEuler(euler, true);
  },
  setRotationFromMatrix: function (m) {
    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    this.quaternion.setFromRotationMatrix(m);
  },
  setRotationFromQuaternion: function (q) {
    // assumes q is normalized

    this.quaternion.copy(q);
  },
  rotateOnAxis: function (axis, angle) {
    // rotate object on axis in object space
    // axis is assumed to be normalized

    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.multiply(_q1);
    return this;
  },
  rotateOnWorldAxis: function (axis, angle) {
    // rotate object on axis in world space
    // axis is assumed to be normalized
    // method assumes no rotated parent

    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.premultiply(_q1);
    return this;
  },
  rotateX: function (angle) {
    return this.rotateOnAxis(_xAxis, angle);
  },
  rotateY: function (angle) {
    return this.rotateOnAxis(_yAxis, angle);
  },
  rotateZ: function (angle) {
    return this.rotateOnAxis(_zAxis, angle);
  },
  translateOnAxis: function (axis, distance) {
    // translate object by distance along axis in object space
    // axis is assumed to be normalized

    _v1$2.copy(axis).applyQuaternion(this.quaternion);
    this.position.add(_v1$2.multiplyScalar(distance));
    return this;
  },
  translateX: function (distance) {
    return this.translateOnAxis(_xAxis, distance);
  },
  translateY: function (distance) {
    return this.translateOnAxis(_yAxis, distance);
  },
  translateZ: function (distance) {
    return this.translateOnAxis(_zAxis, distance);
  },
  localToWorld: function (vector) {
    return vector.applyMatrix4(this.matrixWorld);
  },
  worldToLocal: function (vector) {
    return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
  },
  lookAt: function (x, y, z) {
    // This method does not support objects having non-uniformly-scaled parent(s)

    if (x.isVector3) {
      _target.copy(x);
    } else {
      _target.set(x, y, z);
    }
    const parent = this.parent;
    this.updateWorldMatrix(true, false);
    _position.setFromMatrixPosition(this.matrixWorld);
    if (this.isCamera || this.isLight) {
      _m1$1.lookAt(_position, _target, this.up);
    } else {
      _m1$1.lookAt(_target, _position, this.up);
    }
    this.quaternion.setFromRotationMatrix(_m1$1);
    if (parent) {
      _m1$1.extractRotation(parent.matrixWorld);
      _q1.setFromRotationMatrix(_m1$1);
      this.quaternion.premultiply(_q1.invert());
    }
  },
  add: function (object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.add(arguments[i]);
      }
      return this;
    }
    if (object === this) {
      console.error('THREE.Object3D.add: object can\'t be added as a child of itself.', object);
      return this;
    }
    if (object && object.isObject3D) {
      if (object.parent !== null) {
        object.parent.remove(object);
      }
      object.parent = this;
      this.children.push(object);
      object.dispatchEvent(_addedEvent);
    } else {
      console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', object);
    }
    return this;
  },
  remove: function (object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.remove(arguments[i]);
      }
      return this;
    }
    const index = this.children.indexOf(object);
    if (index !== -1) {
      object.parent = null;
      this.children.splice(index, 1);
      object.dispatchEvent(_removedEvent);
    }
    return this;
  },
  clear: function () {
    for (let i = 0; i < this.children.length; i++) {
      const object = this.children[i];
      object.parent = null;
      object.dispatchEvent(_removedEvent);
    }
    this.children.length = 0;
    return this;
  },
  attach: function (object) {
    // adds object as a child of this, while maintaining the object's world transform

    this.updateWorldMatrix(true, false);
    _m1$1.copy(this.matrixWorld).invert();
    if (object.parent !== null) {
      object.parent.updateWorldMatrix(true, false);
      _m1$1.multiply(object.parent.matrixWorld);
    }
    object.applyMatrix4(_m1$1);
    object.updateWorldMatrix(false, false);
    this.add(object);
    return this;
  },
  getObjectById: function (id) {
    return this.getObjectByProperty('id', id);
  },
  getObjectByName: function (name) {
    return this.getObjectByProperty('name', name);
  },
  getObjectByProperty: function (name, value) {
    if (this[name] === value) return this;
    for (let i = 0, l = this.children.length; i < l; i++) {
      const child = this.children[i];
      const object = child.getObjectByProperty(name, value);
      if (object !== undefined) {
        return object;
      }
    }
    return undefined;
  },
  getWorldPosition: function (target) {
    if (target === undefined) {
      console.warn('THREE.Object3D: .getWorldPosition() target is now required');
      target = new Vector3();
    }
    this.updateWorldMatrix(true, false);
    return target.setFromMatrixPosition(this.matrixWorld);
  },
  getWorldQuaternion: function (target) {
    if (target === undefined) {
      console.warn('THREE.Object3D: .getWorldQuaternion() target is now required');
      target = new Quaternion();
    }
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position, target, _scale);
    return target;
  },
  getWorldScale: function (target) {
    if (target === undefined) {
      console.warn('THREE.Object3D: .getWorldScale() target is now required');
      target = new Vector3();
    }
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position, _quaternion$2, target);
    return target;
  },
  getWorldDirection: function (target) {
    if (target === undefined) {
      console.warn('THREE.Object3D: .getWorldDirection() target is now required');
      target = new Vector3();
    }
    this.updateWorldMatrix(true, false);
    const e = this.matrixWorld.elements;
    return target.set(e[8], e[9], e[10]).normalize();
  },
  raycast: function () {},
  traverse: function (callback) {
    callback(this);
    const children = this.children;
    for (let i = 0, l = children.length; i < l; i++) {
      children[i].traverse(callback);
    }
  },
  traverseVisible: function (callback) {
    if (this.visible === false) return;
    callback(this);
    const children = this.children;
    for (let i = 0, l = children.length; i < l; i++) {
      children[i].traverseVisible(callback);
    }
  },
  traverseAncestors: function (callback) {
    const parent = this.parent;
    if (parent !== null) {
      callback(parent);
      parent.traverseAncestors(callback);
    }
  },
  updateMatrix: function () {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  },
  updateMatrixWorld: function (force) {
    if (this.matrixAutoUpdate) this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || force) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }
      this.matrixWorldNeedsUpdate = false;
      force = true;
    }

    // update children

    const children = this.children;
    for (let i = 0, l = children.length; i < l; i++) {
      children[i].updateMatrixWorld(force);
    }
  },
  updateWorldMatrix: function (updateParents, updateChildren) {
    const parent = this.parent;
    if (updateParents === true && parent !== null) {
      parent.updateWorldMatrix(true, false);
    }
    if (this.matrixAutoUpdate) this.updateMatrix();
    if (this.parent === null) {
      this.matrixWorld.copy(this.matrix);
    } else {
      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
    }

    // update children

    if (updateChildren === true) {
      const children = this.children;
      for (let i = 0, l = children.length; i < l; i++) {
        children[i].updateWorldMatrix(false, true);
      }
    }
  },
  toJSON: function (meta) {
    // meta is a string when called from JSON.stringify
    const isRootObject = meta === undefined || typeof meta === 'string';
    const output = {};

    // meta is a hash used to collect geometries, materials.
    // not providing it implies that this is the root object
    // being serialized.
    if (isRootObject) {
      // initialize meta obj
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {}
      };
      output.metadata = {
        version: 4.5,
        type: 'Object',
        generator: 'Object3D.toJSON'
      };
    }

    // standard Object3D serialization

    const object = {};
    object.uuid = this.uuid;
    object.type = this.type;
    if (this.name !== '') object.name = this.name;
    if (this.castShadow === true) object.castShadow = true;
    if (this.receiveShadow === true) object.receiveShadow = true;
    if (this.visible === false) object.visible = false;
    if (this.frustumCulled === false) object.frustumCulled = false;
    if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
    if (JSON.stringify(this.userData) !== '{}') object.userData = this.userData;
    object.layers = this.layers.mask;
    object.matrix = this.matrix.toArray();
    if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;

    // object specific properties

    if (this.isInstancedMesh) {
      object.type = 'InstancedMesh';
      object.count = this.count;
      object.instanceMatrix = this.instanceMatrix.toJSON();
    }

    //

    function serialize(library, element) {
      if (library[element.uuid] === undefined) {
        library[element.uuid] = element.toJSON(meta);
      }
      return element.uuid;
    }
    if (this.isMesh || this.isLine || this.isPoints) {
      object.geometry = serialize(meta.geometries, this.geometry);
      const parameters = this.geometry.parameters;
      if (parameters !== undefined && parameters.shapes !== undefined) {
        const shapes = parameters.shapes;
        if (Array.isArray(shapes)) {
          for (let i = 0, l = shapes.length; i < l; i++) {
            const shape = shapes[i];
            serialize(meta.shapes, shape);
          }
        } else {
          serialize(meta.shapes, shapes);
        }
      }
    }
    if (this.isSkinnedMesh) {
      object.bindMode = this.bindMode;
      object.bindMatrix = this.bindMatrix.toArray();
      if (this.skeleton !== undefined) {
        serialize(meta.skeletons, this.skeleton);
        object.skeleton = this.skeleton.uuid;
      }
    }
    if (this.material !== undefined) {
      if (Array.isArray(this.material)) {
        const uuids = [];
        for (let i = 0, l = this.material.length; i < l; i++) {
          uuids.push(serialize(meta.materials, this.material[i]));
        }
        object.material = uuids;
      } else {
        object.material = serialize(meta.materials, this.material);
      }
    }

    //

    if (this.children.length > 0) {
      object.children = [];
      for (let i = 0; i < this.children.length; i++) {
        object.children.push(this.children[i].toJSON(meta).object);
      }
    }

    //

    if (this.animations.length > 0) {
      object.animations = [];
      for (let i = 0; i < this.animations.length; i++) {
        const animation = this.animations[i];
        object.animations.push(serialize(meta.animations, animation));
      }
    }
    if (isRootObject) {
      const geometries = extractFromCache(meta.geometries);
      const materials = extractFromCache(meta.materials);
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const shapes = extractFromCache(meta.shapes);
      const skeletons = extractFromCache(meta.skeletons);
      const animations = extractFromCache(meta.animations);
      if (geometries.length > 0) output.geometries = geometries;
      if (materials.length > 0) output.materials = materials;
      if (textures.length > 0) output.textures = textures;
      if (images.length > 0) output.images = images;
      if (shapes.length > 0) output.shapes = shapes;
      if (skeletons.length > 0) output.skeletons = skeletons;
      if (animations.length > 0) output.animations = animations;
    }
    output.object = object;
    return output;

    // extract data from the cache hash
    // remove metadata on each item
    // and return as array
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data = cache[key];
        delete data.metadata;
        values.push(data);
      }
      return values;
    }
  },
  clone: function (recursive) {
    return new this.constructor().copy(this, recursive);
  },
  copy: function (source, recursive = true) {
    this.name = source.name;
    this.up.copy(source.up);
    this.position.copy(source.position);
    this.rotation.order = source.rotation.order;
    this.quaternion.copy(source.quaternion);
    this.scale.copy(source.scale);
    this.matrix.copy(source.matrix);
    this.matrixWorld.copy(source.matrixWorld);
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
    this.layers.mask = source.layers.mask;
    this.visible = source.visible;
    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;
    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    if (recursive === true) {
      for (let i = 0; i < source.children.length; i++) {
        const child = source.children[i];
        this.add(child.clone());
      }
    }
    return this;
  }
});
const _vector1 = /*@__PURE__*/new Vector3();
const _vector2 = /*@__PURE__*/new Vector3();
const _normalMatrix = /*@__PURE__*/new Matrix3();
class Plane {
  constructor(normal, constant) {
    Object.defineProperty(this, 'isPlane', {
      value: true
    });

    // normal is assumed to be normalized

    this.normal = normal !== undefined ? normal : new Vector3(1, 0, 0);
    this.constant = constant !== undefined ? constant : 0;
  }
  set(normal, constant) {
    this.normal.copy(normal);
    this.constant = constant;
    return this;
  }
  setComponents(x, y, z, w) {
    this.normal.set(x, y, z);
    this.constant = w;
    return this;
  }
  setFromNormalAndCoplanarPoint(normal, point) {
    this.normal.copy(normal);
    this.constant = -point.dot(this.normal);
    return this;
  }
  setFromCoplanarPoints(a, b, c) {
    const normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();

    // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

    this.setFromNormalAndCoplanarPoint(normal, a);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(plane) {
    this.normal.copy(plane.normal);
    this.constant = plane.constant;
    return this;
  }
  normalize() {
    // Note: will lead to a divide by zero if the plane is invalid.

    const inverseNormalLength = 1.0 / this.normal.length();
    this.normal.multiplyScalar(inverseNormalLength);
    this.constant *= inverseNormalLength;
    return this;
  }
  negate() {
    this.constant *= -1;
    this.normal.negate();
    return this;
  }
  distanceToPoint(point) {
    return this.normal.dot(point) + this.constant;
  }
  distanceToSphere(sphere) {
    return this.distanceToPoint(sphere.center) - sphere.radius;
  }
  projectPoint(point, target) {
    if (target === undefined) {
      console.warn('THREE.Plane: .projectPoint() target is now required');
      target = new Vector3();
    }
    return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
  }
  intersectLine(line, target) {
    if (target === undefined) {
      console.warn('THREE.Plane: .intersectLine() target is now required');
      target = new Vector3();
    }
    const direction = line.delta(_vector1);
    const denominator = this.normal.dot(direction);
    if (denominator === 0) {
      // line is coplanar, return origin
      if (this.distanceToPoint(line.start) === 0) {
        return target.copy(line.start);
      }

      // Unsure if this is the correct method to handle this case.
      return undefined;
    }
    const t = -(line.start.dot(this.normal) + this.constant) / denominator;
    if (t < 0 || t > 1) {
      return undefined;
    }
    return target.copy(direction).multiplyScalar(t).add(line.start);
  }
  intersectsLine(line) {
    // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

    const startSign = this.distanceToPoint(line.start);
    const endSign = this.distanceToPoint(line.end);
    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
  }
  intersectsBox(box) {
    return box.intersectsPlane(this);
  }
  intersectsSphere(sphere) {
    return sphere.intersectsPlane(this);
  }
  coplanarPoint(target) {
    if (target === undefined) {
      console.warn('THREE.Plane: .coplanarPoint() target is now required');
      target = new Vector3();
    }
    return target.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(matrix, optionalNormalMatrix) {
    const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
    const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
    const normal = this.normal.applyMatrix3(normalMatrix).normalize();
    this.constant = -referencePoint.dot(normal);
    return this;
  }
  translate(offset) {
    this.constant -= offset.dot(this.normal);
    return this;
  }
  equals(plane) {
    return plane.normal.equals(this.normal) && plane.constant === this.constant;
  }
}
exports.Plane = Plane;
const _v0$1 = /*@__PURE__*/new Vector3();
const _v1$3 = /*@__PURE__*/new Vector3();
const _v2$1 = /*@__PURE__*/new Vector3();
const _v3 = /*@__PURE__*/new Vector3();
const _vab = /*@__PURE__*/new Vector3();
const _vac = /*@__PURE__*/new Vector3();
const _vbc = /*@__PURE__*/new Vector3();
const _vap = /*@__PURE__*/new Vector3();
const _vbp = /*@__PURE__*/new Vector3();
const _vcp = /*@__PURE__*/new Vector3();
class Triangle {
  constructor(a, b, c) {
    this.a = a !== undefined ? a : new Vector3();
    this.b = b !== undefined ? b : new Vector3();
    this.c = c !== undefined ? c : new Vector3();
  }
  static getNormal(a, b, c, target) {
    if (target === undefined) {
      console.warn('THREE.Triangle: .getNormal() target is now required');
      target = new Vector3();
    }
    target.subVectors(c, b);
    _v0$1.subVectors(a, b);
    target.cross(_v0$1);
    const targetLengthSq = target.lengthSq();
    if (targetLengthSq > 0) {
      return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
    }
    return target.set(0, 0, 0);
  }

  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(point, a, b, c, target) {
    _v0$1.subVectors(c, a);
    _v1$3.subVectors(b, a);
    _v2$1.subVectors(point, a);
    const dot00 = _v0$1.dot(_v0$1);
    const dot01 = _v0$1.dot(_v1$3);
    const dot02 = _v0$1.dot(_v2$1);
    const dot11 = _v1$3.dot(_v1$3);
    const dot12 = _v1$3.dot(_v2$1);
    const denom = dot00 * dot11 - dot01 * dot01;
    if (target === undefined) {
      console.warn('THREE.Triangle: .getBarycoord() target is now required');
      target = new Vector3();
    }

    // collinear or singular triangle
    if (denom === 0) {
      // arbitrary location outside of triangle?
      // not sure if this is the best idea, maybe should be returning undefined
      return target.set(-2, -1, -1);
    }
    const invDenom = 1 / denom;
    const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    const v = (dot00 * dot12 - dot01 * dot02) * invDenom;

    // barycentric coordinates must always sum to 1
    return target.set(1 - u - v, v, u);
  }
  static containsPoint(point, a, b, c) {
    this.getBarycoord(point, a, b, c, _v3);
    return _v3.x >= 0 && _v3.y >= 0 && _v3.x + _v3.y <= 1;
  }
  static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
    this.getBarycoord(point, p1, p2, p3, _v3);
    target.set(0, 0);
    target.addScaledVector(uv1, _v3.x);
    target.addScaledVector(uv2, _v3.y);
    target.addScaledVector(uv3, _v3.z);
    return target;
  }
  static isFrontFacing(a, b, c, direction) {
    _v0$1.subVectors(c, b);
    _v1$3.subVectors(a, b);

    // strictly front facing
    return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
  }
  set(a, b, c) {
    this.a.copy(a);
    this.b.copy(b);
    this.c.copy(c);
    return this;
  }
  setFromPointsAndIndices(points, i0, i1, i2) {
    this.a.copy(points[i0]);
    this.b.copy(points[i1]);
    this.c.copy(points[i2]);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(triangle) {
    this.a.copy(triangle.a);
    this.b.copy(triangle.b);
    this.c.copy(triangle.c);
    return this;
  }
  getArea() {
    _v0$1.subVectors(this.c, this.b);
    _v1$3.subVectors(this.a, this.b);
    return _v0$1.cross(_v1$3).length() * 0.5;
  }
  getMidpoint(target) {
    if (target === undefined) {
      console.warn('THREE.Triangle: .getMidpoint() target is now required');
      target = new Vector3();
    }
    return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(target) {
    return Triangle.getNormal(this.a, this.b, this.c, target);
  }
  getPlane(target) {
    if (target === undefined) {
      console.warn('THREE.Triangle: .getPlane() target is now required');
      target = new Plane();
    }
    return target.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(point, target) {
    return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
  }
  getUV(point, uv1, uv2, uv3, target) {
    return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
  }
  containsPoint(point) {
    return Triangle.containsPoint(point, this.a, this.b, this.c);
  }
  isFrontFacing(direction) {
    return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
  }
  intersectsBox(box) {
    return box.intersectsTriangle(this);
  }
  closestPointToPoint(p, target) {
    if (target === undefined) {
      console.warn('THREE.Triangle: .closestPointToPoint() target is now required');
      target = new Vector3();
    }
    const a = this.a,
      b = this.b,
      c = this.c;
    let v, w;

    // algorithm thanks to Real-Time Collision Detection by Christer Ericson,
    // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
    // under the accompanying license; see chapter 5.1.5 for detailed explanation.
    // basically, we're distinguishing which of the voronoi regions of the triangle
    // the point lies in with the minimum amount of redundant computation.

    _vab.subVectors(b, a);
    _vac.subVectors(c, a);
    _vap.subVectors(p, a);
    const d1 = _vab.dot(_vap);
    const d2 = _vac.dot(_vap);
    if (d1 <= 0 && d2 <= 0) {
      // vertex region of A; barycentric coords (1, 0, 0)
      return target.copy(a);
    }
    _vbp.subVectors(p, b);
    const d3 = _vab.dot(_vbp);
    const d4 = _vac.dot(_vbp);
    if (d3 >= 0 && d4 <= d3) {
      // vertex region of B; barycentric coords (0, 1, 0)
      return target.copy(b);
    }
    const vc = d1 * d4 - d3 * d2;
    if (vc <= 0 && d1 >= 0 && d3 <= 0) {
      v = d1 / (d1 - d3);
      // edge region of AB; barycentric coords (1-v, v, 0)
      return target.copy(a).addScaledVector(_vab, v);
    }
    _vcp.subVectors(p, c);
    const d5 = _vab.dot(_vcp);
    const d6 = _vac.dot(_vcp);
    if (d6 >= 0 && d5 <= d6) {
      // vertex region of C; barycentric coords (0, 0, 1)
      return target.copy(c);
    }
    const vb = d5 * d2 - d1 * d6;
    if (vb <= 0 && d2 >= 0 && d6 <= 0) {
      w = d2 / (d2 - d6);
      // edge region of AC; barycentric coords (1-w, 0, w)
      return target.copy(a).addScaledVector(_vac, w);
    }
    const va = d3 * d6 - d5 * d4;
    if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
      _vbc.subVectors(c, b);
      w = (d4 - d3) / (d4 - d3 + (d5 - d6));
      // edge region of BC; barycentric coords (0, 1-w, w)
      return target.copy(b).addScaledVector(_vbc, w); // edge region of BC
    }

    // face region
    const denom = 1 / (va + vb + vc);
    // u = va * denom
    v = vb * denom;
    w = vc * denom;
    return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
  }
  equals(triangle) {
    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
  }
}
exports.Triangle = Triangle;
const _colorKeywords = {
  'aliceblue': 0xF0F8FF,
  'antiquewhite': 0xFAEBD7,
  'aqua': 0x00FFFF,
  'aquamarine': 0x7FFFD4,
  'azure': 0xF0FFFF,
  'beige': 0xF5F5DC,
  'bisque': 0xFFE4C4,
  'black': 0x000000,
  'blanchedalmond': 0xFFEBCD,
  'blue': 0x0000FF,
  'blueviolet': 0x8A2BE2,
  'brown': 0xA52A2A,
  'burlywood': 0xDEB887,
  'cadetblue': 0x5F9EA0,
  'chartreuse': 0x7FFF00,
  'chocolate': 0xD2691E,
  'coral': 0xFF7F50,
  'cornflowerblue': 0x6495ED,
  'cornsilk': 0xFFF8DC,
  'crimson': 0xDC143C,
  'cyan': 0x00FFFF,
  'darkblue': 0x00008B,
  'darkcyan': 0x008B8B,
  'darkgoldenrod': 0xB8860B,
  'darkgray': 0xA9A9A9,
  'darkgreen': 0x006400,
  'darkgrey': 0xA9A9A9,
  'darkkhaki': 0xBDB76B,
  'darkmagenta': 0x8B008B,
  'darkolivegreen': 0x556B2F,
  'darkorange': 0xFF8C00,
  'darkorchid': 0x9932CC,
  'darkred': 0x8B0000,
  'darksalmon': 0xE9967A,
  'darkseagreen': 0x8FBC8F,
  'darkslateblue': 0x483D8B,
  'darkslategray': 0x2F4F4F,
  'darkslategrey': 0x2F4F4F,
  'darkturquoise': 0x00CED1,
  'darkviolet': 0x9400D3,
  'deeppink': 0xFF1493,
  'deepskyblue': 0x00BFFF,
  'dimgray': 0x696969,
  'dimgrey': 0x696969,
  'dodgerblue': 0x1E90FF,
  'firebrick': 0xB22222,
  'floralwhite': 0xFFFAF0,
  'forestgreen': 0x228B22,
  'fuchsia': 0xFF00FF,
  'gainsboro': 0xDCDCDC,
  'ghostwhite': 0xF8F8FF,
  'gold': 0xFFD700,
  'goldenrod': 0xDAA520,
  'gray': 0x808080,
  'green': 0x008000,
  'greenyellow': 0xADFF2F,
  'grey': 0x808080,
  'honeydew': 0xF0FFF0,
  'hotpink': 0xFF69B4,
  'indianred': 0xCD5C5C,
  'indigo': 0x4B0082,
  'ivory': 0xFFFFF0,
  'khaki': 0xF0E68C,
  'lavender': 0xE6E6FA,
  'lavenderblush': 0xFFF0F5,
  'lawngreen': 0x7CFC00,
  'lemonchiffon': 0xFFFACD,
  'lightblue': 0xADD8E6,
  'lightcoral': 0xF08080,
  'lightcyan': 0xE0FFFF,
  'lightgoldenrodyellow': 0xFAFAD2,
  'lightgray': 0xD3D3D3,
  'lightgreen': 0x90EE90,
  'lightgrey': 0xD3D3D3,
  'lightpink': 0xFFB6C1,
  'lightsalmon': 0xFFA07A,
  'lightseagreen': 0x20B2AA,
  'lightskyblue': 0x87CEFA,
  'lightslategray': 0x778899,
  'lightslategrey': 0x778899,
  'lightsteelblue': 0xB0C4DE,
  'lightyellow': 0xFFFFE0,
  'lime': 0x00FF00,
  'limegreen': 0x32CD32,
  'linen': 0xFAF0E6,
  'magenta': 0xFF00FF,
  'maroon': 0x800000,
  'mediumaquamarine': 0x66CDAA,
  'mediumblue': 0x0000CD,
  'mediumorchid': 0xBA55D3,
  'mediumpurple': 0x9370DB,
  'mediumseagreen': 0x3CB371,
  'mediumslateblue': 0x7B68EE,
  'mediumspringgreen': 0x00FA9A,
  'mediumturquoise': 0x48D1CC,
  'mediumvioletred': 0xC71585,
  'midnightblue': 0x191970,
  'mintcream': 0xF5FFFA,
  'mistyrose': 0xFFE4E1,
  'moccasin': 0xFFE4B5,
  'navajowhite': 0xFFDEAD,
  'navy': 0x000080,
  'oldlace': 0xFDF5E6,
  'olive': 0x808000,
  'olivedrab': 0x6B8E23,
  'orange': 0xFFA500,
  'orangered': 0xFF4500,
  'orchid': 0xDA70D6,
  'palegoldenrod': 0xEEE8AA,
  'palegreen': 0x98FB98,
  'paleturquoise': 0xAFEEEE,
  'palevioletred': 0xDB7093,
  'papayawhip': 0xFFEFD5,
  'peachpuff': 0xFFDAB9,
  'peru': 0xCD853F,
  'pink': 0xFFC0CB,
  'plum': 0xDDA0DD,
  'powderblue': 0xB0E0E6,
  'purple': 0x800080,
  'rebeccapurple': 0x663399,
  'red': 0xFF0000,
  'rosybrown': 0xBC8F8F,
  'royalblue': 0x4169E1,
  'saddlebrown': 0x8B4513,
  'salmon': 0xFA8072,
  'sandybrown': 0xF4A460,
  'seagreen': 0x2E8B57,
  'seashell': 0xFFF5EE,
  'sienna': 0xA0522D,
  'silver': 0xC0C0C0,
  'skyblue': 0x87CEEB,
  'slateblue': 0x6A5ACD,
  'slategray': 0x708090,
  'slategrey': 0x708090,
  'snow': 0xFFFAFA,
  'springgreen': 0x00FF7F,
  'steelblue': 0x4682B4,
  'tan': 0xD2B48C,
  'teal': 0x008080,
  'thistle': 0xD8BFD8,
  'tomato': 0xFF6347,
  'turquoise': 0x40E0D0,
  'violet': 0xEE82EE,
  'wheat': 0xF5DEB3,
  'white': 0xFFFFFF,
  'whitesmoke': 0xF5F5F5,
  'yellow': 0xFFFF00,
  'yellowgreen': 0x9ACD32
};
const _hslA = {
  h: 0,
  s: 0,
  l: 0
};
const _hslB = {
  h: 0,
  s: 0,
  l: 0
};
function hue2rgb(p, q, t) {
  if (t < 0) t += 1;
  if (t > 1) t -= 1;
  if (t < 1 / 6) return p + (q - p) * 6 * t;
  if (t < 1 / 2) return q;
  if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
  return p;
}
function SRGBToLinear(c) {
  return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(c) {
  return c < 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
}
class Color {
  constructor(r, g, b) {
    Object.defineProperty(this, 'isColor', {
      value: true
    });
    if (g === undefined && b === undefined) {
      // r is THREE.Color, hex or string
      return this.set(r);
    }
    return this.setRGB(r, g, b);
  }
  set(value) {
    if (value && value.isColor) {
      this.copy(value);
    } else if (typeof value === 'number') {
      this.setHex(value);
    } else if (typeof value === 'string') {
      this.setStyle(value);
    }
    return this;
  }
  setScalar(scalar) {
    this.r = scalar;
    this.g = scalar;
    this.b = scalar;
    return this;
  }
  setHex(hex) {
    hex = Math.floor(hex);
    this.r = (hex >> 16 & 255) / 255;
    this.g = (hex >> 8 & 255) / 255;
    this.b = (hex & 255) / 255;
    return this;
  }
  setRGB(r, g, b) {
    this.r = r;
    this.g = g;
    this.b = b;
    return this;
  }
  setHSL(h, s, l) {
    // h,s,l ranges are in 0.0 - 1.0
    h = MathUtils.euclideanModulo(h, 1);
    s = MathUtils.clamp(s, 0, 1);
    l = MathUtils.clamp(l, 0, 1);
    if (s === 0) {
      this.r = this.g = this.b = l;
    } else {
      const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
      const q = 2 * l - p;
      this.r = hue2rgb(q, p, h + 1 / 3);
      this.g = hue2rgb(q, p, h);
      this.b = hue2rgb(q, p, h - 1 / 3);
    }
    return this;
  }
  setStyle(style) {
    function handleAlpha(string) {
      if (string === undefined) return;
      if (parseFloat(string) < 1) {
        console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
      }
    }
    let m;
    if (m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
      // rgb / hsl

      let color;
      const name = m[1];
      const components = m[2];
      switch (name) {
        case 'rgb':
        case 'rgba':
          if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            // rgb(255,0,0) rgba(255,0,0,0.5)
            this.r = Math.min(255, parseInt(color[1], 10)) / 255;
            this.g = Math.min(255, parseInt(color[2], 10)) / 255;
            this.b = Math.min(255, parseInt(color[3], 10)) / 255;
            handleAlpha(color[4]);
            return this;
          }
          if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
            this.r = Math.min(100, parseInt(color[1], 10)) / 100;
            this.g = Math.min(100, parseInt(color[2], 10)) / 100;
            this.b = Math.min(100, parseInt(color[3], 10)) / 100;
            handleAlpha(color[4]);
            return this;
          }
          break;
        case 'hsl':
        case 'hsla':
          if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            // hsl(120,50%,50%) hsla(120,50%,50%,0.5)
            const h = parseFloat(color[1]) / 360;
            const s = parseInt(color[2], 10) / 100;
            const l = parseInt(color[3], 10) / 100;
            handleAlpha(color[4]);
            return this.setHSL(h, s, l);
          }
          break;
      }
    } else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
      // hex color

      const hex = m[1];
      const size = hex.length;
      if (size === 3) {
        // #ff0
        this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
        this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
        this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
        return this;
      } else if (size === 6) {
        // #ff0000
        this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
        this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
        this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
        return this;
      }
    }
    if (style && style.length > 0) {
      return this.setColorName(style);
    }
    return this;
  }
  setColorName(style) {
    // color keywords
    const hex = _colorKeywords[style];
    if (hex !== undefined) {
      // red
      this.setHex(hex);
    } else {
      // unknown color
      console.warn('THREE.Color: Unknown color ' + style);
    }
    return this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(color) {
    this.r = color.r;
    this.g = color.g;
    this.b = color.b;
    return this;
  }
  copyGammaToLinear(color, gammaFactor = 2.0) {
    this.r = Math.pow(color.r, gammaFactor);
    this.g = Math.pow(color.g, gammaFactor);
    this.b = Math.pow(color.b, gammaFactor);
    return this;
  }
  copyLinearToGamma(color, gammaFactor = 2.0) {
    const safeInverse = gammaFactor > 0 ? 1.0 / gammaFactor : 1.0;
    this.r = Math.pow(color.r, safeInverse);
    this.g = Math.pow(color.g, safeInverse);
    this.b = Math.pow(color.b, safeInverse);
    return this;
  }
  convertGammaToLinear(gammaFactor) {
    this.copyGammaToLinear(this, gammaFactor);
    return this;
  }
  convertLinearToGamma(gammaFactor) {
    this.copyLinearToGamma(this, gammaFactor);
    return this;
  }
  copySRGBToLinear(color) {
    this.r = SRGBToLinear(color.r);
    this.g = SRGBToLinear(color.g);
    this.b = SRGBToLinear(color.b);
    return this;
  }
  copyLinearToSRGB(color) {
    this.r = LinearToSRGB(color.r);
    this.g = LinearToSRGB(color.g);
    this.b = LinearToSRGB(color.b);
    return this;
  }
  convertSRGBToLinear() {
    this.copySRGBToLinear(this);
    return this;
  }
  convertLinearToSRGB() {
    this.copyLinearToSRGB(this);
    return this;
  }
  getHex() {
    return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
  }
  getHexString() {
    return ('000000' + this.getHex().toString(16)).slice(-6);
  }
  getHSL(target) {
    // h,s,l ranges are in 0.0 - 1.0

    if (target === undefined) {
      console.warn('THREE.Color: .getHSL() target is now required');
      target = {
        h: 0,
        s: 0,
        l: 0
      };
    }
    const r = this.r,
      g = this.g,
      b = this.b;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let hue, saturation;
    const lightness = (min + max) / 2.0;
    if (min === max) {
      hue = 0;
      saturation = 0;
    } else {
      const delta = max - min;
      saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
      switch (max) {
        case r:
          hue = (g - b) / delta + (g < b ? 6 : 0);
          break;
        case g:
          hue = (b - r) / delta + 2;
          break;
        case b:
          hue = (r - g) / delta + 4;
          break;
      }
      hue /= 6;
    }
    target.h = hue;
    target.s = saturation;
    target.l = lightness;
    return target;
  }
  getStyle() {
    return 'rgb(' + (this.r * 255 | 0) + ',' + (this.g * 255 | 0) + ',' + (this.b * 255 | 0) + ')';
  }
  offsetHSL(h, s, l) {
    this.getHSL(_hslA);
    _hslA.h += h;
    _hslA.s += s;
    _hslA.l += l;
    this.setHSL(_hslA.h, _hslA.s, _hslA.l);
    return this;
  }
  add(color) {
    this.r += color.r;
    this.g += color.g;
    this.b += color.b;
    return this;
  }
  addColors(color1, color2) {
    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;
    return this;
  }
  addScalar(s) {
    this.r += s;
    this.g += s;
    this.b += s;
    return this;
  }
  sub(color) {
    this.r = Math.max(0, this.r - color.r);
    this.g = Math.max(0, this.g - color.g);
    this.b = Math.max(0, this.b - color.b);
    return this;
  }
  multiply(color) {
    this.r *= color.r;
    this.g *= color.g;
    this.b *= color.b;
    return this;
  }
  multiplyScalar(s) {
    this.r *= s;
    this.g *= s;
    this.b *= s;
    return this;
  }
  lerp(color, alpha) {
    this.r += (color.r - this.r) * alpha;
    this.g += (color.g - this.g) * alpha;
    this.b += (color.b - this.b) * alpha;
    return this;
  }
  lerpColors(color1, color2, alpha) {
    this.r = color1.r + (color2.r - color1.r) * alpha;
    this.g = color1.g + (color2.g - color1.g) * alpha;
    this.b = color1.b + (color2.b - color1.b) * alpha;
    return this;
  }
  lerpHSL(color, alpha) {
    this.getHSL(_hslA);
    color.getHSL(_hslB);
    const h = MathUtils.lerp(_hslA.h, _hslB.h, alpha);
    const s = MathUtils.lerp(_hslA.s, _hslB.s, alpha);
    const l = MathUtils.lerp(_hslA.l, _hslB.l, alpha);
    this.setHSL(h, s, l);
    return this;
  }
  equals(c) {
    return c.r === this.r && c.g === this.g && c.b === this.b;
  }
  fromArray(array, offset = 0) {
    this.r = array[offset];
    this.g = array[offset + 1];
    this.b = array[offset + 2];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.r;
    array[offset + 1] = this.g;
    array[offset + 2] = this.b;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this.r = attribute.getX(index);
    this.g = attribute.getY(index);
    this.b = attribute.getZ(index);
    if (attribute.normalized === true) {
      // assuming Uint8Array

      this.r /= 255;
      this.g /= 255;
      this.b /= 255;
    }
    return this;
  }
  toJSON() {
    return this.getHex();
  }
}
exports.Color = Color;
Color.NAMES = _colorKeywords;
Color.prototype.r = 1;
Color.prototype.g = 1;
Color.prototype.b = 1;
class Face3 {
  constructor(a, b, c, normal, color, materialIndex = 0) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.normal = normal && normal.isVector3 ? normal : new Vector3();
    this.vertexNormals = Array.isArray(normal) ? normal : [];
    this.color = color && color.isColor ? color : new Color();
    this.vertexColors = Array.isArray(color) ? color : [];
    this.materialIndex = materialIndex;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.a = source.a;
    this.b = source.b;
    this.c = source.c;
    this.normal.copy(source.normal);
    this.color.copy(source.color);
    this.materialIndex = source.materialIndex;
    for (let i = 0, il = source.vertexNormals.length; i < il; i++) {
      this.vertexNormals[i] = source.vertexNormals[i].clone();
    }
    for (let i = 0, il = source.vertexColors.length; i < il; i++) {
      this.vertexColors[i] = source.vertexColors[i].clone();
    }
    return this;
  }
}
exports.Face3 = Face3;
let materialId = 0;
function Material() {
  Object.defineProperty(this, 'id', {
    value: materialId++
  });
  this.uuid = MathUtils.generateUUID();
  this.name = '';
  this.type = 'Material';
  this.fog = true;
  this.blending = NormalBlending;
  this.side = FrontSide;
  this.flatShading = false;
  this.vertexColors = false;
  this.opacity = 1;
  this.transparent = false;
  this.blendSrc = SrcAlphaFactor;
  this.blendDst = OneMinusSrcAlphaFactor;
  this.blendEquation = AddEquation;
  this.blendSrcAlpha = null;
  this.blendDstAlpha = null;
  this.blendEquationAlpha = null;
  this.depthFunc = LessEqualDepth;
  this.depthTest = true;
  this.depthWrite = true;
  this.stencilWriteMask = 0xff;
  this.stencilFunc = AlwaysStencilFunc;
  this.stencilRef = 0;
  this.stencilFuncMask = 0xff;
  this.stencilFail = KeepStencilOp;
  this.stencilZFail = KeepStencilOp;
  this.stencilZPass = KeepStencilOp;
  this.stencilWrite = false;
  this.clippingPlanes = null;
  this.clipIntersection = false;
  this.clipShadows = false;
  this.shadowSide = null;
  this.colorWrite = true;
  this.precision = null; // override the renderer's default precision for this material

  this.polygonOffset = false;
  this.polygonOffsetFactor = 0;
  this.polygonOffsetUnits = 0;
  this.dithering = false;
  this.alphaTest = 0;
  this.premultipliedAlpha = false;
  this.visible = true;
  this.toneMapped = true;
  this.userData = {};
  this.version = 0;
}
Material.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: Material,
  isMaterial: true,
  onBeforeCompile: function /* shaderobject, renderer */ () {},
  customProgramCacheKey: function () {
    return this.onBeforeCompile.toString();
  },
  setValues: function (values) {
    if (values === undefined) return;
    for (const key in values) {
      const newValue = values[key];
      if (newValue === undefined) {
        console.warn('THREE.Material: \'' + key + '\' parameter is undefined.');
        continue;
      }

      // for backward compatability if shading is set in the constructor
      if (key === 'shading') {
        console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
        this.flatShading = newValue === FlatShading ? true : false;
        continue;
      }
      const currentValue = this[key];
      if (currentValue === undefined) {
        console.warn('THREE.' + this.type + ': \'' + key + '\' is not a property of this material.');
        continue;
      }
      if (currentValue && currentValue.isColor) {
        currentValue.set(newValue);
      } else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) {
        currentValue.copy(newValue);
      } else {
        this[key] = newValue;
      }
    }
  },
  toJSON: function (meta) {
    const isRoot = meta === undefined || typeof meta === 'string';
    if (isRoot) {
      meta = {
        textures: {},
        images: {}
      };
    }
    const data = {
      metadata: {
        version: 4.5,
        type: 'Material',
        generator: 'Material.toJSON'
      }
    };

    // standard Material serialization
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== '') data.name = this.name;
    if (this.color && this.color.isColor) data.color = this.color.getHex();
    if (this.roughness !== undefined) data.roughness = this.roughness;
    if (this.metalness !== undefined) data.metalness = this.metalness;
    if (this.sheen && this.sheen.isColor) data.sheen = this.sheen.getHex();
    if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
    if (this.emissiveIntensity && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
    if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
    if (this.shininess !== undefined) data.shininess = this.shininess;
    if (this.clearcoat !== undefined) data.clearcoat = this.clearcoat;
    if (this.clearcoatRoughness !== undefined) data.clearcoatRoughness = this.clearcoatRoughness;
    if (this.clearcoatMap && this.clearcoatMap.isTexture) {
      data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
    }
    if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
      data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
    }
    if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
      data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
      data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
    }
    if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
    if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
    if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
    if (this.lightMap && this.lightMap.isTexture) data.lightMap = this.lightMap.toJSON(meta).uuid;
    if (this.aoMap && this.aoMap.isTexture) {
      data.aoMap = this.aoMap.toJSON(meta).uuid;
      data.aoMapIntensity = this.aoMapIntensity;
    }
    if (this.bumpMap && this.bumpMap.isTexture) {
      data.bumpMap = this.bumpMap.toJSON(meta).uuid;
      data.bumpScale = this.bumpScale;
    }
    if (this.normalMap && this.normalMap.isTexture) {
      data.normalMap = this.normalMap.toJSON(meta).uuid;
      data.normalMapType = this.normalMapType;
      data.normalScale = this.normalScale.toArray();
    }
    if (this.displacementMap && this.displacementMap.isTexture) {
      data.displacementMap = this.displacementMap.toJSON(meta).uuid;
      data.displacementScale = this.displacementScale;
      data.displacementBias = this.displacementBias;
    }
    if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
    if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
    if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
    if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;
    if (this.envMap && this.envMap.isTexture) {
      data.envMap = this.envMap.toJSON(meta).uuid;
      data.reflectivity = this.reflectivity; // Scale behind envMap
      data.refractionRatio = this.refractionRatio;
      if (this.combine !== undefined) data.combine = this.combine;
      if (this.envMapIntensity !== undefined) data.envMapIntensity = this.envMapIntensity;
    }
    if (this.gradientMap && this.gradientMap.isTexture) {
      data.gradientMap = this.gradientMap.toJSON(meta).uuid;
    }
    if (this.size !== undefined) data.size = this.size;
    if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;
    if (this.blending !== NormalBlending) data.blending = this.blending;
    if (this.flatShading === true) data.flatShading = this.flatShading;
    if (this.side !== FrontSide) data.side = this.side;
    if (this.vertexColors) data.vertexColors = true;
    if (this.opacity < 1) data.opacity = this.opacity;
    if (this.transparent === true) data.transparent = this.transparent;
    data.depthFunc = this.depthFunc;
    data.depthTest = this.depthTest;
    data.depthWrite = this.depthWrite;
    data.stencilWrite = this.stencilWrite;
    data.stencilWriteMask = this.stencilWriteMask;
    data.stencilFunc = this.stencilFunc;
    data.stencilRef = this.stencilRef;
    data.stencilFuncMask = this.stencilFuncMask;
    data.stencilFail = this.stencilFail;
    data.stencilZFail = this.stencilZFail;
    data.stencilZPass = this.stencilZPass;

    // rotation (SpriteMaterial)
    if (this.rotation && this.rotation !== 0) data.rotation = this.rotation;
    if (this.polygonOffset === true) data.polygonOffset = true;
    if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
    if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
    if (this.linewidth && this.linewidth !== 1) data.linewidth = this.linewidth;
    if (this.dashSize !== undefined) data.dashSize = this.dashSize;
    if (this.gapSize !== undefined) data.gapSize = this.gapSize;
    if (this.scale !== undefined) data.scale = this.scale;
    if (this.dithering === true) data.dithering = true;
    if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
    if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;
    if (this.wireframe === true) data.wireframe = this.wireframe;
    if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
    if (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;
    if (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;
    if (this.morphTargets === true) data.morphTargets = true;
    if (this.morphNormals === true) data.morphNormals = true;
    if (this.skinning === true) data.skinning = true;
    if (this.visible === false) data.visible = false;
    if (this.toneMapped === false) data.toneMapped = false;
    if (JSON.stringify(this.userData) !== '{}') data.userData = this.userData;

    // TODO: Copied from Object3D.toJSON

    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data = cache[key];
        delete data.metadata;
        values.push(data);
      }
      return values;
    }
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      if (textures.length > 0) data.textures = textures;
      if (images.length > 0) data.images = images;
    }
    return data;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (source) {
    this.name = source.name;
    this.fog = source.fog;
    this.blending = source.blending;
    this.side = source.side;
    this.flatShading = source.flatShading;
    this.vertexColors = source.vertexColors;
    this.opacity = source.opacity;
    this.transparent = source.transparent;
    this.blendSrc = source.blendSrc;
    this.blendDst = source.blendDst;
    this.blendEquation = source.blendEquation;
    this.blendSrcAlpha = source.blendSrcAlpha;
    this.blendDstAlpha = source.blendDstAlpha;
    this.blendEquationAlpha = source.blendEquationAlpha;
    this.depthFunc = source.depthFunc;
    this.depthTest = source.depthTest;
    this.depthWrite = source.depthWrite;
    this.stencilWriteMask = source.stencilWriteMask;
    this.stencilFunc = source.stencilFunc;
    this.stencilRef = source.stencilRef;
    this.stencilFuncMask = source.stencilFuncMask;
    this.stencilFail = source.stencilFail;
    this.stencilZFail = source.stencilZFail;
    this.stencilZPass = source.stencilZPass;
    this.stencilWrite = source.stencilWrite;
    const srcPlanes = source.clippingPlanes;
    let dstPlanes = null;
    if (srcPlanes !== null) {
      const n = srcPlanes.length;
      dstPlanes = new Array(n);
      for (let i = 0; i !== n; ++i) {
        dstPlanes[i] = srcPlanes[i].clone();
      }
    }
    this.clippingPlanes = dstPlanes;
    this.clipIntersection = source.clipIntersection;
    this.clipShadows = source.clipShadows;
    this.shadowSide = source.shadowSide;
    this.colorWrite = source.colorWrite;
    this.precision = source.precision;
    this.polygonOffset = source.polygonOffset;
    this.polygonOffsetFactor = source.polygonOffsetFactor;
    this.polygonOffsetUnits = source.polygonOffsetUnits;
    this.dithering = source.dithering;
    this.alphaTest = source.alphaTest;
    this.premultipliedAlpha = source.premultipliedAlpha;
    this.visible = source.visible;
    this.toneMapped = source.toneMapped;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    return this;
  },
  dispose: function () {
    this.dispatchEvent({
      type: 'dispose'
    });
  }
});
Object.defineProperty(Material.prototype, 'needsUpdate', {
  set: function (value) {
    if (value === true) this.version++;
  }
});

/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>
 * }
 */

function MeshBasicMaterial(parameters) {
  Material.call(this);
  this.type = 'MeshBasicMaterial';
  this.color = new Color(0xffffff); // emissive

  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1.0;
  this.aoMap = null;
  this.aoMapIntensity = 1.0;
  this.specularMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.combine = MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';
  this.skinning = false;
  this.morphTargets = false;
  this.setValues(parameters);
}
MeshBasicMaterial.prototype = Object.create(Material.prototype);
MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;
MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
MeshBasicMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.map = source.map;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.specularMap = source.specularMap;
  this.alphaMap = source.alphaMap;
  this.envMap = source.envMap;
  this.combine = source.combine;
  this.reflectivity = source.reflectivity;
  this.refractionRatio = source.refractionRatio;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  return this;
};
const _vector$3 = new Vector3();
const _vector2$1 = new Vector2();
function BufferAttribute(array, itemSize, normalized) {
  if (Array.isArray(array)) {
    throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
  }
  this.name = '';
  this.array = array;
  this.itemSize = itemSize;
  this.count = array !== undefined ? array.length / itemSize : 0;
  this.normalized = normalized === true;
  this.usage = StaticDrawUsage;
  this.updateRange = {
    offset: 0,
    count: -1
  };
  this.version = 0;
}
Object.defineProperty(BufferAttribute.prototype, 'needsUpdate', {
  set: function (value) {
    if (value === true) this.version++;
  }
});
Object.assign(BufferAttribute.prototype, {
  isBufferAttribute: true,
  onUploadCallback: function () {},
  setUsage: function (value) {
    this.usage = value;
    return this;
  },
  copy: function (source) {
    this.name = source.name;
    this.array = new source.array.constructor(source.array);
    this.itemSize = source.itemSize;
    this.count = source.count;
    this.normalized = source.normalized;
    this.usage = source.usage;
    return this;
  },
  copyAt: function (index1, attribute, index2) {
    index1 *= this.itemSize;
    index2 *= attribute.itemSize;
    for (let i = 0, l = this.itemSize; i < l; i++) {
      this.array[index1 + i] = attribute.array[index2 + i];
    }
    return this;
  },
  copyArray: function (array) {
    this.array.set(array);
    return this;
  },
  copyColorsArray: function (colors) {
    const array = this.array;
    let offset = 0;
    for (let i = 0, l = colors.length; i < l; i++) {
      let color = colors[i];
      if (color === undefined) {
        console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i);
        color = new Color();
      }
      array[offset++] = color.r;
      array[offset++] = color.g;
      array[offset++] = color.b;
    }
    return this;
  },
  copyVector2sArray: function (vectors) {
    const array = this.array;
    let offset = 0;
    for (let i = 0, l = vectors.length; i < l; i++) {
      let vector = vectors[i];
      if (vector === undefined) {
        console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i);
        vector = new Vector2();
      }
      array[offset++] = vector.x;
      array[offset++] = vector.y;
    }
    return this;
  },
  copyVector3sArray: function (vectors) {
    const array = this.array;
    let offset = 0;
    for (let i = 0, l = vectors.length; i < l; i++) {
      let vector = vectors[i];
      if (vector === undefined) {
        console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i);
        vector = new Vector3();
      }
      array[offset++] = vector.x;
      array[offset++] = vector.y;
      array[offset++] = vector.z;
    }
    return this;
  },
  copyVector4sArray: function (vectors) {
    const array = this.array;
    let offset = 0;
    for (let i = 0, l = vectors.length; i < l; i++) {
      let vector = vectors[i];
      if (vector === undefined) {
        console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i);
        vector = new Vector4();
      }
      array[offset++] = vector.x;
      array[offset++] = vector.y;
      array[offset++] = vector.z;
      array[offset++] = vector.w;
    }
    return this;
  },
  applyMatrix3: function (m) {
    if (this.itemSize === 2) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector2$1.fromBufferAttribute(this, i);
        _vector2$1.applyMatrix3(m);
        this.setXY(i, _vector2$1.x, _vector2$1.y);
      }
    } else if (this.itemSize === 3) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector$3.fromBufferAttribute(this, i);
        _vector$3.applyMatrix3(m);
        this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
      }
    }
    return this;
  },
  applyMatrix4: function (m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$3.x = this.getX(i);
      _vector$3.y = this.getY(i);
      _vector$3.z = this.getZ(i);
      _vector$3.applyMatrix4(m);
      this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
    }
    return this;
  },
  applyNormalMatrix: function (m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$3.x = this.getX(i);
      _vector$3.y = this.getY(i);
      _vector$3.z = this.getZ(i);
      _vector$3.applyNormalMatrix(m);
      this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
    }
    return this;
  },
  transformDirection: function (m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$3.x = this.getX(i);
      _vector$3.y = this.getY(i);
      _vector$3.z = this.getZ(i);
      _vector$3.transformDirection(m);
      this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
    }
    return this;
  },
  set: function (value, offset = 0) {
    this.array.set(value, offset);
    return this;
  },
  getX: function (index) {
    return this.array[index * this.itemSize];
  },
  setX: function (index, x) {
    this.array[index * this.itemSize] = x;
    return this;
  },
  getY: function (index) {
    return this.array[index * this.itemSize + 1];
  },
  setY: function (index, y) {
    this.array[index * this.itemSize + 1] = y;
    return this;
  },
  getZ: function (index) {
    return this.array[index * this.itemSize + 2];
  },
  setZ: function (index, z) {
    this.array[index * this.itemSize + 2] = z;
    return this;
  },
  getW: function (index) {
    return this.array[index * this.itemSize + 3];
  },
  setW: function (index, w) {
    this.array[index * this.itemSize + 3] = w;
    return this;
  },
  setXY: function (index, x, y) {
    index *= this.itemSize;
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    return this;
  },
  setXYZ: function (index, x, y, z) {
    index *= this.itemSize;
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    return this;
  },
  setXYZW: function (index, x, y, z, w) {
    index *= this.itemSize;
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    this.array[index + 3] = w;
    return this;
  },
  onUpload: function (callback) {
    this.onUploadCallback = callback;
    return this;
  },
  clone: function () {
    return new this.constructor(this.array, this.itemSize).copy(this);
  },
  toJSON: function () {
    return {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.prototype.slice.call(this.array),
      normalized: this.normalized
    };
  }
});

//

function Int8BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Int8Array(array), itemSize, normalized);
}
Int8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;
function Uint8BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint8Array(array), itemSize, normalized);
}
Uint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;
function Uint8ClampedBufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint8ClampedArray(array), itemSize, normalized);
}
Uint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;
function Int16BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Int16Array(array), itemSize, normalized);
}
Int16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;
function Uint16BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
}
Uint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;
function Int32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Int32Array(array), itemSize, normalized);
}
Int32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;
function Uint32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint32Array(array), itemSize, normalized);
}
Uint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;
function Float16BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
}
Float16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float16BufferAttribute.prototype.constructor = Float16BufferAttribute;
Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;
function Float32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Float32Array(array), itemSize, normalized);
}
Float32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;
function Float64BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Float64Array(array), itemSize, normalized);
}
Float64BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;
function arrayMax(array) {
  if (array.length === 0) return -Infinity;
  let max = array[0];
  for (let i = 1, l = array.length; i < l; ++i) {
    if (array[i] > max) max = array[i];
  }
  return max;
}
const TYPED_ARRAYS = {
  Int8Array: Int8Array,
  Uint8Array: Uint8Array,
  // Workaround for IE11 pre KB2929437. See #11440
  Uint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,
  Int16Array: Int16Array,
  Uint16Array: Uint16Array,
  Int32Array: Int32Array,
  Uint32Array: Uint32Array,
  Float32Array: Float32Array,
  Float64Array: Float64Array
};
function getTypedArray(type, buffer) {
  return new TYPED_ARRAYS[type](buffer);
}
let _id = 0;
const _m1$2 = new Matrix4();
const _obj = new Object3D();
const _offset = new Vector3();
const _box$2 = new Box3();
const _boxMorphTargets = new Box3();
const _vector$4 = new Vector3();
function BufferGeometry() {
  Object.defineProperty(this, 'id', {
    value: _id++
  });
  this.uuid = MathUtils.generateUUID();
  this.name = '';
  this.type = 'BufferGeometry';
  this.index = null;
  this.attributes = {};
  this.morphAttributes = {};
  this.morphTargetsRelative = false;
  this.groups = [];
  this.boundingBox = null;
  this.boundingSphere = null;
  this.drawRange = {
    start: 0,
    count: Infinity
  };
  this.userData = {};
}
BufferGeometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: BufferGeometry,
  isBufferGeometry: true,
  getIndex: function () {
    return this.index;
  },
  setIndex: function (index) {
    if (Array.isArray(index)) {
      this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
    } else {
      this.index = index;
    }
    return this;
  },
  getAttribute: function (name) {
    return this.attributes[name];
  },
  setAttribute: function (name, attribute) {
    this.attributes[name] = attribute;
    return this;
  },
  deleteAttribute: function (name) {
    delete this.attributes[name];
    return this;
  },
  hasAttribute: function (name) {
    return this.attributes[name] !== undefined;
  },
  addGroup: function (start, count, materialIndex = 0) {
    this.groups.push({
      start: start,
      count: count,
      materialIndex: materialIndex
    });
  },
  clearGroups: function () {
    this.groups = [];
  },
  setDrawRange: function (start, count) {
    this.drawRange.start = start;
    this.drawRange.count = count;
  },
  applyMatrix4: function (matrix) {
    const position = this.attributes.position;
    if (position !== undefined) {
      position.applyMatrix4(matrix);
      position.needsUpdate = true;
    }
    const normal = this.attributes.normal;
    if (normal !== undefined) {
      const normalMatrix = new Matrix3().getNormalMatrix(matrix);
      normal.applyNormalMatrix(normalMatrix);
      normal.needsUpdate = true;
    }
    const tangent = this.attributes.tangent;
    if (tangent !== undefined) {
      tangent.transformDirection(matrix);
      tangent.needsUpdate = true;
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    return this;
  },
  rotateX: function (angle) {
    // rotate geometry around world x-axis

    _m1$2.makeRotationX(angle);
    this.applyMatrix4(_m1$2);
    return this;
  },
  rotateY: function (angle) {
    // rotate geometry around world y-axis

    _m1$2.makeRotationY(angle);
    this.applyMatrix4(_m1$2);
    return this;
  },
  rotateZ: function (angle) {
    // rotate geometry around world z-axis

    _m1$2.makeRotationZ(angle);
    this.applyMatrix4(_m1$2);
    return this;
  },
  translate: function (x, y, z) {
    // translate geometry

    _m1$2.makeTranslation(x, y, z);
    this.applyMatrix4(_m1$2);
    return this;
  },
  scale: function (x, y, z) {
    // scale geometry

    _m1$2.makeScale(x, y, z);
    this.applyMatrix4(_m1$2);
    return this;
  },
  lookAt: function (vector) {
    _obj.lookAt(vector);
    _obj.updateMatrix();
    this.applyMatrix4(_obj.matrix);
    return this;
  },
  center: function () {
    this.computeBoundingBox();
    this.boundingBox.getCenter(_offset).negate();
    this.translate(_offset.x, _offset.y, _offset.z);
    return this;
  },
  setFromPoints: function (points) {
    const position = [];
    for (let i = 0, l = points.length; i < l; i++) {
      const point = points[i];
      position.push(point.x, point.y, point.z || 0);
    }
    this.setAttribute('position', new Float32BufferAttribute(position, 3));
    return this;
  },
  computeBoundingBox: function () {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(+Infinity, +Infinity, +Infinity));
      return;
    }
    if (position !== undefined) {
      this.boundingBox.setFromBufferAttribute(position);

      // process morph attributes if present

      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];
          _box$2.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$4.addVectors(this.boundingBox.min, _box$2.min);
            this.boundingBox.expandByPoint(_vector$4);
            _vector$4.addVectors(this.boundingBox.max, _box$2.max);
            this.boundingBox.expandByPoint(_vector$4);
          } else {
            this.boundingBox.expandByPoint(_box$2.min);
            this.boundingBox.expandByPoint(_box$2.max);
          }
        }
      }
    } else {
      this.boundingBox.makeEmpty();
    }
    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
  },
  computeBoundingSphere: function () {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingSphere.set(new Vector3(), Infinity);
      return;
    }
    if (position) {
      // first, find the center of the bounding sphere

      const center = this.boundingSphere.center;
      _box$2.setFromBufferAttribute(position);

      // process morph attributes if present

      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];
          _boxMorphTargets.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$4.addVectors(_box$2.min, _boxMorphTargets.min);
            _box$2.expandByPoint(_vector$4);
            _vector$4.addVectors(_box$2.max, _boxMorphTargets.max);
            _box$2.expandByPoint(_vector$4);
          } else {
            _box$2.expandByPoint(_boxMorphTargets.min);
            _box$2.expandByPoint(_boxMorphTargets.max);
          }
        }
      }
      _box$2.getCenter(center);

      // second, try to find a boundingSphere with a radius smaller than the
      // boundingSphere of the boundingBox: sqrt(3) smaller in the best case

      let maxRadiusSq = 0;
      for (let i = 0, il = position.count; i < il; i++) {
        _vector$4.fromBufferAttribute(position, i);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$4));
      }

      // process morph attributes if present

      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];
          const morphTargetsRelative = this.morphTargetsRelative;
          for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
            _vector$4.fromBufferAttribute(morphAttribute, j);
            if (morphTargetsRelative) {
              _offset.fromBufferAttribute(position, j);
              _vector$4.add(_offset);
            }
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$4));
          }
        }
      }
      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
      if (isNaN(this.boundingSphere.radius)) {
        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
  },
  computeFaceNormals: function () {

    // backwards compatibility
  },
  computeTangents: function () {
    const index = this.index;
    const attributes = this.attributes;

    // based on http://www.terathon.com/code/tangent.html
    // (per vertex tangents)

    if (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {
      console.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');
      return;
    }
    const indices = index.array;
    const positions = attributes.position.array;
    const normals = attributes.normal.array;
    const uvs = attributes.uv.array;
    const nVertices = positions.length / 3;
    if (attributes.tangent === undefined) {
      this.setAttribute('tangent', new BufferAttribute(new Float32Array(4 * nVertices), 4));
    }
    const tangents = attributes.tangent.array;
    const tan1 = [],
      tan2 = [];
    for (let i = 0; i < nVertices; i++) {
      tan1[i] = new Vector3();
      tan2[i] = new Vector3();
    }
    const vA = new Vector3(),
      vB = new Vector3(),
      vC = new Vector3(),
      uvA = new Vector2(),
      uvB = new Vector2(),
      uvC = new Vector2(),
      sdir = new Vector3(),
      tdir = new Vector3();
    function handleTriangle(a, b, c) {
      vA.fromArray(positions, a * 3);
      vB.fromArray(positions, b * 3);
      vC.fromArray(positions, c * 3);
      uvA.fromArray(uvs, a * 2);
      uvB.fromArray(uvs, b * 2);
      uvC.fromArray(uvs, c * 2);
      vB.sub(vA);
      vC.sub(vA);
      uvB.sub(uvA);
      uvC.sub(uvA);
      const r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y);

      // silently ignore degenerate uv triangles having coincident or colinear vertices

      if (!isFinite(r)) return;
      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
      tan1[a].add(sdir);
      tan1[b].add(sdir);
      tan1[c].add(sdir);
      tan2[a].add(tdir);
      tan2[b].add(tdir);
      tan2[c].add(tdir);
    }
    let groups = this.groups;
    if (groups.length === 0) {
      groups = [{
        start: 0,
        count: indices.length
      }];
    }
    for (let i = 0, il = groups.length; i < il; ++i) {
      const group = groups[i];
      const start = group.start;
      const count = group.count;
      for (let j = start, jl = start + count; j < jl; j += 3) {
        handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);
      }
    }
    const tmp = new Vector3(),
      tmp2 = new Vector3();
    const n = new Vector3(),
      n2 = new Vector3();
    function handleVertex(v) {
      n.fromArray(normals, v * 3);
      n2.copy(n);
      const t = tan1[v];

      // Gram-Schmidt orthogonalize

      tmp.copy(t);
      tmp.sub(n.multiplyScalar(n.dot(t))).normalize();

      // Calculate handedness

      tmp2.crossVectors(n2, t);
      const test = tmp2.dot(tan2[v]);
      const w = test < 0.0 ? -1.0 : 1.0;
      tangents[v * 4] = tmp.x;
      tangents[v * 4 + 1] = tmp.y;
      tangents[v * 4 + 2] = tmp.z;
      tangents[v * 4 + 3] = w;
    }
    for (let i = 0, il = groups.length; i < il; ++i) {
      const group = groups[i];
      const start = group.start;
      const count = group.count;
      for (let j = start, jl = start + count; j < jl; j += 3) {
        handleVertex(indices[j + 0]);
        handleVertex(indices[j + 1]);
        handleVertex(indices[j + 2]);
      }
    }
  },
  computeVertexNormals: function () {
    const index = this.index;
    const positionAttribute = this.getAttribute('position');
    if (positionAttribute !== undefined) {
      let normalAttribute = this.getAttribute('normal');
      if (normalAttribute === undefined) {
        normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
        this.setAttribute('normal', normalAttribute);
      } else {
        // reset existing normals to zero

        for (let i = 0, il = normalAttribute.count; i < il; i++) {
          normalAttribute.setXYZ(i, 0, 0, 0);
        }
      }
      const pA = new Vector3(),
        pB = new Vector3(),
        pC = new Vector3();
      const nA = new Vector3(),
        nB = new Vector3(),
        nC = new Vector3();
      const cb = new Vector3(),
        ab = new Vector3();

      // indexed elements

      if (index) {
        for (let i = 0, il = index.count; i < il; i += 3) {
          const vA = index.getX(i + 0);
          const vB = index.getX(i + 1);
          const vC = index.getX(i + 2);
          pA.fromBufferAttribute(positionAttribute, vA);
          pB.fromBufferAttribute(positionAttribute, vB);
          pC.fromBufferAttribute(positionAttribute, vC);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          nA.fromBufferAttribute(normalAttribute, vA);
          nB.fromBufferAttribute(normalAttribute, vB);
          nC.fromBufferAttribute(normalAttribute, vC);
          nA.add(cb);
          nB.add(cb);
          nC.add(cb);
          normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
        }
      } else {
        // non-indexed elements (unconnected triangle soup)

        for (let i = 0, il = positionAttribute.count; i < il; i += 3) {
          pA.fromBufferAttribute(positionAttribute, i + 0);
          pB.fromBufferAttribute(positionAttribute, i + 1);
          pC.fromBufferAttribute(positionAttribute, i + 2);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);
        }
      }
      this.normalizeNormals();
      normalAttribute.needsUpdate = true;
    }
  },
  merge: function (geometry, offset) {
    if (!(geometry && geometry.isBufferGeometry)) {
      console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
      return;
    }
    if (offset === undefined) {
      offset = 0;
      console.warn('THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. ' + 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.');
    }
    const attributes = this.attributes;
    for (const key in attributes) {
      if (geometry.attributes[key] === undefined) continue;
      const attribute1 = attributes[key];
      const attributeArray1 = attribute1.array;
      const attribute2 = geometry.attributes[key];
      const attributeArray2 = attribute2.array;
      const attributeOffset = attribute2.itemSize * offset;
      const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);
      for (let i = 0, j = attributeOffset; i < length; i++, j++) {
        attributeArray1[j] = attributeArray2[i];
      }
    }
    return this;
  },
  normalizeNormals: function () {
    const normals = this.attributes.normal;
    for (let i = 0, il = normals.count; i < il; i++) {
      _vector$4.fromBufferAttribute(normals, i);
      _vector$4.normalize();
      normals.setXYZ(i, _vector$4.x, _vector$4.y, _vector$4.z);
    }
  },
  toNonIndexed: function () {
    function convertBufferAttribute(attribute, indices) {
      const array = attribute.array;
      const itemSize = attribute.itemSize;
      const normalized = attribute.normalized;
      const array2 = new array.constructor(indices.length * itemSize);
      let index = 0,
        index2 = 0;
      for (let i = 0, l = indices.length; i < l; i++) {
        index = indices[i] * itemSize;
        for (let j = 0; j < itemSize; j++) {
          array2[index2++] = array[index++];
        }
      }
      return new BufferAttribute(array2, itemSize, normalized);
    }

    //

    if (this.index === null) {
      console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');
      return this;
    }
    const geometry2 = new BufferGeometry();
    const indices = this.index.array;
    const attributes = this.attributes;

    // attributes

    for (const name in attributes) {
      const attribute = attributes[name];
      const newAttribute = convertBufferAttribute(attribute, indices);
      geometry2.setAttribute(name, newAttribute);
    }

    // morph attributes

    const morphAttributes = this.morphAttributes;
    for (const name in morphAttributes) {
      const morphArray = [];
      const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

      for (let i = 0, il = morphAttribute.length; i < il; i++) {
        const attribute = morphAttribute[i];
        const newAttribute = convertBufferAttribute(attribute, indices);
        morphArray.push(newAttribute);
      }
      geometry2.morphAttributes[name] = morphArray;
    }
    geometry2.morphTargetsRelative = this.morphTargetsRelative;

    // groups

    const groups = this.groups;
    for (let i = 0, l = groups.length; i < l; i++) {
      const group = groups[i];
      geometry2.addGroup(group.start, group.count, group.materialIndex);
    }
    return geometry2;
  },
  toJSON: function () {
    const data = {
      metadata: {
        version: 4.5,
        type: 'BufferGeometry',
        generator: 'BufferGeometry.toJSON'
      }
    };

    // standard BufferGeometry serialization

    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== '') data.name = this.name;
    if (Object.keys(this.userData).length > 0) data.userData = this.userData;
    if (this.parameters !== undefined) {
      const parameters = this.parameters;
      for (const key in parameters) {
        if (parameters[key] !== undefined) data[key] = parameters[key];
      }
      return data;
    }
    data.data = {
      attributes: {}
    };
    const index = this.index;
    if (index !== null) {
      data.data.index = {
        type: index.array.constructor.name,
        array: Array.prototype.slice.call(index.array)
      };
    }
    const attributes = this.attributes;
    for (const key in attributes) {
      const attribute = attributes[key];
      const attributeData = attribute.toJSON(data.data);
      if (attribute.name !== '') attributeData.name = attribute.name;
      data.data.attributes[key] = attributeData;
    }
    const morphAttributes = {};
    let hasMorphAttributes = false;
    for (const key in this.morphAttributes) {
      const attributeArray = this.morphAttributes[key];
      const array = [];
      for (let i = 0, il = attributeArray.length; i < il; i++) {
        const attribute = attributeArray[i];
        const attributeData = attribute.toJSON(data.data);
        if (attribute.name !== '') attributeData.name = attribute.name;
        array.push(attributeData);
      }
      if (array.length > 0) {
        morphAttributes[key] = array;
        hasMorphAttributes = true;
      }
    }
    if (hasMorphAttributes) {
      data.data.morphAttributes = morphAttributes;
      data.data.morphTargetsRelative = this.morphTargetsRelative;
    }
    const groups = this.groups;
    if (groups.length > 0) {
      data.data.groups = JSON.parse(JSON.stringify(groups));
    }
    const boundingSphere = this.boundingSphere;
    if (boundingSphere !== null) {
      data.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
      };
    }
    return data;
  },
  clone: function () {
    /*
     // Handle primitives
    	 const parameters = this.parameters;
    	 if ( parameters !== undefined ) {
    	 const values = [];
    	 for ( const key in parameters ) {
    	 values.push( parameters[ key ] );
    	 }
    	 const geometry = Object.create( this.constructor.prototype );
     this.constructor.apply( geometry, values );
     return geometry;
    	 }
    	 return new this.constructor().copy( this );
     */

    return new BufferGeometry().copy(this);
  },
  copy: function (source) {
    // reset

    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;

    // used for storing cloned, shared data

    const data = {};

    // name

    this.name = source.name;

    // index

    const index = source.index;
    if (index !== null) {
      this.setIndex(index.clone(data));
    }

    // attributes

    const attributes = source.attributes;
    for (const name in attributes) {
      const attribute = attributes[name];
      this.setAttribute(name, attribute.clone(data));
    }

    // morph attributes

    const morphAttributes = source.morphAttributes;
    for (const name in morphAttributes) {
      const array = [];
      const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

      for (let i = 0, l = morphAttribute.length; i < l; i++) {
        array.push(morphAttribute[i].clone(data));
      }
      this.morphAttributes[name] = array;
    }
    this.morphTargetsRelative = source.morphTargetsRelative;

    // groups

    const groups = source.groups;
    for (let i = 0, l = groups.length; i < l; i++) {
      const group = groups[i];
      this.addGroup(group.start, group.count, group.materialIndex);
    }

    // bounding box

    const boundingBox = source.boundingBox;
    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    }

    // bounding sphere

    const boundingSphere = source.boundingSphere;
    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    }

    // draw range

    this.drawRange.start = source.drawRange.start;
    this.drawRange.count = source.drawRange.count;

    // user data

    this.userData = source.userData;
    return this;
  },
  dispose: function () {
    this.dispatchEvent({
      type: 'dispose'
    });
  }
});
const _inverseMatrix = new Matrix4();
const _ray = new Ray();
const _sphere = new Sphere();
const _vA = new Vector3();
const _vB = new Vector3();
const _vC = new Vector3();
const _tempA = new Vector3();
const _tempB = new Vector3();
const _tempC = new Vector3();
const _morphA = new Vector3();
const _morphB = new Vector3();
const _morphC = new Vector3();
const _uvA = new Vector2();
const _uvB = new Vector2();
const _uvC = new Vector2();
const _intersectionPoint = new Vector3();
const _intersectionPointWorld = new Vector3();
function Mesh(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
  Object3D.call(this);
  this.type = 'Mesh';
  this.geometry = geometry;
  this.material = material;
  this.updateMorphTargets();
}
Mesh.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Mesh,
  isMesh: true,
  copy: function (source) {
    Object3D.prototype.copy.call(this, source);
    if (source.morphTargetInfluences !== undefined) {
      this.morphTargetInfluences = source.morphTargetInfluences.slice();
    }
    if (source.morphTargetDictionary !== undefined) {
      this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
    }
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  },
  updateMorphTargets: function () {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);
      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];
        if (morphAttribute !== undefined) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
            const name = morphAttribute[m].name || String(m);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;
      if (morphTargets !== undefined && morphTargets.length > 0) {
        console.error('THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
      }
    }
  },
  raycast: function (raycaster, intersects) {
    const geometry = this.geometry;
    const material = this.material;
    const matrixWorld = this.matrixWorld;
    if (material === undefined) return;

    // Checking boundingSphere distance to ray

    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
    _sphere.copy(geometry.boundingSphere);
    _sphere.applyMatrix4(matrixWorld);
    if (raycaster.ray.intersectsSphere(_sphere) === false) return;

    //

    _inverseMatrix.copy(matrixWorld).invert();
    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);

    // Check boundingBox before continuing

    if (geometry.boundingBox !== null) {
      if (_ray.intersectsBox(geometry.boundingBox) === false) return;
    }
    let intersection;
    if (geometry.isBufferGeometry) {
      const index = geometry.index;
      const position = geometry.attributes.position;
      const morphPosition = geometry.morphAttributes.position;
      const morphTargetsRelative = geometry.morphTargetsRelative;
      const uv = geometry.attributes.uv;
      const uv2 = geometry.attributes.uv2;
      const groups = geometry.groups;
      const drawRange = geometry.drawRange;
      if (index !== null) {
        // indexed buffer geometry

        if (Array.isArray(material)) {
          for (let i = 0, il = groups.length; i < il; i++) {
            const group = groups[i];
            const groupMaterial = material[group.materialIndex];
            const start = Math.max(group.start, drawRange.start);
            const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
            for (let j = start, jl = end; j < jl; j += 3) {
              const a = index.getX(j);
              const b = index.getX(j + 1);
              const c = index.getX(j + 2);
              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
              if (intersection) {
                intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics
                intersection.face.materialIndex = group.materialIndex;
                intersects.push(intersection);
              }
            }
          }
        } else {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(index.count, drawRange.start + drawRange.count);
          for (let i = start, il = end; i < il; i += 3) {
            const a = index.getX(i);
            const b = index.getX(i + 1);
            const c = index.getX(i + 2);
            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
            if (intersection) {
              intersection.faceIndex = Math.floor(i / 3); // triangle number in indexed buffer semantics
              intersects.push(intersection);
            }
          }
        }
      } else if (position !== undefined) {
        // non-indexed buffer geometry

        if (Array.isArray(material)) {
          for (let i = 0, il = groups.length; i < il; i++) {
            const group = groups[i];
            const groupMaterial = material[group.materialIndex];
            const start = Math.max(group.start, drawRange.start);
            const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
            for (let j = start, jl = end; j < jl; j += 3) {
              const a = j;
              const b = j + 1;
              const c = j + 2;
              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
              if (intersection) {
                intersection.faceIndex = Math.floor(j / 3); // triangle number in non-indexed buffer semantics
                intersection.face.materialIndex = group.materialIndex;
                intersects.push(intersection);
              }
            }
          }
        } else {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(position.count, drawRange.start + drawRange.count);
          for (let i = start, il = end; i < il; i += 3) {
            const a = i;
            const b = i + 1;
            const c = i + 2;
            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
            if (intersection) {
              intersection.faceIndex = Math.floor(i / 3); // triangle number in non-indexed buffer semantics
              intersects.push(intersection);
            }
          }
        }
      }
    } else if (geometry.isGeometry) {
      console.error('THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
    }
  }
});
function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
  let intersect;
  if (material.side === BackSide) {
    intersect = ray.intersectTriangle(pC, pB, pA, true, point);
  } else {
    intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
  }
  if (intersect === null) return null;
  _intersectionPointWorld.copy(point);
  _intersectionPointWorld.applyMatrix4(object.matrixWorld);
  const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
  if (distance < raycaster.near || distance > raycaster.far) return null;
  return {
    distance: distance,
    point: _intersectionPointWorld.clone(),
    object: object
  };
}
function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {
  _vA.fromBufferAttribute(position, a);
  _vB.fromBufferAttribute(position, b);
  _vC.fromBufferAttribute(position, c);
  const morphInfluences = object.morphTargetInfluences;
  if (material.morphTargets && morphPosition && morphInfluences) {
    _morphA.set(0, 0, 0);
    _morphB.set(0, 0, 0);
    _morphC.set(0, 0, 0);
    for (let i = 0, il = morphPosition.length; i < il; i++) {
      const influence = morphInfluences[i];
      const morphAttribute = morphPosition[i];
      if (influence === 0) continue;
      _tempA.fromBufferAttribute(morphAttribute, a);
      _tempB.fromBufferAttribute(morphAttribute, b);
      _tempC.fromBufferAttribute(morphAttribute, c);
      if (morphTargetsRelative) {
        _morphA.addScaledVector(_tempA, influence);
        _morphB.addScaledVector(_tempB, influence);
        _morphC.addScaledVector(_tempC, influence);
      } else {
        _morphA.addScaledVector(_tempA.sub(_vA), influence);
        _morphB.addScaledVector(_tempB.sub(_vB), influence);
        _morphC.addScaledVector(_tempC.sub(_vC), influence);
      }
    }
    _vA.add(_morphA);
    _vB.add(_morphB);
    _vC.add(_morphC);
  }
  if (object.isSkinnedMesh) {
    object.boneTransform(a, _vA);
    object.boneTransform(b, _vB);
    object.boneTransform(c, _vC);
  }
  const intersection = checkIntersection(object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint);
  if (intersection) {
    if (uv) {
      _uvA.fromBufferAttribute(uv, a);
      _uvB.fromBufferAttribute(uv, b);
      _uvC.fromBufferAttribute(uv, c);
      intersection.uv = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
    }
    if (uv2) {
      _uvA.fromBufferAttribute(uv2, a);
      _uvB.fromBufferAttribute(uv2, b);
      _uvC.fromBufferAttribute(uv2, c);
      intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
    }
    const face = new Face3(a, b, c);
    Triangle.getNormal(_vA, _vB, _vC, face.normal);
    intersection.face = face;
  }
  return intersection;
}
class BoxGeometry extends BufferGeometry {
  constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
    super();
    this.type = 'BoxGeometry';
    this.parameters = {
      width: width,
      height: height,
      depth: depth,
      widthSegments: widthSegments,
      heightSegments: heightSegments,
      depthSegments: depthSegments
    };
    const scope = this;

    // segments

    widthSegments = Math.floor(widthSegments);
    heightSegments = Math.floor(heightSegments);
    depthSegments = Math.floor(depthSegments);

    // buffers

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];

    // helper variables

    let numberOfVertices = 0;
    let groupStart = 0;

    // build each side of the box geometry

    buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px
    buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx
    buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py
    buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny
    buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz
    buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz

    // build geometry

    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
    function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
      const segmentWidth = width / gridX;
      const segmentHeight = height / gridY;
      const widthHalf = width / 2;
      const heightHalf = height / 2;
      const depthHalf = depth / 2;
      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;
      let vertexCounter = 0;
      let groupCount = 0;
      const vector = new Vector3();

      // generate vertices, normals and uvs

      for (let iy = 0; iy < gridY1; iy++) {
        const y = iy * segmentHeight - heightHalf;
        for (let ix = 0; ix < gridX1; ix++) {
          const x = ix * segmentWidth - widthHalf;

          // set values to correct vector component

          vector[u] = x * udir;
          vector[v] = y * vdir;
          vector[w] = depthHalf;

          // now apply vector to vertex buffer

          vertices.push(vector.x, vector.y, vector.z);

          // set values to correct vector component

          vector[u] = 0;
          vector[v] = 0;
          vector[w] = depth > 0 ? 1 : -1;

          // now apply vector to normal buffer

          normals.push(vector.x, vector.y, vector.z);

          // uvs

          uvs.push(ix / gridX);
          uvs.push(1 - iy / gridY);

          // counters

          vertexCounter += 1;
        }
      }

      // indices

      // 1. you need three indices to draw a single face
      // 2. a single segment consists of two faces
      // 3. so we need to generate six (2*3) indices per segment

      for (let iy = 0; iy < gridY; iy++) {
        for (let ix = 0; ix < gridX; ix++) {
          const a = numberOfVertices + ix + gridX1 * iy;
          const b = numberOfVertices + ix + gridX1 * (iy + 1);
          const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
          const d = numberOfVertices + (ix + 1) + gridX1 * iy;

          // faces

          indices.push(a, b, d);
          indices.push(b, c, d);

          // increase counter

          groupCount += 6;
        }
      }

      // add a group to the geometry. this will ensure multi material support

      scope.addGroup(groupStart, groupCount, materialIndex);

      // calculate new start value for groups

      groupStart += groupCount;

      // update total number of vertices

      numberOfVertices += vertexCounter;
    }
  }
}

/**
 * Uniform Utilities
 */
exports.BoxGeometry = exports.BoxBufferGeometry = BoxGeometry;
function cloneUniforms(src) {
  const dst = {};
  for (const u in src) {
    dst[u] = {};
    for (const p in src[u]) {
      const property = src[u][p];
      if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture)) {
        dst[u][p] = property.clone();
      } else if (Array.isArray(property)) {
        dst[u][p] = property.slice();
      } else {
        dst[u][p] = property;
      }
    }
  }
  return dst;
}
function mergeUniforms(uniforms) {
  const merged = {};
  for (let u = 0; u < uniforms.length; u++) {
    const tmp = cloneUniforms(uniforms[u]);
    for (const p in tmp) {
      merged[p] = tmp[p];
    }
  }
  return merged;
}

// Legacy

const UniformsUtils = {
  clone: cloneUniforms,
  merge: mergeUniforms
};
exports.UniformsUtils = UniformsUtils;
var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

/**
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function ShaderMaterial(parameters) {
  Material.call(this);
  this.type = 'ShaderMaterial';
  this.defines = {};
  this.uniforms = {};
  this.vertexShader = default_vertex;
  this.fragmentShader = default_fragment;
  this.linewidth = 1;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.fog = false; // set to use scene fog
  this.lights = false; // set to use scene lights
  this.clipping = false; // set to use user-defined clipping planes

  this.skinning = false; // set to use skinning attribute streams
  this.morphTargets = false; // set to use morph targets
  this.morphNormals = false; // set to use morph normals

  this.extensions = {
    derivatives: false,
    // set to use derivatives
    fragDepth: false,
    // set to use fragment depth values
    drawBuffers: false,
    // set to use draw buffers
    shaderTextureLOD: false // set to use shader texture LOD
  };

  // When rendered geometry doesn't include these attributes but the material does,
  // use these default values in WebGL. This avoids errors when buffer data is missing.
  this.defaultAttributeValues = {
    'color': [1, 1, 1],
    'uv': [0, 0],
    'uv2': [0, 0]
  };
  this.index0AttributeName = undefined;
  this.uniformsNeedUpdate = false;
  this.glslVersion = null;
  if (parameters !== undefined) {
    if (parameters.attributes !== undefined) {
      console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');
    }
    this.setValues(parameters);
  }
}
ShaderMaterial.prototype = Object.create(Material.prototype);
ShaderMaterial.prototype.constructor = ShaderMaterial;
ShaderMaterial.prototype.isShaderMaterial = true;
ShaderMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.fragmentShader = source.fragmentShader;
  this.vertexShader = source.vertexShader;
  this.uniforms = cloneUniforms(source.uniforms);
  this.defines = Object.assign({}, source.defines);
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.lights = source.lights;
  this.clipping = source.clipping;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  this.extensions = Object.assign({}, source.extensions);
  this.glslVersion = source.glslVersion;
  return this;
};
ShaderMaterial.prototype.toJSON = function (meta) {
  const data = Material.prototype.toJSON.call(this, meta);
  data.glslVersion = this.glslVersion;
  data.uniforms = {};
  for (const name in this.uniforms) {
    const uniform = this.uniforms[name];
    const value = uniform.value;
    if (value && value.isTexture) {
      data.uniforms[name] = {
        type: 't',
        value: value.toJSON(meta).uuid
      };
    } else if (value && value.isColor) {
      data.uniforms[name] = {
        type: 'c',
        value: value.getHex()
      };
    } else if (value && value.isVector2) {
      data.uniforms[name] = {
        type: 'v2',
        value: value.toArray()
      };
    } else if (value && value.isVector3) {
      data.uniforms[name] = {
        type: 'v3',
        value: value.toArray()
      };
    } else if (value && value.isVector4) {
      data.uniforms[name] = {
        type: 'v4',
        value: value.toArray()
      };
    } else if (value && value.isMatrix3) {
      data.uniforms[name] = {
        type: 'm3',
        value: value.toArray()
      };
    } else if (value && value.isMatrix4) {
      data.uniforms[name] = {
        type: 'm4',
        value: value.toArray()
      };
    } else {
      data.uniforms[name] = {
        value: value
      };

      // note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far
    }
  }

  if (Object.keys(this.defines).length > 0) data.defines = this.defines;
  data.vertexShader = this.vertexShader;
  data.fragmentShader = this.fragmentShader;
  const extensions = {};
  for (const key in this.extensions) {
    if (this.extensions[key] === true) extensions[key] = true;
  }
  if (Object.keys(extensions).length > 0) data.extensions = extensions;
  return data;
};
function Camera() {
  Object3D.call(this);
  this.type = 'Camera';
  this.matrixWorldInverse = new Matrix4();
  this.projectionMatrix = new Matrix4();
  this.projectionMatrixInverse = new Matrix4();
}
Camera.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Camera,
  isCamera: true,
  copy: function (source, recursive) {
    Object3D.prototype.copy.call(this, source, recursive);
    this.matrixWorldInverse.copy(source.matrixWorldInverse);
    this.projectionMatrix.copy(source.projectionMatrix);
    this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
    return this;
  },
  getWorldDirection: function (target) {
    if (target === undefined) {
      console.warn('THREE.Camera: .getWorldDirection() target is now required');
      target = new Vector3();
    }
    this.updateWorldMatrix(true, false);
    const e = this.matrixWorld.elements;
    return target.set(-e[8], -e[9], -e[10]).normalize();
  },
  updateMatrixWorld: function (force) {
    Object3D.prototype.updateMatrixWorld.call(this, force);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  },
  updateWorldMatrix: function (updateParents, updateChildren) {
    Object3D.prototype.updateWorldMatrix.call(this, updateParents, updateChildren);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  },
  clone: function () {
    return new this.constructor().copy(this);
  }
});
function PerspectiveCamera(fov = 50, aspect = 1, near = 0.1, far = 2000) {
  Camera.call(this);
  this.type = 'PerspectiveCamera';
  this.fov = fov;
  this.zoom = 1;
  this.near = near;
  this.far = far;
  this.focus = 10;
  this.aspect = aspect;
  this.view = null;
  this.filmGauge = 35; // width of the film (default in millimeters)
  this.filmOffset = 0; // horizontal film offset (same unit as gauge)

  this.updateProjectionMatrix();
}
PerspectiveCamera.prototype = Object.assign(Object.create(Camera.prototype), {
  constructor: PerspectiveCamera,
  isPerspectiveCamera: true,
  copy: function (source, recursive) {
    Camera.prototype.copy.call(this, source, recursive);
    this.fov = source.fov;
    this.zoom = source.zoom;
    this.near = source.near;
    this.far = source.far;
    this.focus = source.focus;
    this.aspect = source.aspect;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    this.filmGauge = source.filmGauge;
    this.filmOffset = source.filmOffset;
    return this;
  },
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength: function (focalLength) {
    /** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
    const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
    this.fov = MathUtils.RAD2DEG * 2 * Math.atan(vExtentSlope);
    this.updateProjectionMatrix();
  },
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength: function () {
    const vExtentSlope = Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / vExtentSlope;
  },
  getEffectiveFOV: function () {
    return MathUtils.RAD2DEG * 2 * Math.atan(Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom);
  },
  getFilmWidth: function () {
    // film not completely covered in portrait format (aspect < 1)
    return this.filmGauge * Math.min(this.aspect, 1);
  },
  getFilmHeight: function () {
    // film not completely covered in landscape format (aspect > 1)
    return this.filmGauge / Math.max(this.aspect, 1);
  },
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset: function (fullWidth, fullHeight, x, y, width, height) {
    this.aspect = fullWidth / fullHeight;
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  },
  clearViewOffset: function () {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  },
  updateProjectionMatrix: function () {
    const near = this.near;
    let top = near * Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom;
    let height = 2 * top;
    let width = this.aspect * height;
    let left = -0.5 * width;
    const view = this.view;
    if (this.view !== null && this.view.enabled) {
      const fullWidth = view.fullWidth,
        fullHeight = view.fullHeight;
      left += view.offsetX * width / fullWidth;
      top -= view.offsetY * height / fullHeight;
      width *= view.width / fullWidth;
      height *= view.height / fullHeight;
    }
    const skew = this.filmOffset;
    if (skew !== 0) left += near * skew / this.getFilmWidth();
    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  },
  toJSON: function (meta) {
    const data = Object3D.prototype.toJSON.call(this, meta);
    data.object.fov = this.fov;
    data.object.zoom = this.zoom;
    data.object.near = this.near;
    data.object.far = this.far;
    data.object.focus = this.focus;
    data.object.aspect = this.aspect;
    if (this.view !== null) data.object.view = Object.assign({}, this.view);
    data.object.filmGauge = this.filmGauge;
    data.object.filmOffset = this.filmOffset;
    return data;
  }
});
const fov = 90,
  aspect = 1;
function CubeCamera(near, far, renderTarget) {
  Object3D.call(this);
  this.type = 'CubeCamera';
  if (renderTarget.isWebGLCubeRenderTarget !== true) {
    console.error('THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.');
    return;
  }
  this.renderTarget = renderTarget;
  const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
  cameraPX.layers = this.layers;
  cameraPX.up.set(0, -1, 0);
  cameraPX.lookAt(new Vector3(1, 0, 0));
  this.add(cameraPX);
  const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
  cameraNX.layers = this.layers;
  cameraNX.up.set(0, -1, 0);
  cameraNX.lookAt(new Vector3(-1, 0, 0));
  this.add(cameraNX);
  const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
  cameraPY.layers = this.layers;
  cameraPY.up.set(0, 0, 1);
  cameraPY.lookAt(new Vector3(0, 1, 0));
  this.add(cameraPY);
  const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
  cameraNY.layers = this.layers;
  cameraNY.up.set(0, 0, -1);
  cameraNY.lookAt(new Vector3(0, -1, 0));
  this.add(cameraNY);
  const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
  cameraPZ.layers = this.layers;
  cameraPZ.up.set(0, -1, 0);
  cameraPZ.lookAt(new Vector3(0, 0, 1));
  this.add(cameraPZ);
  const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
  cameraNZ.layers = this.layers;
  cameraNZ.up.set(0, -1, 0);
  cameraNZ.lookAt(new Vector3(0, 0, -1));
  this.add(cameraNZ);
  this.update = function (renderer, scene) {
    if (this.parent === null) this.updateMatrixWorld();
    const currentXrEnabled = renderer.xr.enabled;
    const currentRenderTarget = renderer.getRenderTarget();
    renderer.xr.enabled = false;
    const generateMipmaps = renderTarget.texture.generateMipmaps;
    renderTarget.texture.generateMipmaps = false;
    renderer.setRenderTarget(renderTarget, 0);
    renderer.render(scene, cameraPX);
    renderer.setRenderTarget(renderTarget, 1);
    renderer.render(scene, cameraNX);
    renderer.setRenderTarget(renderTarget, 2);
    renderer.render(scene, cameraPY);
    renderer.setRenderTarget(renderTarget, 3);
    renderer.render(scene, cameraNY);
    renderer.setRenderTarget(renderTarget, 4);
    renderer.render(scene, cameraPZ);
    renderTarget.texture.generateMipmaps = generateMipmaps;
    renderer.setRenderTarget(renderTarget, 5);
    renderer.render(scene, cameraNZ);
    renderer.setRenderTarget(currentRenderTarget);
    renderer.xr.enabled = currentXrEnabled;
  };
}
CubeCamera.prototype = Object.create(Object3D.prototype);
CubeCamera.prototype.constructor = CubeCamera;
function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
  images = images !== undefined ? images : [];
  mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
  format = format !== undefined ? format : RGBFormat;
  Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
  this.flipY = false;

  // Why CubeTexture._needsFlipEnvMap is necessary:
  //
  // By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
  // in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
  // in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.

  // three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
  // and the flag _needsFlipEnvMap controls this conversion. The flip is not required (and thus _needsFlipEnvMap is set to false)
  // when using WebGLCubeRenderTarget.texture as a cube texture.

  this._needsFlipEnvMap = true;
}
CubeTexture.prototype = Object.create(Texture.prototype);
CubeTexture.prototype.constructor = CubeTexture;
CubeTexture.prototype.isCubeTexture = true;
Object.defineProperty(CubeTexture.prototype, 'images', {
  get: function () {
    return this.image;
  },
  set: function (value) {
    this.image = value;
  }
});
class WebGLCubeRenderTarget extends WebGLRenderTarget {
  constructor(size, options, dummy) {
    if (Number.isInteger(options)) {
      console.warn('THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )');
      options = dummy;
    }
    super(size, size, options);
    Object.defineProperty(this, 'isWebGLCubeRenderTarget', {
      value: true
    });
    options = options || {};
    this.texture = new CubeTexture(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
    this.texture._needsFlipEnvMap = false;
  }
  fromEquirectangularTexture(renderer, texture) {
    this.texture.type = texture.type;
    this.texture.format = RGBAFormat; // see #18859
    this.texture.encoding = texture.encoding;
    this.texture.generateMipmaps = texture.generateMipmaps;
    this.texture.minFilter = texture.minFilter;
    this.texture.magFilter = texture.magFilter;
    const shader = {
      uniforms: {
        tEquirect: {
          value: null
        }
      },
      vertexShader: /* glsl */`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
      fragmentShader: /* glsl */`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
    };
    const geometry = new BoxGeometry(5, 5, 5);
    const material = new ShaderMaterial({
      name: 'CubemapFromEquirect',
      uniforms: cloneUniforms(shader.uniforms),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      side: BackSide,
      blending: NoBlending
    });
    material.uniforms.tEquirect.value = texture;
    const mesh = new Mesh(geometry, material);
    const currentMinFilter = texture.minFilter;

    // Avoid blurred poles
    if (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;
    const camera = new CubeCamera(1, 10, this);
    camera.update(renderer, mesh);
    texture.minFilter = currentMinFilter;
    mesh.geometry.dispose();
    mesh.material.dispose();
    return this;
  }
  clear(renderer, color, depth, stencil) {
    const currentRenderTarget = renderer.getRenderTarget();
    for (let i = 0; i < 6; i++) {
      renderer.setRenderTarget(this, i);
      renderer.clear(color, depth, stencil);
    }
    renderer.setRenderTarget(currentRenderTarget);
  }
}
exports.WebGLCubeRenderTarget = WebGLCubeRenderTarget;
function DataTexture(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
  Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
  this.image = {
    data: data || null,
    width: width || 1,
    height: height || 1
  };
  this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
  this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
  this.generateMipmaps = false;
  this.flipY = false;
  this.unpackAlignment = 1;
  this.needsUpdate = true;
}
DataTexture.prototype = Object.create(Texture.prototype);
DataTexture.prototype.constructor = DataTexture;
DataTexture.prototype.isDataTexture = true;
const _sphere$1 = /*@__PURE__*/new Sphere();
const _vector$5 = /*@__PURE__*/new Vector3();
class Frustum {
  constructor(p0, p1, p2, p3, p4, p5) {
    this.planes = [p0 !== undefined ? p0 : new Plane(), p1 !== undefined ? p1 : new Plane(), p2 !== undefined ? p2 : new Plane(), p3 !== undefined ? p3 : new Plane(), p4 !== undefined ? p4 : new Plane(), p5 !== undefined ? p5 : new Plane()];
  }
  set(p0, p1, p2, p3, p4, p5) {
    const planes = this.planes;
    planes[0].copy(p0);
    planes[1].copy(p1);
    planes[2].copy(p2);
    planes[3].copy(p3);
    planes[4].copy(p4);
    planes[5].copy(p5);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(frustum) {
    const planes = this.planes;
    for (let i = 0; i < 6; i++) {
      planes[i].copy(frustum.planes[i]);
    }
    return this;
  }
  setFromProjectionMatrix(m) {
    const planes = this.planes;
    const me = m.elements;
    const me0 = me[0],
      me1 = me[1],
      me2 = me[2],
      me3 = me[3];
    const me4 = me[4],
      me5 = me[5],
      me6 = me[6],
      me7 = me[7];
    const me8 = me[8],
      me9 = me[9],
      me10 = me[10],
      me11 = me[11];
    const me12 = me[12],
      me13 = me[13],
      me14 = me[14],
      me15 = me[15];
    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
    planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
    planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
    return this;
  }
  intersectsObject(object) {
    const geometry = object.geometry;
    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
    _sphere$1.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
    return this.intersectsSphere(_sphere$1);
  }
  intersectsSprite(sprite) {
    _sphere$1.center.set(0, 0, 0);
    _sphere$1.radius = 0.7071067811865476;
    _sphere$1.applyMatrix4(sprite.matrixWorld);
    return this.intersectsSphere(_sphere$1);
  }
  intersectsSphere(sphere) {
    const planes = this.planes;
    const center = sphere.center;
    const negRadius = -sphere.radius;
    for (let i = 0; i < 6; i++) {
      const distance = planes[i].distanceToPoint(center);
      if (distance < negRadius) {
        return false;
      }
    }
    return true;
  }
  intersectsBox(box) {
    const planes = this.planes;
    for (let i = 0; i < 6; i++) {
      const plane = planes[i];

      // corner at max distance

      _vector$5.x = plane.normal.x > 0 ? box.max.x : box.min.x;
      _vector$5.y = plane.normal.y > 0 ? box.max.y : box.min.y;
      _vector$5.z = plane.normal.z > 0 ? box.max.z : box.min.z;
      if (plane.distanceToPoint(_vector$5) < 0) {
        return false;
      }
    }
    return true;
  }
  containsPoint(point) {
    const planes = this.planes;
    for (let i = 0; i < 6; i++) {
      if (planes[i].distanceToPoint(point) < 0) {
        return false;
      }
    }
    return true;
  }
}
exports.Frustum = Frustum;
function WebGLAnimation() {
  let context = null;
  let isAnimating = false;
  let animationLoop = null;
  let requestId = null;
  function onAnimationFrame(time, frame) {
    animationLoop(time, frame);
    requestId = context.requestAnimationFrame(onAnimationFrame);
  }
  return {
    start: function () {
      if (isAnimating === true) return;
      if (animationLoop === null) return;
      requestId = context.requestAnimationFrame(onAnimationFrame);
      isAnimating = true;
    },
    stop: function () {
      context.cancelAnimationFrame(requestId);
      isAnimating = false;
    },
    setAnimationLoop: function (callback) {
      animationLoop = callback;
    },
    setContext: function (value) {
      context = value;
    }
  };
}
function WebGLAttributes(gl, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  const buffers = new WeakMap();
  function createBuffer(attribute, bufferType) {
    const array = attribute.array;
    const usage = attribute.usage;
    const buffer = gl.createBuffer();
    gl.bindBuffer(bufferType, buffer);
    gl.bufferData(bufferType, array, usage);
    attribute.onUploadCallback();
    let type = 5126;
    if (array instanceof Float32Array) {
      type = 5126;
    } else if (array instanceof Float64Array) {
      console.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.');
    } else if (array instanceof Uint16Array) {
      if (attribute.isFloat16BufferAttribute) {
        if (isWebGL2) {
          type = 5131;
        } else {
          console.warn('THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.');
        }
      } else {
        type = 5123;
      }
    } else if (array instanceof Int16Array) {
      type = 5122;
    } else if (array instanceof Uint32Array) {
      type = 5125;
    } else if (array instanceof Int32Array) {
      type = 5124;
    } else if (array instanceof Int8Array) {
      type = 5120;
    } else if (array instanceof Uint8Array) {
      type = 5121;
    }
    return {
      buffer: buffer,
      type: type,
      bytesPerElement: array.BYTES_PER_ELEMENT,
      version: attribute.version
    };
  }
  function updateBuffer(buffer, attribute, bufferType) {
    const array = attribute.array;
    const updateRange = attribute.updateRange;
    gl.bindBuffer(bufferType, buffer);
    if (updateRange.count === -1) {
      // Not using update ranges

      gl.bufferSubData(bufferType, 0, array);
    } else {
      if (isWebGL2) {
        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
      } else {
        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
      }
      updateRange.count = -1; // reset range
    }
  }

  //

  function get(attribute) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    return buffers.get(attribute);
  }
  function remove(attribute) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    const data = buffers.get(attribute);
    if (data) {
      gl.deleteBuffer(data.buffer);
      buffers.delete(attribute);
    }
  }
  function update(attribute, bufferType) {
    if (attribute.isGLBufferAttribute) {
      const cached = buffers.get(attribute);
      if (!cached || cached.version < attribute.version) {
        buffers.set(attribute, {
          buffer: attribute.buffer,
          type: attribute.type,
          bytesPerElement: attribute.elementSize,
          version: attribute.version
        });
      }
      return;
    }
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    const data = buffers.get(attribute);
    if (data === undefined) {
      buffers.set(attribute, createBuffer(attribute, bufferType));
    } else if (data.version < attribute.version) {
      updateBuffer(data.buffer, attribute, bufferType);
      data.version = attribute.version;
    }
  }
  return {
    get: get,
    remove: remove,
    update: update
  };
}
class PlaneGeometry extends BufferGeometry {
  constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
    super();
    this.type = 'PlaneGeometry';
    this.parameters = {
      width: width,
      height: height,
      widthSegments: widthSegments,
      heightSegments: heightSegments
    };
    const width_half = width / 2;
    const height_half = height / 2;
    const gridX = Math.floor(widthSegments);
    const gridY = Math.floor(heightSegments);
    const gridX1 = gridX + 1;
    const gridY1 = gridY + 1;
    const segment_width = width / gridX;
    const segment_height = height / gridY;

    //

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy < gridY1; iy++) {
      const y = iy * segment_height - height_half;
      for (let ix = 0; ix < gridX1; ix++) {
        const x = ix * segment_width - width_half;
        vertices.push(x, -y, 0);
        normals.push(0, 0, 1);
        uvs.push(ix / gridX);
        uvs.push(1 - iy / gridY);
      }
    }
    for (let iy = 0; iy < gridY; iy++) {
      for (let ix = 0; ix < gridX; ix++) {
        const a = ix + gridX1 * iy;
        const b = ix + gridX1 * (iy + 1);
        const c = ix + 1 + gridX1 * (iy + 1);
        const d = ix + 1 + gridX1 * iy;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
  }
}
exports.PlaneGeometry = exports.PlaneBufferGeometry = PlaneGeometry;
var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif";
var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif";
var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";
var begin_vertex = "vec3 transformed = vec3( position );";
var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";
var bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif";
var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";
var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";
var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";
var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";
var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";
var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";
var color_pars_vertex = "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";
var color_vertex = "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";
var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}";
var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";
var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";
var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";
var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";
var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}";
var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";
var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";
var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";
var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";
var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";
var fog_vertex = "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif";
var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif";
var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";
var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";
var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif";
var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";
var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif";
var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif";
var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif";
var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
var lights_toon_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";
var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";
var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif";
var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif";
var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";
var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";
var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";
var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif";
var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";
var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";
var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";
var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif";
var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";
var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif";
var normal_fragment_begin = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";
var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif";
var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif";
var clearcoat_normal_fragment_begin = "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";
var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif";
var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";
var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";
var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";
var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";
var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";
var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";
var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";
var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";
var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";
var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";
var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";
var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";
var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";
var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
var transmissionmap_fragment = "#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif";
var transmissionmap_pars_fragment = "#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif";
var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";
var uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";
var uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";
var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";
var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";
var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
var cube_frag = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";
var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";
var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";
var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";
var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";
var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";
var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";
var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";
var meshtoon_frag = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshtoon_vert = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var meshphysical_frag = "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshphysical_vert = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";
var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";
var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";
var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
var shadow_vert = "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
const ShaderChunk = {
  alphamap_fragment: alphamap_fragment,
  alphamap_pars_fragment: alphamap_pars_fragment,
  alphatest_fragment: alphatest_fragment,
  aomap_fragment: aomap_fragment,
  aomap_pars_fragment: aomap_pars_fragment,
  begin_vertex: begin_vertex,
  beginnormal_vertex: beginnormal_vertex,
  bsdfs: bsdfs,
  bumpmap_pars_fragment: bumpmap_pars_fragment,
  clipping_planes_fragment: clipping_planes_fragment,
  clipping_planes_pars_fragment: clipping_planes_pars_fragment,
  clipping_planes_pars_vertex: clipping_planes_pars_vertex,
  clipping_planes_vertex: clipping_planes_vertex,
  color_fragment: color_fragment,
  color_pars_fragment: color_pars_fragment,
  color_pars_vertex: color_pars_vertex,
  color_vertex: color_vertex,
  common: common,
  cube_uv_reflection_fragment: cube_uv_reflection_fragment,
  defaultnormal_vertex: defaultnormal_vertex,
  displacementmap_pars_vertex: displacementmap_pars_vertex,
  displacementmap_vertex: displacementmap_vertex,
  emissivemap_fragment: emissivemap_fragment,
  emissivemap_pars_fragment: emissivemap_pars_fragment,
  encodings_fragment: encodings_fragment,
  encodings_pars_fragment: encodings_pars_fragment,
  envmap_fragment: envmap_fragment,
  envmap_common_pars_fragment: envmap_common_pars_fragment,
  envmap_pars_fragment: envmap_pars_fragment,
  envmap_pars_vertex: envmap_pars_vertex,
  envmap_physical_pars_fragment: envmap_physical_pars_fragment,
  envmap_vertex: envmap_vertex,
  fog_vertex: fog_vertex,
  fog_pars_vertex: fog_pars_vertex,
  fog_fragment: fog_fragment,
  fog_pars_fragment: fog_pars_fragment,
  gradientmap_pars_fragment: gradientmap_pars_fragment,
  lightmap_fragment: lightmap_fragment,
  lightmap_pars_fragment: lightmap_pars_fragment,
  lights_lambert_vertex: lights_lambert_vertex,
  lights_pars_begin: lights_pars_begin,
  lights_toon_fragment: lights_toon_fragment,
  lights_toon_pars_fragment: lights_toon_pars_fragment,
  lights_phong_fragment: lights_phong_fragment,
  lights_phong_pars_fragment: lights_phong_pars_fragment,
  lights_physical_fragment: lights_physical_fragment,
  lights_physical_pars_fragment: lights_physical_pars_fragment,
  lights_fragment_begin: lights_fragment_begin,
  lights_fragment_maps: lights_fragment_maps,
  lights_fragment_end: lights_fragment_end,
  logdepthbuf_fragment: logdepthbuf_fragment,
  logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
  logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
  logdepthbuf_vertex: logdepthbuf_vertex,
  map_fragment: map_fragment,
  map_pars_fragment: map_pars_fragment,
  map_particle_fragment: map_particle_fragment,
  map_particle_pars_fragment: map_particle_pars_fragment,
  metalnessmap_fragment: metalnessmap_fragment,
  metalnessmap_pars_fragment: metalnessmap_pars_fragment,
  morphnormal_vertex: morphnormal_vertex,
  morphtarget_pars_vertex: morphtarget_pars_vertex,
  morphtarget_vertex: morphtarget_vertex,
  normal_fragment_begin: normal_fragment_begin,
  normal_fragment_maps: normal_fragment_maps,
  normalmap_pars_fragment: normalmap_pars_fragment,
  clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
  clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
  clearcoat_pars_fragment: clearcoat_pars_fragment,
  packing: packing,
  premultiplied_alpha_fragment: premultiplied_alpha_fragment,
  project_vertex: project_vertex,
  dithering_fragment: dithering_fragment,
  dithering_pars_fragment: dithering_pars_fragment,
  roughnessmap_fragment: roughnessmap_fragment,
  roughnessmap_pars_fragment: roughnessmap_pars_fragment,
  shadowmap_pars_fragment: shadowmap_pars_fragment,
  shadowmap_pars_vertex: shadowmap_pars_vertex,
  shadowmap_vertex: shadowmap_vertex,
  shadowmask_pars_fragment: shadowmask_pars_fragment,
  skinbase_vertex: skinbase_vertex,
  skinning_pars_vertex: skinning_pars_vertex,
  skinning_vertex: skinning_vertex,
  skinnormal_vertex: skinnormal_vertex,
  specularmap_fragment: specularmap_fragment,
  specularmap_pars_fragment: specularmap_pars_fragment,
  tonemapping_fragment: tonemapping_fragment,
  tonemapping_pars_fragment: tonemapping_pars_fragment,
  transmissionmap_fragment: transmissionmap_fragment,
  transmissionmap_pars_fragment: transmissionmap_pars_fragment,
  uv_pars_fragment: uv_pars_fragment,
  uv_pars_vertex: uv_pars_vertex,
  uv_vertex: uv_vertex,
  uv2_pars_fragment: uv2_pars_fragment,
  uv2_pars_vertex: uv2_pars_vertex,
  uv2_vertex: uv2_vertex,
  worldpos_vertex: worldpos_vertex,
  background_frag: background_frag,
  background_vert: background_vert,
  cube_frag: cube_frag,
  cube_vert: cube_vert,
  depth_frag: depth_frag,
  depth_vert: depth_vert,
  distanceRGBA_frag: distanceRGBA_frag,
  distanceRGBA_vert: distanceRGBA_vert,
  equirect_frag: equirect_frag,
  equirect_vert: equirect_vert,
  linedashed_frag: linedashed_frag,
  linedashed_vert: linedashed_vert,
  meshbasic_frag: meshbasic_frag,
  meshbasic_vert: meshbasic_vert,
  meshlambert_frag: meshlambert_frag,
  meshlambert_vert: meshlambert_vert,
  meshmatcap_frag: meshmatcap_frag,
  meshmatcap_vert: meshmatcap_vert,
  meshtoon_frag: meshtoon_frag,
  meshtoon_vert: meshtoon_vert,
  meshphong_frag: meshphong_frag,
  meshphong_vert: meshphong_vert,
  meshphysical_frag: meshphysical_frag,
  meshphysical_vert: meshphysical_vert,
  normal_frag: normal_frag,
  normal_vert: normal_vert,
  points_frag: points_frag,
  points_vert: points_vert,
  shadow_frag: shadow_frag,
  shadow_vert: shadow_vert,
  sprite_frag: sprite_frag,
  sprite_vert: sprite_vert
};

/**
 * Uniforms library for shared webgl shaders
 */
exports.ShaderChunk = ShaderChunk;
const UniformsLib = {
  common: {
    diffuse: {
      value: new Color(0xeeeeee)
    },
    opacity: {
      value: 1.0
    },
    map: {
      value: null
    },
    uvTransform: {
      value: new Matrix3()
    },
    uv2Transform: {
      value: new Matrix3()
    },
    alphaMap: {
      value: null
    }
  },
  specularmap: {
    specularMap: {
      value: null
    }
  },
  envmap: {
    envMap: {
      value: null
    },
    flipEnvMap: {
      value: -1
    },
    reflectivity: {
      value: 1.0
    },
    refractionRatio: {
      value: 0.98
    },
    maxMipLevel: {
      value: 0
    }
  },
  aomap: {
    aoMap: {
      value: null
    },
    aoMapIntensity: {
      value: 1
    }
  },
  lightmap: {
    lightMap: {
      value: null
    },
    lightMapIntensity: {
      value: 1
    }
  },
  emissivemap: {
    emissiveMap: {
      value: null
    }
  },
  bumpmap: {
    bumpMap: {
      value: null
    },
    bumpScale: {
      value: 1
    }
  },
  normalmap: {
    normalMap: {
      value: null
    },
    normalScale: {
      value: new Vector2(1, 1)
    }
  },
  displacementmap: {
    displacementMap: {
      value: null
    },
    displacementScale: {
      value: 1
    },
    displacementBias: {
      value: 0
    }
  },
  roughnessmap: {
    roughnessMap: {
      value: null
    }
  },
  metalnessmap: {
    metalnessMap: {
      value: null
    }
  },
  gradientmap: {
    gradientMap: {
      value: null
    }
  },
  fog: {
    fogDensity: {
      value: 0.00025
    },
    fogNear: {
      value: 1
    },
    fogFar: {
      value: 2000
    },
    fogColor: {
      value: new Color(0xffffff)
    }
  },
  lights: {
    ambientLightColor: {
      value: []
    },
    lightProbe: {
      value: []
    },
    directionalLights: {
      value: [],
      properties: {
        direction: {},
        color: {}
      }
    },
    directionalLightShadows: {
      value: [],
      properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {}
      }
    },
    directionalShadowMap: {
      value: []
    },
    directionalShadowMatrix: {
      value: []
    },
    spotLights: {
      value: [],
      properties: {
        color: {},
        position: {},
        direction: {},
        distance: {},
        coneCos: {},
        penumbraCos: {},
        decay: {}
      }
    },
    spotLightShadows: {
      value: [],
      properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {}
      }
    },
    spotShadowMap: {
      value: []
    },
    spotShadowMatrix: {
      value: []
    },
    pointLights: {
      value: [],
      properties: {
        color: {},
        position: {},
        decay: {},
        distance: {}
      }
    },
    pointLightShadows: {
      value: [],
      properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {},
        shadowCameraNear: {},
        shadowCameraFar: {}
      }
    },
    pointShadowMap: {
      value: []
    },
    pointShadowMatrix: {
      value: []
    },
    hemisphereLights: {
      value: [],
      properties: {
        direction: {},
        skyColor: {},
        groundColor: {}
      }
    },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: {
      value: [],
      properties: {
        color: {},
        position: {},
        width: {},
        height: {}
      }
    },
    ltc_1: {
      value: null
    },
    ltc_2: {
      value: null
    }
  },
  points: {
    diffuse: {
      value: new Color(0xeeeeee)
    },
    opacity: {
      value: 1.0
    },
    size: {
      value: 1.0
    },
    scale: {
      value: 1.0
    },
    map: {
      value: null
    },
    alphaMap: {
      value: null
    },
    uvTransform: {
      value: new Matrix3()
    }
  },
  sprite: {
    diffuse: {
      value: new Color(0xeeeeee)
    },
    opacity: {
      value: 1.0
    },
    center: {
      value: new Vector2(0.5, 0.5)
    },
    rotation: {
      value: 0.0
    },
    map: {
      value: null
    },
    alphaMap: {
      value: null
    },
    uvTransform: {
      value: new Matrix3()
    }
  }
};
exports.UniformsLib = UniformsLib;
const ShaderLib = {
  basic: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]),
    vertexShader: ShaderChunk.meshbasic_vert,
    fragmentShader: ShaderChunk.meshbasic_frag
  },
  lambert: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, {
      emissive: {
        value: new Color(0x000000)
      }
    }]),
    vertexShader: ShaderChunk.meshlambert_vert,
    fragmentShader: ShaderChunk.meshlambert_frag
  },
  phong: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {
      emissive: {
        value: new Color(0x000000)
      },
      specular: {
        value: new Color(0x111111)
      },
      shininess: {
        value: 30
      }
    }]),
    vertexShader: ShaderChunk.meshphong_vert,
    fragmentShader: ShaderChunk.meshphong_frag
  },
  standard: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, {
      emissive: {
        value: new Color(0x000000)
      },
      roughness: {
        value: 1.0
      },
      metalness: {
        value: 0.0
      },
      envMapIntensity: {
        value: 1
      } // temporary
    }]),

    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  },
  toon: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, {
      emissive: {
        value: new Color(0x000000)
      }
    }]),
    vertexShader: ShaderChunk.meshtoon_vert,
    fragmentShader: ShaderChunk.meshtoon_frag
  },
  matcap: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, {
      matcap: {
        value: null
      }
    }]),
    vertexShader: ShaderChunk.meshmatcap_vert,
    fragmentShader: ShaderChunk.meshmatcap_frag
  },
  points: {
    uniforms: mergeUniforms([UniformsLib.points, UniformsLib.fog]),
    vertexShader: ShaderChunk.points_vert,
    fragmentShader: ShaderChunk.points_frag
  },
  dashed: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.fog, {
      scale: {
        value: 1
      },
      dashSize: {
        value: 1
      },
      totalSize: {
        value: 2
      }
    }]),
    vertexShader: ShaderChunk.linedashed_vert,
    fragmentShader: ShaderChunk.linedashed_frag
  },
  depth: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]),
    vertexShader: ShaderChunk.depth_vert,
    fragmentShader: ShaderChunk.depth_frag
  },
  normal: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, {
      opacity: {
        value: 1.0
      }
    }]),
    vertexShader: ShaderChunk.normal_vert,
    fragmentShader: ShaderChunk.normal_frag
  },
  sprite: {
    uniforms: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),
    vertexShader: ShaderChunk.sprite_vert,
    fragmentShader: ShaderChunk.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: {
        value: new Matrix3()
      },
      t2D: {
        value: null
      }
    },
    vertexShader: ShaderChunk.background_vert,
    fragmentShader: ShaderChunk.background_frag
  },
  /* -------------------------------------------------------------------------
  //	Cube map shader
   ------------------------------------------------------------------------- */

  cube: {
    uniforms: mergeUniforms([UniformsLib.envmap, {
      opacity: {
        value: 1.0
      }
    }]),
    vertexShader: ShaderChunk.cube_vert,
    fragmentShader: ShaderChunk.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: {
        value: null
      }
    },
    vertexShader: ShaderChunk.equirect_vert,
    fragmentShader: ShaderChunk.equirect_frag
  },
  distanceRGBA: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, {
      referencePosition: {
        value: new Vector3()
      },
      nearDistance: {
        value: 1
      },
      farDistance: {
        value: 1000
      }
    }]),
    vertexShader: ShaderChunk.distanceRGBA_vert,
    fragmentShader: ShaderChunk.distanceRGBA_frag
  },
  shadow: {
    uniforms: mergeUniforms([UniformsLib.lights, UniformsLib.fog, {
      color: {
        value: new Color(0x00000)
      },
      opacity: {
        value: 1.0
      }
    }]),
    vertexShader: ShaderChunk.shadow_vert,
    fragmentShader: ShaderChunk.shadow_frag
  }
};
exports.ShaderLib = ShaderLib;
ShaderLib.physical = {
  uniforms: mergeUniforms([ShaderLib.standard.uniforms, {
    clearcoat: {
      value: 0
    },
    clearcoatMap: {
      value: null
    },
    clearcoatRoughness: {
      value: 0
    },
    clearcoatRoughnessMap: {
      value: null
    },
    clearcoatNormalScale: {
      value: new Vector2(1, 1)
    },
    clearcoatNormalMap: {
      value: null
    },
    sheen: {
      value: new Color(0x000000)
    },
    transmission: {
      value: 0
    },
    transmissionMap: {
      value: null
    }
  }]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag
};
function WebGLBackground(renderer, cubemaps, state, objects, premultipliedAlpha) {
  const clearColor = new Color(0x000000);
  let clearAlpha = 0;
  let planeMesh;
  let boxMesh;
  let currentBackground = null;
  let currentBackgroundVersion = 0;
  let currentTonemapping = null;
  function render(renderList, scene, camera, forceClear) {
    let background = scene.isScene === true ? scene.background : null;
    if (background && background.isTexture) {
      background = cubemaps.get(background);
    }

    // Ignore background in AR
    // TODO: Reconsider this.

    const xr = renderer.xr;
    const session = xr.getSession && xr.getSession();
    if (session && session.environmentBlendMode === 'additive') {
      background = null;
    }
    if (background === null) {
      setClear(clearColor, clearAlpha);
    } else if (background && background.isColor) {
      setClear(background, 1);
      forceClear = true;
    }
    if (renderer.autoClear || forceClear) {
      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    }
    if (background && (background.isCubeTexture || background.isWebGLCubeRenderTarget || background.mapping === CubeUVReflectionMapping)) {
      if (boxMesh === undefined) {
        boxMesh = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({
          name: 'BackgroundCubeMaterial',
          uniforms: cloneUniforms(ShaderLib.cube.uniforms),
          vertexShader: ShaderLib.cube.vertexShader,
          fragmentShader: ShaderLib.cube.fragmentShader,
          side: BackSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        boxMesh.geometry.deleteAttribute('normal');
        boxMesh.geometry.deleteAttribute('uv');
        boxMesh.onBeforeRender = function (renderer, scene, camera) {
          this.matrixWorld.copyPosition(camera.matrixWorld);
        };

        // enable code injection for non-built-in material
        Object.defineProperty(boxMesh.material, 'envMap', {
          get: function () {
            return this.uniforms.envMap.value;
          }
        });
        objects.update(boxMesh);
      }
      if (background.isWebGLCubeRenderTarget) {
        // TODO Deprecate

        background = background.texture;
      }
      boxMesh.material.uniforms.envMap.value = background;
      boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background._needsFlipEnvMap ? -1 : 1;
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        boxMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }

      // push to the pre-sorted opaque render list
      renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
    } else if (background && background.isTexture) {
      if (planeMesh === undefined) {
        planeMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({
          name: 'BackgroundMaterial',
          uniforms: cloneUniforms(ShaderLib.background.uniforms),
          vertexShader: ShaderLib.background.vertexShader,
          fragmentShader: ShaderLib.background.fragmentShader,
          side: FrontSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        planeMesh.geometry.deleteAttribute('normal');

        // enable code injection for non-built-in material
        Object.defineProperty(planeMesh.material, 'map', {
          get: function () {
            return this.uniforms.t2D.value;
          }
        });
        objects.update(planeMesh);
      }
      planeMesh.material.uniforms.t2D.value = background;
      if (background.matrixAutoUpdate === true) {
        background.updateMatrix();
      }
      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        planeMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }

      // push to the pre-sorted opaque render list
      renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
    }
  }
  function setClear(color, alpha) {
    state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
  }
  return {
    getClearColor: function () {
      return clearColor;
    },
    setClearColor: function (color, alpha = 1) {
      clearColor.set(color);
      clearAlpha = alpha;
      setClear(clearColor, clearAlpha);
    },
    getClearAlpha: function () {
      return clearAlpha;
    },
    setClearAlpha: function (alpha) {
      clearAlpha = alpha;
      setClear(clearColor, clearAlpha);
    },
    render: render
  };
}
function WebGLBindingStates(gl, extensions, attributes, capabilities) {
  const maxVertexAttributes = gl.getParameter(34921);
  const extension = capabilities.isWebGL2 ? null : extensions.get('OES_vertex_array_object');
  const vaoAvailable = capabilities.isWebGL2 || extension !== null;
  const bindingStates = {};
  const defaultState = createBindingState(null);
  let currentState = defaultState;
  function setup(object, material, program, geometry, index) {
    let updateBuffers = false;
    if (vaoAvailable) {
      const state = getBindingState(geometry, program, material);
      if (currentState !== state) {
        currentState = state;
        bindVertexArrayObject(currentState.object);
      }
      updateBuffers = needsUpdate(geometry, index);
      if (updateBuffers) saveCache(geometry, index);
    } else {
      const wireframe = material.wireframe === true;
      if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
        currentState.geometry = geometry.id;
        currentState.program = program.id;
        currentState.wireframe = wireframe;
        updateBuffers = true;
      }
    }
    if (object.isInstancedMesh === true) {
      updateBuffers = true;
    }
    if (index !== null) {
      attributes.update(index, 34963);
    }
    if (updateBuffers) {
      setupVertexAttributes(object, material, program, geometry);
      if (index !== null) {
        gl.bindBuffer(34963, attributes.get(index).buffer);
      }
    }
  }
  function createVertexArrayObject() {
    if (capabilities.isWebGL2) return gl.createVertexArray();
    return extension.createVertexArrayOES();
  }
  function bindVertexArrayObject(vao) {
    if (capabilities.isWebGL2) return gl.bindVertexArray(vao);
    return extension.bindVertexArrayOES(vao);
  }
  function deleteVertexArrayObject(vao) {
    if (capabilities.isWebGL2) return gl.deleteVertexArray(vao);
    return extension.deleteVertexArrayOES(vao);
  }
  function getBindingState(geometry, program, material) {
    const wireframe = material.wireframe === true;
    let programMap = bindingStates[geometry.id];
    if (programMap === undefined) {
      programMap = {};
      bindingStates[geometry.id] = programMap;
    }
    let stateMap = programMap[program.id];
    if (stateMap === undefined) {
      stateMap = {};
      programMap[program.id] = stateMap;
    }
    let state = stateMap[wireframe];
    if (state === undefined) {
      state = createBindingState(createVertexArrayObject());
      stateMap[wireframe] = state;
    }
    return state;
  }
  function createBindingState(vao) {
    const newAttributes = [];
    const enabledAttributes = [];
    const attributeDivisors = [];
    for (let i = 0; i < maxVertexAttributes; i++) {
      newAttributes[i] = 0;
      enabledAttributes[i] = 0;
      attributeDivisors[i] = 0;
    }
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: false,
      newAttributes: newAttributes,
      enabledAttributes: enabledAttributes,
      attributeDivisors: attributeDivisors,
      object: vao,
      attributes: {},
      index: null
    };
  }
  function needsUpdate(geometry, index) {
    const cachedAttributes = currentState.attributes;
    const geometryAttributes = geometry.attributes;
    let attributesNum = 0;
    for (const key in geometryAttributes) {
      const cachedAttribute = cachedAttributes[key];
      const geometryAttribute = geometryAttributes[key];
      if (cachedAttribute === undefined) return true;
      if (cachedAttribute.attribute !== geometryAttribute) return true;
      if (cachedAttribute.data !== geometryAttribute.data) return true;
      attributesNum++;
    }
    if (currentState.attributesNum !== attributesNum) return true;
    if (currentState.index !== index) return true;
    return false;
  }
  function saveCache(geometry, index) {
    const cache = {};
    const attributes = geometry.attributes;
    let attributesNum = 0;
    for (const key in attributes) {
      const attribute = attributes[key];
      const data = {};
      data.attribute = attribute;
      if (attribute.data) {
        data.data = attribute.data;
      }
      cache[key] = data;
      attributesNum++;
    }
    currentState.attributes = cache;
    currentState.attributesNum = attributesNum;
    currentState.index = index;
  }
  function initAttributes() {
    const newAttributes = currentState.newAttributes;
    for (let i = 0, il = newAttributes.length; i < il; i++) {
      newAttributes[i] = 0;
    }
  }
  function enableAttribute(attribute) {
    enableAttributeAndDivisor(attribute, 0);
  }
  function enableAttributeAndDivisor(attribute, meshPerAttribute) {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    const attributeDivisors = currentState.attributeDivisors;
    newAttributes[attribute] = 1;
    if (enabledAttributes[attribute] === 0) {
      gl.enableVertexAttribArray(attribute);
      enabledAttributes[attribute] = 1;
    }
    if (attributeDivisors[attribute] !== meshPerAttribute) {
      const extension = capabilities.isWebGL2 ? gl : extensions.get('ANGLE_instanced_arrays');
      extension[capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'](attribute, meshPerAttribute);
      attributeDivisors[attribute] = meshPerAttribute;
    }
  }
  function disableUnusedAttributes() {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    for (let i = 0, il = enabledAttributes.length; i < il; i++) {
      if (enabledAttributes[i] !== newAttributes[i]) {
        gl.disableVertexAttribArray(i);
        enabledAttributes[i] = 0;
      }
    }
  }
  function vertexAttribPointer(index, size, type, normalized, stride, offset) {
    if (capabilities.isWebGL2 === true && (type === 5124 || type === 5125)) {
      gl.vertexAttribIPointer(index, size, type, stride, offset);
    } else {
      gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
    }
  }
  function setupVertexAttributes(object, material, program, geometry) {
    if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
      if (extensions.get('ANGLE_instanced_arrays') === null) return;
    }
    initAttributes();
    const geometryAttributes = geometry.attributes;
    const programAttributes = program.getAttributes();
    const materialDefaultAttributeValues = material.defaultAttributeValues;
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];
      if (programAttribute >= 0) {
        const geometryAttribute = geometryAttributes[name];
        if (geometryAttribute !== undefined) {
          const normalized = geometryAttribute.normalized;
          const size = geometryAttribute.itemSize;
          const attribute = attributes.get(geometryAttribute);

          // TODO Attribute may not be available on context restore

          if (attribute === undefined) continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          const bytesPerElement = attribute.bytesPerElement;
          if (geometryAttribute.isInterleavedBufferAttribute) {
            const data = geometryAttribute.data;
            const stride = data.stride;
            const offset = geometryAttribute.offset;
            if (data && data.isInstancedInterleavedBuffer) {
              enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);
              if (geometry._maxInstanceCount === undefined) {
                geometry._maxInstanceCount = data.meshPerAttribute * data.count;
              }
            } else {
              enableAttribute(programAttribute);
            }
            gl.bindBuffer(34962, buffer);
            vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement);
          } else {
            if (geometryAttribute.isInstancedBufferAttribute) {
              enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);
              if (geometry._maxInstanceCount === undefined) {
                geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
              }
            } else {
              enableAttribute(programAttribute);
            }
            gl.bindBuffer(34962, buffer);
            vertexAttribPointer(programAttribute, size, type, normalized, 0, 0);
          }
        } else if (name === 'instanceMatrix') {
          const attribute = attributes.get(object.instanceMatrix);

          // TODO Attribute may not be available on context restore

          if (attribute === undefined) continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          enableAttributeAndDivisor(programAttribute + 0, 1);
          enableAttributeAndDivisor(programAttribute + 1, 1);
          enableAttributeAndDivisor(programAttribute + 2, 1);
          enableAttributeAndDivisor(programAttribute + 3, 1);
          gl.bindBuffer(34962, buffer);
          gl.vertexAttribPointer(programAttribute + 0, 4, type, false, 64, 0);
          gl.vertexAttribPointer(programAttribute + 1, 4, type, false, 64, 16);
          gl.vertexAttribPointer(programAttribute + 2, 4, type, false, 64, 32);
          gl.vertexAttribPointer(programAttribute + 3, 4, type, false, 64, 48);
        } else if (name === 'instanceColor') {
          const attribute = attributes.get(object.instanceColor);

          // TODO Attribute may not be available on context restore

          if (attribute === undefined) continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          enableAttributeAndDivisor(programAttribute, 1);
          gl.bindBuffer(34962, buffer);
          gl.vertexAttribPointer(programAttribute, 3, type, false, 12, 0);
        } else if (materialDefaultAttributeValues !== undefined) {
          const value = materialDefaultAttributeValues[name];
          if (value !== undefined) {
            switch (value.length) {
              case 2:
                gl.vertexAttrib2fv(programAttribute, value);
                break;
              case 3:
                gl.vertexAttrib3fv(programAttribute, value);
                break;
              case 4:
                gl.vertexAttrib4fv(programAttribute, value);
                break;
              default:
                gl.vertexAttrib1fv(programAttribute, value);
            }
          }
        }
      }
    }
    disableUnusedAttributes();
  }
  function dispose() {
    reset();
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      for (const programId in programMap) {
        const stateMap = programMap[programId];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[programId];
      }
      delete bindingStates[geometryId];
    }
  }
  function releaseStatesOfGeometry(geometry) {
    if (bindingStates[geometry.id] === undefined) return;
    const programMap = bindingStates[geometry.id];
    for (const programId in programMap) {
      const stateMap = programMap[programId];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[programId];
    }
    delete bindingStates[geometry.id];
  }
  function releaseStatesOfProgram(program) {
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      if (programMap[program.id] === undefined) continue;
      const stateMap = programMap[program.id];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[program.id];
    }
  }
  function reset() {
    resetDefaultState();
    if (currentState === defaultState) return;
    currentState = defaultState;
    bindVertexArrayObject(currentState.object);
  }

  // for backward-compatilibity

  function resetDefaultState() {
    defaultState.geometry = null;
    defaultState.program = null;
    defaultState.wireframe = false;
  }
  return {
    setup: setup,
    reset: reset,
    resetDefaultState: resetDefaultState,
    dispose: dispose,
    releaseStatesOfGeometry: releaseStatesOfGeometry,
    releaseStatesOfProgram: releaseStatesOfProgram,
    initAttributes: initAttributes,
    enableAttribute: enableAttribute,
    disableUnusedAttributes: disableUnusedAttributes
  };
}
function WebGLBufferRenderer(gl, extensions, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode;
  function setMode(value) {
    mode = value;
  }
  function render(start, count) {
    gl.drawArrays(mode, start, count);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0) return;
    let extension, methodName;
    if (isWebGL2) {
      extension = gl;
      methodName = 'drawArraysInstanced';
    } else {
      extension = extensions.get('ANGLE_instanced_arrays');
      methodName = 'drawArraysInstancedANGLE';
      if (extension === null) {
        console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
        return;
      }
    }
    extension[methodName](mode, start, count, primcount);
    info.update(count, mode, primcount);
  }

  //

  this.setMode = setMode;
  this.render = render;
  this.renderInstances = renderInstances;
}
function WebGLCapabilities(gl, extensions, parameters) {
  let maxAnisotropy;
  function getMaxAnisotropy() {
    if (maxAnisotropy !== undefined) return maxAnisotropy;
    const extension = extensions.get('EXT_texture_filter_anisotropic');
    if (extension !== null) {
      maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
      maxAnisotropy = 0;
    }
    return maxAnisotropy;
  }
  function getMaxPrecision(precision) {
    if (precision === 'highp') {
      if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) {
        return 'highp';
      }
      precision = 'mediump';
    }
    if (precision === 'mediump') {
      if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) {
        return 'mediump';
      }
    }
    return 'lowp';
  }

  /* eslint-disable no-undef */
  const isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext;
  /* eslint-enable no-undef */

  let precision = parameters.precision !== undefined ? parameters.precision : 'highp';
  const maxPrecision = getMaxPrecision(precision);
  if (maxPrecision !== precision) {
    console.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.');
    precision = maxPrecision;
  }
  const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
  const maxTextures = gl.getParameter(34930);
  const maxVertexTextures = gl.getParameter(35660);
  const maxTextureSize = gl.getParameter(3379);
  const maxCubemapSize = gl.getParameter(34076);
  const maxAttributes = gl.getParameter(34921);
  const maxVertexUniforms = gl.getParameter(36347);
  const maxVaryings = gl.getParameter(36348);
  const maxFragmentUniforms = gl.getParameter(36349);
  const vertexTextures = maxVertexTextures > 0;
  const floatFragmentTextures = isWebGL2 || !!extensions.get('OES_texture_float');
  const floatVertexTextures = vertexTextures && floatFragmentTextures;
  const maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;
  return {
    isWebGL2: isWebGL2,
    getMaxAnisotropy: getMaxAnisotropy,
    getMaxPrecision: getMaxPrecision,
    precision: precision,
    logarithmicDepthBuffer: logarithmicDepthBuffer,
    maxTextures: maxTextures,
    maxVertexTextures: maxVertexTextures,
    maxTextureSize: maxTextureSize,
    maxCubemapSize: maxCubemapSize,
    maxAttributes: maxAttributes,
    maxVertexUniforms: maxVertexUniforms,
    maxVaryings: maxVaryings,
    maxFragmentUniforms: maxFragmentUniforms,
    vertexTextures: vertexTextures,
    floatFragmentTextures: floatFragmentTextures,
    floatVertexTextures: floatVertexTextures,
    maxSamples: maxSamples
  };
}
function WebGLClipping(properties) {
  const scope = this;
  let globalState = null,
    numGlobalPlanes = 0,
    localClippingEnabled = false,
    renderingShadows = false;
  const plane = new Plane(),
    viewNormalMatrix = new Matrix3(),
    uniform = {
      value: null,
      needsUpdate: false
    };
  this.uniform = uniform;
  this.numPlanes = 0;
  this.numIntersection = 0;
  this.init = function (planes, enableLocalClipping, camera) {
    const enabled = planes.length !== 0 || enableLocalClipping ||
    // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    numGlobalPlanes !== 0 || localClippingEnabled;
    localClippingEnabled = enableLocalClipping;
    globalState = projectPlanes(planes, camera, 0);
    numGlobalPlanes = planes.length;
    return enabled;
  };
  this.beginShadows = function () {
    renderingShadows = true;
    projectPlanes(null);
  };
  this.endShadows = function () {
    renderingShadows = false;
    resetGlobalState();
  };
  this.setState = function (material, camera, useCache) {
    const planes = material.clippingPlanes,
      clipIntersection = material.clipIntersection,
      clipShadows = material.clipShadows;
    const materialProperties = properties.get(material);
    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
      // there's no local clipping

      if (renderingShadows) {
        // there's no global clipping

        projectPlanes(null);
      } else {
        resetGlobalState();
      }
    } else {
      const nGlobal = renderingShadows ? 0 : numGlobalPlanes,
        lGlobal = nGlobal * 4;
      let dstArray = materialProperties.clippingState || null;
      uniform.value = dstArray; // ensure unique state

      dstArray = projectPlanes(planes, camera, lGlobal, useCache);
      for (let i = 0; i !== lGlobal; ++i) {
        dstArray[i] = globalState[i];
      }
      materialProperties.clippingState = dstArray;
      this.numIntersection = clipIntersection ? this.numPlanes : 0;
      this.numPlanes += nGlobal;
    }
  };
  function resetGlobalState() {
    if (uniform.value !== globalState) {
      uniform.value = globalState;
      uniform.needsUpdate = numGlobalPlanes > 0;
    }
    scope.numPlanes = numGlobalPlanes;
    scope.numIntersection = 0;
  }
  function projectPlanes(planes, camera, dstOffset, skipTransform) {
    const nPlanes = planes !== null ? planes.length : 0;
    let dstArray = null;
    if (nPlanes !== 0) {
      dstArray = uniform.value;
      if (skipTransform !== true || dstArray === null) {
        const flatSize = dstOffset + nPlanes * 4,
          viewMatrix = camera.matrixWorldInverse;
        viewNormalMatrix.getNormalMatrix(viewMatrix);
        if (dstArray === null || dstArray.length < flatSize) {
          dstArray = new Float32Array(flatSize);
        }
        for (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
          plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
          plane.normal.toArray(dstArray, i4);
          dstArray[i4 + 3] = plane.constant;
        }
      }
      uniform.value = dstArray;
      uniform.needsUpdate = true;
    }
    scope.numPlanes = nPlanes;
    scope.numIntersection = 0;
    return dstArray;
  }
}
function WebGLCubeMaps(renderer) {
  let cubemaps = new WeakMap();
  function mapTextureMapping(texture, mapping) {
    if (mapping === EquirectangularReflectionMapping) {
      texture.mapping = CubeReflectionMapping;
    } else if (mapping === EquirectangularRefractionMapping) {
      texture.mapping = CubeRefractionMapping;
    }
    return texture;
  }
  function get(texture) {
    if (texture && texture.isTexture) {
      const mapping = texture.mapping;
      if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
        if (cubemaps.has(texture)) {
          const cubemap = cubemaps.get(texture).texture;
          return mapTextureMapping(cubemap, texture.mapping);
        } else {
          const image = texture.image;
          if (image && image.height > 0) {
            const currentRenderList = renderer.getRenderList();
            const currentRenderTarget = renderer.getRenderTarget();
            const renderTarget = new WebGLCubeRenderTarget(image.height / 2);
            renderTarget.fromEquirectangularTexture(renderer, texture);
            cubemaps.set(texture, renderTarget);
            renderer.setRenderTarget(currentRenderTarget);
            renderer.setRenderList(currentRenderList);
            texture.addEventListener('dispose', onTextureDispose);
            return mapTextureMapping(renderTarget.texture, texture.mapping);
          } else {
            // image not yet ready. try the conversion next frame

            return null;
          }
        }
      }
    }
    return texture;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener('dispose', onTextureDispose);
    const cubemap = cubemaps.get(texture);
    if (cubemap !== undefined) {
      cubemaps.delete(texture);
      cubemap.dispose();
    }
  }
  function dispose() {
    cubemaps = new WeakMap();
  }
  return {
    get: get,
    dispose: dispose
  };
}
function WebGLExtensions(gl) {
  const extensions = {};
  function getExtension(name) {
    if (extensions[name] !== undefined) {
      return extensions[name];
    }
    let extension;
    switch (name) {
      case 'WEBGL_depth_texture':
        extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
        break;
      case 'EXT_texture_filter_anisotropic':
        extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
        break;
      case 'WEBGL_compressed_texture_s3tc':
        extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
        break;
      case 'WEBGL_compressed_texture_pvrtc':
        extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
        break;
      default:
        extension = gl.getExtension(name);
    }
    extensions[name] = extension;
    return extension;
  }
  return {
    has: function (name) {
      return getExtension(name) !== null;
    },
    init: function (capabilities) {
      if (capabilities.isWebGL2) {
        getExtension('EXT_color_buffer_float');
      } else {
        getExtension('WEBGL_depth_texture');
        getExtension('OES_texture_float');
        getExtension('OES_texture_half_float');
        getExtension('OES_texture_half_float_linear');
        getExtension('OES_standard_derivatives');
        getExtension('OES_element_index_uint');
        getExtension('OES_vertex_array_object');
        getExtension('ANGLE_instanced_arrays');
      }
      getExtension('OES_texture_float_linear');
      getExtension('EXT_color_buffer_half_float');
    },
    get: function (name) {
      const extension = getExtension(name);
      if (extension === null) {
        console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');
      }
      return extension;
    }
  };
}
function WebGLGeometries(gl, attributes, info, bindingStates) {
  const geometries = {};
  const wireframeAttributes = new WeakMap();
  function onGeometryDispose(event) {
    const geometry = event.target;
    if (geometry.index !== null) {
      attributes.remove(geometry.index);
    }
    for (const name in geometry.attributes) {
      attributes.remove(geometry.attributes[name]);
    }
    geometry.removeEventListener('dispose', onGeometryDispose);
    delete geometries[geometry.id];
    const attribute = wireframeAttributes.get(geometry);
    if (attribute) {
      attributes.remove(attribute);
      wireframeAttributes.delete(geometry);
    }
    bindingStates.releaseStatesOfGeometry(geometry);
    if (geometry.isInstancedBufferGeometry === true) {
      delete geometry._maxInstanceCount;
    }

    //

    info.memory.geometries--;
  }
  function get(object, geometry) {
    if (geometries[geometry.id] === true) return geometry;
    geometry.addEventListener('dispose', onGeometryDispose);
    geometries[geometry.id] = true;
    info.memory.geometries++;
    return geometry;
  }
  function update(geometry) {
    const geometryAttributes = geometry.attributes;

    // Updating index buffer in VAO now. See WebGLBindingStates.

    for (const name in geometryAttributes) {
      attributes.update(geometryAttributes[name], 34962);
    }

    // morph targets

    const morphAttributes = geometry.morphAttributes;
    for (const name in morphAttributes) {
      const array = morphAttributes[name];
      for (let i = 0, l = array.length; i < l; i++) {
        attributes.update(array[i], 34962);
      }
    }
  }
  function updateWireframeAttribute(geometry) {
    const indices = [];
    const geometryIndex = geometry.index;
    const geometryPosition = geometry.attributes.position;
    let version = 0;
    if (geometryIndex !== null) {
      const array = geometryIndex.array;
      version = geometryIndex.version;
      for (let i = 0, l = array.length; i < l; i += 3) {
        const a = array[i + 0];
        const b = array[i + 1];
        const c = array[i + 2];
        indices.push(a, b, b, c, c, a);
      }
    } else {
      const array = geometryPosition.array;
      version = geometryPosition.version;
      for (let i = 0, l = array.length / 3 - 1; i < l; i += 3) {
        const a = i + 0;
        const b = i + 1;
        const c = i + 2;
        indices.push(a, b, b, c, c, a);
      }
    }
    const attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
    attribute.version = version;

    // Updating index buffer in VAO now. See WebGLBindingStates

    //

    const previousAttribute = wireframeAttributes.get(geometry);
    if (previousAttribute) attributes.remove(previousAttribute);

    //

    wireframeAttributes.set(geometry, attribute);
  }
  function getWireframeAttribute(geometry) {
    const currentAttribute = wireframeAttributes.get(geometry);
    if (currentAttribute) {
      const geometryIndex = geometry.index;
      if (geometryIndex !== null) {
        // if the attribute is obsolete, create a new one

        if (currentAttribute.version < geometryIndex.version) {
          updateWireframeAttribute(geometry);
        }
      }
    } else {
      updateWireframeAttribute(geometry);
    }
    return wireframeAttributes.get(geometry);
  }
  return {
    get: get,
    update: update,
    getWireframeAttribute: getWireframeAttribute
  };
}
function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode;
  function setMode(value) {
    mode = value;
  }
  let type, bytesPerElement;
  function setIndex(value) {
    type = value.type;
    bytesPerElement = value.bytesPerElement;
  }
  function render(start, count) {
    gl.drawElements(mode, count, type, start * bytesPerElement);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0) return;
    let extension, methodName;
    if (isWebGL2) {
      extension = gl;
      methodName = 'drawElementsInstanced';
    } else {
      extension = extensions.get('ANGLE_instanced_arrays');
      methodName = 'drawElementsInstancedANGLE';
      if (extension === null) {
        console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
        return;
      }
    }
    extension[methodName](mode, count, type, start * bytesPerElement, primcount);
    info.update(count, mode, primcount);
  }

  //

  this.setMode = setMode;
  this.setIndex = setIndex;
  this.render = render;
  this.renderInstances = renderInstances;
}
function WebGLInfo(gl) {
  const memory = {
    geometries: 0,
    textures: 0
  };
  const render = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function update(count, mode, instanceCount) {
    render.calls++;
    switch (mode) {
      case 4:
        render.triangles += instanceCount * (count / 3);
        break;
      case 1:
        render.lines += instanceCount * (count / 2);
        break;
      case 3:
        render.lines += instanceCount * (count - 1);
        break;
      case 2:
        render.lines += instanceCount * count;
        break;
      case 0:
        render.points += instanceCount * count;
        break;
      default:
        console.error('THREE.WebGLInfo: Unknown draw mode:', mode);
        break;
    }
  }
  function reset() {
    render.frame++;
    render.calls = 0;
    render.triangles = 0;
    render.points = 0;
    render.lines = 0;
  }
  return {
    memory: memory,
    render: render,
    programs: null,
    autoReset: true,
    reset: reset,
    update: update
  };
}
function numericalSort(a, b) {
  return a[0] - b[0];
}
function absNumericalSort(a, b) {
  return Math.abs(b[1]) - Math.abs(a[1]);
}
function WebGLMorphtargets(gl) {
  const influencesList = {};
  const morphInfluences = new Float32Array(8);
  const workInfluences = [];
  for (let i = 0; i < 8; i++) {
    workInfluences[i] = [i, 0];
  }
  function update(object, geometry, material, program) {
    const objectInfluences = object.morphTargetInfluences;

    // When object doesn't have morph target influences defined, we treat it as a 0-length array
    // This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences

    const length = objectInfluences === undefined ? 0 : objectInfluences.length;
    let influences = influencesList[geometry.id];
    if (influences === undefined) {
      // initialise list

      influences = [];
      for (let i = 0; i < length; i++) {
        influences[i] = [i, 0];
      }
      influencesList[geometry.id] = influences;
    }

    // Collect influences

    for (let i = 0; i < length; i++) {
      const influence = influences[i];
      influence[0] = i;
      influence[1] = objectInfluences[i];
    }
    influences.sort(absNumericalSort);
    for (let i = 0; i < 8; i++) {
      if (i < length && influences[i][1]) {
        workInfluences[i][0] = influences[i][0];
        workInfluences[i][1] = influences[i][1];
      } else {
        workInfluences[i][0] = Number.MAX_SAFE_INTEGER;
        workInfluences[i][1] = 0;
      }
    }
    workInfluences.sort(numericalSort);
    const morphTargets = material.morphTargets && geometry.morphAttributes.position;
    const morphNormals = material.morphNormals && geometry.morphAttributes.normal;
    let morphInfluencesSum = 0;
    for (let i = 0; i < 8; i++) {
      const influence = workInfluences[i];
      const index = influence[0];
      const value = influence[1];
      if (index !== Number.MAX_SAFE_INTEGER && value) {
        if (morphTargets && geometry.getAttribute('morphTarget' + i) !== morphTargets[index]) {
          geometry.setAttribute('morphTarget' + i, morphTargets[index]);
        }
        if (morphNormals && geometry.getAttribute('morphNormal' + i) !== morphNormals[index]) {
          geometry.setAttribute('morphNormal' + i, morphNormals[index]);
        }
        morphInfluences[i] = value;
        morphInfluencesSum += value;
      } else {
        if (morphTargets && geometry.hasAttribute('morphTarget' + i) === true) {
          geometry.deleteAttribute('morphTarget' + i);
        }
        if (morphNormals && geometry.hasAttribute('morphNormal' + i) === true) {
          geometry.deleteAttribute('morphNormal' + i);
        }
        morphInfluences[i] = 0;
      }
    }

    // GLSL shader uses formula baseinfluence * base + sum(target * influence)
    // This allows us to switch between absolute morphs and relative morphs without changing shader code
    // When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
    const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
    program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);
    program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);
  }
  return {
    update: update
  };
}
function WebGLObjects(gl, geometries, attributes, info) {
  let updateMap = new WeakMap();
  function update(object) {
    const frame = info.render.frame;
    const geometry = object.geometry;
    const buffergeometry = geometries.get(object, geometry);

    // Update once per frame

    if (updateMap.get(buffergeometry) !== frame) {
      geometries.update(buffergeometry);
      updateMap.set(buffergeometry, frame);
    }
    if (object.isInstancedMesh) {
      if (object.hasEventListener('dispose', onInstancedMeshDispose) === false) {
        object.addEventListener('dispose', onInstancedMeshDispose);
      }
      attributes.update(object.instanceMatrix, 34962);
      if (object.instanceColor !== null) {
        attributes.update(object.instanceColor, 34962);
      }
    }
    return buffergeometry;
  }
  function dispose() {
    updateMap = new WeakMap();
  }
  function onInstancedMeshDispose(event) {
    const instancedMesh = event.target;
    instancedMesh.removeEventListener('dispose', onInstancedMeshDispose);
    attributes.remove(instancedMesh.instanceMatrix);
    if (instancedMesh.instanceColor !== null) attributes.remove(instancedMesh.instanceColor);
  }
  return {
    update: update,
    dispose: dispose
  };
}
function DataTexture2DArray(data = null, width = 1, height = 1, depth = 1) {
  Texture.call(this, null);
  this.image = {
    data,
    width,
    height,
    depth
  };
  this.magFilter = NearestFilter;
  this.minFilter = NearestFilter;
  this.wrapR = ClampToEdgeWrapping;
  this.generateMipmaps = false;
  this.flipY = false;
  this.needsUpdate = true;
}
DataTexture2DArray.prototype = Object.create(Texture.prototype);
DataTexture2DArray.prototype.constructor = DataTexture2DArray;
DataTexture2DArray.prototype.isDataTexture2DArray = true;
function DataTexture3D(data = null, width = 1, height = 1, depth = 1) {
  // We're going to add .setXXX() methods for setting properties later.
  // Users can still set in DataTexture3D directly.
  //
  //	const texture = new THREE.DataTexture3D( data, width, height, depth );
  // 	texture.anisotropy = 16;
  //
  // See #14839

  Texture.call(this, null);
  this.image = {
    data,
    width,
    height,
    depth
  };
  this.magFilter = NearestFilter;
  this.minFilter = NearestFilter;
  this.wrapR = ClampToEdgeWrapping;
  this.generateMipmaps = false;
  this.flipY = false;
  this.needsUpdate = true;
}
DataTexture3D.prototype = Object.create(Texture.prototype);
DataTexture3D.prototype.constructor = DataTexture3D;
DataTexture3D.prototype.isDataTexture3D = true;

/**
 * Uniforms of a program.
 * Those form a tree structure with a special top-level container for the root,
 * which you get by calling 'new WebGLUniforms( gl, program )'.
 *
 *
 * Properties of inner nodes including the top-level container:
 *
 * .seq - array of nested uniforms
 * .map - nested uniforms by name
 *
 *
 * Methods of all nodes except the top-level container:
 *
 * .setValue( gl, value, [textures] )
 *
 * 		uploads a uniform value(s)
 *  	the 'textures' parameter is needed for sampler uniforms
 *
 *
 * Static methods of the top-level container (textures factorizations):
 *
 * .upload( gl, seq, values, textures )
 *
 * 		sets uniforms in 'seq' to 'values[id].value'
 *
 * .seqWithValue( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with corresponding entry in values
 *
 *
 * Methods of the top-level container (textures factorizations):
 *
 * .setValue( gl, name, value, textures )
 *
 * 		sets uniform with  name 'name' to 'value'
 *
 * .setOptional( gl, obj, prop )
 *
 * 		like .set for an optional property of the object
 *
 */

const emptyTexture = new Texture();
const emptyTexture2dArray = new DataTexture2DArray();
const emptyTexture3d = new DataTexture3D();
const emptyCubeTexture = new CubeTexture();

// --- Utilities ---

// Array Caches (provide typed arrays for temporary by size)

const arrayCacheF32 = [];
const arrayCacheI32 = [];

// Float32Array caches used for uploading Matrix uniforms

const mat4array = new Float32Array(16);
const mat3array = new Float32Array(9);
const mat2array = new Float32Array(4);

// Flattening for arrays of vectors and matrices

function flatten(array, nBlocks, blockSize) {
  const firstElem = array[0];
  if (firstElem <= 0 || firstElem > 0) return array;
  // unoptimized: ! isNaN( firstElem )
  // see http://jacksondunstan.com/articles/983

  const n = nBlocks * blockSize;
  let r = arrayCacheF32[n];
  if (r === undefined) {
    r = new Float32Array(n);
    arrayCacheF32[n] = r;
  }
  if (nBlocks !== 0) {
    firstElem.toArray(r, 0);
    for (let i = 1, offset = 0; i !== nBlocks; ++i) {
      offset += blockSize;
      array[i].toArray(r, offset);
    }
  }
  return r;
}
function arraysEqual(a, b) {
  if (a.length !== b.length) return false;
  for (let i = 0, l = a.length; i < l; i++) {
    if (a[i] !== b[i]) return false;
  }
  return true;
}
function copyArray(a, b) {
  for (let i = 0, l = b.length; i < l; i++) {
    a[i] = b[i];
  }
}

// Texture unit allocation

function allocTexUnits(textures, n) {
  let r = arrayCacheI32[n];
  if (r === undefined) {
    r = new Int32Array(n);
    arrayCacheI32[n] = r;
  }
  for (let i = 0; i !== n; ++i) {
    r[i] = textures.allocateTextureUnit();
  }
  return r;
}

// --- Setters ---

// Note: Defining these methods externally, because they come in a bunch
// and this way their names minify.

// Single scalar

function setValueV1f(gl, v) {
  const cache = this.cache;
  if (cache[0] === v) return;
  gl.uniform1f(this.addr, v);
  cache[0] = v;
}

// Single float vector (from flat array or THREE.VectorN)

function setValueV2f(gl, v) {
  const cache = this.cache;
  if (v.x !== undefined) {
    if (cache[0] !== v.x || cache[1] !== v.y) {
      gl.uniform2f(this.addr, v.x, v.y);
      cache[0] = v.x;
      cache[1] = v.y;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform2fv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV3f(gl, v) {
  const cache = this.cache;
  if (v.x !== undefined) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
      gl.uniform3f(this.addr, v.x, v.y, v.z);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
    }
  } else if (v.r !== undefined) {
    if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
      gl.uniform3f(this.addr, v.r, v.g, v.b);
      cache[0] = v.r;
      cache[1] = v.g;
      cache[2] = v.b;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform3fv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV4f(gl, v) {
  const cache = this.cache;
  if (v.x !== undefined) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
      gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
      cache[3] = v.w;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform4fv(this.addr, v);
    copyArray(cache, v);
  }
}

// Single matrix (from flat array or MatrixN)

function setValueM2(gl, v) {
  const cache = this.cache;
  const elements = v.elements;
  if (elements === undefined) {
    if (arraysEqual(cache, v)) return;
    gl.uniformMatrix2fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat2array.set(elements);
    gl.uniformMatrix2fv(this.addr, false, mat2array);
    copyArray(cache, elements);
  }
}
function setValueM3(gl, v) {
  const cache = this.cache;
  const elements = v.elements;
  if (elements === undefined) {
    if (arraysEqual(cache, v)) return;
    gl.uniformMatrix3fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat3array.set(elements);
    gl.uniformMatrix3fv(this.addr, false, mat3array);
    copyArray(cache, elements);
  }
}
function setValueM4(gl, v) {
  const cache = this.cache;
  const elements = v.elements;
  if (elements === undefined) {
    if (arraysEqual(cache, v)) return;
    gl.uniformMatrix4fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat4array.set(elements);
    gl.uniformMatrix4fv(this.addr, false, mat4array);
    copyArray(cache, elements);
  }
}

// Single texture (2D / Cube)

function setValueT1(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.safeSetTexture2D(v || emptyTexture, unit);
}
function setValueT2DArray1(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture2DArray(v || emptyTexture2dArray, unit);
}
function setValueT3D1(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture3D(v || emptyTexture3d, unit);
}
function setValueT6(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.safeSetTextureCube(v || emptyCubeTexture, unit);
}

// Integer / Boolean vectors or arrays thereof (always flat arrays)

function setValueV1i(gl, v) {
  const cache = this.cache;
  if (cache[0] === v) return;
  gl.uniform1i(this.addr, v);
  cache[0] = v;
}
function setValueV2i(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v)) return;
  gl.uniform2iv(this.addr, v);
  copyArray(cache, v);
}
function setValueV3i(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v)) return;
  gl.uniform3iv(this.addr, v);
  copyArray(cache, v);
}
function setValueV4i(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v)) return;
  gl.uniform4iv(this.addr, v);
  copyArray(cache, v);
}

// uint

function setValueV1ui(gl, v) {
  const cache = this.cache;
  if (cache[0] === v) return;
  gl.uniform1ui(this.addr, v);
  cache[0] = v;
}

// Helper to pick the right setter for the singular case

function getSingularSetter(type) {
  switch (type) {
    case 0x1406:
      return setValueV1f;
    // FLOAT
    case 0x8b50:
      return setValueV2f;
    // _VEC2
    case 0x8b51:
      return setValueV3f;
    // _VEC3
    case 0x8b52:
      return setValueV4f;
    // _VEC4

    case 0x8b5a:
      return setValueM2;
    // _MAT2
    case 0x8b5b:
      return setValueM3;
    // _MAT3
    case 0x8b5c:
      return setValueM4;
    // _MAT4

    case 0x1404:
    case 0x8b56:
      return setValueV1i;
    // INT, BOOL
    case 0x8b53:
    case 0x8b57:
      return setValueV2i;
    // _VEC2
    case 0x8b54:
    case 0x8b58:
      return setValueV3i;
    // _VEC3
    case 0x8b55:
    case 0x8b59:
      return setValueV4i;
    // _VEC4

    case 0x1405:
      return setValueV1ui;
    // UINT

    case 0x8b5e: // SAMPLER_2D
    case 0x8d66: // SAMPLER_EXTERNAL_OES
    case 0x8dca: // INT_SAMPLER_2D
    case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
    case 0x8b62:
      // SAMPLER_2D_SHADOW
      return setValueT1;
    case 0x8b5f: // SAMPLER_3D
    case 0x8dcb: // INT_SAMPLER_3D
    case 0x8dd3:
      // UNSIGNED_INT_SAMPLER_3D
      return setValueT3D1;
    case 0x8b60: // SAMPLER_CUBE
    case 0x8dcc: // INT_SAMPLER_CUBE
    case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
    case 0x8dc5:
      // SAMPLER_CUBE_SHADOW
      return setValueT6;
    case 0x8dc1: // SAMPLER_2D_ARRAY
    case 0x8dcf: // INT_SAMPLER_2D_ARRAY
    case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
    case 0x8dc4:
      // SAMPLER_2D_ARRAY_SHADOW
      return setValueT2DArray1;
  }
}

// Array of scalars
function setValueV1fArray(gl, v) {
  gl.uniform1fv(this.addr, v);
}

// Integer / Boolean vectors or arrays thereof (always flat arrays)
function setValueV1iArray(gl, v) {
  gl.uniform1iv(this.addr, v);
}
function setValueV2iArray(gl, v) {
  gl.uniform2iv(this.addr, v);
}
function setValueV3iArray(gl, v) {
  gl.uniform3iv(this.addr, v);
}
function setValueV4iArray(gl, v) {
  gl.uniform4iv(this.addr, v);
}

// Array of vectors (flat or from THREE classes)

function setValueV2fArray(gl, v) {
  const data = flatten(v, this.size, 2);
  gl.uniform2fv(this.addr, data);
}
function setValueV3fArray(gl, v) {
  const data = flatten(v, this.size, 3);
  gl.uniform3fv(this.addr, data);
}
function setValueV4fArray(gl, v) {
  const data = flatten(v, this.size, 4);
  gl.uniform4fv(this.addr, data);
}

// Array of matrices (flat or from THREE clases)

function setValueM2Array(gl, v) {
  const data = flatten(v, this.size, 4);
  gl.uniformMatrix2fv(this.addr, false, data);
}
function setValueM3Array(gl, v) {
  const data = flatten(v, this.size, 9);
  gl.uniformMatrix3fv(this.addr, false, data);
}
function setValueM4Array(gl, v) {
  const data = flatten(v, this.size, 16);
  gl.uniformMatrix4fv(this.addr, false, data);
}

// Array of textures (2D / Cube)

function setValueT1Array(gl, v, textures) {
  const n = v.length;
  const units = allocTexUnits(textures, n);
  gl.uniform1iv(this.addr, units);
  for (let i = 0; i !== n; ++i) {
    textures.safeSetTexture2D(v[i] || emptyTexture, units[i]);
  }
}
function setValueT6Array(gl, v, textures) {
  const n = v.length;
  const units = allocTexUnits(textures, n);
  gl.uniform1iv(this.addr, units);
  for (let i = 0; i !== n; ++i) {
    textures.safeSetTextureCube(v[i] || emptyCubeTexture, units[i]);
  }
}

// Helper to pick the right setter for a pure (bottom-level) array

function getPureArraySetter(type) {
  switch (type) {
    case 0x1406:
      return setValueV1fArray;
    // FLOAT
    case 0x8b50:
      return setValueV2fArray;
    // _VEC2
    case 0x8b51:
      return setValueV3fArray;
    // _VEC3
    case 0x8b52:
      return setValueV4fArray;
    // _VEC4

    case 0x8b5a:
      return setValueM2Array;
    // _MAT2
    case 0x8b5b:
      return setValueM3Array;
    // _MAT3
    case 0x8b5c:
      return setValueM4Array;
    // _MAT4

    case 0x1404:
    case 0x8b56:
      return setValueV1iArray;
    // INT, BOOL
    case 0x8b53:
    case 0x8b57:
      return setValueV2iArray;
    // _VEC2
    case 0x8b54:
    case 0x8b58:
      return setValueV3iArray;
    // _VEC3
    case 0x8b55:
    case 0x8b59:
      return setValueV4iArray;
    // _VEC4

    case 0x8b5e: // SAMPLER_2D
    case 0x8d66: // SAMPLER_EXTERNAL_OES
    case 0x8dca: // INT_SAMPLER_2D
    case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
    case 0x8b62:
      // SAMPLER_2D_SHADOW
      return setValueT1Array;
    case 0x8b60: // SAMPLER_CUBE
    case 0x8dcc: // INT_SAMPLER_CUBE
    case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
    case 0x8dc5:
      // SAMPLER_CUBE_SHADOW
      return setValueT6Array;
  }
}

// --- Uniform Classes ---

function SingleUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.setValue = getSingularSetter(activeInfo.type);

  // this.path = activeInfo.name; // DEBUG
}

function PureArrayUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.size = activeInfo.size;
  this.setValue = getPureArraySetter(activeInfo.type);

  // this.path = activeInfo.name; // DEBUG
}

PureArrayUniform.prototype.updateCache = function (data) {
  const cache = this.cache;
  if (data instanceof Float32Array && cache.length !== data.length) {
    this.cache = new Float32Array(data.length);
  }
  copyArray(cache, data);
};
function StructuredUniform(id) {
  this.id = id;
  this.seq = [];
  this.map = {};
}
StructuredUniform.prototype.setValue = function (gl, value, textures) {
  const seq = this.seq;
  for (let i = 0, n = seq.length; i !== n; ++i) {
    const u = seq[i];
    u.setValue(gl, value[u.id], textures);
  }
};

// --- Top-level ---

// Parser - builds up the property tree from the path strings

const RePathPart = /(\w+)(\])?(\[|\.)?/g;

// extracts
// 	- the identifier (member name or array index)
//  - followed by an optional right bracket (found when array index)
//  - followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.

function addUniform(container, uniformObject) {
  container.seq.push(uniformObject);
  container.map[uniformObject.id] = uniformObject;
}
function parseUniform(activeInfo, addr, container) {
  const path = activeInfo.name,
    pathLength = path.length;

  // reset RegExp object, because of the early exit of a previous run
  RePathPart.lastIndex = 0;
  while (true) {
    const match = RePathPart.exec(path),
      matchEnd = RePathPart.lastIndex;
    let id = match[1];
    const idIsIndex = match[2] === ']',
      subscript = match[3];
    if (idIsIndex) id = id | 0; // convert to integer

    if (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {
      // bare name or "pure" bottom-level array "[0]" suffix

      addUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
      break;
    } else {
      // step into inner node / create it in case it doesn't exist

      const map = container.map;
      let next = map[id];
      if (next === undefined) {
        next = new StructuredUniform(id);
        addUniform(container, next);
      }
      container = next;
    }
  }
}

// Root Container

function WebGLUniforms(gl, program) {
  this.seq = [];
  this.map = {};
  const n = gl.getProgramParameter(program, 35718);
  for (let i = 0; i < n; ++i) {
    const info = gl.getActiveUniform(program, i),
      addr = gl.getUniformLocation(program, info.name);
    parseUniform(info, addr, this);
  }
}
WebGLUniforms.prototype.setValue = function (gl, name, value, textures) {
  const u = this.map[name];
  if (u !== undefined) u.setValue(gl, value, textures);
};
WebGLUniforms.prototype.setOptional = function (gl, object, name) {
  const v = object[name];
  if (v !== undefined) this.setValue(gl, name, v);
};

// Static interface

WebGLUniforms.upload = function (gl, seq, values, textures) {
  for (let i = 0, n = seq.length; i !== n; ++i) {
    const u = seq[i],
      v = values[u.id];
    if (v.needsUpdate !== false) {
      // note: always updating when .needsUpdate is undefined
      u.setValue(gl, v.value, textures);
    }
  }
};
WebGLUniforms.seqWithValue = function (seq, values) {
  const r = [];
  for (let i = 0, n = seq.length; i !== n; ++i) {
    const u = seq[i];
    if (u.id in values) r.push(u);
  }
  return r;
};
function WebGLShader(gl, type, string) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, string);
  gl.compileShader(shader);
  return shader;
}
let programIdCount = 0;
function addLineNumbers(string) {
  const lines = string.split('\n');
  for (let i = 0; i < lines.length; i++) {
    lines[i] = i + 1 + ': ' + lines[i];
  }
  return lines.join('\n');
}
function getEncodingComponents(encoding) {
  switch (encoding) {
    case LinearEncoding:
      return ['Linear', '( value )'];
    case sRGBEncoding:
      return ['sRGB', '( value )'];
    case RGBEEncoding:
      return ['RGBE', '( value )'];
    case RGBM7Encoding:
      return ['RGBM', '( value, 7.0 )'];
    case RGBM16Encoding:
      return ['RGBM', '( value, 16.0 )'];
    case RGBDEncoding:
      return ['RGBD', '( value, 256.0 )'];
    case GammaEncoding:
      return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];
    case LogLuvEncoding:
      return ['LogLuv', '( value )'];
    default:
      console.warn('THREE.WebGLProgram: Unsupported encoding:', encoding);
      return ['Linear', '( value )'];
  }
}
function getShaderErrors(gl, shader, type) {
  const status = gl.getShaderParameter(shader, 35713);
  const log = gl.getShaderInfoLog(shader).trim();
  if (status && log === '') return '';

  // --enable-privileged-webgl-extension
  // console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

  const source = gl.getShaderSource(shader);
  return 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\n' + log + addLineNumbers(source);
}
function getTexelDecodingFunction(functionName, encoding) {
  const components = getEncodingComponents(encoding);
  return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[0] + 'ToLinear' + components[1] + '; }';
}
function getTexelEncodingFunction(functionName, encoding) {
  const components = getEncodingComponents(encoding);
  return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }';
}
function getToneMappingFunction(functionName, toneMapping) {
  let toneMappingName;
  switch (toneMapping) {
    case LinearToneMapping:
      toneMappingName = 'Linear';
      break;
    case ReinhardToneMapping:
      toneMappingName = 'Reinhard';
      break;
    case CineonToneMapping:
      toneMappingName = 'OptimizedCineon';
      break;
    case ACESFilmicToneMapping:
      toneMappingName = 'ACESFilmic';
      break;
    case CustomToneMapping:
      toneMappingName = 'Custom';
      break;
    default:
      console.warn('THREE.WebGLProgram: Unsupported toneMapping:', toneMapping);
      toneMappingName = 'Linear';
  }
  return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';
}
function generateExtensions(parameters) {
  const chunks = [parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ? '#extension GL_OES_standard_derivatives : enable' : '', (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '', parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? '#extension GL_EXT_draw_buffers : require' : '', (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''];
  return chunks.filter(filterEmptyLine).join('\n');
}
function generateDefines(defines) {
  const chunks = [];
  for (const name in defines) {
    const value = defines[name];
    if (value === false) continue;
    chunks.push('#define ' + name + ' ' + value);
  }
  return chunks.join('\n');
}
function fetchAttributeLocations(gl, program) {
  const attributes = {};
  const n = gl.getProgramParameter(program, 35721);
  for (let i = 0; i < n; i++) {
    const info = gl.getActiveAttrib(program, i);
    const name = info.name;

    // console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

    attributes[name] = gl.getAttribLocation(program, name);
  }
  return attributes;
}
function filterEmptyLine(string) {
  return string !== '';
}
function replaceLightNums(string, parameters) {
  return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
}
function replaceClippingPlaneNums(string, parameters) {
  return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
}

// Resolve Includes

const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(string) {
  return string.replace(includePattern, includeReplacer);
}
function includeReplacer(match, include) {
  const string = ShaderChunk[include];
  if (string === undefined) {
    throw new Error('Can not resolve #include <' + include + '>');
  }
  return resolveIncludes(string);
}

// Unroll Loops

const deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function unrollLoops(string) {
  return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
}
function deprecatedLoopReplacer(match, start, end, snippet) {
  console.warn('WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.');
  return loopReplacer(match, start, end, snippet);
}
function loopReplacer(match, start, end, snippet) {
  let string = '';
  for (let i = parseInt(start); i < parseInt(end); i++) {
    string += snippet.replace(/\[\s*i\s*\]/g, '[ ' + i + ' ]').replace(/UNROLLED_LOOP_INDEX/g, i);
  }
  return string;
}

//

function generatePrecision(parameters) {
  let precisionstring = 'precision ' + parameters.precision + ' float;\nprecision ' + parameters.precision + ' int;';
  if (parameters.precision === 'highp') {
    precisionstring += '\n#define HIGH_PRECISION';
  } else if (parameters.precision === 'mediump') {
    precisionstring += '\n#define MEDIUM_PRECISION';
  } else if (parameters.precision === 'lowp') {
    precisionstring += '\n#define LOW_PRECISION';
  }
  return precisionstring;
}
function generateShadowMapTypeDefine(parameters) {
  let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
  if (parameters.shadowMapType === PCFShadowMap) {
    shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
  } else if (parameters.shadowMapType === PCFSoftShadowMap) {
    shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
  } else if (parameters.shadowMapType === VSMShadowMap) {
    shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';
  }
  return shadowMapTypeDefine;
}
function generateEnvMapTypeDefine(parameters) {
  let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
        break;
      case CubeUVReflectionMapping:
      case CubeUVRefractionMapping:
        envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
        break;
    }
  }
  return envMapTypeDefine;
}
function generateEnvMapModeDefine(parameters) {
  let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeRefractionMapping:
      case CubeUVRefractionMapping:
        envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
        break;
    }
  }
  return envMapModeDefine;
}
function generateEnvMapBlendingDefine(parameters) {
  let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';
  if (parameters.envMap) {
    switch (parameters.combine) {
      case MultiplyOperation:
        envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
        break;
      case MixOperation:
        envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
        break;
      case AddOperation:
        envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
        break;
    }
  }
  return envMapBlendingDefine;
}
function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
  const gl = renderer.getContext();
  const defines = parameters.defines;
  let vertexShader = parameters.vertexShader;
  let fragmentShader = parameters.fragmentShader;
  const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
  const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
  const envMapModeDefine = generateEnvMapModeDefine(parameters);
  const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
  const gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1.0;
  const customExtensions = parameters.isWebGL2 ? '' : generateExtensions(parameters);
  const customDefines = generateDefines(defines);
  const program = gl.createProgram();
  let prefixVertex, prefixFragment;
  let versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : '';
  if (parameters.isRawShaderMaterial) {
    prefixVertex = [customDefines].filter(filterEmptyLine).join('\n');
    if (prefixVertex.length > 0) {
      prefixVertex += '\n';
    }
    prefixFragment = [customExtensions, customDefines].filter(filterEmptyLine).join('\n');
    if (prefixFragment.length > 0) {
      prefixFragment += '\n';
    }
  } else {
    prefixVertex = [generatePrecision(parameters), '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.instancing ? '#define USE_INSTANCING' : '', parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '', parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '', '#define GAMMA_FACTOR ' + gammaFactorDefine, '#define MAX_BONES ' + parameters.maxBones, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.vertexUvs ? '#define USE_UV' : '', parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.skinning ? '#define USE_SKINNING' : '', parameters.useVertexTexture ? '#define BONE_TEXTURE' : '', parameters.morphTargets ? '#define USE_MORPHTARGETS' : '', parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '', 'uniform mat4 modelMatrix;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform mat4 viewMatrix;', 'uniform mat3 normalMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', '#ifdef USE_INSTANCING', '	attribute mat4 instanceMatrix;', '#endif', '#ifdef USE_INSTANCING_COLOR', '	attribute vec3 instanceColor;', '#endif', 'attribute vec3 position;', 'attribute vec3 normal;', 'attribute vec2 uv;', '#ifdef USE_TANGENT', '	attribute vec4 tangent;', '#endif', '#ifdef USE_COLOR', '	attribute vec3 color;', '#endif', '#ifdef USE_MORPHTARGETS', '	attribute vec3 morphTarget0;', '	attribute vec3 morphTarget1;', '	attribute vec3 morphTarget2;', '	attribute vec3 morphTarget3;', '	#ifdef USE_MORPHNORMALS', '		attribute vec3 morphNormal0;', '		attribute vec3 morphNormal1;', '		attribute vec3 morphNormal2;', '		attribute vec3 morphNormal3;', '	#else', '		attribute vec3 morphTarget4;', '		attribute vec3 morphTarget5;', '		attribute vec3 morphTarget6;', '		attribute vec3 morphTarget7;', '	#endif', '#endif', '#ifdef USE_SKINNING', '	attribute vec4 skinIndex;', '	attribute vec4 skinWeight;', '#endif', '\n'].filter(filterEmptyLine).join('\n');
    prefixFragment = [customExtensions, generatePrecision(parameters), '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + (parameters.alphaTest % 1 ? '' : '.0') : '',
    // add '.0' if integer

    '#define GAMMA_FACTOR ' + gammaFactorDefine, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.matcap ? '#define USE_MATCAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapTypeDefine : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.envMap ? '#define ' + envMapBlendingDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.sheen ? '#define USE_SHEEN' : '', parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '', parameters.vertexUvs ? '#define USE_UV' : '', parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', parameters.gradientMap ? '#define USE_GRADIENTMAP' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '', parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '', (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? '#define TEXTURE_LOD_EXT' : '', 'uniform mat4 viewMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', parameters.toneMapping !== NoToneMapping ? '#define TONE_MAPPING' : '', parameters.toneMapping !== NoToneMapping ? ShaderChunk['tonemapping_pars_fragment'] : '',
    // this code is required here because it is used by the toneMapping() function defined below
    parameters.toneMapping !== NoToneMapping ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '', parameters.dithering ? '#define DITHERING' : '', ShaderChunk['encodings_pars_fragment'],
    // this code is required here because it is used by the various encoding/decoding function defined below
    parameters.map ? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding) : '', parameters.matcap ? getTexelDecodingFunction('matcapTexelToLinear', parameters.matcapEncoding) : '', parameters.envMap ? getTexelDecodingFunction('envMapTexelToLinear', parameters.envMapEncoding) : '', parameters.emissiveMap ? getTexelDecodingFunction('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '', parameters.lightMap ? getTexelDecodingFunction('lightMapTexelToLinear', parameters.lightMapEncoding) : '', getTexelEncodingFunction('linearToOutputTexel', parameters.outputEncoding), parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '', '\n'].filter(filterEmptyLine).join('\n');
  }
  vertexShader = resolveIncludes(vertexShader);
  vertexShader = replaceLightNums(vertexShader, parameters);
  vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
  fragmentShader = resolveIncludes(fragmentShader);
  fragmentShader = replaceLightNums(fragmentShader, parameters);
  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
  vertexShader = unrollLoops(vertexShader);
  fragmentShader = unrollLoops(fragmentShader);
  if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
    // GLSL 3.0 conversion for built-in materials and ShaderMaterial

    versionString = '#version 300 es\n';
    prefixVertex = ['#define attribute in', '#define varying out', '#define texture2D texture'].join('\n') + '\n' + prefixVertex;
    prefixFragment = ['#define varying in', parameters.glslVersion === GLSL3 ? '' : 'out highp vec4 pc_fragColor;', parameters.glslVersion === GLSL3 ? '' : '#define gl_FragColor pc_fragColor', '#define gl_FragDepthEXT gl_FragDepth', '#define texture2D texture', '#define textureCube texture', '#define texture2DProj textureProj', '#define texture2DLodEXT textureLod', '#define texture2DProjLodEXT textureProjLod', '#define textureCubeLodEXT textureLod', '#define texture2DGradEXT textureGrad', '#define texture2DProjGradEXT textureProjGrad', '#define textureCubeGradEXT textureGrad'].join('\n') + '\n' + prefixFragment;
  }
  const vertexGlsl = versionString + prefixVertex + vertexShader;
  const fragmentGlsl = versionString + prefixFragment + fragmentShader;

  // console.log( '*VERTEX*', vertexGlsl );
  // console.log( '*FRAGMENT*', fragmentGlsl );

  const glVertexShader = WebGLShader(gl, 35633, vertexGlsl);
  const glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);
  gl.attachShader(program, glVertexShader);
  gl.attachShader(program, glFragmentShader);

  // Force a particular attribute to index 0.

  if (parameters.index0AttributeName !== undefined) {
    gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
  } else if (parameters.morphTargets === true) {
    // programs with morphTargets displace position out of attribute 0
    gl.bindAttribLocation(program, 0, 'position');
  }
  gl.linkProgram(program);

  // check for link errors
  if (renderer.debug.checkShaderErrors) {
    const programLog = gl.getProgramInfoLog(program).trim();
    const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
    const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
    let runnable = true;
    let haveDiagnostics = true;
    if (gl.getProgramParameter(program, 35714) === false) {
      runnable = false;
      const vertexErrors = getShaderErrors(gl, glVertexShader, 'vertex');
      const fragmentErrors = getShaderErrors(gl, glFragmentShader, 'fragment');
      console.error('THREE.WebGLProgram: shader error: ', gl.getError(), '35715', gl.getProgramParameter(program, 35715), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors);
    } else if (programLog !== '') {
      console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog);
    } else if (vertexLog === '' || fragmentLog === '') {
      haveDiagnostics = false;
    }
    if (haveDiagnostics) {
      this.diagnostics = {
        runnable: runnable,
        programLog: programLog,
        vertexShader: {
          log: vertexLog,
          prefix: prefixVertex
        },
        fragmentShader: {
          log: fragmentLog,
          prefix: prefixFragment
        }
      };
    }
  }

  // Clean up

  // Crashes in iOS9 and iOS10. #18402
  // gl.detachShader( program, glVertexShader );
  // gl.detachShader( program, glFragmentShader );

  gl.deleteShader(glVertexShader);
  gl.deleteShader(glFragmentShader);

  // set up caching for uniform locations

  let cachedUniforms;
  this.getUniforms = function () {
    if (cachedUniforms === undefined) {
      cachedUniforms = new WebGLUniforms(gl, program);
    }
    return cachedUniforms;
  };

  // set up caching for attribute locations

  let cachedAttributes;
  this.getAttributes = function () {
    if (cachedAttributes === undefined) {
      cachedAttributes = fetchAttributeLocations(gl, program);
    }
    return cachedAttributes;
  };

  // free resource

  this.destroy = function () {
    bindingStates.releaseStatesOfProgram(this);
    gl.deleteProgram(program);
    this.program = undefined;
  };

  //

  this.name = parameters.shaderName;
  this.id = programIdCount++;
  this.cacheKey = cacheKey;
  this.usedTimes = 1;
  this.program = program;
  this.vertexShader = glVertexShader;
  this.fragmentShader = glFragmentShader;
  return this;
}
function WebGLPrograms(renderer, cubemaps, extensions, capabilities, bindingStates, clipping) {
  const programs = [];
  const isWebGL2 = capabilities.isWebGL2;
  const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
  const floatVertexTextures = capabilities.floatVertexTextures;
  const maxVertexUniforms = capabilities.maxVertexUniforms;
  const vertexTextures = capabilities.vertexTextures;
  let precision = capabilities.precision;
  const shaderIDs = {
    MeshDepthMaterial: 'depth',
    MeshDistanceMaterial: 'distanceRGBA',
    MeshNormalMaterial: 'normal',
    MeshBasicMaterial: 'basic',
    MeshLambertMaterial: 'lambert',
    MeshPhongMaterial: 'phong',
    MeshToonMaterial: 'toon',
    MeshStandardMaterial: 'physical',
    MeshPhysicalMaterial: 'physical',
    MeshMatcapMaterial: 'matcap',
    LineBasicMaterial: 'basic',
    LineDashedMaterial: 'dashed',
    PointsMaterial: 'points',
    ShadowMaterial: 'shadow',
    SpriteMaterial: 'sprite'
  };
  const parameterNames = ['precision', 'isWebGL2', 'supportsVertexTextures', 'outputEncoding', 'instancing', 'instancingColor', 'map', 'mapEncoding', 'matcap', 'matcapEncoding', 'envMap', 'envMapMode', 'envMapEncoding', 'envMapCubeUV', 'lightMap', 'lightMapEncoding', 'aoMap', 'emissiveMap', 'emissiveMapEncoding', 'bumpMap', 'normalMap', 'objectSpaceNormalMap', 'tangentSpaceNormalMap', 'clearcoatMap', 'clearcoatRoughnessMap', 'clearcoatNormalMap', 'displacementMap', 'specularMap', 'roughnessMap', 'metalnessMap', 'gradientMap', 'alphaMap', 'combine', 'vertexColors', 'vertexTangents', 'vertexUvs', 'uvsVertexOnly', 'fog', 'useFog', 'fogExp2', 'flatShading', 'sizeAttenuation', 'logarithmicDepthBuffer', 'skinning', 'maxBones', 'useVertexTexture', 'morphTargets', 'morphNormals', 'maxMorphTargets', 'maxMorphNormals', 'premultipliedAlpha', 'numDirLights', 'numPointLights', 'numSpotLights', 'numHemiLights', 'numRectAreaLights', 'numDirLightShadows', 'numPointLightShadows', 'numSpotLightShadows', 'shadowMapEnabled', 'shadowMapType', 'toneMapping', 'physicallyCorrectLights', 'alphaTest', 'doubleSided', 'flipSided', 'numClippingPlanes', 'numClipIntersection', 'depthPacking', 'dithering', 'sheen', 'transmissionMap'];
  function getMaxBones(object) {
    const skeleton = object.skeleton;
    const bones = skeleton.bones;
    if (floatVertexTextures) {
      return 1024;
    } else {
      // default for when object is not specified
      // ( for example when prebuilding shader to be used with multiple objects )
      //
      //  - leave some extra space for other uniforms
      //  - limit here is ANGLE's 254 max uniform vectors
      //    (up to 54 should be safe)

      const nVertexUniforms = maxVertexUniforms;
      const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
      const maxBones = Math.min(nVertexMatrices, bones.length);
      if (maxBones < bones.length) {
        console.warn('THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.');
        return 0;
      }
      return maxBones;
    }
  }
  function getTextureEncodingFromMap(map) {
    let encoding;
    if (map && map.isTexture) {
      encoding = map.encoding;
    } else if (map && map.isWebGLRenderTarget) {
      console.warn('THREE.WebGLPrograms.getTextureEncodingFromMap: don\'t use render targets as textures. Use their .texture property instead.');
      encoding = map.texture.encoding;
    } else {
      encoding = LinearEncoding;
    }
    return encoding;
  }
  function getParameters(material, lights, shadows, scene, object) {
    const fog = scene.fog;
    const environment = material.isMeshStandardMaterial ? scene.environment : null;
    const envMap = cubemaps.get(material.envMap || environment);
    const shaderID = shaderIDs[material.type];

    // heuristics to create shader parameters according to lights in the scene
    // (not to blow over maxLights budget)

    const maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;
    if (material.precision !== null) {
      precision = capabilities.getMaxPrecision(material.precision);
      if (precision !== material.precision) {
        console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');
      }
    }
    let vertexShader, fragmentShader;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      vertexShader = shader.vertexShader;
      fragmentShader = shader.fragmentShader;
    } else {
      vertexShader = material.vertexShader;
      fragmentShader = material.fragmentShader;
    }
    const currentRenderTarget = renderer.getRenderTarget();
    const parameters = {
      isWebGL2: isWebGL2,
      shaderID: shaderID,
      shaderName: material.type,
      vertexShader: vertexShader,
      fragmentShader: fragmentShader,
      defines: material.defines,
      isRawShaderMaterial: material.isRawShaderMaterial === true,
      glslVersion: material.glslVersion,
      precision: precision,
      instancing: object.isInstancedMesh === true,
      instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
      supportsVertexTextures: vertexTextures,
      outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,
      map: !!material.map,
      mapEncoding: getTextureEncodingFromMap(material.map),
      matcap: !!material.matcap,
      matcapEncoding: getTextureEncodingFromMap(material.matcap),
      envMap: !!envMap,
      envMapMode: envMap && envMap.mapping,
      envMapEncoding: getTextureEncodingFromMap(envMap),
      envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),
      lightMap: !!material.lightMap,
      lightMapEncoding: getTextureEncodingFromMap(material.lightMap),
      aoMap: !!material.aoMap,
      emissiveMap: !!material.emissiveMap,
      emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),
      bumpMap: !!material.bumpMap,
      normalMap: !!material.normalMap,
      objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
      tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
      clearcoatMap: !!material.clearcoatMap,
      clearcoatRoughnessMap: !!material.clearcoatRoughnessMap,
      clearcoatNormalMap: !!material.clearcoatNormalMap,
      displacementMap: !!material.displacementMap,
      roughnessMap: !!material.roughnessMap,
      metalnessMap: !!material.metalnessMap,
      specularMap: !!material.specularMap,
      alphaMap: !!material.alphaMap,
      gradientMap: !!material.gradientMap,
      sheen: !!material.sheen,
      transmissionMap: !!material.transmissionMap,
      combine: material.combine,
      vertexTangents: material.normalMap && material.vertexTangents,
      vertexColors: material.vertexColors,
      vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap,
      uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || !!material.transmissionMap) && !!material.displacementMap,
      fog: !!fog,
      useFog: material.fog,
      fogExp2: fog && fog.isFogExp2,
      flatShading: material.flatShading,
      sizeAttenuation: material.sizeAttenuation,
      logarithmicDepthBuffer: logarithmicDepthBuffer,
      skinning: material.skinning && maxBones > 0,
      maxBones: maxBones,
      useVertexTexture: floatVertexTextures,
      morphTargets: material.morphTargets,
      morphNormals: material.morphNormals,
      maxMorphTargets: renderer.maxMorphTargets,
      maxMorphNormals: renderer.maxMorphNormals,
      numDirLights: lights.directional.length,
      numPointLights: lights.point.length,
      numSpotLights: lights.spot.length,
      numRectAreaLights: lights.rectArea.length,
      numHemiLights: lights.hemi.length,
      numDirLightShadows: lights.directionalShadowMap.length,
      numPointLightShadows: lights.pointShadowMap.length,
      numSpotLightShadows: lights.spotShadowMap.length,
      numClippingPlanes: clipping.numPlanes,
      numClipIntersection: clipping.numIntersection,
      dithering: material.dithering,
      shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
      shadowMapType: renderer.shadowMap.type,
      toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
      physicallyCorrectLights: renderer.physicallyCorrectLights,
      premultipliedAlpha: material.premultipliedAlpha,
      alphaTest: material.alphaTest,
      doubleSided: material.side === DoubleSide,
      flipSided: material.side === BackSide,
      depthPacking: material.depthPacking !== undefined ? material.depthPacking : false,
      index0AttributeName: material.index0AttributeName,
      extensionDerivatives: material.extensions && material.extensions.derivatives,
      extensionFragDepth: material.extensions && material.extensions.fragDepth,
      extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
      extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
      rendererExtensionFragDepth: isWebGL2 || extensions.has('EXT_frag_depth'),
      rendererExtensionDrawBuffers: isWebGL2 || extensions.has('WEBGL_draw_buffers'),
      rendererExtensionShaderTextureLod: isWebGL2 || extensions.has('EXT_shader_texture_lod'),
      customProgramCacheKey: material.customProgramCacheKey()
    };
    return parameters;
  }
  function getProgramCacheKey(parameters) {
    const array = [];
    if (parameters.shaderID) {
      array.push(parameters.shaderID);
    } else {
      array.push(parameters.fragmentShader);
      array.push(parameters.vertexShader);
    }
    if (parameters.defines !== undefined) {
      for (const name in parameters.defines) {
        array.push(name);
        array.push(parameters.defines[name]);
      }
    }
    if (parameters.isRawShaderMaterial === false) {
      for (let i = 0; i < parameterNames.length; i++) {
        array.push(parameters[parameterNames[i]]);
      }
      array.push(renderer.outputEncoding);
      array.push(renderer.gammaFactor);
    }
    array.push(parameters.customProgramCacheKey);
    return array.join();
  }
  function getUniforms(material) {
    const shaderID = shaderIDs[material.type];
    let uniforms;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      uniforms = UniformsUtils.clone(shader.uniforms);
    } else {
      uniforms = material.uniforms;
    }
    return uniforms;
  }
  function acquireProgram(parameters, cacheKey) {
    let program;

    // Check if code has been already compiled
    for (let p = 0, pl = programs.length; p < pl; p++) {
      const preexistingProgram = programs[p];
      if (preexistingProgram.cacheKey === cacheKey) {
        program = preexistingProgram;
        ++program.usedTimes;
        break;
      }
    }
    if (program === undefined) {
      program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
      programs.push(program);
    }
    return program;
  }
  function releaseProgram(program) {
    if (--program.usedTimes === 0) {
      // Remove from unordered set
      const i = programs.indexOf(program);
      programs[i] = programs[programs.length - 1];
      programs.pop();

      // Free WebGL resources
      program.destroy();
    }
  }
  return {
    getParameters: getParameters,
    getProgramCacheKey: getProgramCacheKey,
    getUniforms: getUniforms,
    acquireProgram: acquireProgram,
    releaseProgram: releaseProgram,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: programs
  };
}
function WebGLProperties() {
  let properties = new WeakMap();
  function get(object) {
    let map = properties.get(object);
    if (map === undefined) {
      map = {};
      properties.set(object, map);
    }
    return map;
  }
  function remove(object) {
    properties.delete(object);
  }
  function update(object, key, value) {
    properties.get(object)[key] = value;
  }
  function dispose() {
    properties = new WeakMap();
  }
  return {
    get: get,
    remove: remove,
    update: update,
    dispose: dispose
  };
}
function painterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.program !== b.program) {
    return a.program.id - b.program.id;
  } else if (a.material.id !== b.material.id) {
    return a.material.id - b.material.id;
  } else if (a.z !== b.z) {
    return a.z - b.z;
  } else {
    return a.id - b.id;
  }
}
function reversePainterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.z !== b.z) {
    return b.z - a.z;
  } else {
    return a.id - b.id;
  }
}
function WebGLRenderList(properties) {
  const renderItems = [];
  let renderItemsIndex = 0;
  const opaque = [];
  const transparent = [];
  const defaultProgram = {
    id: -1
  };
  function init() {
    renderItemsIndex = 0;
    opaque.length = 0;
    transparent.length = 0;
  }
  function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
    let renderItem = renderItems[renderItemsIndex];
    const materialProperties = properties.get(material);
    if (renderItem === undefined) {
      renderItem = {
        id: object.id,
        object: object,
        geometry: geometry,
        material: material,
        program: materialProperties.program || defaultProgram,
        groupOrder: groupOrder,
        renderOrder: object.renderOrder,
        z: z,
        group: group
      };
      renderItems[renderItemsIndex] = renderItem;
    } else {
      renderItem.id = object.id;
      renderItem.object = object;
      renderItem.geometry = geometry;
      renderItem.material = material;
      renderItem.program = materialProperties.program || defaultProgram;
      renderItem.groupOrder = groupOrder;
      renderItem.renderOrder = object.renderOrder;
      renderItem.z = z;
      renderItem.group = group;
    }
    renderItemsIndex++;
    return renderItem;
  }
  function push(object, geometry, material, groupOrder, z, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
    (material.transparent === true ? transparent : opaque).push(renderItem);
  }
  function unshift(object, geometry, material, groupOrder, z, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
    (material.transparent === true ? transparent : opaque).unshift(renderItem);
  }
  function sort(customOpaqueSort, customTransparentSort) {
    if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);
    if (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable);
  }
  function finish() {
    // Clear references from inactive renderItems in the list

    for (let i = renderItemsIndex, il = renderItems.length; i < il; i++) {
      const renderItem = renderItems[i];
      if (renderItem.id === null) break;
      renderItem.id = null;
      renderItem.object = null;
      renderItem.geometry = null;
      renderItem.material = null;
      renderItem.program = null;
      renderItem.group = null;
    }
  }
  return {
    opaque: opaque,
    transparent: transparent,
    init: init,
    push: push,
    unshift: unshift,
    finish: finish,
    sort: sort
  };
}
function WebGLRenderLists(properties) {
  let lists = new WeakMap();
  function get(scene, camera) {
    const cameras = lists.get(scene);
    let list;
    if (cameras === undefined) {
      list = new WebGLRenderList(properties);
      lists.set(scene, new WeakMap());
      lists.get(scene).set(camera, list);
    } else {
      list = cameras.get(camera);
      if (list === undefined) {
        list = new WebGLRenderList(properties);
        cameras.set(camera, list);
      }
    }
    return list;
  }
  function dispose() {
    lists = new WeakMap();
  }
  return {
    get: get,
    dispose: dispose
  };
}
function UniformsCache() {
  const lights = {};
  return {
    get: function (light) {
      if (lights[light.id] !== undefined) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case 'DirectionalLight':
          uniforms = {
            direction: new Vector3(),
            color: new Color()
          };
          break;
        case 'SpotLight':
          uniforms = {
            position: new Vector3(),
            direction: new Vector3(),
            color: new Color(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case 'PointLight':
          uniforms = {
            position: new Vector3(),
            color: new Color(),
            distance: 0,
            decay: 0
          };
          break;
        case 'HemisphereLight':
          uniforms = {
            direction: new Vector3(),
            skyColor: new Color(),
            groundColor: new Color()
          };
          break;
        case 'RectAreaLight':
          uniforms = {
            color: new Color(),
            position: new Vector3(),
            halfWidth: new Vector3(),
            halfHeight: new Vector3()
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
function ShadowUniformsCache() {
  const lights = {};
  return {
    get: function (light) {
      if (lights[light.id] !== undefined) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case 'DirectionalLight':
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case 'SpotLight':
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case 'PointLight':
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
            shadowCameraNear: 1,
            shadowCameraFar: 1000
          };
          break;

        // TODO (abelnation): set RectAreaLight shadow uniforms
      }

      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
let nextVersion = 0;
function shadowCastingLightsFirst(lightA, lightB) {
  return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
}
function WebGLLights(extensions, capabilities) {
  const cache = new UniformsCache();
  const shadowCache = ShadowUniformsCache();
  const state = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotShadow: [],
    spotShadowMap: [],
    spotShadowMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: []
  };
  for (let i = 0; i < 9; i++) state.probe.push(new Vector3());
  const vector3 = new Vector3();
  const matrix4 = new Matrix4();
  const matrix42 = new Matrix4();
  function setup(lights) {
    let r = 0,
      g = 0,
      b = 0;
    for (let i = 0; i < 9; i++) state.probe[i].set(0, 0, 0);
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    let numDirectionalShadows = 0;
    let numPointShadows = 0;
    let numSpotShadows = 0;
    lights.sort(shadowCastingLightsFirst);
    for (let i = 0, l = lights.length; i < l; i++) {
      const light = lights[i];
      const color = light.color;
      const intensity = light.intensity;
      const distance = light.distance;
      const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
      if (light.isAmbientLight) {
        r += color.r * intensity;
        g += color.g * intensity;
        b += color.b * intensity;
      } else if (light.isLightProbe) {
        for (let j = 0; j < 9; j++) {
          state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
        }
      } else if (light.isDirectionalLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.directionalShadow[directionalLength] = shadowUniforms;
          state.directionalShadowMap[directionalLength] = shadowMap;
          state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
          numDirectionalShadows++;
        }
        state.directional[directionalLength] = uniforms;
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = cache.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.distance = distance;
        uniforms.coneCos = Math.cos(light.angle);
        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
        uniforms.decay = light.decay;
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.spotShadow[spotLength] = shadowUniforms;
          state.spotShadowMap[spotLength] = shadowMap;
          state.spotShadowMatrix[spotLength] = light.shadow.matrix;
          numSpotShadows++;
        }
        state.spot[spotLength] = uniforms;
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = cache.get(light);

        // (a) intensity is the total visible light emitted
        //uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );

        // (b) intensity is the brightness of the light
        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
        uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);
        state.rectArea[rectAreaLength] = uniforms;
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        uniforms.distance = light.distance;
        uniforms.decay = light.decay;
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          shadowUniforms.shadowCameraNear = shadow.camera.near;
          shadowUniforms.shadowCameraFar = shadow.camera.far;
          state.pointShadow[pointLength] = shadowUniforms;
          state.pointShadowMap[pointLength] = shadowMap;
          state.pointShadowMatrix[pointLength] = light.shadow.matrix;
          numPointShadows++;
        }
        state.point[pointLength] = uniforms;
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = cache.get(light);
        uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
        uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
        state.hemi[hemiLength] = uniforms;
        hemiLength++;
      }
    }
    if (rectAreaLength > 0) {
      if (capabilities.isWebGL2) {
        // WebGL 2

        state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
        state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
      } else {
        // WebGL 1

        if (extensions.has('OES_texture_float_linear') === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
          state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
        } else if (extensions.has('OES_texture_half_float_linear') === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
          state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
        } else {
          console.error('THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.');
        }
      }
    }
    state.ambient[0] = r;
    state.ambient[1] = g;
    state.ambient[2] = b;
    const hash = state.hash;
    if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
      state.directional.length = directionalLength;
      state.spot.length = spotLength;
      state.rectArea.length = rectAreaLength;
      state.point.length = pointLength;
      state.hemi.length = hemiLength;
      state.directionalShadow.length = numDirectionalShadows;
      state.directionalShadowMap.length = numDirectionalShadows;
      state.pointShadow.length = numPointShadows;
      state.pointShadowMap.length = numPointShadows;
      state.spotShadow.length = numSpotShadows;
      state.spotShadowMap.length = numSpotShadows;
      state.directionalShadowMatrix.length = numDirectionalShadows;
      state.pointShadowMatrix.length = numPointShadows;
      state.spotShadowMatrix.length = numSpotShadows;
      hash.directionalLength = directionalLength;
      hash.pointLength = pointLength;
      hash.spotLength = spotLength;
      hash.rectAreaLength = rectAreaLength;
      hash.hemiLength = hemiLength;
      hash.numDirectionalShadows = numDirectionalShadows;
      hash.numPointShadows = numPointShadows;
      hash.numSpotShadows = numSpotShadows;
      state.version = nextVersion++;
    }
  }
  function setupView(lights, camera) {
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    const viewMatrix = camera.matrixWorldInverse;
    for (let i = 0, l = lights.length; i < l; i++) {
      const light = lights[i];
      if (light.isDirectionalLight) {
        const uniforms = state.directional[directionalLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = state.spot[spotLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = state.rectArea[rectAreaLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);

        // extract local rotation of light to derive width/height half vectors
        matrix42.identity();
        matrix4.copy(light.matrixWorld);
        matrix4.premultiply(viewMatrix);
        matrix42.extractRotation(matrix4);
        uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
        uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);
        uniforms.halfWidth.applyMatrix4(matrix42);
        uniforms.halfHeight.applyMatrix4(matrix42);
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = state.point[pointLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = state.hemi[hemiLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        uniforms.direction.transformDirection(viewMatrix);
        uniforms.direction.normalize();
        hemiLength++;
      }
    }
  }
  return {
    setup: setup,
    setupView: setupView,
    state: state
  };
}
function WebGLRenderState(extensions, capabilities) {
  const lights = new WebGLLights(extensions, capabilities);
  const lightsArray = [];
  const shadowsArray = [];
  function init() {
    lightsArray.length = 0;
    shadowsArray.length = 0;
  }
  function pushLight(light) {
    lightsArray.push(light);
  }
  function pushShadow(shadowLight) {
    shadowsArray.push(shadowLight);
  }
  function setupLights() {
    lights.setup(lightsArray);
  }
  function setupLightsView(camera) {
    lights.setupView(lightsArray, camera);
  }
  const state = {
    lightsArray: lightsArray,
    shadowsArray: shadowsArray,
    lights: lights
  };
  return {
    init: init,
    state: state,
    setupLights: setupLights,
    setupLightsView: setupLightsView,
    pushLight: pushLight,
    pushShadow: pushShadow
  };
}
function WebGLRenderStates(extensions, capabilities) {
  let renderStates = new WeakMap();
  function get(scene, renderCallDepth = 0) {
    let renderState;
    if (renderStates.has(scene) === false) {
      renderState = new WebGLRenderState(extensions, capabilities);
      renderStates.set(scene, []);
      renderStates.get(scene).push(renderState);
    } else {
      if (renderCallDepth >= renderStates.get(scene).length) {
        renderState = new WebGLRenderState(extensions, capabilities);
        renderStates.get(scene).push(renderState);
      } else {
        renderState = renderStates.get(scene)[renderCallDepth];
      }
    }
    return renderState;
  }
  function dispose() {
    renderStates = new WeakMap();
  }
  return {
    get: get,
    dispose: dispose
  };
}

/**
 * parameters = {
 *
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

function MeshDepthMaterial(parameters) {
  Material.call(this);
  this.type = 'MeshDepthMaterial';
  this.depthPacking = BasicDepthPacking;
  this.skinning = false;
  this.morphTargets = false;
  this.map = null;
  this.alphaMap = null;
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.fog = false;
  this.setValues(parameters);
}
MeshDepthMaterial.prototype = Object.create(Material.prototype);
MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;
MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
MeshDepthMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.depthPacking = source.depthPacking;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.map = source.map;
  this.alphaMap = source.alphaMap;
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  return this;
};

/**
 * parameters = {
 *
 *  referencePosition: <float>,
 *  nearDistance: <float>,
 *  farDistance: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>
 *
 * }
 */

function MeshDistanceMaterial(parameters) {
  Material.call(this);
  this.type = 'MeshDistanceMaterial';
  this.referencePosition = new Vector3();
  this.nearDistance = 1;
  this.farDistance = 1000;
  this.skinning = false;
  this.morphTargets = false;
  this.map = null;
  this.alphaMap = null;
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.fog = false;
  this.setValues(parameters);
}
MeshDistanceMaterial.prototype = Object.create(Material.prototype);
MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;
MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
MeshDistanceMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.referencePosition.copy(source.referencePosition);
  this.nearDistance = source.nearDistance;
  this.farDistance = source.farDistance;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.map = source.map;
  this.alphaMap = source.alphaMap;
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  return this;
};
var vsm_frag = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
var vsm_vert = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";
function WebGLShadowMap(_renderer, _objects, maxTextureSize) {
  let _frustum = new Frustum();
  const _shadowMapSize = new Vector2(),
    _viewportSize = new Vector2(),
    _viewport = new Vector4(),
    _depthMaterials = [],
    _distanceMaterials = [],
    _materialCache = {};
  const shadowSide = {
    0: BackSide,
    1: FrontSide,
    2: DoubleSide
  };
  const shadowMaterialVertical = new ShaderMaterial({
    defines: {
      SAMPLE_RATE: 2.0 / 8.0,
      HALF_SAMPLE_RATE: 1.0 / 8.0
    },
    uniforms: {
      shadow_pass: {
        value: null
      },
      resolution: {
        value: new Vector2()
      },
      radius: {
        value: 4.0
      }
    },
    vertexShader: vsm_vert,
    fragmentShader: vsm_frag
  });
  const shadowMaterialHorizontal = shadowMaterialVertical.clone();
  shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
  const fullScreenTri = new BufferGeometry();
  fullScreenTri.setAttribute('position', new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
  const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
  const scope = this;
  this.enabled = false;
  this.autoUpdate = true;
  this.needsUpdate = false;
  this.type = PCFShadowMap;
  this.render = function (lights, scene, camera) {
    if (scope.enabled === false) return;
    if (scope.autoUpdate === false && scope.needsUpdate === false) return;
    if (lights.length === 0) return;
    const currentRenderTarget = _renderer.getRenderTarget();
    const activeCubeFace = _renderer.getActiveCubeFace();
    const activeMipmapLevel = _renderer.getActiveMipmapLevel();
    const _state = _renderer.state;

    // Set GL state for depth map.
    _state.setBlending(NoBlending);
    _state.buffers.color.setClear(1, 1, 1, 1);
    _state.buffers.depth.setTest(true);
    _state.setScissorTest(false);

    // render depth map

    for (let i = 0, il = lights.length; i < il; i++) {
      const light = lights[i];
      const shadow = light.shadow;
      if (shadow === undefined) {
        console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
        continue;
      }
      if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;
      _shadowMapSize.copy(shadow.mapSize);
      const shadowFrameExtents = shadow.getFrameExtents();
      _shadowMapSize.multiply(shadowFrameExtents);
      _viewportSize.copy(shadow.mapSize);
      if (_shadowMapSize.x > maxTextureSize || _shadowMapSize.y > maxTextureSize) {
        if (_shadowMapSize.x > maxTextureSize) {
          _viewportSize.x = Math.floor(maxTextureSize / shadowFrameExtents.x);
          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
          shadow.mapSize.x = _viewportSize.x;
        }
        if (_shadowMapSize.y > maxTextureSize) {
          _viewportSize.y = Math.floor(maxTextureSize / shadowFrameExtents.y);
          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
          shadow.mapSize.y = _viewportSize.y;
        }
      }
      if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
        const pars = {
          minFilter: LinearFilter,
          magFilter: LinearFilter,
          format: RGBAFormat
        };
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + '.shadowMap';
        shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.camera.updateProjectionMatrix();
      }
      if (shadow.map === null) {
        const pars = {
          minFilter: NearestFilter,
          magFilter: NearestFilter,
          format: RGBAFormat
        };
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + '.shadowMap';
        shadow.camera.updateProjectionMatrix();
      }
      _renderer.setRenderTarget(shadow.map);
      _renderer.clear();
      const viewportCount = shadow.getViewportCount();
      for (let vp = 0; vp < viewportCount; vp++) {
        const viewport = shadow.getViewport(vp);
        _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);
        _state.viewport(_viewport);
        shadow.updateMatrices(light, vp);
        _frustum = shadow.getFrustum();
        renderObject(scene, camera, shadow.camera, light, this.type);
      }

      // do blur pass for VSM

      if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {
        VSMPass(shadow, camera);
      }
      shadow.needsUpdate = false;
    }
    scope.needsUpdate = false;
    _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
  };
  function VSMPass(shadow, camera) {
    const geometry = _objects.update(fullScreenMesh);

    // vertical pass

    shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
    shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialVertical.uniforms.radius.value = shadow.radius;
    _renderer.setRenderTarget(shadow.mapPass);
    _renderer.clear();
    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);

    // horizontal pass

    shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
    shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
    _renderer.setRenderTarget(shadow.map);
    _renderer.clear();
    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
  }
  function getDepthMaterialVariant(useMorphing, useSkinning, useInstancing) {
    const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
    let material = _depthMaterials[index];
    if (material === undefined) {
      material = new MeshDepthMaterial({
        depthPacking: RGBADepthPacking,
        morphTargets: useMorphing,
        skinning: useSkinning
      });
      _depthMaterials[index] = material;
    }
    return material;
  }
  function getDistanceMaterialVariant(useMorphing, useSkinning, useInstancing) {
    const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
    let material = _distanceMaterials[index];
    if (material === undefined) {
      material = new MeshDistanceMaterial({
        morphTargets: useMorphing,
        skinning: useSkinning
      });
      _distanceMaterials[index] = material;
    }
    return material;
  }
  function getDepthMaterial(object, geometry, material, light, shadowCameraNear, shadowCameraFar, type) {
    let result = null;
    let getMaterialVariant = getDepthMaterialVariant;
    let customMaterial = object.customDepthMaterial;
    if (light.isPointLight === true) {
      getMaterialVariant = getDistanceMaterialVariant;
      customMaterial = object.customDistanceMaterial;
    }
    if (customMaterial === undefined) {
      let useMorphing = false;
      if (material.morphTargets === true) {
        useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
      }
      let useSkinning = false;
      if (object.isSkinnedMesh === true) {
        if (material.skinning === true) {
          useSkinning = true;
        } else {
          console.warn('THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object);
        }
      }
      const useInstancing = object.isInstancedMesh === true;
      result = getMaterialVariant(useMorphing, useSkinning, useInstancing);
    } else {
      result = customMaterial;
    }
    if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
      // in this case we need a unique material instance reflecting the
      // appropriate state

      const keyA = result.uuid,
        keyB = material.uuid;
      let materialsForVariant = _materialCache[keyA];
      if (materialsForVariant === undefined) {
        materialsForVariant = {};
        _materialCache[keyA] = materialsForVariant;
      }
      let cachedMaterial = materialsForVariant[keyB];
      if (cachedMaterial === undefined) {
        cachedMaterial = result.clone();
        materialsForVariant[keyB] = cachedMaterial;
      }
      result = cachedMaterial;
    }
    result.visible = material.visible;
    result.wireframe = material.wireframe;
    if (type === VSMShadowMap) {
      result.side = material.shadowSide !== null ? material.shadowSide : material.side;
    } else {
      result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
    }
    result.clipShadows = material.clipShadows;
    result.clippingPlanes = material.clippingPlanes;
    result.clipIntersection = material.clipIntersection;
    result.wireframeLinewidth = material.wireframeLinewidth;
    result.linewidth = material.linewidth;
    if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
      result.referencePosition.setFromMatrixPosition(light.matrixWorld);
      result.nearDistance = shadowCameraNear;
      result.farDistance = shadowCameraFar;
    }
    return result;
  }
  function renderObject(object, camera, shadowCamera, light, type) {
    if (object.visible === false) return;
    const visible = object.layers.test(camera.layers);
    if (visible && (object.isMesh || object.isLine || object.isPoints)) {
      if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
        const geometry = _objects.update(object);
        const material = object.material;
        if (Array.isArray(material)) {
          const groups = geometry.groups;
          for (let k = 0, kl = groups.length; k < kl; k++) {
            const group = groups[k];
            const groupMaterial = material[group.materialIndex];
            if (groupMaterial && groupMaterial.visible) {
              const depthMaterial = getDepthMaterial(object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);
              _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
            }
          }
        } else if (material.visible) {
          const depthMaterial = getDepthMaterial(object, geometry, material, light, shadowCamera.near, shadowCamera.far, type);
          _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
        }
      }
    }
    const children = object.children;
    for (let i = 0, l = children.length; i < l; i++) {
      renderObject(children[i], camera, shadowCamera, light, type);
    }
  }
}
function WebGLState(gl, extensions, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  function ColorBuffer() {
    let locked = false;
    const color = new Vector4();
    let currentColorMask = null;
    const currentColorClear = new Vector4(0, 0, 0, 0);
    return {
      setMask: function (colorMask) {
        if (currentColorMask !== colorMask && !locked) {
          gl.colorMask(colorMask, colorMask, colorMask, colorMask);
          currentColorMask = colorMask;
        }
      },
      setLocked: function (lock) {
        locked = lock;
      },
      setClear: function (r, g, b, a, premultipliedAlpha) {
        if (premultipliedAlpha === true) {
          r *= a;
          g *= a;
          b *= a;
        }
        color.set(r, g, b, a);
        if (currentColorClear.equals(color) === false) {
          gl.clearColor(r, g, b, a);
          currentColorClear.copy(color);
        }
      },
      reset: function () {
        locked = false;
        currentColorMask = null;
        currentColorClear.set(-1, 0, 0, 0); // set to invalid state
      }
    };
  }

  function DepthBuffer() {
    let locked = false;
    let currentDepthMask = null;
    let currentDepthFunc = null;
    let currentDepthClear = null;
    return {
      setTest: function (depthTest) {
        if (depthTest) {
          enable(2929);
        } else {
          disable(2929);
        }
      },
      setMask: function (depthMask) {
        if (currentDepthMask !== depthMask && !locked) {
          gl.depthMask(depthMask);
          currentDepthMask = depthMask;
        }
      },
      setFunc: function (depthFunc) {
        if (currentDepthFunc !== depthFunc) {
          if (depthFunc) {
            switch (depthFunc) {
              case NeverDepth:
                gl.depthFunc(512);
                break;
              case AlwaysDepth:
                gl.depthFunc(519);
                break;
              case LessDepth:
                gl.depthFunc(513);
                break;
              case LessEqualDepth:
                gl.depthFunc(515);
                break;
              case EqualDepth:
                gl.depthFunc(514);
                break;
              case GreaterEqualDepth:
                gl.depthFunc(518);
                break;
              case GreaterDepth:
                gl.depthFunc(516);
                break;
              case NotEqualDepth:
                gl.depthFunc(517);
                break;
              default:
                gl.depthFunc(515);
            }
          } else {
            gl.depthFunc(515);
          }
          currentDepthFunc = depthFunc;
        }
      },
      setLocked: function (lock) {
        locked = lock;
      },
      setClear: function (depth) {
        if (currentDepthClear !== depth) {
          gl.clearDepth(depth);
          currentDepthClear = depth;
        }
      },
      reset: function () {
        locked = false;
        currentDepthMask = null;
        currentDepthFunc = null;
        currentDepthClear = null;
      }
    };
  }
  function StencilBuffer() {
    let locked = false;
    let currentStencilMask = null;
    let currentStencilFunc = null;
    let currentStencilRef = null;
    let currentStencilFuncMask = null;
    let currentStencilFail = null;
    let currentStencilZFail = null;
    let currentStencilZPass = null;
    let currentStencilClear = null;
    return {
      setTest: function (stencilTest) {
        if (!locked) {
          if (stencilTest) {
            enable(2960);
          } else {
            disable(2960);
          }
        }
      },
      setMask: function (stencilMask) {
        if (currentStencilMask !== stencilMask && !locked) {
          gl.stencilMask(stencilMask);
          currentStencilMask = stencilMask;
        }
      },
      setFunc: function (stencilFunc, stencilRef, stencilMask) {
        if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
          gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
          currentStencilFunc = stencilFunc;
          currentStencilRef = stencilRef;
          currentStencilFuncMask = stencilMask;
        }
      },
      setOp: function (stencilFail, stencilZFail, stencilZPass) {
        if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
          gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
          currentStencilFail = stencilFail;
          currentStencilZFail = stencilZFail;
          currentStencilZPass = stencilZPass;
        }
      },
      setLocked: function (lock) {
        locked = lock;
      },
      setClear: function (stencil) {
        if (currentStencilClear !== stencil) {
          gl.clearStencil(stencil);
          currentStencilClear = stencil;
        }
      },
      reset: function () {
        locked = false;
        currentStencilMask = null;
        currentStencilFunc = null;
        currentStencilRef = null;
        currentStencilFuncMask = null;
        currentStencilFail = null;
        currentStencilZFail = null;
        currentStencilZPass = null;
        currentStencilClear = null;
      }
    };
  }

  //

  const colorBuffer = new ColorBuffer();
  const depthBuffer = new DepthBuffer();
  const stencilBuffer = new StencilBuffer();
  let enabledCapabilities = {};
  let currentProgram = null;
  let currentBlendingEnabled = null;
  let currentBlending = null;
  let currentBlendEquation = null;
  let currentBlendSrc = null;
  let currentBlendDst = null;
  let currentBlendEquationAlpha = null;
  let currentBlendSrcAlpha = null;
  let currentBlendDstAlpha = null;
  let currentPremultipledAlpha = false;
  let currentFlipSided = null;
  let currentCullFace = null;
  let currentLineWidth = null;
  let currentPolygonOffsetFactor = null;
  let currentPolygonOffsetUnits = null;
  const maxTextures = gl.getParameter(35661);
  let lineWidthAvailable = false;
  let version = 0;
  const glVersion = gl.getParameter(7938);
  if (glVersion.indexOf('WebGL') !== -1) {
    version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 1.0;
  } else if (glVersion.indexOf('OpenGL ES') !== -1) {
    version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 2.0;
  }
  let currentTextureSlot = null;
  let currentBoundTextures = {};
  const currentScissor = new Vector4();
  const currentViewport = new Vector4();
  function createTexture(type, target, count) {
    const data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.
    const texture = gl.createTexture();
    gl.bindTexture(type, texture);
    gl.texParameteri(type, 10241, 9728);
    gl.texParameteri(type, 10240, 9728);
    for (let i = 0; i < count; i++) {
      gl.texImage2D(target + i, 0, 6408, 1, 1, 0, 6408, 5121, data);
    }
    return texture;
  }
  const emptyTextures = {};
  emptyTextures[3553] = createTexture(3553, 3553, 1);
  emptyTextures[34067] = createTexture(34067, 34069, 6);

  // init

  colorBuffer.setClear(0, 0, 0, 1);
  depthBuffer.setClear(1);
  stencilBuffer.setClear(0);
  enable(2929);
  depthBuffer.setFunc(LessEqualDepth);
  setFlipSided(false);
  setCullFace(CullFaceBack);
  enable(2884);
  setBlending(NoBlending);

  //

  function enable(id) {
    if (enabledCapabilities[id] !== true) {
      gl.enable(id);
      enabledCapabilities[id] = true;
    }
  }
  function disable(id) {
    if (enabledCapabilities[id] !== false) {
      gl.disable(id);
      enabledCapabilities[id] = false;
    }
  }
  function useProgram(program) {
    if (currentProgram !== program) {
      gl.useProgram(program);
      currentProgram = program;
      return true;
    }
    return false;
  }
  const equationToGL = {
    [AddEquation]: 32774,
    [SubtractEquation]: 32778,
    [ReverseSubtractEquation]: 32779
  };
  if (isWebGL2) {
    equationToGL[MinEquation] = 32775;
    equationToGL[MaxEquation] = 32776;
  } else {
    const extension = extensions.get('EXT_blend_minmax');
    if (extension !== null) {
      equationToGL[MinEquation] = extension.MIN_EXT;
      equationToGL[MaxEquation] = extension.MAX_EXT;
    }
  }
  const factorToGL = {
    [ZeroFactor]: 0,
    [OneFactor]: 1,
    [SrcColorFactor]: 768,
    [SrcAlphaFactor]: 770,
    [SrcAlphaSaturateFactor]: 776,
    [DstColorFactor]: 774,
    [DstAlphaFactor]: 772,
    [OneMinusSrcColorFactor]: 769,
    [OneMinusSrcAlphaFactor]: 771,
    [OneMinusDstColorFactor]: 775,
    [OneMinusDstAlphaFactor]: 773
  };
  function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
    if (blending === NoBlending) {
      if (currentBlendingEnabled) {
        disable(3042);
        currentBlendingEnabled = false;
      }
      return;
    }
    if (!currentBlendingEnabled) {
      enable(3042);
      currentBlendingEnabled = true;
    }
    if (blending !== CustomBlending) {
      if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
        if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
          gl.blendEquation(32774);
          currentBlendEquation = AddEquation;
          currentBlendEquationAlpha = AddEquation;
        }
        if (premultipliedAlpha) {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(1, 771, 1, 771);
              break;
            case AdditiveBlending:
              gl.blendFunc(1, 1);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(0, 0, 769, 771);
              break;
            case MultiplyBlending:
              gl.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error('THREE.WebGLState: Invalid blending: ', blending);
              break;
          }
        } else {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(770, 771, 1, 771);
              break;
            case AdditiveBlending:
              gl.blendFunc(770, 1);
              break;
            case SubtractiveBlending:
              gl.blendFunc(0, 769);
              break;
            case MultiplyBlending:
              gl.blendFunc(0, 768);
              break;
            default:
              console.error('THREE.WebGLState: Invalid blending: ', blending);
              break;
          }
        }
        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
        currentBlending = blending;
        currentPremultipledAlpha = premultipliedAlpha;
      }
      return;
    }

    // custom blending

    blendEquationAlpha = blendEquationAlpha || blendEquation;
    blendSrcAlpha = blendSrcAlpha || blendSrc;
    blendDstAlpha = blendDstAlpha || blendDst;
    if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
      gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
      currentBlendEquation = blendEquation;
      currentBlendEquationAlpha = blendEquationAlpha;
    }
    if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
      gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
      currentBlendSrc = blendSrc;
      currentBlendDst = blendDst;
      currentBlendSrcAlpha = blendSrcAlpha;
      currentBlendDstAlpha = blendDstAlpha;
    }
    currentBlending = blending;
    currentPremultipledAlpha = null;
  }
  function setMaterial(material, frontFaceCW) {
    material.side === DoubleSide ? disable(2884) : enable(2884);
    let flipSided = material.side === BackSide;
    if (frontFaceCW) flipSided = !flipSided;
    setFlipSided(flipSided);
    material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
    depthBuffer.setFunc(material.depthFunc);
    depthBuffer.setTest(material.depthTest);
    depthBuffer.setMask(material.depthWrite);
    colorBuffer.setMask(material.colorWrite);
    const stencilWrite = material.stencilWrite;
    stencilBuffer.setTest(stencilWrite);
    if (stencilWrite) {
      stencilBuffer.setMask(material.stencilWriteMask);
      stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
      stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
    }
    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
  }

  //

  function setFlipSided(flipSided) {
    if (currentFlipSided !== flipSided) {
      if (flipSided) {
        gl.frontFace(2304);
      } else {
        gl.frontFace(2305);
      }
      currentFlipSided = flipSided;
    }
  }
  function setCullFace(cullFace) {
    if (cullFace !== CullFaceNone) {
      enable(2884);
      if (cullFace !== currentCullFace) {
        if (cullFace === CullFaceBack) {
          gl.cullFace(1029);
        } else if (cullFace === CullFaceFront) {
          gl.cullFace(1028);
        } else {
          gl.cullFace(1032);
        }
      }
    } else {
      disable(2884);
    }
    currentCullFace = cullFace;
  }
  function setLineWidth(width) {
    if (width !== currentLineWidth) {
      if (lineWidthAvailable) gl.lineWidth(width);
      currentLineWidth = width;
    }
  }
  function setPolygonOffset(polygonOffset, factor, units) {
    if (polygonOffset) {
      enable(32823);
      if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
        gl.polygonOffset(factor, units);
        currentPolygonOffsetFactor = factor;
        currentPolygonOffsetUnits = units;
      }
    } else {
      disable(32823);
    }
  }
  function setScissorTest(scissorTest) {
    if (scissorTest) {
      enable(3089);
    } else {
      disable(3089);
    }
  }

  // texture

  function activeTexture(webglSlot) {
    if (webglSlot === undefined) webglSlot = 33984 + maxTextures - 1;
    if (currentTextureSlot !== webglSlot) {
      gl.activeTexture(webglSlot);
      currentTextureSlot = webglSlot;
    }
  }
  function bindTexture(webglType, webglTexture) {
    if (currentTextureSlot === null) {
      activeTexture();
    }
    let boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture === undefined) {
      boundTexture = {
        type: undefined,
        texture: undefined
      };
      currentBoundTextures[currentTextureSlot] = boundTexture;
    }
    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
      gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;
    }
  }
  function unbindTexture() {
    const boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture !== undefined && boundTexture.type !== undefined) {
      gl.bindTexture(boundTexture.type, null);
      boundTexture.type = undefined;
      boundTexture.texture = undefined;
    }
  }
  function compressedTexImage2D() {
    try {
      gl.compressedTexImage2D.apply(gl, arguments);
    } catch (error) {
      console.error('THREE.WebGLState:', error);
    }
  }
  function texImage2D() {
    try {
      gl.texImage2D.apply(gl, arguments);
    } catch (error) {
      console.error('THREE.WebGLState:', error);
    }
  }
  function texImage3D() {
    try {
      gl.texImage3D.apply(gl, arguments);
    } catch (error) {
      console.error('THREE.WebGLState:', error);
    }
  }

  //

  function scissor(scissor) {
    if (currentScissor.equals(scissor) === false) {
      gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
      currentScissor.copy(scissor);
    }
  }
  function viewport(viewport) {
    if (currentViewport.equals(viewport) === false) {
      gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
      currentViewport.copy(viewport);
    }
  }

  //

  function reset() {
    enabledCapabilities = {};
    currentTextureSlot = null;
    currentBoundTextures = {};
    currentProgram = null;
    currentBlendingEnabled = null;
    currentBlending = null;
    currentBlendEquation = null;
    currentBlendSrc = null;
    currentBlendDst = null;
    currentBlendEquationAlpha = null;
    currentBlendSrcAlpha = null;
    currentBlendDstAlpha = null;
    currentPremultipledAlpha = false;
    currentFlipSided = null;
    currentCullFace = null;
    currentLineWidth = null;
    currentPolygonOffsetFactor = null;
    currentPolygonOffsetUnits = null;
    colorBuffer.reset();
    depthBuffer.reset();
    stencilBuffer.reset();
  }
  return {
    buffers: {
      color: colorBuffer,
      depth: depthBuffer,
      stencil: stencilBuffer
    },
    enable: enable,
    disable: disable,
    useProgram: useProgram,
    setBlending: setBlending,
    setMaterial: setMaterial,
    setFlipSided: setFlipSided,
    setCullFace: setCullFace,
    setLineWidth: setLineWidth,
    setPolygonOffset: setPolygonOffset,
    setScissorTest: setScissorTest,
    activeTexture: activeTexture,
    bindTexture: bindTexture,
    unbindTexture: unbindTexture,
    compressedTexImage2D: compressedTexImage2D,
    texImage2D: texImage2D,
    texImage3D: texImage3D,
    scissor: scissor,
    viewport: viewport,
    reset: reset
  };
}
function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
  const isWebGL2 = capabilities.isWebGL2;
  const maxTextures = capabilities.maxTextures;
  const maxCubemapSize = capabilities.maxCubemapSize;
  const maxTextureSize = capabilities.maxTextureSize;
  const maxSamples = capabilities.maxSamples;
  const _videoTextures = new WeakMap();
  let _canvas;

  // cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
  // also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
  // Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).

  let useOffscreenCanvas = false;
  try {
    useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined' && new OffscreenCanvas(1, 1).getContext('2d') !== null;
  } catch (err) {

    // Ignore any errors
  }
  function createCanvas(width, height) {
    // Use OffscreenCanvas when available. Specially needed in web workers

    return useOffscreenCanvas ? new OffscreenCanvas(width, height) : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
  }
  function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
    let scale = 1;

    // handle case if texture exceeds max size

    if (image.width > maxSize || image.height > maxSize) {
      scale = maxSize / Math.max(image.width, image.height);
    }

    // only perform resize if necessary

    if (scale < 1 || needsPowerOfTwo === true) {
      // only perform resize for certain image types

      if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
        const floor = needsPowerOfTwo ? MathUtils.floorPowerOfTwo : Math.floor;
        const width = floor(scale * image.width);
        const height = floor(scale * image.height);
        if (_canvas === undefined) _canvas = createCanvas(width, height);

        // cube textures can't reuse the same canvas

        const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas;
        canvas.width = width;
        canvas.height = height;
        const context = canvas.getContext('2d');
        context.drawImage(image, 0, 0, width, height);
        console.warn('THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').');
        return canvas;
      } else {
        if ('data' in image) {
          console.warn('THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').');
        }
        return image;
      }
    }
    return image;
  }
  function isPowerOfTwo(image) {
    return MathUtils.isPowerOfTwo(image.width) && MathUtils.isPowerOfTwo(image.height);
  }
  function textureNeedsPowerOfTwo(texture) {
    if (isWebGL2) return false;
    return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function textureNeedsGenerateMipmaps(texture, supportsMips) {
    return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function generateMipmap(target, texture, width, height) {
    _gl.generateMipmap(target);
    const textureProperties = properties.get(texture);

    // Note: Math.log( x ) * Math.LOG2E used instead of Math.log2( x ) which is not supported by IE11
    textureProperties.__maxMipLevel = Math.log(Math.max(width, height)) * Math.LOG2E;
  }
  function getInternalFormat(internalFormatName, glFormat, glType) {
    if (isWebGL2 === false) return glFormat;
    if (internalFormatName !== null) {
      if (_gl[internalFormatName] !== undefined) return _gl[internalFormatName];
      console.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'');
    }
    let internalFormat = glFormat;
    if (glFormat === 6403) {
      if (glType === 5126) internalFormat = 33326;
      if (glType === 5131) internalFormat = 33325;
      if (glType === 5121) internalFormat = 33321;
    }
    if (glFormat === 6407) {
      if (glType === 5126) internalFormat = 34837;
      if (glType === 5131) internalFormat = 34843;
      if (glType === 5121) internalFormat = 32849;
    }
    if (glFormat === 6408) {
      if (glType === 5126) internalFormat = 34836;
      if (glType === 5131) internalFormat = 34842;
      if (glType === 5121) internalFormat = 32856;
    }
    if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 34842 || internalFormat === 34836) {
      extensions.get('EXT_color_buffer_float');
    }
    return internalFormat;
  }

  // Fallback filters for non-power-of-2 textures

  function filterFallback(f) {
    if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {
      return 9728;
    }
    return 9729;
  }

  //

  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener('dispose', onTextureDispose);
    deallocateTexture(texture);
    if (texture.isVideoTexture) {
      _videoTextures.delete(texture);
    }
    info.memory.textures--;
  }
  function onRenderTargetDispose(event) {
    const renderTarget = event.target;
    renderTarget.removeEventListener('dispose', onRenderTargetDispose);
    deallocateRenderTarget(renderTarget);
    info.memory.textures--;
  }

  //

  function deallocateTexture(texture) {
    const textureProperties = properties.get(texture);
    if (textureProperties.__webglInit === undefined) return;
    _gl.deleteTexture(textureProperties.__webglTexture);
    properties.remove(texture);
  }
  function deallocateRenderTarget(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(renderTarget.texture);
    if (!renderTarget) return;
    if (textureProperties.__webglTexture !== undefined) {
      _gl.deleteTexture(textureProperties.__webglTexture);
    }
    if (renderTarget.depthTexture) {
      renderTarget.depthTexture.dispose();
    }
    if (renderTarget.isWebGLCubeRenderTarget) {
      for (let i = 0; i < 6; i++) {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
        if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
      }
    } else {
      _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
      if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
      if (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
      if (renderTargetProperties.__webglColorRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
      if (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
    }
    properties.remove(renderTarget.texture);
    properties.remove(renderTarget);
  }

  //

  let textureUnits = 0;
  function resetTextureUnits() {
    textureUnits = 0;
  }
  function allocateTextureUnit() {
    const textureUnit = textureUnits;
    if (textureUnit >= maxTextures) {
      console.warn('THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures);
    }
    textureUnits += 1;
    return textureUnit;
  }

  //

  function setTexture2D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.isVideoTexture) updateVideoTexture(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      const image = texture.image;
      if (image === undefined) {
        console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined');
      } else if (image.complete === false) {
        console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');
      } else {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(3553, textureProperties.__webglTexture);
  }
  function setTexture2DArray(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(35866, textureProperties.__webglTexture);
  }
  function setTexture3D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(32879, textureProperties.__webglTexture);
  }
  function setTextureCube(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadCubeTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(34067, textureProperties.__webglTexture);
  }
  const wrappingToGL = {
    [RepeatWrapping]: 10497,
    [ClampToEdgeWrapping]: 33071,
    [MirroredRepeatWrapping]: 33648
  };
  const filterToGL = {
    [NearestFilter]: 9728,
    [NearestMipmapNearestFilter]: 9984,
    [NearestMipmapLinearFilter]: 9986,
    [LinearFilter]: 9729,
    [LinearMipmapNearestFilter]: 9985,
    [LinearMipmapLinearFilter]: 9987
  };
  function setTextureParameters(textureType, texture, supportsMips) {
    if (supportsMips) {
      _gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS]);
      _gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT]);
      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR]);
      }
      _gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter]);
      _gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter]);
    } else {
      _gl.texParameteri(textureType, 10242, 33071);
      _gl.texParameteri(textureType, 10243, 33071);
      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, 33071);
      }
      if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
        console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.');
      }
      _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));
      _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));
      if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
        console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.');
      }
    }
    const extension = extensions.get('EXT_texture_filter_anisotropic');
    if (extension) {
      if (texture.type === FloatType && extensions.get('OES_texture_float_linear') === null) return;
      if (texture.type === HalfFloatType && (isWebGL2 || extensions.get('OES_texture_half_float_linear')) === null) return;
      if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
        properties.get(texture).__currentAnisotropy = texture.anisotropy;
      }
    }
  }
  function initTexture(textureProperties, texture) {
    if (textureProperties.__webglInit === undefined) {
      textureProperties.__webglInit = true;
      texture.addEventListener('dispose', onTextureDispose);
      textureProperties.__webglTexture = _gl.createTexture();
      info.memory.textures++;
    }
  }
  function uploadTexture(textureProperties, texture, slot) {
    let textureType = 3553;
    if (texture.isDataTexture2DArray) textureType = 35866;
    if (texture.isDataTexture3D) textureType = 32879;
    initTexture(textureProperties, texture);
    state.activeTexture(33984 + slot);
    state.bindTexture(textureType, textureProperties.__webglTexture);
    _gl.pixelStorei(37440, texture.flipY);
    _gl.pixelStorei(37441, texture.premultiplyAlpha);
    _gl.pixelStorei(3317, texture.unpackAlignment);
    const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo(texture.image) === false;
    const image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
    const supportsMips = isPowerOfTwo(image) || isWebGL2,
      glFormat = utils.convert(texture.format);
    let glType = utils.convert(texture.type),
      glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
    setTextureParameters(textureType, texture, supportsMips);
    let mipmap;
    const mipmaps = texture.mipmaps;
    if (texture.isDepthTexture) {
      // populate depth texture with dummy data

      glInternalFormat = 6402;
      if (isWebGL2) {
        if (texture.type === FloatType) {
          glInternalFormat = 36012;
        } else if (texture.type === UnsignedIntType) {
          glInternalFormat = 33190;
        } else if (texture.type === UnsignedInt248Type) {
          glInternalFormat = 35056;
        } else {
          glInternalFormat = 33189; // WebGL2 requires sized internalformat for glTexImage2D
        }
      } else {
        if (texture.type === FloatType) {
          console.error('WebGLRenderer: Floating point depth texture requires WebGL2.');
        }
      }

      // validation checks for WebGL 1

      if (texture.format === DepthFormat && glInternalFormat === 6402) {
        // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
        // DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
        // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
        if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
          console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');
          texture.type = UnsignedShortType;
          glType = utils.convert(texture.type);
        }
      }
      if (texture.format === DepthStencilFormat && glInternalFormat === 6402) {
        // Depth stencil textures need the DEPTH_STENCIL internal format
        // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
        glInternalFormat = 34041;

        // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
        // DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
        // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
        if (texture.type !== UnsignedInt248Type) {
          console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');
          texture.type = UnsignedInt248Type;
          glType = utils.convert(texture.type);
        }
      }

      //

      state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
    } else if (texture.isDataTexture) {
      // use manually created mipmaps if available
      // if there are no manual mipmaps
      // set 0 level mipmap and then use GL to generate other mipmap levels

      if (mipmaps.length > 0 && supportsMips) {
        for (let i = 0, il = mipmaps.length; i < il; i++) {
          mipmap = mipmaps[i];
          state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }
        texture.generateMipmaps = false;
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
        textureProperties.__maxMipLevel = 0;
      }
    } else if (texture.isCompressedTexture) {
      for (let i = 0, il = mipmaps.length; i < il; i++) {
        mipmap = mipmaps[i];
        if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
          if (glFormat !== null) {
            state.compressedTexImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
          } else {
            console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
          }
        } else {
          state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }
      }
      textureProperties.__maxMipLevel = mipmaps.length - 1;
    } else if (texture.isDataTexture2DArray) {
      state.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
      textureProperties.__maxMipLevel = 0;
    } else if (texture.isDataTexture3D) {
      state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
      textureProperties.__maxMipLevel = 0;
    } else {
      // regular Texture (image, video, canvas)

      // use manually created mipmaps if available
      // if there are no manual mipmaps
      // set 0 level mipmap and then use GL to generate other mipmap levels

      if (mipmaps.length > 0 && supportsMips) {
        for (let i = 0, il = mipmaps.length; i < il; i++) {
          mipmap = mipmaps[i];
          state.texImage2D(3553, i, glInternalFormat, glFormat, glType, mipmap);
        }
        texture.generateMipmaps = false;
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
        textureProperties.__maxMipLevel = 0;
      }
    }
    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      generateMipmap(textureType, texture, image.width, image.height);
    }
    textureProperties.__version = texture.version;
    if (texture.onUpdate) texture.onUpdate(texture);
  }
  function uploadCubeTexture(textureProperties, texture, slot) {
    if (texture.image.length !== 6) return;
    initTexture(textureProperties, texture);
    state.activeTexture(33984 + slot);
    state.bindTexture(34067, textureProperties.__webglTexture);
    _gl.pixelStorei(37440, texture.flipY);
    _gl.pixelStorei(37441, texture.premultiplyAlpha);
    _gl.pixelStorei(3317, texture.unpackAlignment);
    const isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);
    const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
    const cubeImage = [];
    for (let i = 0; i < 6; i++) {
      if (!isCompressed && !isDataTexture) {
        cubeImage[i] = resizeImage(texture.image[i], false, true, maxCubemapSize);
      } else {
        cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
      }
    }
    const image = cubeImage[0],
      supportsMips = isPowerOfTwo(image) || isWebGL2,
      glFormat = utils.convert(texture.format),
      glType = utils.convert(texture.type),
      glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
    setTextureParameters(34067, texture, supportsMips);
    let mipmaps;
    if (isCompressed) {
      for (let i = 0; i < 6; i++) {
        mipmaps = cubeImage[i].mipmaps;
        for (let j = 0; j < mipmaps.length; j++) {
          const mipmap = mipmaps[j];
          if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
            if (glFormat !== null) {
              state.compressedTexImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
            } else {
              console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');
            }
          } else {
            state.texImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
          }
        }
      }
      textureProperties.__maxMipLevel = mipmaps.length - 1;
    } else {
      mipmaps = texture.mipmaps;
      for (let i = 0; i < 6; i++) {
        if (isDataTexture) {
          state.texImage2D(34069 + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
          for (let j = 0; j < mipmaps.length; j++) {
            const mipmap = mipmaps[j];
            const mipmapImage = mipmap.image[i].image;
            state.texImage2D(34069 + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
          }
        } else {
          state.texImage2D(34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);
          for (let j = 0; j < mipmaps.length; j++) {
            const mipmap = mipmaps[j];
            state.texImage2D(34069 + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i]);
          }
        }
      }
      textureProperties.__maxMipLevel = mipmaps.length;
    }
    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      // We assume images for cube map have the same size.
      generateMipmap(34067, texture, image.width, image.height);
    }
    textureProperties.__version = texture.version;
    if (texture.onUpdate) texture.onUpdate(texture);
  }

  // Render targets

  // Setup storage for target texture and bind it to correct framebuffer
  function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
    const glFormat = utils.convert(renderTarget.texture.format);
    const glType = utils.convert(renderTarget.texture.type);
    const glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
    state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
    _gl.bindFramebuffer(36160, framebuffer);
    _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0);
    _gl.bindFramebuffer(36160, null);
  }

  // Setup storage for internal depth/stencil buffers and bind to correct framebuffer
  function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
    _gl.bindRenderbuffer(36161, renderbuffer);
    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
      let glInternalFormat = 33189;
      if (isMultisample) {
        const depthTexture = renderTarget.depthTexture;
        if (depthTexture && depthTexture.isDepthTexture) {
          if (depthTexture.type === FloatType) {
            glInternalFormat = 36012;
          } else if (depthTexture.type === UnsignedIntType) {
            glInternalFormat = 33190;
          }
        }
        const samples = getRenderTargetSamples(renderTarget);
        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
      if (isMultisample) {
        const samples = getRenderTargetSamples(renderTarget);
        _gl.renderbufferStorageMultisample(36161, samples, 35056, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
    } else {
      const glFormat = utils.convert(renderTarget.texture.format);
      const glType = utils.convert(renderTarget.texture.type);
      const glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
      if (isMultisample) {
        const samples = getRenderTargetSamples(renderTarget);
        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
      }
    }
    _gl.bindRenderbuffer(36161, null);
  }

  // Setup resources for a Depth Texture for a FBO (needs an extension)
  function setupDepthTexture(framebuffer, renderTarget) {
    const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
    if (isCube) throw new Error('Depth Texture with cube render targets is not supported');
    _gl.bindFramebuffer(36160, framebuffer);
    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
      throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
    }

    // upload an empty depth texture with framebuffer size
    if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
      renderTarget.depthTexture.image.width = renderTarget.width;
      renderTarget.depthTexture.image.height = renderTarget.height;
      renderTarget.depthTexture.needsUpdate = true;
    }
    setTexture2D(renderTarget.depthTexture, 0);
    const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
    if (renderTarget.depthTexture.format === DepthFormat) {
      _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
      _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
    } else {
      throw new Error('Unknown depthTexture format');
    }
  }

  // Setup GL resources for a non-texture depth buffer
  function setupDepthRenderbuffer(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    if (renderTarget.depthTexture) {
      if (isCube) throw new Error('target.depthTexture not supported in Cube render targets');
      setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
    } else {
      if (isCube) {
        renderTargetProperties.__webglDepthbuffer = [];
        for (let i = 0; i < 6; i++) {
          _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i]);
          renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false);
        }
      } else {
        _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
        renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
      }
    }
    _gl.bindFramebuffer(36160, null);
  }

  // Set up GL resources for the render target
  function setupRenderTarget(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(renderTarget.texture);
    renderTarget.addEventListener('dispose', onRenderTargetDispose);
    textureProperties.__webglTexture = _gl.createTexture();
    info.memory.textures++;
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    const isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;
    const supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;

    // Handles WebGL2 RGBFormat fallback - #18858

    if (isWebGL2 && renderTarget.texture.format === RGBFormat && (renderTarget.texture.type === FloatType || renderTarget.texture.type === HalfFloatType)) {
      renderTarget.texture.format = RGBAFormat;
      console.warn('THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.');
    }

    // Setup framebuffer

    if (isCube) {
      renderTargetProperties.__webglFramebuffer = [];
      for (let i = 0; i < 6; i++) {
        renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
      }
    } else {
      renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
      if (isMultisample) {
        if (isWebGL2) {
          renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
          renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();
          _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);
          const glFormat = utils.convert(renderTarget.texture.format);
          const glType = utils.convert(renderTarget.texture.type);
          const glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
          const samples = getRenderTargetSamples(renderTarget);
          _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          _gl.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
          _gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);
          _gl.bindRenderbuffer(36161, null);
          if (renderTarget.depthBuffer) {
            renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
          }
          _gl.bindFramebuffer(36160, null);
        } else {
          console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
        }
      }
    }

    // Setup color buffer

    if (isCube) {
      state.bindTexture(34067, textureProperties.__webglTexture);
      setTextureParameters(34067, renderTarget.texture, supportsMips);
      for (let i = 0; i < 6; i++) {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, 36064, 34069 + i);
      }
      if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) {
        generateMipmap(34067, renderTarget.texture, renderTarget.width, renderTarget.height);
      }
      state.bindTexture(34067, null);
    } else {
      state.bindTexture(3553, textureProperties.__webglTexture);
      setTextureParameters(3553, renderTarget.texture, supportsMips);
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, 36064, 3553);
      if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) {
        generateMipmap(3553, renderTarget.texture, renderTarget.width, renderTarget.height);
      }
      state.bindTexture(3553, null);
    }

    // Setup depth and stencil buffers

    if (renderTarget.depthBuffer) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function updateRenderTargetMipmap(renderTarget) {
    const texture = renderTarget.texture;
    const supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;
    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
      const webglTexture = properties.get(texture).__webglTexture;
      state.bindTexture(target, webglTexture);
      generateMipmap(target, texture, renderTarget.width, renderTarget.height);
      state.bindTexture(target, null);
    }
  }
  function updateMultisampleRenderTarget(renderTarget) {
    if (renderTarget.isWebGLMultisampleRenderTarget) {
      if (isWebGL2) {
        const renderTargetProperties = properties.get(renderTarget);
        _gl.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);
        _gl.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);
        const width = renderTarget.width;
        const height = renderTarget.height;
        let mask = 16384;
        if (renderTarget.depthBuffer) mask |= 256;
        if (renderTarget.stencilBuffer) mask |= 1024;
        _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, 9728);
        _gl.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer); // see #18905
      } else {
        console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
      }
    }
  }
  function getRenderTargetSamples(renderTarget) {
    return isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(maxSamples, renderTarget.samples) : 0;
  }
  function updateVideoTexture(texture) {
    const frame = info.render.frame;

    // Check the last frame we updated the VideoTexture

    if (_videoTextures.get(texture) !== frame) {
      _videoTextures.set(texture, frame);
      texture.update();
    }
  }

  // backwards compatibility

  let warnedTexture2D = false;
  let warnedTextureCube = false;
  function safeSetTexture2D(texture, slot) {
    if (texture && texture.isWebGLRenderTarget) {
      if (warnedTexture2D === false) {
        console.warn('THREE.WebGLTextures.safeSetTexture2D: don\'t use render targets as textures. Use their .texture property instead.');
        warnedTexture2D = true;
      }
      texture = texture.texture;
    }
    setTexture2D(texture, slot);
  }
  function safeSetTextureCube(texture, slot) {
    if (texture && texture.isWebGLCubeRenderTarget) {
      if (warnedTextureCube === false) {
        console.warn('THREE.WebGLTextures.safeSetTextureCube: don\'t use cube render targets as textures. Use their .texture property instead.');
        warnedTextureCube = true;
      }
      texture = texture.texture;
    }
    setTextureCube(texture, slot);
  }

  //

  this.allocateTextureUnit = allocateTextureUnit;
  this.resetTextureUnits = resetTextureUnits;
  this.setTexture2D = setTexture2D;
  this.setTexture2DArray = setTexture2DArray;
  this.setTexture3D = setTexture3D;
  this.setTextureCube = setTextureCube;
  this.setupRenderTarget = setupRenderTarget;
  this.updateRenderTargetMipmap = updateRenderTargetMipmap;
  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
  this.safeSetTexture2D = safeSetTexture2D;
  this.safeSetTextureCube = safeSetTextureCube;
}
function WebGLUtils(gl, extensions, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  function convert(p) {
    let extension;
    if (p === UnsignedByteType) return 5121;
    if (p === UnsignedShort4444Type) return 32819;
    if (p === UnsignedShort5551Type) return 32820;
    if (p === UnsignedShort565Type) return 33635;
    if (p === ByteType) return 5120;
    if (p === ShortType) return 5122;
    if (p === UnsignedShortType) return 5123;
    if (p === IntType) return 5124;
    if (p === UnsignedIntType) return 5125;
    if (p === FloatType) return 5126;
    if (p === HalfFloatType) {
      if (isWebGL2) return 5131;
      extension = extensions.get('OES_texture_half_float');
      if (extension !== null) {
        return extension.HALF_FLOAT_OES;
      } else {
        return null;
      }
    }
    if (p === AlphaFormat) return 6406;
    if (p === RGBFormat) return 6407;
    if (p === RGBAFormat) return 6408;
    if (p === LuminanceFormat) return 6409;
    if (p === LuminanceAlphaFormat) return 6410;
    if (p === DepthFormat) return 6402;
    if (p === DepthStencilFormat) return 34041;
    if (p === RedFormat) return 6403;

    // WebGL2 formats.

    if (p === RedIntegerFormat) return 36244;
    if (p === RGFormat) return 33319;
    if (p === RGIntegerFormat) return 33320;
    if (p === RGBIntegerFormat) return 36248;
    if (p === RGBAIntegerFormat) return 36249;
    if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
      extension = extensions.get('WEBGL_compressed_texture_s3tc');
      if (extension !== null) {
        if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else {
        return null;
      }
    }
    if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
      extension = extensions.get('WEBGL_compressed_texture_pvrtc');
      if (extension !== null) {
        if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else {
        return null;
      }
    }
    if (p === RGB_ETC1_Format) {
      extension = extensions.get('WEBGL_compressed_texture_etc1');
      if (extension !== null) {
        return extension.COMPRESSED_RGB_ETC1_WEBGL;
      } else {
        return null;
      }
    }
    if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
      extension = extensions.get('WEBGL_compressed_texture_etc');
      if (extension !== null) {
        if (p === RGB_ETC2_Format) return extension.COMPRESSED_RGB8_ETC2;
        if (p === RGBA_ETC2_EAC_Format) return extension.COMPRESSED_RGBA8_ETC2_EAC;
      }
    }
    if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format || p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format || p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format || p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format || p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format || p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format) {
      extension = extensions.get('WEBGL_compressed_texture_astc');
      if (extension !== null) {
        // TODO Complete?

        return p;
      } else {
        return null;
      }
    }
    if (p === RGBA_BPTC_Format) {
      extension = extensions.get('EXT_texture_compression_bptc');
      if (extension !== null) {
        // TODO Complete?

        return p;
      } else {
        return null;
      }
    }
    if (p === UnsignedInt248Type) {
      if (isWebGL2) return 34042;
      extension = extensions.get('WEBGL_depth_texture');
      if (extension !== null) {
        return extension.UNSIGNED_INT_24_8_WEBGL;
      } else {
        return null;
      }
    }
  }
  return {
    convert: convert
  };
}
function ArrayCamera(array = []) {
  PerspectiveCamera.call(this);
  this.cameras = array;
}
ArrayCamera.prototype = Object.assign(Object.create(PerspectiveCamera.prototype), {
  constructor: ArrayCamera,
  isArrayCamera: true
});
function Group() {
  Object3D.call(this);
  this.type = 'Group';
}
Group.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Group,
  isGroup: true
});
function WebXRController() {
  this._targetRay = null;
  this._grip = null;
  this._hand = null;
}
Object.assign(WebXRController.prototype, {
  constructor: WebXRController,
  getHandSpace: function () {
    if (this._hand === null) {
      this._hand = new Group();
      this._hand.matrixAutoUpdate = false;
      this._hand.visible = false;
      this._hand.joints = {};
      this._hand.inputState = {
        pinching: false
      };
    }
    return this._hand;
  },
  getTargetRaySpace: function () {
    if (this._targetRay === null) {
      this._targetRay = new Group();
      this._targetRay.matrixAutoUpdate = false;
      this._targetRay.visible = false;
    }
    return this._targetRay;
  },
  getGripSpace: function () {
    if (this._grip === null) {
      this._grip = new Group();
      this._grip.matrixAutoUpdate = false;
      this._grip.visible = false;
    }
    return this._grip;
  },
  dispatchEvent: function (event) {
    if (this._targetRay !== null) {
      this._targetRay.dispatchEvent(event);
    }
    if (this._grip !== null) {
      this._grip.dispatchEvent(event);
    }
    if (this._hand !== null) {
      this._hand.dispatchEvent(event);
    }
    return this;
  },
  disconnect: function (inputSource) {
    this.dispatchEvent({
      type: 'disconnected',
      data: inputSource
    });
    if (this._targetRay !== null) {
      this._targetRay.visible = false;
    }
    if (this._grip !== null) {
      this._grip.visible = false;
    }
    if (this._hand !== null) {
      this._hand.visible = false;
    }
    return this;
  },
  update: function (inputSource, frame, referenceSpace) {
    let inputPose = null;
    let gripPose = null;
    let handPose = null;
    const targetRay = this._targetRay;
    const grip = this._grip;
    const hand = this._hand;
    if (inputSource && frame.session.visibilityState !== 'visible-blurred') {
      if (hand && inputSource.hand) {
        handPose = true;
        for (const inputjoint of inputSource.hand.values()) {
          // Update the joints groups with the XRJoint poses
          const jointPose = frame.getJointPose(inputjoint, referenceSpace);
          if (hand.joints[inputjoint.jointName] === undefined) {
            // The transform of this joint will be updated with the joint pose on each frame
            const joint = new Group();
            joint.matrixAutoUpdate = false;
            joint.visible = false;
            hand.joints[inputjoint.jointName] = joint;
            // ??
            hand.add(joint);
          }
          const joint = hand.joints[inputjoint.jointName];
          if (jointPose !== null) {
            joint.matrix.fromArray(jointPose.transform.matrix);
            joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
            joint.jointRadius = jointPose.radius;
          }
          joint.visible = jointPose !== null;
        }

        // Custom events

        // Check pinchz
        const indexTip = hand.joints['index-finger-tip'];
        const thumbTip = hand.joints['thumb-tip'];
        const distance = indexTip.position.distanceTo(thumbTip.position);
        const distanceToPinch = 0.02;
        const threshold = 0.005;
        if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
          hand.inputState.pinching = false;
          this.dispatchEvent({
            type: 'pinchend',
            handedness: inputSource.handedness,
            target: this
          });
        } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
          hand.inputState.pinching = true;
          this.dispatchEvent({
            type: 'pinchstart',
            handedness: inputSource.handedness,
            target: this
          });
        }
      } else {
        if (targetRay !== null) {
          inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
          if (inputPose !== null) {
            targetRay.matrix.fromArray(inputPose.transform.matrix);
            targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
          }
        }
        if (grip !== null && inputSource.gripSpace) {
          gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
          if (gripPose !== null) {
            grip.matrix.fromArray(gripPose.transform.matrix);
            grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
          }
        }
      }
    }
    if (targetRay !== null) {
      targetRay.visible = inputPose !== null;
    }
    if (grip !== null) {
      grip.visible = gripPose !== null;
    }
    if (hand !== null) {
      hand.visible = handPose !== null;
    }
    return this;
  }
});
function WebXRManager(renderer, gl) {
  const scope = this;
  let session = null;
  let framebufferScaleFactor = 1.0;
  let referenceSpace = null;
  let referenceSpaceType = 'local-floor';
  let pose = null;
  const controllers = [];
  const inputSourcesMap = new Map();

  //

  const cameraL = new PerspectiveCamera();
  cameraL.layers.enable(1);
  cameraL.viewport = new Vector4();
  const cameraR = new PerspectiveCamera();
  cameraR.layers.enable(2);
  cameraR.viewport = new Vector4();
  const cameras = [cameraL, cameraR];
  const cameraVR = new ArrayCamera();
  cameraVR.layers.enable(1);
  cameraVR.layers.enable(2);
  let _currentDepthNear = null;
  let _currentDepthFar = null;

  //

  this.enabled = false;
  this.isPresenting = false;
  this.getController = function (index) {
    let controller = controllers[index];
    if (controller === undefined) {
      controller = new WebXRController();
      controllers[index] = controller;
    }
    return controller.getTargetRaySpace();
  };
  this.getControllerGrip = function (index) {
    let controller = controllers[index];
    if (controller === undefined) {
      controller = new WebXRController();
      controllers[index] = controller;
    }
    return controller.getGripSpace();
  };
  this.getHand = function (index) {
    let controller = controllers[index];
    if (controller === undefined) {
      controller = new WebXRController();
      controllers[index] = controller;
    }
    return controller.getHandSpace();
  };

  //

  function onSessionEvent(event) {
    const controller = inputSourcesMap.get(event.inputSource);
    if (controller) {
      controller.dispatchEvent({
        type: event.type,
        data: event.inputSource
      });
    }
  }
  function onSessionEnd() {
    inputSourcesMap.forEach(function (controller, inputSource) {
      controller.disconnect(inputSource);
    });
    inputSourcesMap.clear();
    _currentDepthNear = null;
    _currentDepthFar = null;

    //

    renderer.setFramebuffer(null);
    renderer.setRenderTarget(renderer.getRenderTarget()); // Hack #15830
    animation.stop();
    scope.isPresenting = false;
    scope.dispatchEvent({
      type: 'sessionend'
    });
  }
  this.setFramebufferScaleFactor = function (value) {
    framebufferScaleFactor = value;
    if (scope.isPresenting === true) {
      console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.');
    }
  };
  this.setReferenceSpaceType = function (value) {
    referenceSpaceType = value;
    if (scope.isPresenting === true) {
      console.warn('THREE.WebXRManager: Cannot change reference space type while presenting.');
    }
  };
  this.getReferenceSpace = function () {
    return referenceSpace;
  };
  this.getSession = function () {
    return session;
  };
  this.setSession = async function (value) {
    session = value;
    if (session !== null) {
      session.addEventListener('select', onSessionEvent);
      session.addEventListener('selectstart', onSessionEvent);
      session.addEventListener('selectend', onSessionEvent);
      session.addEventListener('squeeze', onSessionEvent);
      session.addEventListener('squeezestart', onSessionEvent);
      session.addEventListener('squeezeend', onSessionEvent);
      session.addEventListener('end', onSessionEnd);
      session.addEventListener('inputsourceschange', onInputSourcesChange);
      const attributes = gl.getContextAttributes();
      if (attributes.xrCompatible !== true) {
        await gl.makeXRCompatible();
      }
      const layerInit = {
        antialias: attributes.antialias,
        alpha: attributes.alpha,
        depth: attributes.depth,
        stencil: attributes.stencil,
        framebufferScaleFactor: framebufferScaleFactor
      };

      // eslint-disable-next-line no-undef
      const baseLayer = new XRWebGLLayer(session, gl, layerInit);
      session.updateRenderState({
        baseLayer: baseLayer
      });
      referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
      animation.setContext(session);
      animation.start();
      scope.isPresenting = true;
      scope.dispatchEvent({
        type: 'sessionstart'
      });
    }
  };
  function onInputSourcesChange(event) {
    const inputSources = session.inputSources;

    // Assign inputSources to available controllers

    for (let i = 0; i < controllers.length; i++) {
      inputSourcesMap.set(inputSources[i], controllers[i]);
    }

    // Notify disconnected

    for (let i = 0; i < event.removed.length; i++) {
      const inputSource = event.removed[i];
      const controller = inputSourcesMap.get(inputSource);
      if (controller) {
        controller.dispatchEvent({
          type: 'disconnected',
          data: inputSource
        });
        inputSourcesMap.delete(inputSource);
      }
    }

    // Notify connected

    for (let i = 0; i < event.added.length; i++) {
      const inputSource = event.added[i];
      const controller = inputSourcesMap.get(inputSource);
      if (controller) {
        controller.dispatchEvent({
          type: 'connected',
          data: inputSource
        });
      }
    }
  }

  //

  const cameraLPos = new Vector3();
  const cameraRPos = new Vector3();

  /**
   * Assumes 2 cameras that are parallel and share an X-axis, and that
   * the cameras' projection and world matrices have already been set.
   * And that near and far planes are identical for both cameras.
   * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
   */
  function setProjectionFromUnion(camera, cameraL, cameraR) {
    cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
    cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);
    const ipd = cameraLPos.distanceTo(cameraRPos);
    const projL = cameraL.projectionMatrix.elements;
    const projR = cameraR.projectionMatrix.elements;

    // VR systems will have identical far and near planes, and
    // most likely identical top and bottom frustum extents.
    // Use the left camera for these values.
    const near = projL[14] / (projL[10] - 1);
    const far = projL[14] / (projL[10] + 1);
    const topFov = (projL[9] + 1) / projL[5];
    const bottomFov = (projL[9] - 1) / projL[5];
    const leftFov = (projL[8] - 1) / projL[0];
    const rightFov = (projR[8] + 1) / projR[0];
    const left = near * leftFov;
    const right = near * rightFov;

    // Calculate the new camera's position offset from the
    // left camera. xOffset should be roughly half `ipd`.
    const zOffset = ipd / (-leftFov + rightFov);
    const xOffset = zOffset * -leftFov;

    // TODO: Better way to apply this offset?
    cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
    camera.translateX(xOffset);
    camera.translateZ(zOffset);
    camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
    camera.matrixWorldInverse.copy(camera.matrixWorld).invert();

    // Find the union of the frustum values of the cameras and scale
    // the values so that the near plane's position does not change in world space,
    // although must now be relative to the new union camera.
    const near2 = near + zOffset;
    const far2 = far + zOffset;
    const left2 = left - xOffset;
    const right2 = right + (ipd - xOffset);
    const top2 = topFov * far / far2 * near2;
    const bottom2 = bottomFov * far / far2 * near2;
    camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
  }
  function updateCamera(camera, parent) {
    if (parent === null) {
      camera.matrixWorld.copy(camera.matrix);
    } else {
      camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
    }
    camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
  }
  this.getCamera = function (camera) {
    cameraVR.near = cameraR.near = cameraL.near = camera.near;
    cameraVR.far = cameraR.far = cameraL.far = camera.far;
    if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
      // Note that the new renderState won't apply until the next frame. See #18320

      session.updateRenderState({
        depthNear: cameraVR.near,
        depthFar: cameraVR.far
      });
      _currentDepthNear = cameraVR.near;
      _currentDepthFar = cameraVR.far;
    }
    const parent = camera.parent;
    const cameras = cameraVR.cameras;
    updateCamera(cameraVR, parent);
    for (let i = 0; i < cameras.length; i++) {
      updateCamera(cameras[i], parent);
    }

    // update camera and its children

    camera.matrixWorld.copy(cameraVR.matrixWorld);
    camera.matrix.copy(cameraVR.matrix);
    camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
    const children = camera.children;
    for (let i = 0, l = children.length; i < l; i++) {
      children[i].updateMatrixWorld(true);
    }

    // update projection matrix for proper view frustum culling

    if (cameras.length === 2) {
      setProjectionFromUnion(cameraVR, cameraL, cameraR);
    } else {
      // assume single camera setup (AR)

      cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
    }
    return cameraVR;
  };

  // Animation Loop

  let onAnimationFrameCallback = null;
  function onAnimationFrame(time, frame) {
    pose = frame.getViewerPose(referenceSpace);
    if (pose !== null) {
      const views = pose.views;
      const baseLayer = session.renderState.baseLayer;
      renderer.setFramebuffer(baseLayer.framebuffer);
      let cameraVRNeedsUpdate = false;

      // check if it's necessary to rebuild cameraVR's camera list

      if (views.length !== cameraVR.cameras.length) {
        cameraVR.cameras.length = 0;
        cameraVRNeedsUpdate = true;
      }
      for (let i = 0; i < views.length; i++) {
        const view = views[i];
        const viewport = baseLayer.getViewport(view);
        const camera = cameras[i];
        camera.matrix.fromArray(view.transform.matrix);
        camera.projectionMatrix.fromArray(view.projectionMatrix);
        camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
        if (i === 0) {
          cameraVR.matrix.copy(camera.matrix);
        }
        if (cameraVRNeedsUpdate === true) {
          cameraVR.cameras.push(camera);
        }
      }
    }

    //

    const inputSources = session.inputSources;
    for (let i = 0; i < controllers.length; i++) {
      const controller = controllers[i];
      const inputSource = inputSources[i];
      controller.update(inputSource, frame, referenceSpace);
    }
    if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);
  }
  const animation = new WebGLAnimation();
  animation.setAnimationLoop(onAnimationFrame);
  this.setAnimationLoop = function (callback) {
    onAnimationFrameCallback = callback;
  };
  this.dispose = function () {};
}
Object.assign(WebXRManager.prototype, EventDispatcher.prototype);
function WebGLMaterials(properties) {
  function refreshFogUniforms(uniforms, fog) {
    uniforms.fogColor.value.copy(fog.color);
    if (fog.isFog) {
      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;
    } else if (fog.isFogExp2) {
      uniforms.fogDensity.value = fog.density;
    }
  }
  function refreshMaterialUniforms(uniforms, material, pixelRatio, height) {
    if (material.isMeshBasicMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshLambertMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsLambert(uniforms, material);
    } else if (material.isMeshToonMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsToon(uniforms, material);
    } else if (material.isMeshPhongMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsPhong(uniforms, material);
    } else if (material.isMeshStandardMaterial) {
      refreshUniformsCommon(uniforms, material);
      if (material.isMeshPhysicalMaterial) {
        refreshUniformsPhysical(uniforms, material);
      } else {
        refreshUniformsStandard(uniforms, material);
      }
    } else if (material.isMeshMatcapMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsMatcap(uniforms, material);
    } else if (material.isMeshDepthMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDepth(uniforms, material);
    } else if (material.isMeshDistanceMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDistance(uniforms, material);
    } else if (material.isMeshNormalMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsNormal(uniforms, material);
    } else if (material.isLineBasicMaterial) {
      refreshUniformsLine(uniforms, material);
      if (material.isLineDashedMaterial) {
        refreshUniformsDash(uniforms, material);
      }
    } else if (material.isPointsMaterial) {
      refreshUniformsPoints(uniforms, material, pixelRatio, height);
    } else if (material.isSpriteMaterial) {
      refreshUniformsSprites(uniforms, material);
    } else if (material.isShadowMaterial) {
      uniforms.color.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
    } else if (material.isShaderMaterial) {
      material.uniformsNeedUpdate = false; // #15581
    }
  }

  function refreshUniformsCommon(uniforms, material) {
    uniforms.opacity.value = material.opacity;
    if (material.color) {
      uniforms.diffuse.value.copy(material.color);
    }
    if (material.emissive) {
      uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
    }
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    if (material.specularMap) {
      uniforms.specularMap.value = material.specularMap;
    }
    const envMap = properties.get(material).envMap;
    if (envMap) {
      uniforms.envMap.value = envMap;
      uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap._needsFlipEnvMap ? -1 : 1;
      uniforms.reflectivity.value = material.reflectivity;
      uniforms.refractionRatio.value = material.refractionRatio;
      const maxMipLevel = properties.get(envMap).__maxMipLevel;
      if (maxMipLevel !== undefined) {
        uniforms.maxMipLevel.value = maxMipLevel;
      }
    }
    if (material.lightMap) {
      uniforms.lightMap.value = material.lightMap;
      uniforms.lightMapIntensity.value = material.lightMapIntensity;
    }
    if (material.aoMap) {
      uniforms.aoMap.value = material.aoMap;
      uniforms.aoMapIntensity.value = material.aoMapIntensity;
    }

    // uv repeat and offset setting priorities
    // 1. color map
    // 2. specular map
    // 3. displacementMap map
    // 4. normal map
    // 5. bump map
    // 6. roughnessMap map
    // 7. metalnessMap map
    // 8. alphaMap map
    // 9. emissiveMap map
    // 10. clearcoat map
    // 11. clearcoat normal map
    // 12. clearcoat roughnessMap map

    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.specularMap) {
      uvScaleMap = material.specularMap;
    } else if (material.displacementMap) {
      uvScaleMap = material.displacementMap;
    } else if (material.normalMap) {
      uvScaleMap = material.normalMap;
    } else if (material.bumpMap) {
      uvScaleMap = material.bumpMap;
    } else if (material.roughnessMap) {
      uvScaleMap = material.roughnessMap;
    } else if (material.metalnessMap) {
      uvScaleMap = material.metalnessMap;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    } else if (material.emissiveMap) {
      uvScaleMap = material.emissiveMap;
    } else if (material.clearcoatMap) {
      uvScaleMap = material.clearcoatMap;
    } else if (material.clearcoatNormalMap) {
      uvScaleMap = material.clearcoatNormalMap;
    } else if (material.clearcoatRoughnessMap) {
      uvScaleMap = material.clearcoatRoughnessMap;
    }
    if (uvScaleMap !== undefined) {
      // backwards compatibility
      if (uvScaleMap.isWebGLRenderTarget) {
        uvScaleMap = uvScaleMap.texture;
      }
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }

    // uv repeat and offset setting priorities for uv2
    // 1. ao map
    // 2. light map

    let uv2ScaleMap;
    if (material.aoMap) {
      uv2ScaleMap = material.aoMap;
    } else if (material.lightMap) {
      uv2ScaleMap = material.lightMap;
    }
    if (uv2ScaleMap !== undefined) {
      // backwards compatibility
      if (uv2ScaleMap.isWebGLRenderTarget) {
        uv2ScaleMap = uv2ScaleMap.texture;
      }
      if (uv2ScaleMap.matrixAutoUpdate === true) {
        uv2ScaleMap.updateMatrix();
      }
      uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
    }
  }
  function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
  }
  function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;
  }
  function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size * pixelRatio;
    uniforms.scale.value = height * 0.5;
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }

    // uv repeat and offset setting priorities
    // 1. color map
    // 2. alpha map

    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    }
    if (uvScaleMap !== undefined) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }
  function refreshUniformsSprites(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.rotation.value = material.rotation;
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }

    // uv repeat and offset setting priorities
    // 1. color map
    // 2. alpha map

    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    }
    if (uvScaleMap !== undefined) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }
  function refreshUniformsLambert(uniforms, material) {
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
  }
  function refreshUniformsPhong(uniforms, material) {
    uniforms.specular.value.copy(material.specular);
    uniforms.shininess.value = Math.max(material.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )

    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsToon(uniforms, material) {
    if (material.gradientMap) {
      uniforms.gradientMap.value = material.gradientMap;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsStandard(uniforms, material) {
    uniforms.roughness.value = material.roughness;
    uniforms.metalness.value = material.metalness;
    if (material.roughnessMap) {
      uniforms.roughnessMap.value = material.roughnessMap;
    }
    if (material.metalnessMap) {
      uniforms.metalnessMap.value = material.metalnessMap;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    const envMap = properties.get(material).envMap;
    if (envMap) {
      //uniforms.envMap.value = material.envMap; // part of uniforms common
      uniforms.envMapIntensity.value = material.envMapIntensity;
    }
  }
  function refreshUniformsPhysical(uniforms, material) {
    refreshUniformsStandard(uniforms, material);
    uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common

    uniforms.clearcoat.value = material.clearcoat;
    uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
    if (material.sheen) uniforms.sheen.value.copy(material.sheen);
    if (material.clearcoatMap) {
      uniforms.clearcoatMap.value = material.clearcoatMap;
    }
    if (material.clearcoatRoughnessMap) {
      uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
    }
    if (material.clearcoatNormalMap) {
      uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
      uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
      if (material.side === BackSide) {
        uniforms.clearcoatNormalScale.value.negate();
      }
    }
    uniforms.transmission.value = material.transmission;
    if (material.transmissionMap) {
      uniforms.transmissionMap.value = material.transmissionMap;
    }
  }
  function refreshUniformsMatcap(uniforms, material) {
    if (material.matcap) {
      uniforms.matcap.value = material.matcap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsDepth(uniforms, material) {
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsDistance(uniforms, material) {
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    uniforms.referencePosition.value.copy(material.referencePosition);
    uniforms.nearDistance.value = material.nearDistance;
    uniforms.farDistance.value = material.farDistance;
  }
  function refreshUniformsNormal(uniforms, material) {
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  return {
    refreshFogUniforms: refreshFogUniforms,
    refreshMaterialUniforms: refreshMaterialUniforms
  };
}
function createCanvasElement() {
  const canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
  canvas.style.display = 'block';
  return canvas;
}
function WebGLRenderer(parameters) {
  parameters = parameters || {};
  const _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement(),
    _context = parameters.context !== undefined ? parameters.context : null,
    _alpha = parameters.alpha !== undefined ? parameters.alpha : false,
    _depth = parameters.depth !== undefined ? parameters.depth : true,
    _stencil = parameters.stencil !== undefined ? parameters.stencil : true,
    _antialias = parameters.antialias !== undefined ? parameters.antialias : false,
    _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
    _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
    _powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
    _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;
  let currentRenderList = null;
  let currentRenderState = null;

  // render() can be called from within a callback triggered by another render.
  // We track this so that the nested render call gets its state isolated from the parent render call.

  const renderStateStack = [];

  // public properties

  this.domElement = _canvas;

  // Debug configuration container
  this.debug = {
    /**
     * Enables error checking and reporting when shader programs are being compiled
     * @type {boolean}
     */
    checkShaderErrors: true
  };

  // clearing

  this.autoClear = true;
  this.autoClearColor = true;
  this.autoClearDepth = true;
  this.autoClearStencil = true;

  // scene graph

  this.sortObjects = true;

  // user-defined clipping

  this.clippingPlanes = [];
  this.localClippingEnabled = false;

  // physically based shading

  this.gammaFactor = 2.0; // for backwards compatibility
  this.outputEncoding = LinearEncoding;

  // physical lights

  this.physicallyCorrectLights = false;

  // tone mapping

  this.toneMapping = NoToneMapping;
  this.toneMappingExposure = 1.0;

  // morphs

  this.maxMorphTargets = 8;
  this.maxMorphNormals = 4;

  // internal properties

  const _this = this;
  let _isContextLost = false;

  // internal state cache

  let _framebuffer = null;
  let _currentActiveCubeFace = 0;
  let _currentActiveMipmapLevel = 0;
  let _currentRenderTarget = null;
  let _currentFramebuffer = null;
  let _currentMaterialId = -1;
  let _currentCamera = null;
  const _currentViewport = new Vector4();
  const _currentScissor = new Vector4();
  let _currentScissorTest = null;

  //

  let _width = _canvas.width;
  let _height = _canvas.height;
  let _pixelRatio = 1;
  let _opaqueSort = null;
  let _transparentSort = null;
  const _viewport = new Vector4(0, 0, _width, _height);
  const _scissor = new Vector4(0, 0, _width, _height);
  let _scissorTest = false;

  // frustum

  const _frustum = new Frustum();

  // clipping

  let _clippingEnabled = false;
  let _localClippingEnabled = false;

  // camera matrices cache

  const _projScreenMatrix = new Matrix4();
  const _vector3 = new Vector3();
  const _emptyScene = {
    background: null,
    fog: null,
    environment: null,
    overrideMaterial: null,
    isScene: true
  };
  function getTargetPixelRatio() {
    return _currentRenderTarget === null ? _pixelRatio : 1;
  }

  // initialize

  let _gl = _context;
  function getContext(contextNames, contextAttributes) {
    for (let i = 0; i < contextNames.length; i++) {
      const contextName = contextNames[i];
      const context = _canvas.getContext(contextName, contextAttributes);
      if (context !== null) return context;
    }
    return null;
  }
  try {
    const contextAttributes = {
      alpha: _alpha,
      depth: _depth,
      stencil: _stencil,
      antialias: _antialias,
      premultipliedAlpha: _premultipliedAlpha,
      preserveDrawingBuffer: _preserveDrawingBuffer,
      powerPreference: _powerPreference,
      failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
    };

    // event listeners must be registered before WebGL context is created, see #12753

    _canvas.addEventListener('webglcontextlost', onContextLost, false);
    _canvas.addEventListener('webglcontextrestored', onContextRestore, false);
    if (_gl === null) {
      const contextNames = ['webgl2', 'webgl', 'experimental-webgl'];
      if (_this.isWebGL1Renderer === true) {
        contextNames.shift();
      }
      _gl = getContext(contextNames, contextAttributes);
      if (_gl === null) {
        if (getContext(contextNames)) {
          throw new Error('Error creating WebGL context with your selected attributes.');
        } else {
          throw new Error('Error creating WebGL context.');
        }
      }
    }

    // Some experimental-webgl implementations do not have getShaderPrecisionFormat

    if (_gl.getShaderPrecisionFormat === undefined) {
      _gl.getShaderPrecisionFormat = function () {
        return {
          'rangeMin': 1,
          'rangeMax': 1,
          'precision': 1
        };
      };
    }
  } catch (error) {
    console.error('THREE.WebGLRenderer: ' + error.message);
    throw error;
  }
  let extensions, capabilities, state, info;
  let properties, textures, cubemaps, attributes, geometries, objects;
  let programCache, materials, renderLists, renderStates, clipping;
  let background, morphtargets, bufferRenderer, indexedBufferRenderer;
  let utils, bindingStates;
  function initGLContext() {
    extensions = new WebGLExtensions(_gl);
    capabilities = new WebGLCapabilities(_gl, extensions, parameters);
    extensions.init(capabilities);
    utils = new WebGLUtils(_gl, extensions, capabilities);
    state = new WebGLState(_gl, extensions, capabilities);
    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
    info = new WebGLInfo(_gl);
    properties = new WebGLProperties();
    textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
    cubemaps = new WebGLCubeMaps(_this);
    attributes = new WebGLAttributes(_gl, capabilities);
    bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
    geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
    objects = new WebGLObjects(_gl, geometries, attributes, info);
    morphtargets = new WebGLMorphtargets(_gl);
    clipping = new WebGLClipping(properties);
    programCache = new WebGLPrograms(_this, cubemaps, extensions, capabilities, bindingStates, clipping);
    materials = new WebGLMaterials(properties);
    renderLists = new WebGLRenderLists(properties);
    renderStates = new WebGLRenderStates(extensions, capabilities);
    background = new WebGLBackground(_this, cubemaps, state, objects, _premultipliedAlpha);
    bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
    indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
    info.programs = programCache.programs;
    _this.capabilities = capabilities;
    _this.extensions = extensions;
    _this.properties = properties;
    _this.renderLists = renderLists;
    _this.state = state;
    _this.info = info;
  }
  initGLContext();

  // xr

  const xr = new WebXRManager(_this, _gl);
  this.xr = xr;

  // shadow map

  const shadowMap = new WebGLShadowMap(_this, objects, capabilities.maxTextureSize);
  this.shadowMap = shadowMap;

  // API

  this.getContext = function () {
    return _gl;
  };
  this.getContextAttributes = function () {
    return _gl.getContextAttributes();
  };
  this.forceContextLoss = function () {
    const extension = extensions.get('WEBGL_lose_context');
    if (extension) extension.loseContext();
  };
  this.forceContextRestore = function () {
    const extension = extensions.get('WEBGL_lose_context');
    if (extension) extension.restoreContext();
  };
  this.getPixelRatio = function () {
    return _pixelRatio;
  };
  this.setPixelRatio = function (value) {
    if (value === undefined) return;
    _pixelRatio = value;
    this.setSize(_width, _height, false);
  };
  this.getSize = function (target) {
    if (target === undefined) {
      console.warn('WebGLRenderer: .getsize() now requires a Vector2 as an argument');
      target = new Vector2();
    }
    return target.set(_width, _height);
  };
  this.setSize = function (width, height, updateStyle) {
    if (xr.isPresenting) {
      console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');
      return;
    }
    _width = width;
    _height = height;
    _canvas.width = Math.floor(width * _pixelRatio);
    _canvas.height = Math.floor(height * _pixelRatio);
    if (updateStyle !== false) {
      _canvas.style.width = width + 'px';
      _canvas.style.height = height + 'px';
    }
    this.setViewport(0, 0, width, height);
  };
  this.getDrawingBufferSize = function (target) {
    if (target === undefined) {
      console.warn('WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument');
      target = new Vector2();
    }
    return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
  };
  this.setDrawingBufferSize = function (width, height, pixelRatio) {
    _width = width;
    _height = height;
    _pixelRatio = pixelRatio;
    _canvas.width = Math.floor(width * pixelRatio);
    _canvas.height = Math.floor(height * pixelRatio);
    this.setViewport(0, 0, width, height);
  };
  this.getCurrentViewport = function (target) {
    if (target === undefined) {
      console.warn('WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument');
      target = new Vector4();
    }
    return target.copy(_currentViewport);
  };
  this.getViewport = function (target) {
    return target.copy(_viewport);
  };
  this.setViewport = function (x, y, width, height) {
    if (x.isVector4) {
      _viewport.set(x.x, x.y, x.z, x.w);
    } else {
      _viewport.set(x, y, width, height);
    }
    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
  };
  this.getScissor = function (target) {
    return target.copy(_scissor);
  };
  this.setScissor = function (x, y, width, height) {
    if (x.isVector4) {
      _scissor.set(x.x, x.y, x.z, x.w);
    } else {
      _scissor.set(x, y, width, height);
    }
    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
  };
  this.getScissorTest = function () {
    return _scissorTest;
  };
  this.setScissorTest = function (boolean) {
    state.setScissorTest(_scissorTest = boolean);
  };
  this.setOpaqueSort = function (method) {
    _opaqueSort = method;
  };
  this.setTransparentSort = function (method) {
    _transparentSort = method;
  };

  // Clearing

  this.getClearColor = function (target) {
    if (target === undefined) {
      console.warn('WebGLRenderer: .getClearColor() now requires a Color as an argument');
      target = new Color();
    }
    return target.copy(background.getClearColor());
  };
  this.setClearColor = function () {
    background.setClearColor.apply(background, arguments);
  };
  this.getClearAlpha = function () {
    return background.getClearAlpha();
  };
  this.setClearAlpha = function () {
    background.setClearAlpha.apply(background, arguments);
  };
  this.clear = function (color, depth, stencil) {
    let bits = 0;
    if (color === undefined || color) bits |= 16384;
    if (depth === undefined || depth) bits |= 256;
    if (stencil === undefined || stencil) bits |= 1024;
    _gl.clear(bits);
  };
  this.clearColor = function () {
    this.clear(true, false, false);
  };
  this.clearDepth = function () {
    this.clear(false, true, false);
  };
  this.clearStencil = function () {
    this.clear(false, false, true);
  };

  //

  this.dispose = function () {
    _canvas.removeEventListener('webglcontextlost', onContextLost, false);
    _canvas.removeEventListener('webglcontextrestored', onContextRestore, false);
    renderLists.dispose();
    renderStates.dispose();
    properties.dispose();
    cubemaps.dispose();
    objects.dispose();
    bindingStates.dispose();
    xr.dispose();
    animation.stop();
  };

  // Events

  function onContextLost(event) {
    event.preventDefault();
    console.log('THREE.WebGLRenderer: Context Lost.');
    _isContextLost = true;
  }
  function onContextRestore( /* event */
  ) {
    console.log('THREE.WebGLRenderer: Context Restored.');
    _isContextLost = false;
    initGLContext();
  }
  function onMaterialDispose(event) {
    const material = event.target;
    material.removeEventListener('dispose', onMaterialDispose);
    deallocateMaterial(material);
  }

  // Buffer deallocation

  function deallocateMaterial(material) {
    releaseMaterialProgramReference(material);
    properties.remove(material);
  }
  function releaseMaterialProgramReference(material) {
    const programInfo = properties.get(material).program;
    if (programInfo !== undefined) {
      programCache.releaseProgram(programInfo);
    }
  }

  // Buffer rendering

  function renderObjectImmediate(object, program) {
    object.render(function (object) {
      _this.renderBufferImmediate(object, program);
    });
  }
  this.renderBufferImmediate = function (object, program) {
    bindingStates.initAttributes();
    const buffers = properties.get(object);
    if (object.hasPositions && !buffers.position) buffers.position = _gl.createBuffer();
    if (object.hasNormals && !buffers.normal) buffers.normal = _gl.createBuffer();
    if (object.hasUvs && !buffers.uv) buffers.uv = _gl.createBuffer();
    if (object.hasColors && !buffers.color) buffers.color = _gl.createBuffer();
    const programAttributes = program.getAttributes();
    if (object.hasPositions) {
      _gl.bindBuffer(34962, buffers.position);
      _gl.bufferData(34962, object.positionArray, 35048);
      bindingStates.enableAttribute(programAttributes.position);
      _gl.vertexAttribPointer(programAttributes.position, 3, 5126, false, 0, 0);
    }
    if (object.hasNormals) {
      _gl.bindBuffer(34962, buffers.normal);
      _gl.bufferData(34962, object.normalArray, 35048);
      bindingStates.enableAttribute(programAttributes.normal);
      _gl.vertexAttribPointer(programAttributes.normal, 3, 5126, false, 0, 0);
    }
    if (object.hasUvs) {
      _gl.bindBuffer(34962, buffers.uv);
      _gl.bufferData(34962, object.uvArray, 35048);
      bindingStates.enableAttribute(programAttributes.uv);
      _gl.vertexAttribPointer(programAttributes.uv, 2, 5126, false, 0, 0);
    }
    if (object.hasColors) {
      _gl.bindBuffer(34962, buffers.color);
      _gl.bufferData(34962, object.colorArray, 35048);
      bindingStates.enableAttribute(programAttributes.color);
      _gl.vertexAttribPointer(programAttributes.color, 3, 5126, false, 0, 0);
    }
    bindingStates.disableUnusedAttributes();
    _gl.drawArrays(4, 0, object.count);
    object.count = 0;
  };
  this.renderBufferDirect = function (camera, scene, geometry, material, object, group) {
    if (scene === null) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)

    const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
    const program = setProgram(camera, scene, material, object);
    state.setMaterial(material, frontFaceCW);

    //

    let index = geometry.index;
    const position = geometry.attributes.position;

    //

    if (index === null) {
      if (position === undefined || position.count === 0) return;
    } else if (index.count === 0) {
      return;
    }

    //

    let rangeFactor = 1;
    if (material.wireframe === true) {
      index = geometries.getWireframeAttribute(geometry);
      rangeFactor = 2;
    }
    if (material.morphTargets || material.morphNormals) {
      morphtargets.update(object, geometry, material, program);
    }
    bindingStates.setup(object, material, program, geometry, index);
    let attribute;
    let renderer = bufferRenderer;
    if (index !== null) {
      attribute = attributes.get(index);
      renderer = indexedBufferRenderer;
      renderer.setIndex(attribute);
    }

    //

    const dataCount = index !== null ? index.count : position.count;
    const rangeStart = geometry.drawRange.start * rangeFactor;
    const rangeCount = geometry.drawRange.count * rangeFactor;
    const groupStart = group !== null ? group.start * rangeFactor : 0;
    const groupCount = group !== null ? group.count * rangeFactor : Infinity;
    const drawStart = Math.max(rangeStart, groupStart);
    const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
    const drawCount = Math.max(0, drawEnd - drawStart + 1);
    if (drawCount === 0) return;

    //

    if (object.isMesh) {
      if (material.wireframe === true) {
        state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
        renderer.setMode(1);
      } else {
        renderer.setMode(4);
      }
    } else if (object.isLine) {
      let lineWidth = material.linewidth;
      if (lineWidth === undefined) lineWidth = 1; // Not using Line*Material

      state.setLineWidth(lineWidth * getTargetPixelRatio());
      if (object.isLineSegments) {
        renderer.setMode(1);
      } else if (object.isLineLoop) {
        renderer.setMode(2);
      } else {
        renderer.setMode(3);
      }
    } else if (object.isPoints) {
      renderer.setMode(0);
    } else if (object.isSprite) {
      renderer.setMode(4);
    }
    if (object.isInstancedMesh) {
      renderer.renderInstances(drawStart, drawCount, object.count);
    } else if (geometry.isInstancedBufferGeometry) {
      const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
      renderer.renderInstances(drawStart, drawCount, instanceCount);
    } else {
      renderer.render(drawStart, drawCount);
    }
  };

  // Compile

  this.compile = function (scene, camera) {
    currentRenderState = renderStates.get(scene);
    currentRenderState.init();
    scene.traverseVisible(function (object) {
      if (object.isLight && object.layers.test(camera.layers)) {
        currentRenderState.pushLight(object);
        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      }
    });
    currentRenderState.setupLights();
    const compiled = new WeakMap();
    scene.traverse(function (object) {
      const material = object.material;
      if (material) {
        if (Array.isArray(material)) {
          for (let i = 0; i < material.length; i++) {
            const material2 = material[i];
            if (compiled.has(material2) === false) {
              initMaterial(material2, scene, object);
              compiled.set(material2);
            }
          }
        } else if (compiled.has(material) === false) {
          initMaterial(material, scene, object);
          compiled.set(material);
        }
      }
    });
  };

  // Animation Loop

  let onAnimationFrameCallback = null;
  function onAnimationFrame(time) {
    if (xr.isPresenting) return;
    if (onAnimationFrameCallback) onAnimationFrameCallback(time);
  }
  const animation = new WebGLAnimation();
  animation.setAnimationLoop(onAnimationFrame);
  if (typeof window !== 'undefined') animation.setContext(window);
  this.setAnimationLoop = function (callback) {
    onAnimationFrameCallback = callback;
    xr.setAnimationLoop(callback);
    callback === null ? animation.stop() : animation.start();
  };

  // Rendering

  this.render = function (scene, camera) {
    let renderTarget, forceClear;
    if (arguments[2] !== undefined) {
      console.warn('THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.');
      renderTarget = arguments[2];
    }
    if (arguments[3] !== undefined) {
      console.warn('THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.');
      forceClear = arguments[3];
    }
    if (camera !== undefined && camera.isCamera !== true) {
      console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
      return;
    }
    if (_isContextLost === true) return;

    // reset caching for this frame

    bindingStates.resetDefaultState();
    _currentMaterialId = -1;
    _currentCamera = null;

    // update scene graph

    if (scene.autoUpdate === true) scene.updateMatrixWorld();

    // update camera matrices and frustum

    if (camera.parent === null) camera.updateMatrixWorld();
    if (xr.enabled === true && xr.isPresenting === true) {
      camera = xr.getCamera(camera);
    }

    //
    if (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, renderTarget || _currentRenderTarget);
    currentRenderState = renderStates.get(scene, renderStateStack.length);
    currentRenderState.init();
    renderStateStack.push(currentRenderState);
    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    _frustum.setFromProjectionMatrix(_projScreenMatrix);
    _localClippingEnabled = this.localClippingEnabled;
    _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
    currentRenderList = renderLists.get(scene, camera);
    currentRenderList.init();
    projectObject(scene, camera, 0, _this.sortObjects);
    currentRenderList.finish();
    if (_this.sortObjects === true) {
      currentRenderList.sort(_opaqueSort, _transparentSort);
    }

    //

    if (_clippingEnabled === true) clipping.beginShadows();
    const shadowsArray = currentRenderState.state.shadowsArray;
    shadowMap.render(shadowsArray, scene, camera);
    currentRenderState.setupLights();
    currentRenderState.setupLightsView(camera);
    if (_clippingEnabled === true) clipping.endShadows();

    //

    if (this.info.autoReset === true) this.info.reset();
    if (renderTarget !== undefined) {
      this.setRenderTarget(renderTarget);
    }

    //

    background.render(currentRenderList, scene, camera, forceClear);

    // render scene

    const opaqueObjects = currentRenderList.opaque;
    const transparentObjects = currentRenderList.transparent;
    if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);
    if (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera);

    //

    if (scene.isScene === true) scene.onAfterRender(_this, scene, camera);

    //

    if (_currentRenderTarget !== null) {
      // Generate mipmap if we're using any kind of mipmap filtering

      textures.updateRenderTargetMipmap(_currentRenderTarget);

      // resolve multisample renderbuffers to a single-sample texture if necessary

      textures.updateMultisampleRenderTarget(_currentRenderTarget);
    }

    // Ensure depth buffer writing is enabled so it can be cleared on next render

    state.buffers.depth.setTest(true);
    state.buffers.depth.setMask(true);
    state.buffers.color.setMask(true);
    state.setPolygonOffset(false);

    // _gl.finish();

    renderStateStack.pop();
    if (renderStateStack.length > 0) {
      currentRenderState = renderStateStack[renderStateStack.length - 1];
    } else {
      currentRenderState = null;
    }
    currentRenderList = null;
  };
  function projectObject(object, camera, groupOrder, sortObjects) {
    if (object.visible === false) return;
    const visible = object.layers.test(camera.layers);
    if (visible) {
      if (object.isGroup) {
        groupOrder = object.renderOrder;
      } else if (object.isLOD) {
        if (object.autoUpdate === true) object.update(camera);
      } else if (object.isLight) {
        currentRenderState.pushLight(object);
        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      } else if (object.isSprite) {
        if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
          }
          const geometry = objects.update(object);
          const material = object.material;
          if (material.visible) {
            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      } else if (object.isImmediateRenderObject) {
        if (sortObjects) {
          _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
        }
        currentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null);
      } else if (object.isMesh || object.isLine || object.isPoints) {
        if (object.isSkinnedMesh) {
          // update skeleton only once in a frame

          if (object.skeleton.frame !== info.render.frame) {
            object.skeleton.update();
            object.skeleton.frame = info.render.frame;
          }
        }
        if (!object.frustumCulled || _frustum.intersectsObject(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
          }
          const geometry = objects.update(object);
          const material = object.material;
          if (Array.isArray(material)) {
            const groups = geometry.groups;
            for (let i = 0, l = groups.length; i < l; i++) {
              const group = groups[i];
              const groupMaterial = material[group.materialIndex];
              if (groupMaterial && groupMaterial.visible) {
                currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
              }
            }
          } else if (material.visible) {
            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      }
    }
    const children = object.children;
    for (let i = 0, l = children.length; i < l; i++) {
      projectObject(children[i], camera, groupOrder, sortObjects);
    }
  }
  function renderObjects(renderList, scene, camera) {
    const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
    for (let i = 0, l = renderList.length; i < l; i++) {
      const renderItem = renderList[i];
      const object = renderItem.object;
      const geometry = renderItem.geometry;
      const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
      const group = renderItem.group;
      if (camera.isArrayCamera) {
        const cameras = camera.cameras;
        for (let j = 0, jl = cameras.length; j < jl; j++) {
          const camera2 = cameras[j];
          if (object.layers.test(camera2.layers)) {
            state.viewport(_currentViewport.copy(camera2.viewport));
            currentRenderState.setupLightsView(camera2);
            renderObject(object, scene, camera2, geometry, material, group);
          }
        }
      } else {
        renderObject(object, scene, camera, geometry, material, group);
      }
    }
  }
  function renderObject(object, scene, camera, geometry, material, group) {
    object.onBeforeRender(_this, scene, camera, geometry, material, group);
    object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
    object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
    if (object.isImmediateRenderObject) {
      const program = setProgram(camera, scene, material, object);
      state.setMaterial(material);
      bindingStates.reset();
      renderObjectImmediate(object, program);
    } else {
      _this.renderBufferDirect(camera, scene, geometry, material, object, group);
    }
    object.onAfterRender(_this, scene, camera, geometry, material, group);
  }
  function initMaterial(material, scene, object) {
    if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

    const materialProperties = properties.get(material);
    const lights = currentRenderState.state.lights;
    const shadowsArray = currentRenderState.state.shadowsArray;
    const lightsStateVersion = lights.state.version;
    const parameters = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
    const programCacheKey = programCache.getProgramCacheKey(parameters);
    let program = materialProperties.program;
    let programChange = true;

    // always update environment and fog - changing these trigger an initMaterial call, but it's possible that the program doesn't change

    materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
    materialProperties.fog = scene.fog;
    materialProperties.envMap = cubemaps.get(material.envMap || materialProperties.environment);
    if (program === undefined) {
      // new material
      material.addEventListener('dispose', onMaterialDispose);
    } else if (program.cacheKey !== programCacheKey) {
      // changed glsl or parameters
      releaseMaterialProgramReference(material);
    } else if (materialProperties.lightsStateVersion !== lightsStateVersion) {
      programChange = false;
    } else if (parameters.shaderID !== undefined) {
      // same glsl and uniform list
      return;
    } else {
      // only rebuild uniform list
      programChange = false;
    }
    if (programChange) {
      parameters.uniforms = programCache.getUniforms(material);
      material.onBeforeCompile(parameters, _this);
      program = programCache.acquireProgram(parameters, programCacheKey);
      materialProperties.program = program;
      materialProperties.uniforms = parameters.uniforms;
      materialProperties.outputEncoding = parameters.outputEncoding;
    }
    const uniforms = materialProperties.uniforms;
    if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
      materialProperties.numClippingPlanes = clipping.numPlanes;
      materialProperties.numIntersection = clipping.numIntersection;
      uniforms.clippingPlanes = clipping.uniform;
    }

    // store the light setup it was created for

    materialProperties.needsLights = materialNeedsLights(material);
    materialProperties.lightsStateVersion = lightsStateVersion;
    if (materialProperties.needsLights) {
      // wire up the material to this renderer's lighting state

      uniforms.ambientLightColor.value = lights.state.ambient;
      uniforms.lightProbe.value = lights.state.probe;
      uniforms.directionalLights.value = lights.state.directional;
      uniforms.directionalLightShadows.value = lights.state.directionalShadow;
      uniforms.spotLights.value = lights.state.spot;
      uniforms.spotLightShadows.value = lights.state.spotShadow;
      uniforms.rectAreaLights.value = lights.state.rectArea;
      uniforms.ltc_1.value = lights.state.rectAreaLTC1;
      uniforms.ltc_2.value = lights.state.rectAreaLTC2;
      uniforms.pointLights.value = lights.state.point;
      uniforms.pointLightShadows.value = lights.state.pointShadow;
      uniforms.hemisphereLights.value = lights.state.hemi;
      uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
      uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
      uniforms.spotShadowMap.value = lights.state.spotShadowMap;
      uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
      uniforms.pointShadowMap.value = lights.state.pointShadowMap;
      uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
      // TODO (abelnation): add area lights shadow info to uniforms
    }

    const progUniforms = materialProperties.program.getUniforms();
    const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
    materialProperties.uniformsList = uniformsList;
  }
  function setProgram(camera, scene, material, object) {
    if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

    textures.resetTextureUnits();
    const fog = scene.fog;
    const environment = material.isMeshStandardMaterial ? scene.environment : null;
    const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
    const envMap = cubemaps.get(material.envMap || environment);
    const materialProperties = properties.get(material);
    const lights = currentRenderState.state.lights;
    if (_clippingEnabled === true) {
      if (_localClippingEnabled === true || camera !== _currentCamera) {
        const useCache = camera === _currentCamera && material.id === _currentMaterialId;

        // we might want to call this function with some ClippingGroup
        // object instead of the material, once it becomes feasible
        // (#8465, #8379)
        clipping.setState(material, camera, useCache);
      }
    }
    if (material.version === materialProperties.__version) {
      if (material.fog && materialProperties.fog !== fog) {
        initMaterial(material, scene, object);
      } else if (materialProperties.environment !== environment) {
        initMaterial(material, scene, object);
      } else if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
        initMaterial(material, scene, object);
      } else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
        initMaterial(material, scene, object);
      } else if (materialProperties.outputEncoding !== encoding) {
        initMaterial(material, scene, object);
      } else if (materialProperties.envMap !== envMap) {
        initMaterial(material, scene, object);
      }
    } else {
      initMaterial(material, scene, object);
      materialProperties.__version = material.version;
    }
    let refreshProgram = false;
    let refreshMaterial = false;
    let refreshLights = false;
    const program = materialProperties.program,
      p_uniforms = program.getUniforms(),
      m_uniforms = materialProperties.uniforms;
    if (state.useProgram(program.program)) {
      refreshProgram = true;
      refreshMaterial = true;
      refreshLights = true;
    }
    if (material.id !== _currentMaterialId) {
      _currentMaterialId = material.id;
      refreshMaterial = true;
    }
    if (refreshProgram || _currentCamera !== camera) {
      p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);
      if (capabilities.logarithmicDepthBuffer) {
        p_uniforms.setValue(_gl, 'logDepthBufFC', 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));
      }
      if (_currentCamera !== camera) {
        _currentCamera = camera;

        // lighting uniforms depend on the camera so enforce an update
        // now, in case this material supports lights - or later, when
        // the next material that does gets activated:

        refreshMaterial = true; // set to true on material change
        refreshLights = true; // remains set until update done
      }

      // load material specific uniforms
      // (shader material also gets them for the sake of genericity)

      if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
        const uCamPos = p_uniforms.map.cameraPosition;
        if (uCamPos !== undefined) {
          uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
        }
      }
      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
        p_uniforms.setValue(_gl, 'isOrthographic', camera.isOrthographicCamera === true);
      }
      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || material.skinning) {
        p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);
      }
    }

    // skinning uniforms must be set even if material didn't change
    // auto-setting of texture unit for bone texture must go before other textures
    // otherwise textures used for skinning can take over texture units reserved for other material textures

    if (material.skinning) {
      p_uniforms.setOptional(_gl, object, 'bindMatrix');
      p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');
      const skeleton = object.skeleton;
      if (skeleton) {
        const bones = skeleton.bones;
        if (capabilities.floatVertexTextures) {
          if (skeleton.boneTexture === null) {
            // layout (1 matrix = 4 pixels)
            //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
            //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
            //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
            //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
            //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)

            let size = Math.sqrt(bones.length * 4); // 4 pixels needed for 1 matrix
            size = MathUtils.ceilPowerOfTwo(size);
            size = Math.max(size, 4);
            const boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel
            boneMatrices.set(skeleton.boneMatrices); // copy current values

            const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
            skeleton.boneMatrices = boneMatrices;
            skeleton.boneTexture = boneTexture;
            skeleton.boneTextureSize = size;
          }
          p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture, textures);
          p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);
        } else {
          p_uniforms.setOptional(_gl, skeleton, 'boneMatrices');
        }
      }
    }
    if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
      materialProperties.receiveShadow = object.receiveShadow;
      p_uniforms.setValue(_gl, 'receiveShadow', object.receiveShadow);
    }
    if (refreshMaterial) {
      p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);
      if (materialProperties.needsLights) {
        // the current material requires lighting info

        // note: all lighting uniforms are always set correctly
        // they simply reference the renderer's state for their
        // values
        //
        // use the current material's .needsUpdate flags to set
        // the GL state when required

        markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
      }

      // refresh uniforms common to several materials

      if (fog && material.fog) {
        materials.refreshFogUniforms(m_uniforms, fog);
      }
      materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height);
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
    }
    if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
      material.uniformsNeedUpdate = false;
    }
    if (material.isSpriteMaterial) {
      p_uniforms.setValue(_gl, 'center', object.center);
    }

    // common matrices

    p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);
    p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);
    p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);
    return program;
  }

  // If uniforms are marked as clean, they don't need to be loaded to the GPU.

  function markUniformsLightsNeedsUpdate(uniforms, value) {
    uniforms.ambientLightColor.needsUpdate = value;
    uniforms.lightProbe.needsUpdate = value;
    uniforms.directionalLights.needsUpdate = value;
    uniforms.directionalLightShadows.needsUpdate = value;
    uniforms.pointLights.needsUpdate = value;
    uniforms.pointLightShadows.needsUpdate = value;
    uniforms.spotLights.needsUpdate = value;
    uniforms.spotLightShadows.needsUpdate = value;
    uniforms.rectAreaLights.needsUpdate = value;
    uniforms.hemisphereLights.needsUpdate = value;
  }
  function materialNeedsLights(material) {
    return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
  }

  //
  this.setFramebuffer = function (value) {
    if (_framebuffer !== value && _currentRenderTarget === null) _gl.bindFramebuffer(36160, value);
    _framebuffer = value;
  };
  this.getActiveCubeFace = function () {
    return _currentActiveCubeFace;
  };
  this.getActiveMipmapLevel = function () {
    return _currentActiveMipmapLevel;
  };
  this.getRenderList = function () {
    return currentRenderList;
  };
  this.setRenderList = function (renderList) {
    currentRenderList = renderList;
  };
  this.getRenderTarget = function () {
    return _currentRenderTarget;
  };
  this.setRenderTarget = function (renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
    _currentRenderTarget = renderTarget;
    _currentActiveCubeFace = activeCubeFace;
    _currentActiveMipmapLevel = activeMipmapLevel;
    if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) {
      textures.setupRenderTarget(renderTarget);
    }
    let framebuffer = _framebuffer;
    let isCube = false;
    if (renderTarget) {
      const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
      if (renderTarget.isWebGLCubeRenderTarget) {
        framebuffer = __webglFramebuffer[activeCubeFace];
        isCube = true;
      } else if (renderTarget.isWebGLMultisampleRenderTarget) {
        framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
      } else {
        framebuffer = __webglFramebuffer;
      }
      _currentViewport.copy(renderTarget.viewport);
      _currentScissor.copy(renderTarget.scissor);
      _currentScissorTest = renderTarget.scissorTest;
    } else {
      _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
      _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
      _currentScissorTest = _scissorTest;
    }
    if (_currentFramebuffer !== framebuffer) {
      _gl.bindFramebuffer(36160, framebuffer);
      _currentFramebuffer = framebuffer;
    }
    state.viewport(_currentViewport);
    state.scissor(_currentScissor);
    state.setScissorTest(_currentScissorTest);
    if (isCube) {
      const textureProperties = properties.get(renderTarget.texture);
      _gl.framebufferTexture2D(36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
    }
  };
  this.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
    if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
      console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
      return;
    }
    let framebuffer = properties.get(renderTarget).__webglFramebuffer;
    if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) {
      framebuffer = framebuffer[activeCubeFaceIndex];
    }
    if (framebuffer) {
      let restore = false;
      if (framebuffer !== _currentFramebuffer) {
        _gl.bindFramebuffer(36160, framebuffer);
        restore = true;
      }
      try {
        const texture = renderTarget.texture;
        const textureFormat = texture.format;
        const textureType = texture.type;
        if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {
          console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
          return;
        }
        const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has('EXT_color_buffer_half_float') || capabilities.isWebGL2 && extensions.has('EXT_color_buffer_float'));
        if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) &&
        // IE11, Edge and Chrome Mac < 52 (#9513)
        !(textureType === FloatType && (capabilities.isWebGL2 || extensions.has('OES_texture_float') || extensions.has('WEBGL_color_buffer_float'))) &&
        // Chrome Mac >= 52 and Firefox
        !halfFloatSupportedByExt) {
          console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
          return;
        }
        if (_gl.checkFramebufferStatus(36160) === 36053) {
          // the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

          if (x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height) {
            _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
          }
        } else {
          console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');
        }
      } finally {
        if (restore) {
          _gl.bindFramebuffer(36160, _currentFramebuffer);
        }
      }
    }
  };
  this.copyFramebufferToTexture = function (position, texture, level = 0) {
    const levelScale = Math.pow(2, -level);
    const width = Math.floor(texture.image.width * levelScale);
    const height = Math.floor(texture.image.height * levelScale);
    const glFormat = utils.convert(texture.format);
    textures.setTexture2D(texture, 0);
    _gl.copyTexImage2D(3553, level, glFormat, position.x, position.y, width, height, 0);
    state.unbindTexture();
  };
  this.copyTextureToTexture = function (position, srcTexture, dstTexture, level = 0) {
    const width = srcTexture.image.width;
    const height = srcTexture.image.height;
    const glFormat = utils.convert(dstTexture.format);
    const glType = utils.convert(dstTexture.type);
    textures.setTexture2D(dstTexture, 0);

    // As another texture upload may have changed pixelStorei
    // parameters, make sure they are correct for the dstTexture
    _gl.pixelStorei(37440, dstTexture.flipY);
    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
    _gl.pixelStorei(3317, dstTexture.unpackAlignment);
    if (srcTexture.isDataTexture) {
      _gl.texSubImage2D(3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
    } else {
      if (srcTexture.isCompressedTexture) {
        _gl.compressedTexSubImage2D(3553, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
      } else {
        _gl.texSubImage2D(3553, level, position.x, position.y, glFormat, glType, srcTexture.image);
      }
    }

    // Generate mipmaps only when copying level 0
    if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(3553);
    state.unbindTexture();
  };
  this.initTexture = function (texture) {
    textures.setTexture2D(texture, 0);
    state.unbindTexture();
  };
  this.resetState = function () {
    state.reset();
    bindingStates.reset();
  };
  if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
      detail: this
    })); // eslint-disable-line no-undef
  }
}

function WebGL1Renderer(parameters) {
  WebGLRenderer.call(this, parameters);
}
WebGL1Renderer.prototype = Object.assign(Object.create(WebGLRenderer.prototype), {
  constructor: WebGL1Renderer,
  isWebGL1Renderer: true
});
class FogExp2 {
  constructor(color, density) {
    Object.defineProperty(this, 'isFogExp2', {
      value: true
    });
    this.name = '';
    this.color = new Color(color);
    this.density = density !== undefined ? density : 0.00025;
  }
  clone() {
    return new FogExp2(this.color, this.density);
  }
  toJSON( /* meta */
  ) {
    return {
      type: 'FogExp2',
      color: this.color.getHex(),
      density: this.density
    };
  }
}
exports.FogExp2 = FogExp2;
class Fog {
  constructor(color, near, far) {
    Object.defineProperty(this, 'isFog', {
      value: true
    });
    this.name = '';
    this.color = new Color(color);
    this.near = near !== undefined ? near : 1;
    this.far = far !== undefined ? far : 1000;
  }
  clone() {
    return new Fog(this.color, this.near, this.far);
  }
  toJSON( /* meta */
  ) {
    return {
      type: 'Fog',
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
}
exports.Fog = Fog;
class Scene extends Object3D {
  constructor() {
    super();
    Object.defineProperty(this, 'isScene', {
      value: true
    });
    this.type = 'Scene';
    this.background = null;
    this.environment = null;
    this.fog = null;
    this.overrideMaterial = null;
    this.autoUpdate = true; // checked by the renderer

    if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
        detail: this
      })); // eslint-disable-line no-undef
    }
  }

  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.background !== null) this.background = source.background.clone();
    if (source.environment !== null) this.environment = source.environment.clone();
    if (source.fog !== null) this.fog = source.fog.clone();
    if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
    this.autoUpdate = source.autoUpdate;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.background !== null) data.object.background = this.background.toJSON(meta);
    if (this.environment !== null) data.object.environment = this.environment.toJSON(meta);
    if (this.fog !== null) data.object.fog = this.fog.toJSON();
    return data;
  }
}
exports.Scene = Scene;
function InterleavedBuffer(array, stride) {
  this.array = array;
  this.stride = stride;
  this.count = array !== undefined ? array.length / stride : 0;
  this.usage = StaticDrawUsage;
  this.updateRange = {
    offset: 0,
    count: -1
  };
  this.version = 0;
  this.uuid = MathUtils.generateUUID();
}
Object.defineProperty(InterleavedBuffer.prototype, 'needsUpdate', {
  set: function (value) {
    if (value === true) this.version++;
  }
});
Object.assign(InterleavedBuffer.prototype, {
  isInterleavedBuffer: true,
  onUploadCallback: function () {},
  setUsage: function (value) {
    this.usage = value;
    return this;
  },
  copy: function (source) {
    this.array = new source.array.constructor(source.array);
    this.count = source.count;
    this.stride = source.stride;
    this.usage = source.usage;
    return this;
  },
  copyAt: function (index1, attribute, index2) {
    index1 *= this.stride;
    index2 *= attribute.stride;
    for (let i = 0, l = this.stride; i < l; i++) {
      this.array[index1 + i] = attribute.array[index2 + i];
    }
    return this;
  },
  set: function (value, offset = 0) {
    this.array.set(value, offset);
    return this;
  },
  clone: function (data) {
    if (data.arrayBuffers === undefined) {
      data.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === undefined) {
      this.array.buffer._uuid = MathUtils.generateUUID();
    }
    if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {
      data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
    }
    const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
    const ib = new InterleavedBuffer(array, this.stride);
    ib.setUsage(this.usage);
    return ib;
  },
  onUpload: function (callback) {
    this.onUploadCallback = callback;
    return this;
  },
  toJSON: function (data) {
    if (data.arrayBuffers === undefined) {
      data.arrayBuffers = {};
    }

    // generate UUID for array buffer if necessary

    if (this.array.buffer._uuid === undefined) {
      this.array.buffer._uuid = MathUtils.generateUUID();
    }
    if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {
      data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
    }

    //

    return {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
});
const _vector$6 = new Vector3();
function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {
  this.name = '';
  this.data = interleavedBuffer;
  this.itemSize = itemSize;
  this.offset = offset;
  this.normalized = normalized === true;
}
Object.defineProperties(InterleavedBufferAttribute.prototype, {
  count: {
    get: function () {
      return this.data.count;
    }
  },
  array: {
    get: function () {
      return this.data.array;
    }
  },
  needsUpdate: {
    set: function (value) {
      this.data.needsUpdate = value;
    }
  }
});
Object.assign(InterleavedBufferAttribute.prototype, {
  isInterleavedBufferAttribute: true,
  applyMatrix4: function (m) {
    for (let i = 0, l = this.data.count; i < l; i++) {
      _vector$6.x = this.getX(i);
      _vector$6.y = this.getY(i);
      _vector$6.z = this.getZ(i);
      _vector$6.applyMatrix4(m);
      this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
    }
    return this;
  },
  setX: function (index, x) {
    this.data.array[index * this.data.stride + this.offset] = x;
    return this;
  },
  setY: function (index, y) {
    this.data.array[index * this.data.stride + this.offset + 1] = y;
    return this;
  },
  setZ: function (index, z) {
    this.data.array[index * this.data.stride + this.offset + 2] = z;
    return this;
  },
  setW: function (index, w) {
    this.data.array[index * this.data.stride + this.offset + 3] = w;
    return this;
  },
  getX: function (index) {
    return this.data.array[index * this.data.stride + this.offset];
  },
  getY: function (index) {
    return this.data.array[index * this.data.stride + this.offset + 1];
  },
  getZ: function (index) {
    return this.data.array[index * this.data.stride + this.offset + 2];
  },
  getW: function (index) {
    return this.data.array[index * this.data.stride + this.offset + 3];
  },
  setXY: function (index, x, y) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    return this;
  },
  setXYZ: function (index, x, y, z) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    this.data.array[index + 2] = z;
    return this;
  },
  setXYZW: function (index, x, y, z, w) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    this.data.array[index + 2] = z;
    this.data.array[index + 3] = w;
    return this;
  },
  clone: function (data) {
    if (data === undefined) {
      console.log('THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.');
      const array = [];
      for (let i = 0; i < this.count; i++) {
        const index = i * this.data.stride + this.offset;
        for (let j = 0; j < this.itemSize; j++) {
          array.push(this.data.array[index + j]);
        }
      }
      return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
    } else {
      if (data.interleavedBuffers === undefined) {
        data.interleavedBuffers = {};
      }
      if (data.interleavedBuffers[this.data.uuid] === undefined) {
        data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
      }
      return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
    }
  },
  toJSON: function (data) {
    if (data === undefined) {
      console.log('THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.');
      const array = [];
      for (let i = 0; i < this.count; i++) {
        const index = i * this.data.stride + this.offset;
        for (let j = 0; j < this.itemSize; j++) {
          array.push(this.data.array[index + j]);
        }
      }

      // deinterleave data and save it as an ordinary buffer attribute for now

      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: array,
        normalized: this.normalized
      };
    } else {
      // save as true interlaved attribtue

      if (data.interleavedBuffers === undefined) {
        data.interleavedBuffers = {};
      }
      if (data.interleavedBuffers[this.data.uuid] === undefined) {
        data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
      }
      return {
        isInterleavedBufferAttribute: true,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
    }
  }
});

/**
 * parameters = {
 *  color: <hex>,
 *  map: new THREE.Texture( <Image> ),
 *  alphaMap: new THREE.Texture( <Image> ),
 *  rotation: <float>,
 *  sizeAttenuation: <bool>
 * }
 */

function SpriteMaterial(parameters) {
  Material.call(this);
  this.type = 'SpriteMaterial';
  this.color = new Color(0xffffff);
  this.map = null;
  this.alphaMap = null;
  this.rotation = 0;
  this.sizeAttenuation = true;
  this.transparent = true;
  this.setValues(parameters);
}
SpriteMaterial.prototype = Object.create(Material.prototype);
SpriteMaterial.prototype.constructor = SpriteMaterial;
SpriteMaterial.prototype.isSpriteMaterial = true;
SpriteMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.map = source.map;
  this.alphaMap = source.alphaMap;
  this.rotation = source.rotation;
  this.sizeAttenuation = source.sizeAttenuation;
  return this;
};
let _geometry;
const _intersectPoint = new Vector3();
const _worldScale = new Vector3();
const _mvPosition = new Vector3();
const _alignedPosition = new Vector2();
const _rotatedPosition = new Vector2();
const _viewWorldMatrix = new Matrix4();
const _vA$1 = new Vector3();
const _vB$1 = new Vector3();
const _vC$1 = new Vector3();
const _uvA$1 = new Vector2();
const _uvB$1 = new Vector2();
const _uvC$1 = new Vector2();
function Sprite(material) {
  Object3D.call(this);
  this.type = 'Sprite';
  if (_geometry === undefined) {
    _geometry = new BufferGeometry();
    const float32Array = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]);
    const interleavedBuffer = new InterleavedBuffer(float32Array, 5);
    _geometry.setIndex([0, 1, 2, 0, 2, 3]);
    _geometry.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
    _geometry.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
  }
  this.geometry = _geometry;
  this.material = material !== undefined ? material : new SpriteMaterial();
  this.center = new Vector2(0.5, 0.5);
}
Sprite.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Sprite,
  isSprite: true,
  raycast: function (raycaster, intersects) {
    if (raycaster.camera === null) {
      console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
    }
    _worldScale.setFromMatrixScale(this.matrixWorld);
    _viewWorldMatrix.copy(raycaster.camera.matrixWorld);
    this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
    _mvPosition.setFromMatrixPosition(this.modelViewMatrix);
    if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
      _worldScale.multiplyScalar(-_mvPosition.z);
    }
    const rotation = this.material.rotation;
    let sin, cos;
    if (rotation !== 0) {
      cos = Math.cos(rotation);
      sin = Math.sin(rotation);
    }
    const center = this.center;
    transformVertex(_vA$1.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
    transformVertex(_vB$1.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
    transformVertex(_vC$1.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
    _uvA$1.set(0, 0);
    _uvB$1.set(1, 0);
    _uvC$1.set(1, 1);

    // check first triangle
    let intersect = raycaster.ray.intersectTriangle(_vA$1, _vB$1, _vC$1, false, _intersectPoint);
    if (intersect === null) {
      // check second triangle
      transformVertex(_vB$1.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
      _uvB$1.set(0, 1);
      intersect = raycaster.ray.intersectTriangle(_vA$1, _vC$1, _vB$1, false, _intersectPoint);
      if (intersect === null) {
        return;
      }
    }
    const distance = raycaster.ray.origin.distanceTo(_intersectPoint);
    if (distance < raycaster.near || distance > raycaster.far) return;
    intersects.push({
      distance: distance,
      point: _intersectPoint.clone(),
      uv: Triangle.getUV(_intersectPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2()),
      face: null,
      object: this
    });
  },
  copy: function (source) {
    Object3D.prototype.copy.call(this, source);
    if (source.center !== undefined) this.center.copy(source.center);
    this.material = source.material;
    return this;
  }
});
function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
  // compute position in camera space
  _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);

  // to check if rotation is not zero
  if (sin !== undefined) {
    _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
    _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
  } else {
    _rotatedPosition.copy(_alignedPosition);
  }
  vertexPosition.copy(mvPosition);
  vertexPosition.x += _rotatedPosition.x;
  vertexPosition.y += _rotatedPosition.y;

  // transform to world space
  vertexPosition.applyMatrix4(_viewWorldMatrix);
}
const _v1$4 = new Vector3();
const _v2$2 = new Vector3();
function LOD() {
  Object3D.call(this);
  this._currentLevel = 0;
  this.type = 'LOD';
  Object.defineProperties(this, {
    levels: {
      enumerable: true,
      value: []
    }
  });
  this.autoUpdate = true;
}
LOD.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: LOD,
  isLOD: true,
  copy: function (source) {
    Object3D.prototype.copy.call(this, source, false);
    const levels = source.levels;
    for (let i = 0, l = levels.length; i < l; i++) {
      const level = levels[i];
      this.addLevel(level.object.clone(), level.distance);
    }
    this.autoUpdate = source.autoUpdate;
    return this;
  },
  addLevel: function (object, distance = 0) {
    distance = Math.abs(distance);
    const levels = this.levels;
    let l;
    for (l = 0; l < levels.length; l++) {
      if (distance < levels[l].distance) {
        break;
      }
    }
    levels.splice(l, 0, {
      distance: distance,
      object: object
    });
    this.add(object);
    return this;
  },
  getCurrentLevel: function () {
    return this._currentLevel;
  },
  getObjectForDistance: function (distance) {
    const levels = this.levels;
    if (levels.length > 0) {
      let i, l;
      for (i = 1, l = levels.length; i < l; i++) {
        if (distance < levels[i].distance) {
          break;
        }
      }
      return levels[i - 1].object;
    }
    return null;
  },
  raycast: function (raycaster, intersects) {
    const levels = this.levels;
    if (levels.length > 0) {
      _v1$4.setFromMatrixPosition(this.matrixWorld);
      const distance = raycaster.ray.origin.distanceTo(_v1$4);
      this.getObjectForDistance(distance).raycast(raycaster, intersects);
    }
  },
  update: function (camera) {
    const levels = this.levels;
    if (levels.length > 1) {
      _v1$4.setFromMatrixPosition(camera.matrixWorld);
      _v2$2.setFromMatrixPosition(this.matrixWorld);
      const distance = _v1$4.distanceTo(_v2$2) / camera.zoom;
      levels[0].object.visible = true;
      let i, l;
      for (i = 1, l = levels.length; i < l; i++) {
        if (distance >= levels[i].distance) {
          levels[i - 1].object.visible = false;
          levels[i].object.visible = true;
        } else {
          break;
        }
      }
      this._currentLevel = i - 1;
      for (; i < l; i++) {
        levels[i].object.visible = false;
      }
    }
  },
  toJSON: function (meta) {
    const data = Object3D.prototype.toJSON.call(this, meta);
    if (this.autoUpdate === false) data.object.autoUpdate = false;
    data.object.levels = [];
    const levels = this.levels;
    for (let i = 0, l = levels.length; i < l; i++) {
      const level = levels[i];
      data.object.levels.push({
        object: level.object.uuid,
        distance: level.distance
      });
    }
    return data;
  }
});
const _basePosition = new Vector3();
const _skinIndex = new Vector4();
const _skinWeight = new Vector4();
const _vector$7 = new Vector3();
const _matrix$1 = new Matrix4();
function SkinnedMesh(geometry, material) {
  if (geometry && geometry.isGeometry) {
    console.error('THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
  }
  Mesh.call(this, geometry, material);
  this.type = 'SkinnedMesh';
  this.bindMode = 'attached';
  this.bindMatrix = new Matrix4();
  this.bindMatrixInverse = new Matrix4();
}
SkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
  constructor: SkinnedMesh,
  isSkinnedMesh: true,
  copy: function (source) {
    Mesh.prototype.copy.call(this, source);
    this.bindMode = source.bindMode;
    this.bindMatrix.copy(source.bindMatrix);
    this.bindMatrixInverse.copy(source.bindMatrixInverse);
    this.skeleton = source.skeleton;
    return this;
  },
  bind: function (skeleton, bindMatrix) {
    this.skeleton = skeleton;
    if (bindMatrix === undefined) {
      this.updateMatrixWorld(true);
      this.skeleton.calculateInverses();
      bindMatrix = this.matrixWorld;
    }
    this.bindMatrix.copy(bindMatrix);
    this.bindMatrixInverse.copy(bindMatrix).invert();
  },
  pose: function () {
    this.skeleton.pose();
  },
  normalizeSkinWeights: function () {
    const vector = new Vector4();
    const skinWeight = this.geometry.attributes.skinWeight;
    for (let i = 0, l = skinWeight.count; i < l; i++) {
      vector.x = skinWeight.getX(i);
      vector.y = skinWeight.getY(i);
      vector.z = skinWeight.getZ(i);
      vector.w = skinWeight.getW(i);
      const scale = 1.0 / vector.manhattanLength();
      if (scale !== Infinity) {
        vector.multiplyScalar(scale);
      } else {
        vector.set(1, 0, 0, 0); // do something reasonable
      }

      skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);
    }
  },
  updateMatrixWorld: function (force) {
    Mesh.prototype.updateMatrixWorld.call(this, force);
    if (this.bindMode === 'attached') {
      this.bindMatrixInverse.copy(this.matrixWorld).invert();
    } else if (this.bindMode === 'detached') {
      this.bindMatrixInverse.copy(this.bindMatrix).invert();
    } else {
      console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);
    }
  },
  boneTransform: function (index, target) {
    const skeleton = this.skeleton;
    const geometry = this.geometry;
    _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
    _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);
    _basePosition.fromBufferAttribute(geometry.attributes.position, index).applyMatrix4(this.bindMatrix);
    target.set(0, 0, 0);
    for (let i = 0; i < 4; i++) {
      const weight = _skinWeight.getComponent(i);
      if (weight !== 0) {
        const boneIndex = _skinIndex.getComponent(i);
        _matrix$1.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
        target.addScaledVector(_vector$7.copy(_basePosition).applyMatrix4(_matrix$1), weight);
      }
    }
    return target.applyMatrix4(this.bindMatrixInverse);
  }
});
function Bone() {
  Object3D.call(this);
  this.type = 'Bone';
}
Bone.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Bone,
  isBone: true
});
const _offsetMatrix = new Matrix4();
const _identityMatrix = new Matrix4();
function Skeleton(bones = [], boneInverses = []) {
  this.uuid = MathUtils.generateUUID();
  this.bones = bones.slice(0);
  this.boneInverses = boneInverses;
  this.boneMatrices = null;
  this.boneTexture = null;
  this.boneTextureSize = 0;
  this.frame = -1;
  this.init();
}
Object.assign(Skeleton.prototype, {
  init: function () {
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    this.boneMatrices = new Float32Array(bones.length * 16);

    // calculate inverse bone matrices if necessary

    if (boneInverses.length === 0) {
      this.calculateInverses();
    } else {
      // handle special case

      if (bones.length !== boneInverses.length) {
        console.warn('THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.');
        this.boneInverses = [];
        for (let i = 0, il = this.bones.length; i < il; i++) {
          this.boneInverses.push(new Matrix4());
        }
      }
    }
  },
  calculateInverses: function () {
    this.boneInverses.length = 0;
    for (let i = 0, il = this.bones.length; i < il; i++) {
      const inverse = new Matrix4();
      if (this.bones[i]) {
        inverse.copy(this.bones[i].matrixWorld).invert();
      }
      this.boneInverses.push(inverse);
    }
  },
  pose: function () {
    // recover the bind-time world matrices

    for (let i = 0, il = this.bones.length; i < il; i++) {
      const bone = this.bones[i];
      if (bone) {
        bone.matrixWorld.copy(this.boneInverses[i]).invert();
      }
    }

    // compute the local matrices, positions, rotations and scales

    for (let i = 0, il = this.bones.length; i < il; i++) {
      const bone = this.bones[i];
      if (bone) {
        if (bone.parent && bone.parent.isBone) {
          bone.matrix.copy(bone.parent.matrixWorld).invert();
          bone.matrix.multiply(bone.matrixWorld);
        } else {
          bone.matrix.copy(bone.matrixWorld);
        }
        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
      }
    }
  },
  update: function () {
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    const boneMatrices = this.boneMatrices;
    const boneTexture = this.boneTexture;

    // flatten bone matrices to array

    for (let i = 0, il = bones.length; i < il; i++) {
      // compute the offset between the current and the original transform

      const matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;
      _offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);
      _offsetMatrix.toArray(boneMatrices, i * 16);
    }
    if (boneTexture !== null) {
      boneTexture.needsUpdate = true;
    }
  },
  clone: function () {
    return new Skeleton(this.bones, this.boneInverses);
  },
  getBoneByName: function (name) {
    for (let i = 0, il = this.bones.length; i < il; i++) {
      const bone = this.bones[i];
      if (bone.name === name) {
        return bone;
      }
    }
    return undefined;
  },
  dispose: function () {
    if (this.boneTexture !== null) {
      this.boneTexture.dispose();
      this.boneTexture = null;
    }
  },
  fromJSON: function (json, bones) {
    this.uuid = json.uuid;
    for (let i = 0, l = json.bones.length; i < l; i++) {
      const uuid = json.bones[i];
      let bone = bones[uuid];
      if (bone === undefined) {
        console.warn('THREE.Skeleton: No bone found with UUID:', uuid);
        bone = new Bone();
      }
      this.bones.push(bone);
      this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i]));
    }
    this.init();
    return this;
  },
  toJSON: function () {
    const data = {
      metadata: {
        version: 4.5,
        type: 'Skeleton',
        generator: 'Skeleton.toJSON'
      },
      bones: [],
      boneInverses: []
    };
    data.uuid = this.uuid;
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    for (let i = 0, l = bones.length; i < l; i++) {
      const bone = bones[i];
      data.bones.push(bone.uuid);
      const boneInverse = boneInverses[i];
      data.boneInverses.push(boneInverse.toArray());
    }
    return data;
  }
});
const _instanceLocalMatrix = new Matrix4();
const _instanceWorldMatrix = new Matrix4();
const _instanceIntersects = [];
const _mesh = new Mesh();
function InstancedMesh(geometry, material, count) {
  Mesh.call(this, geometry, material);
  this.instanceMatrix = new BufferAttribute(new Float32Array(count * 16), 16);
  this.instanceColor = null;
  this.count = count;
  this.frustumCulled = false;
}
InstancedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
  constructor: InstancedMesh,
  isInstancedMesh: true,
  copy: function (source) {
    Mesh.prototype.copy.call(this, source);
    this.instanceMatrix.copy(source.instanceMatrix);
    if (source.instanceColor !== null) this.instanceColor = source.instanceColor.clone();
    this.count = source.count;
    return this;
  },
  getColorAt: function (index, color) {
    color.fromArray(this.instanceColor.array, index * 3);
  },
  getMatrixAt: function (index, matrix) {
    matrix.fromArray(this.instanceMatrix.array, index * 16);
  },
  raycast: function (raycaster, intersects) {
    const matrixWorld = this.matrixWorld;
    const raycastTimes = this.count;
    _mesh.geometry = this.geometry;
    _mesh.material = this.material;
    if (_mesh.material === undefined) return;
    for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
      // calculate the world matrix for each instance

      this.getMatrixAt(instanceId, _instanceLocalMatrix);
      _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);

      // the mesh represents this single instance

      _mesh.matrixWorld = _instanceWorldMatrix;
      _mesh.raycast(raycaster, _instanceIntersects);

      // process the result of raycast

      for (let i = 0, l = _instanceIntersects.length; i < l; i++) {
        const intersect = _instanceIntersects[i];
        intersect.instanceId = instanceId;
        intersect.object = this;
        intersects.push(intersect);
      }
      _instanceIntersects.length = 0;
    }
  },
  setColorAt: function (index, color) {
    if (this.instanceColor === null) {
      this.instanceColor = new BufferAttribute(new Float32Array(this.count * 3), 3);
    }
    color.toArray(this.instanceColor.array, index * 3);
  },
  setMatrixAt: function (index, matrix) {
    matrix.toArray(this.instanceMatrix.array, index * 16);
  },
  updateMorphTargets: function () {},
  dispose: function () {
    this.dispatchEvent({
      type: 'dispose'
    });
  }
});

/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round"
 * }
 */

function LineBasicMaterial(parameters) {
  Material.call(this);
  this.type = 'LineBasicMaterial';
  this.color = new Color(0xffffff);
  this.linewidth = 1;
  this.linecap = 'round';
  this.linejoin = 'round';
  this.morphTargets = false;
  this.setValues(parameters);
}
LineBasicMaterial.prototype = Object.create(Material.prototype);
LineBasicMaterial.prototype.constructor = LineBasicMaterial;
LineBasicMaterial.prototype.isLineBasicMaterial = true;
LineBasicMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.linewidth = source.linewidth;
  this.linecap = source.linecap;
  this.linejoin = source.linejoin;
  this.morphTargets = source.morphTargets;
  return this;
};
const _start = new Vector3();
const _end = new Vector3();
const _inverseMatrix$1 = new Matrix4();
const _ray$1 = new Ray();
const _sphere$2 = new Sphere();
function Line(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {
  Object3D.call(this);
  this.type = 'Line';
  this.geometry = geometry;
  this.material = material;
  this.updateMorphTargets();
}
Line.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Line,
  isLine: true,
  copy: function (source) {
    Object3D.prototype.copy.call(this, source);
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  },
  computeLineDistances: function () {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      // we assume non-indexed geometry

      if (geometry.index === null) {
        const positionAttribute = geometry.attributes.position;
        const lineDistances = [0];
        for (let i = 1, l = positionAttribute.count; i < l; i++) {
          _start.fromBufferAttribute(positionAttribute, i - 1);
          _end.fromBufferAttribute(positionAttribute, i);
          lineDistances[i] = lineDistances[i - 1];
          lineDistances[i] += _start.distanceTo(_end);
        }
        geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
      } else {
        console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
      }
    } else if (geometry.isGeometry) {
      console.error('THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
    }
    return this;
  },
  raycast: function (raycaster, intersects) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Line.threshold;

    // Checking boundingSphere distance to ray

    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
    _sphere$2.copy(geometry.boundingSphere);
    _sphere$2.applyMatrix4(matrixWorld);
    _sphere$2.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere$2) === false) return;

    //

    _inverseMatrix$1.copy(matrixWorld).invert();
    _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    const vStart = new Vector3();
    const vEnd = new Vector3();
    const interSegment = new Vector3();
    const interRay = new Vector3();
    const step = this.isLineSegments ? 2 : 1;
    if (geometry.isBufferGeometry) {
      const index = geometry.index;
      const attributes = geometry.attributes;
      const positionAttribute = attributes.position;
      if (index !== null) {
        const indices = index.array;
        for (let i = 0, l = indices.length - 1; i < l; i += step) {
          const a = indices[i];
          const b = indices[i + 1];
          vStart.fromBufferAttribute(positionAttribute, a);
          vEnd.fromBufferAttribute(positionAttribute, b);
          const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
          if (distSq > localThresholdSq) continue;
          interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

          const distance = raycaster.ray.origin.distanceTo(interRay);
          if (distance < raycaster.near || distance > raycaster.far) continue;
          intersects.push({
            distance: distance,
            // What do we want? intersection point on the ray or on the segment??
            // point: raycaster.ray.at( distance ),
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      } else {
        for (let i = 0, l = positionAttribute.count - 1; i < l; i += step) {
          vStart.fromBufferAttribute(positionAttribute, i);
          vEnd.fromBufferAttribute(positionAttribute, i + 1);
          const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
          if (distSq > localThresholdSq) continue;
          interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

          const distance = raycaster.ray.origin.distanceTo(interRay);
          if (distance < raycaster.near || distance > raycaster.far) continue;
          intersects.push({
            distance: distance,
            // What do we want? intersection point on the ray or on the segment??
            // point: raycaster.ray.at( distance ),
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      }
    } else if (geometry.isGeometry) {
      console.error('THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
    }
  },
  updateMorphTargets: function () {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);
      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];
        if (morphAttribute !== undefined) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
            const name = morphAttribute[m].name || String(m);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;
      if (morphTargets !== undefined && morphTargets.length > 0) {
        console.error('THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');
      }
    }
  }
});
const _start$1 = new Vector3();
const _end$1 = new Vector3();
function LineSegments(geometry, material) {
  Line.call(this, geometry, material);
  this.type = 'LineSegments';
}
LineSegments.prototype = Object.assign(Object.create(Line.prototype), {
  constructor: LineSegments,
  isLineSegments: true,
  computeLineDistances: function () {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      // we assume non-indexed geometry

      if (geometry.index === null) {
        const positionAttribute = geometry.attributes.position;
        const lineDistances = [];
        for (let i = 0, l = positionAttribute.count; i < l; i += 2) {
          _start$1.fromBufferAttribute(positionAttribute, i);
          _end$1.fromBufferAttribute(positionAttribute, i + 1);
          lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
          lineDistances[i + 1] = lineDistances[i] + _start$1.distanceTo(_end$1);
        }
        geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
      } else {
        console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
      }
    } else if (geometry.isGeometry) {
      console.error('THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
    }
    return this;
  }
});
function LineLoop(geometry, material) {
  Line.call(this, geometry, material);
  this.type = 'LineLoop';
}
LineLoop.prototype = Object.assign(Object.create(Line.prototype), {
  constructor: LineLoop,
  isLineLoop: true
});

/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>
 *
 *  morphTargets: <bool>
 * }
 */

function PointsMaterial(parameters) {
  Material.call(this);
  this.type = 'PointsMaterial';
  this.color = new Color(0xffffff);
  this.map = null;
  this.alphaMap = null;
  this.size = 1;
  this.sizeAttenuation = true;
  this.morphTargets = false;
  this.setValues(parameters);
}
PointsMaterial.prototype = Object.create(Material.prototype);
PointsMaterial.prototype.constructor = PointsMaterial;
PointsMaterial.prototype.isPointsMaterial = true;
PointsMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.map = source.map;
  this.alphaMap = source.alphaMap;
  this.size = source.size;
  this.sizeAttenuation = source.sizeAttenuation;
  this.morphTargets = source.morphTargets;
  return this;
};
const _inverseMatrix$2 = new Matrix4();
const _ray$2 = new Ray();
const _sphere$3 = new Sphere();
const _position$1 = new Vector3();
function Points(geometry = new BufferGeometry(), material = new PointsMaterial()) {
  Object3D.call(this);
  this.type = 'Points';
  this.geometry = geometry;
  this.material = material;
  this.updateMorphTargets();
}
Points.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Points,
  isPoints: true,
  copy: function (source) {
    Object3D.prototype.copy.call(this, source);
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  },
  raycast: function (raycaster, intersects) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Points.threshold;

    // Checking boundingSphere distance to ray

    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
    _sphere$3.copy(geometry.boundingSphere);
    _sphere$3.applyMatrix4(matrixWorld);
    _sphere$3.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere$3) === false) return;

    //

    _inverseMatrix$2.copy(matrixWorld).invert();
    _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    if (geometry.isBufferGeometry) {
      const index = geometry.index;
      const attributes = geometry.attributes;
      const positionAttribute = attributes.position;
      if (index !== null) {
        const indices = index.array;
        for (let i = 0, il = indices.length; i < il; i++) {
          const a = indices[i];
          _position$1.fromBufferAttribute(positionAttribute, a);
          testPoint(_position$1, a, localThresholdSq, matrixWorld, raycaster, intersects, this);
        }
      } else {
        for (let i = 0, l = positionAttribute.count; i < l; i++) {
          _position$1.fromBufferAttribute(positionAttribute, i);
          testPoint(_position$1, i, localThresholdSq, matrixWorld, raycaster, intersects, this);
        }
      }
    } else {
      console.error('THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
    }
  },
  updateMorphTargets: function () {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);
      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];
        if (morphAttribute !== undefined) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
            const name = morphAttribute[m].name || String(m);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;
      if (morphTargets !== undefined && morphTargets.length > 0) {
        console.error('THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');
      }
    }
  }
});
function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {
  const rayPointDistanceSq = _ray$2.distanceSqToPoint(point);
  if (rayPointDistanceSq < localThresholdSq) {
    const intersectPoint = new Vector3();
    _ray$2.closestPointToPoint(point, intersectPoint);
    intersectPoint.applyMatrix4(matrixWorld);
    const distance = raycaster.ray.origin.distanceTo(intersectPoint);
    if (distance < raycaster.near || distance > raycaster.far) return;
    intersects.push({
      distance: distance,
      distanceToRay: Math.sqrt(rayPointDistanceSq),
      point: intersectPoint,
      index: index,
      face: null,
      object: object
    });
  }
}
function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
  Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
  this.format = format !== undefined ? format : RGBFormat;
  this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
  this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
  this.generateMipmaps = false;
  const scope = this;
  function updateVideo() {
    scope.needsUpdate = true;
    video.requestVideoFrameCallback(updateVideo);
  }
  if ('requestVideoFrameCallback' in video) {
    video.requestVideoFrameCallback(updateVideo);
  }
}
VideoTexture.prototype = Object.assign(Object.create(Texture.prototype), {
  constructor: VideoTexture,
  clone: function () {
    return new this.constructor(this.image).copy(this);
  },
  isVideoTexture: true,
  update: function () {
    const video = this.image;
    const hasVideoFrameCallback = ('requestVideoFrameCallback' in video);
    if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
      this.needsUpdate = true;
    }
  }
});
function CompressedTexture(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
  Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
  this.image = {
    width: width,
    height: height
  };
  this.mipmaps = mipmaps;

  // no flipping for cube textures
  // (also flipping doesn't work for compressed textures )

  this.flipY = false;

  // can't generate mipmaps for compressed textures
  // mips must be embedded in DDS files

  this.generateMipmaps = false;
}
CompressedTexture.prototype = Object.create(Texture.prototype);
CompressedTexture.prototype.constructor = CompressedTexture;
CompressedTexture.prototype.isCompressedTexture = true;
function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
  Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
  this.needsUpdate = true;
}
CanvasTexture.prototype = Object.create(Texture.prototype);
CanvasTexture.prototype.constructor = CanvasTexture;
CanvasTexture.prototype.isCanvasTexture = true;
function DepthTexture(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
  format = format !== undefined ? format : DepthFormat;
  if (format !== DepthFormat && format !== DepthStencilFormat) {
    throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');
  }
  if (type === undefined && format === DepthFormat) type = UnsignedShortType;
  if (type === undefined && format === DepthStencilFormat) type = UnsignedInt248Type;
  Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
  this.image = {
    width: width,
    height: height
  };
  this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
  this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
  this.flipY = false;
  this.generateMipmaps = false;
}
DepthTexture.prototype = Object.create(Texture.prototype);
DepthTexture.prototype.constructor = DepthTexture;
DepthTexture.prototype.isDepthTexture = true;
class CircleGeometry extends BufferGeometry {
  constructor(radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = 'CircleGeometry';
    this.parameters = {
      radius: radius,
      segments: segments,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    segments = Math.max(3, segments);

    // buffers

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];

    // helper variables

    const vertex = new Vector3();
    const uv = new Vector2();

    // center point

    vertices.push(0, 0, 0);
    normals.push(0, 0, 1);
    uvs.push(0.5, 0.5);
    for (let s = 0, i = 3; s <= segments; s++, i += 3) {
      const segment = thetaStart + s / segments * thetaLength;

      // vertex

      vertex.x = radius * Math.cos(segment);
      vertex.y = radius * Math.sin(segment);
      vertices.push(vertex.x, vertex.y, vertex.z);

      // normal

      normals.push(0, 0, 1);

      // uvs

      uv.x = (vertices[i] / radius + 1) / 2;
      uv.y = (vertices[i + 1] / radius + 1) / 2;
      uvs.push(uv.x, uv.y);
    }

    // indices

    for (let i = 1; i <= segments; i++) {
      indices.push(i, i + 1, 0);
    }

    // build geometry

    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
  }
}
exports.CircleGeometry = exports.CircleBufferGeometry = CircleGeometry;
class CylinderGeometry extends BufferGeometry {
  constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = 'CylinderGeometry';
    this.parameters = {
      radiusTop: radiusTop,
      radiusBottom: radiusBottom,
      height: height,
      radialSegments: radialSegments,
      heightSegments: heightSegments,
      openEnded: openEnded,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    const scope = this;
    radialSegments = Math.floor(radialSegments);
    heightSegments = Math.floor(heightSegments);

    // buffers

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];

    // helper variables

    let index = 0;
    const indexArray = [];
    const halfHeight = height / 2;
    let groupStart = 0;

    // generate geometry

    generateTorso();
    if (openEnded === false) {
      if (radiusTop > 0) generateCap(true);
      if (radiusBottom > 0) generateCap(false);
    }

    // build geometry

    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
    function generateTorso() {
      const normal = new Vector3();
      const vertex = new Vector3();
      let groupCount = 0;

      // this will be used to calculate the normal
      const slope = (radiusBottom - radiusTop) / height;

      // generate vertices, normals and uvs

      for (let y = 0; y <= heightSegments; y++) {
        const indexRow = [];
        const v = y / heightSegments;

        // calculate the radius of the current row

        const radius = v * (radiusBottom - radiusTop) + radiusTop;
        for (let x = 0; x <= radialSegments; x++) {
          const u = x / radialSegments;
          const theta = u * thetaLength + thetaStart;
          const sinTheta = Math.sin(theta);
          const cosTheta = Math.cos(theta);

          // vertex

          vertex.x = radius * sinTheta;
          vertex.y = -v * height + halfHeight;
          vertex.z = radius * cosTheta;
          vertices.push(vertex.x, vertex.y, vertex.z);

          // normal

          normal.set(sinTheta, slope, cosTheta).normalize();
          normals.push(normal.x, normal.y, normal.z);

          // uv

          uvs.push(u, 1 - v);

          // save index of vertex in respective row

          indexRow.push(index++);
        }

        // now save vertices of the row in our index array

        indexArray.push(indexRow);
      }

      // generate indices

      for (let x = 0; x < radialSegments; x++) {
        for (let y = 0; y < heightSegments; y++) {
          // we use the index array to access the correct indices

          const a = indexArray[y][x];
          const b = indexArray[y + 1][x];
          const c = indexArray[y + 1][x + 1];
          const d = indexArray[y][x + 1];

          // faces

          indices.push(a, b, d);
          indices.push(b, c, d);

          // update group counter

          groupCount += 6;
        }
      }

      // add a group to the geometry. this will ensure multi material support

      scope.addGroup(groupStart, groupCount, 0);

      // calculate new start value for groups

      groupStart += groupCount;
    }
    function generateCap(top) {
      // save the index of the first center vertex
      const centerIndexStart = index;
      const uv = new Vector2();
      const vertex = new Vector3();
      let groupCount = 0;
      const radius = top === true ? radiusTop : radiusBottom;
      const sign = top === true ? 1 : -1;

      // first we generate the center vertex data of the cap.
      // because the geometry needs one set of uvs per face,
      // we must generate a center vertex per face/segment

      for (let x = 1; x <= radialSegments; x++) {
        // vertex

        vertices.push(0, halfHeight * sign, 0);

        // normal

        normals.push(0, sign, 0);

        // uv

        uvs.push(0.5, 0.5);

        // increase index

        index++;
      }

      // save the index of the last center vertex
      const centerIndexEnd = index;

      // now we generate the surrounding vertices, normals and uvs

      for (let x = 0; x <= radialSegments; x++) {
        const u = x / radialSegments;
        const theta = u * thetaLength + thetaStart;
        const cosTheta = Math.cos(theta);
        const sinTheta = Math.sin(theta);

        // vertex

        vertex.x = radius * sinTheta;
        vertex.y = halfHeight * sign;
        vertex.z = radius * cosTheta;
        vertices.push(vertex.x, vertex.y, vertex.z);

        // normal

        normals.push(0, sign, 0);

        // uv

        uv.x = cosTheta * 0.5 + 0.5;
        uv.y = sinTheta * 0.5 * sign + 0.5;
        uvs.push(uv.x, uv.y);

        // increase index

        index++;
      }

      // generate indices

      for (let x = 0; x < radialSegments; x++) {
        const c = centerIndexStart + x;
        const i = centerIndexEnd + x;
        if (top === true) {
          // face top

          indices.push(i, i + 1, c);
        } else {
          // face bottom

          indices.push(i + 1, i, c);
        }
        groupCount += 3;
      }

      // add a group to the geometry. this will ensure multi material support

      scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);

      // calculate new start value for groups

      groupStart += groupCount;
    }
  }
}
exports.CylinderGeometry = exports.CylinderBufferGeometry = CylinderGeometry;
class ConeGeometry extends CylinderGeometry {
  constructor(radius = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
    super(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
    this.type = 'ConeGeometry';
    this.parameters = {
      radius: radius,
      height: height,
      radialSegments: radialSegments,
      heightSegments: heightSegments,
      openEnded: openEnded,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
  }
}
exports.ConeGeometry = exports.ConeBufferGeometry = ConeGeometry;
class PolyhedronGeometry extends BufferGeometry {
  constructor(vertices, indices, radius = 1, detail = 0) {
    super();
    this.type = 'PolyhedronGeometry';
    this.parameters = {
      vertices: vertices,
      indices: indices,
      radius: radius,
      detail: detail
    };

    // default buffer data

    const vertexBuffer = [];
    const uvBuffer = [];

    // the subdivision creates the vertex buffer data

    subdivide(detail);

    // all vertices should lie on a conceptual sphere with a given radius

    applyRadius(radius);

    // finally, create the uv data

    generateUVs();

    // build non-indexed geometry

    this.setAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));
    this.setAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));
    if (detail === 0) {
      this.computeVertexNormals(); // flat normals
    } else {
      this.normalizeNormals(); // smooth normals
    }

    // helper functions

    function subdivide(detail) {
      const a = new Vector3();
      const b = new Vector3();
      const c = new Vector3();

      // iterate over all faces and apply a subdivison with the given detail value

      for (let i = 0; i < indices.length; i += 3) {
        // get the vertices of the face

        getVertexByIndex(indices[i + 0], a);
        getVertexByIndex(indices[i + 1], b);
        getVertexByIndex(indices[i + 2], c);

        // perform subdivision

        subdivideFace(a, b, c, detail);
      }
    }
    function subdivideFace(a, b, c, detail) {
      const cols = detail + 1;

      // we use this multidimensional array as a data structure for creating the subdivision

      const v = [];

      // construct all of the vertices for this subdivision

      for (let i = 0; i <= cols; i++) {
        v[i] = [];
        const aj = a.clone().lerp(c, i / cols);
        const bj = b.clone().lerp(c, i / cols);
        const rows = cols - i;
        for (let j = 0; j <= rows; j++) {
          if (j === 0 && i === cols) {
            v[i][j] = aj;
          } else {
            v[i][j] = aj.clone().lerp(bj, j / rows);
          }
        }
      }

      // construct all of the faces

      for (let i = 0; i < cols; i++) {
        for (let j = 0; j < 2 * (cols - i) - 1; j++) {
          const k = Math.floor(j / 2);
          if (j % 2 === 0) {
            pushVertex(v[i][k + 1]);
            pushVertex(v[i + 1][k]);
            pushVertex(v[i][k]);
          } else {
            pushVertex(v[i][k + 1]);
            pushVertex(v[i + 1][k + 1]);
            pushVertex(v[i + 1][k]);
          }
        }
      }
    }
    function applyRadius(radius) {
      const vertex = new Vector3();

      // iterate over the entire buffer and apply the radius to each vertex

      for (let i = 0; i < vertexBuffer.length; i += 3) {
        vertex.x = vertexBuffer[i + 0];
        vertex.y = vertexBuffer[i + 1];
        vertex.z = vertexBuffer[i + 2];
        vertex.normalize().multiplyScalar(radius);
        vertexBuffer[i + 0] = vertex.x;
        vertexBuffer[i + 1] = vertex.y;
        vertexBuffer[i + 2] = vertex.z;
      }
    }
    function generateUVs() {
      const vertex = new Vector3();
      for (let i = 0; i < vertexBuffer.length; i += 3) {
        vertex.x = vertexBuffer[i + 0];
        vertex.y = vertexBuffer[i + 1];
        vertex.z = vertexBuffer[i + 2];
        const u = azimuth(vertex) / 2 / Math.PI + 0.5;
        const v = inclination(vertex) / Math.PI + 0.5;
        uvBuffer.push(u, 1 - v);
      }
      correctUVs();
      correctSeam();
    }
    function correctSeam() {
      // handle case when face straddles the seam, see #3269

      for (let i = 0; i < uvBuffer.length; i += 6) {
        // uv data of a single face

        const x0 = uvBuffer[i + 0];
        const x1 = uvBuffer[i + 2];
        const x2 = uvBuffer[i + 4];
        const max = Math.max(x0, x1, x2);
        const min = Math.min(x0, x1, x2);

        // 0.9 is somewhat arbitrary

        if (max > 0.9 && min < 0.1) {
          if (x0 < 0.2) uvBuffer[i + 0] += 1;
          if (x1 < 0.2) uvBuffer[i + 2] += 1;
          if (x2 < 0.2) uvBuffer[i + 4] += 1;
        }
      }
    }
    function pushVertex(vertex) {
      vertexBuffer.push(vertex.x, vertex.y, vertex.z);
    }
    function getVertexByIndex(index, vertex) {
      const stride = index * 3;
      vertex.x = vertices[stride + 0];
      vertex.y = vertices[stride + 1];
      vertex.z = vertices[stride + 2];
    }
    function correctUVs() {
      const a = new Vector3();
      const b = new Vector3();
      const c = new Vector3();
      const centroid = new Vector3();
      const uvA = new Vector2();
      const uvB = new Vector2();
      const uvC = new Vector2();
      for (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
        a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
        b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
        c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
        uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
        uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
        uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
        centroid.copy(a).add(b).add(c).divideScalar(3);
        const azi = azimuth(centroid);
        correctUV(uvA, j + 0, a, azi);
        correctUV(uvB, j + 2, b, azi);
        correctUV(uvC, j + 4, c, azi);
      }
    }
    function correctUV(uv, stride, vector, azimuth) {
      if (azimuth < 0 && uv.x === 1) {
        uvBuffer[stride] = uv.x - 1;
      }
      if (vector.x === 0 && vector.z === 0) {
        uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;
      }
    }

    // Angle around the Y axis, counter-clockwise when looking from above.

    function azimuth(vector) {
      return Math.atan2(vector.z, -vector.x);
    }

    // Angle above the XZ plane.

    function inclination(vector) {
      return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
    }
  }
}
exports.PolyhedronGeometry = exports.PolyhedronBufferGeometry = PolyhedronGeometry;
class DodecahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const t = (1 + Math.sqrt(5)) / 2;
    const r = 1 / t;
    const vertices = [
    // (±1, ±1, ±1)
    -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1,
    // (0, ±1/φ, ±φ)
    0, -r, -t, 0, -r, t, 0, r, -t, 0, r, t,
    // (±1/φ, ±φ, 0)
    -r, -t, 0, -r, t, 0, r, -t, 0, r, t, 0,
    // (±φ, 0, ±1/φ)
    -t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r];
    const indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
    super(vertices, indices, radius, detail);
    this.type = 'DodecahedronGeometry';
    this.parameters = {
      radius: radius,
      detail: detail
    };
  }
}
exports.DodecahedronGeometry = exports.DodecahedronBufferGeometry = DodecahedronGeometry;
const _v0$2 = new Vector3();
const _v1$5 = new Vector3();
const _normal$1 = new Vector3();
const _triangle = new Triangle();
class EdgesGeometry extends BufferGeometry {
  constructor(geometry, thresholdAngle) {
    super();
    this.type = 'EdgesGeometry';
    this.parameters = {
      thresholdAngle: thresholdAngle
    };
    thresholdAngle = thresholdAngle !== undefined ? thresholdAngle : 1;
    if (geometry.isGeometry === true) {
      console.error('THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
      return;
    }
    const precisionPoints = 4;
    const precision = Math.pow(10, precisionPoints);
    const thresholdDot = Math.cos(MathUtils.DEG2RAD * thresholdAngle);
    const indexAttr = geometry.getIndex();
    const positionAttr = geometry.getAttribute('position');
    const indexCount = indexAttr ? indexAttr.count : positionAttr.count;
    const indexArr = [0, 0, 0];
    const vertKeys = ['a', 'b', 'c'];
    const hashes = new Array(3);
    const edgeData = {};
    const vertices = [];
    for (let i = 0; i < indexCount; i += 3) {
      if (indexAttr) {
        indexArr[0] = indexAttr.getX(i);
        indexArr[1] = indexAttr.getX(i + 1);
        indexArr[2] = indexAttr.getX(i + 2);
      } else {
        indexArr[0] = i;
        indexArr[1] = i + 1;
        indexArr[2] = i + 2;
      }
      const {
        a,
        b,
        c
      } = _triangle;
      a.fromBufferAttribute(positionAttr, indexArr[0]);
      b.fromBufferAttribute(positionAttr, indexArr[1]);
      c.fromBufferAttribute(positionAttr, indexArr[2]);
      _triangle.getNormal(_normal$1);

      // create hashes for the edge from the vertices
      hashes[0] = `${Math.round(a.x * precision)},${Math.round(a.y * precision)},${Math.round(a.z * precision)}`;
      hashes[1] = `${Math.round(b.x * precision)},${Math.round(b.y * precision)},${Math.round(b.z * precision)}`;
      hashes[2] = `${Math.round(c.x * precision)},${Math.round(c.y * precision)},${Math.round(c.z * precision)}`;

      // skip degenerate triangles
      if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {
        continue;
      }

      // iterate over every edge
      for (let j = 0; j < 3; j++) {
        // get the first and next vertex making up the edge
        const jNext = (j + 1) % 3;
        const vecHash0 = hashes[j];
        const vecHash1 = hashes[jNext];
        const v0 = _triangle[vertKeys[j]];
        const v1 = _triangle[vertKeys[jNext]];
        const hash = `${vecHash0}_${vecHash1}`;
        const reverseHash = `${vecHash1}_${vecHash0}`;
        if (reverseHash in edgeData && edgeData[reverseHash]) {
          // if we found a sibling edge add it into the vertex array if
          // it meets the angle threshold and delete the edge from the map.
          if (_normal$1.dot(edgeData[reverseHash].normal) <= thresholdDot) {
            vertices.push(v0.x, v0.y, v0.z);
            vertices.push(v1.x, v1.y, v1.z);
          }
          edgeData[reverseHash] = null;
        } else if (!(hash in edgeData)) {
          // if we've already got an edge here then skip adding a new one
          edgeData[hash] = {
            index0: indexArr[j],
            index1: indexArr[jNext],
            normal: _normal$1.clone()
          };
        }
      }
    }

    // iterate over all remaining, unmatched edges and add them to the vertex array
    for (const key in edgeData) {
      if (edgeData[key]) {
        const {
          index0,
          index1
        } = edgeData[key];
        _v0$2.fromBufferAttribute(positionAttr, index0);
        _v1$5.fromBufferAttribute(positionAttr, index1);
        vertices.push(_v0$2.x, _v0$2.y, _v0$2.z);
        vertices.push(_v1$5.x, _v1$5.y, _v1$5.z);
      }
    }
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
  }
}

/**
 * Port from https://github.com/mapbox/earcut (v2.2.2)
 */
exports.EdgesGeometry = EdgesGeometry;
const Earcut = {
  triangulate: function (data, holeIndices, dim) {
    dim = dim || 2;
    const hasHoles = holeIndices && holeIndices.length;
    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    let outerNode = linkedList(data, 0, outerLen, dim, true);
    const triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev) return triangles;
    let minX, minY, maxX, maxY, x, y, invSize;
    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
      minX = maxX = data[0];
      minY = maxY = data[1];
      for (let i = dim; i < outerLen; i += dim) {
        x = data[i];
        y = data[i + 1];
        if (x < minX) minX = x;
        if (y < minY) minY = y;
        if (x > maxX) maxX = x;
        if (y > maxY) maxY = y;
      }

      // minX, minY and invSize are later used to transform coords into integers for z-order calculation
      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 1 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
    return triangles;
  }
};

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
  let i, last;
  if (clockwise === signedArea(data, start, end, dim) > 0) {
    for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
  } else {
    for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
  }
  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }
  return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
  if (!start) return start;
  if (!end) end = start;
  let p = start,
    again;
  do {
    again = false;
    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
      removeNode(p);
      p = end = p.prev;
      if (p === p.next) break;
      again = true;
    } else {
      p = p.next;
    }
  } while (again || p !== end);
  return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear) return;

  // interlink polygon nodes in z-order
  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
  let stop = ear,
    prev,
    next;

  // iterate through ears, slicing them one by one
  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      // cut off the triangle
      triangles.push(prev.i / dim);
      triangles.push(ear.i / dim);
      triangles.push(next.i / dim);
      removeNode(ear);

      // skipping the next vertex leads to less sliver triangles
      ear = next.next;
      stop = next.next;
      continue;
    }
    ear = next;

    // if we looped through the whole remaining polygon and can't find any more ears
    if (ear === stop) {
      // try filtering points and slicing again
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

        // if this didn't work, try curing all small self-intersections locally
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

        // as a last resort, try splitting the remaining polygon into two
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
  const a = ear.prev,
    b = ear,
    c = ear.next;
  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

  // now make sure we don't have other points inside the potential ear
  let p = ear.next.next;
  while (p !== ear.prev) {
    if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  const a = ear.prev,
    b = ear,
    c = ear.next;
  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

  // triangle bbox; min & max are calculated like this for speed
  const minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x,
    minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y,
    maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x,
    maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;

  // z-order range for the current triangle bbox;
  const minZ = zOrder(minTX, minTY, minX, minY, invSize),
    maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
  let p = ear.prevZ,
    n = ear.nextZ;

  // look for points inside the triangle in both directions
  while (p && p.z >= minZ && n && n.z <= maxZ) {
    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.prevZ;
    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  }

  // look for remaining points in decreasing z-order
  while (p && p.z >= minZ) {
    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.prevZ;
  }

  // look for remaining points in increasing z-order
  while (n && n.z <= maxZ) {
    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  }
  return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
  let p = start;
  do {
    const a = p.prev,
      b = p.next.next;
    if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
      triangles.push(a.i / dim);
      triangles.push(p.i / dim);
      triangles.push(b.i / dim);

      // remove two nodes involved
      removeNode(p);
      removeNode(p.next);
      p = start = b;
    }
    p = p.next;
  } while (p !== start);
  return filterPoints(p);
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  // look for a valid diagonal that divides the polygon into two
  let a = start;
  do {
    let b = a.next.next;
    while (b !== a.prev) {
      if (a.i !== b.i && isValidDiagonal(a, b)) {
        // split the polygon in two by the diagonal
        let c = splitPolygon(a, b);

        // filter colinear points around the cuts
        a = filterPoints(a, a.next);
        c = filterPoints(c, c.next);

        // run earcut on each half
        earcutLinked(a, triangles, dim, minX, minY, invSize);
        earcutLinked(c, triangles, dim, minX, minY, invSize);
        return;
      }
      b = b.next;
    }
    a = a.next;
  } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
  const queue = [];
  let i, len, start, end, list;
  for (i = 0, len = holeIndices.length; i < len; i++) {
    start = holeIndices[i] * dim;
    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
    list = linkedList(data, start, end, dim, false);
    if (list === list.next) list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareX);

  // process holes from left to right
  for (i = 0; i < queue.length; i++) {
    eliminateHole(queue[i], outerNode);
    outerNode = filterPoints(outerNode, outerNode.next);
  }
  return outerNode;
}
function compareX(a, b) {
  return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
  outerNode = findHoleBridge(hole, outerNode);
  if (outerNode) {
    const b = splitPolygon(outerNode, hole);

    // filter collinear points around the cuts
    filterPoints(outerNode, outerNode.next);
    filterPoints(b, b.next);
  }
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
  let p = outerNode;
  const hx = hole.x;
  const hy = hole.y;
  let qx = -Infinity,
    m;

  // find a segment intersected by a ray from the hole's leftmost point to the left;
  // segment's endpoint with lesser x will be potential connection point
  do {
    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
      const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
      if (x <= hx && x > qx) {
        qx = x;
        if (x === hx) {
          if (hy === p.y) return p;
          if (hy === p.next.y) return p.next;
        }
        m = p.x < p.next.x ? p : p.next;
      }
    }
    p = p.next;
  } while (p !== outerNode);
  if (!m) return null;
  if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint

  // look for points inside the triangle of hole point, segment intersection and endpoint;
  // if there are no points found, we have a valid connection;
  // otherwise choose the point of the minimum angle with the ray as connection point

  const stop = m,
    mx = m.x,
    my = m.y;
  let tanMin = Infinity,
    tan;
  p = m;
  do {
    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
      tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

      if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
        m = p;
        tanMin = tan;
      }
    }
    p = p.next;
  } while (p !== stop);
  return m;
}

// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
  let p = start;
  do {
    if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
    p.prevZ = p.prev;
    p.nextZ = p.next;
    p = p.next;
  } while (p !== start);
  p.prevZ.nextZ = null;
  p.prevZ = null;
  sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
  let i,
    p,
    q,
    e,
    tail,
    numMerges,
    pSize,
    qSize,
    inSize = 1;
  do {
    p = list;
    list = null;
    tail = null;
    numMerges = 0;
    while (p) {
      numMerges++;
      q = p;
      pSize = 0;
      for (i = 0; i < inSize; i++) {
        pSize++;
        q = q.nextZ;
        if (!q) break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
          e = p;
          p = p.nextZ;
          pSize--;
        } else {
          e = q;
          q = q.nextZ;
          qSize--;
        }
        if (tail) tail.nextZ = e;else list = e;
        e.prevZ = tail;
        tail = e;
      }
      p = q;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
  // coords are transformed into non-negative 15-bit integer range
  x = 32767 * (x - minX) * invSize;
  y = 32767 * (y - minY) * invSize;
  x = (x | x << 8) & 0x00FF00FF;
  x = (x | x << 4) & 0x0F0F0F0F;
  x = (x | x << 2) & 0x33333333;
  x = (x | x << 1) & 0x55555555;
  y = (y | y << 8) & 0x00FF00FF;
  y = (y | y << 4) & 0x0F0F0F0F;
  y = (y | y << 2) & 0x33333333;
  y = (y | y << 1) & 0x55555555;
  return x | y << 1;
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
  let p = start,
    leftmost = start;
  do {
    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
    p = p.next;
  } while (p !== start);
  return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
  return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (
  // dones't intersect other edges
  locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (
  // locally visible
  area(a.prev, a, b.prev) || area(a, b.prev, b)) ||
  // does not create opposite-facing sectors
  equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
}

// signed area of a triangle
function area(p, q, r) {
  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
  const o1 = sign(area(p1, q1, p2));
  const o2 = sign(area(p1, q1, q2));
  const o3 = sign(area(p2, q2, p1));
  const o4 = sign(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4) return true; // general case

  if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
  if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
  if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
  if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

  return false;
}

// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r) {
  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}
function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
  let p = a;
  do {
    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
    p = p.next;
  } while (p !== a);
  return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
  let p = a,
    inside = false;
  const px = (a.x + b.x) / 2,
    py = (a.y + b.y) / 2;
  do {
    if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
    p = p.next;
  } while (p !== a);
  return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
  const a2 = new Node(a.i, a.x, a.y),
    b2 = new Node(b.i, b.x, b.y),
    an = a.next,
    bp = b.prev;
  a.next = b;
  b.prev = a;
  a2.next = an;
  an.prev = a2;
  b2.next = a2;
  a2.prev = b2;
  bp.next = b2;
  b2.prev = bp;
  return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
  const p = new Node(i, x, y);
  if (!last) {
    p.prev = p;
    p.next = p;
  } else {
    p.next = last.next;
    p.prev = last;
    last.next.prev = p;
    last.next = p;
  }
  return p;
}
function removeNode(p) {
  p.next.prev = p.prev;
  p.prev.next = p.next;
  if (p.prevZ) p.prevZ.nextZ = p.nextZ;
  if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}
function Node(i, x, y) {
  // vertex index in coordinates array
  this.i = i;

  // vertex coordinates
  this.x = x;
  this.y = y;

  // previous and next vertex nodes in a polygon ring
  this.prev = null;
  this.next = null;

  // z-order curve value
  this.z = null;

  // previous and next nodes in z-order
  this.prevZ = null;
  this.nextZ = null;

  // indicates whether this is a steiner point
  this.steiner = false;
}
function signedArea(data, start, end, dim) {
  let sum = 0;
  for (let i = start, j = end - dim; i < end; i += dim) {
    sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
    j = i;
  }
  return sum;
}
const ShapeUtils = {
  // calculate area of the contour polygon

  area: function (contour) {
    const n = contour.length;
    let a = 0.0;
    for (let p = n - 1, q = 0; q < n; p = q++) {
      a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
    }
    return a * 0.5;
  },
  isClockWise: function (pts) {
    return ShapeUtils.area(pts) < 0;
  },
  triangulateShape: function (contour, holes) {
    const vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
    const holeIndices = []; // array of hole indices
    const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

    removeDupEndPts(contour);
    addContour(vertices, contour);

    //

    let holeIndex = contour.length;
    holes.forEach(removeDupEndPts);
    for (let i = 0; i < holes.length; i++) {
      holeIndices.push(holeIndex);
      holeIndex += holes[i].length;
      addContour(vertices, holes[i]);
    }

    //

    const triangles = Earcut.triangulate(vertices, holeIndices);

    //

    for (let i = 0; i < triangles.length; i += 3) {
      faces.push(triangles.slice(i, i + 3));
    }
    return faces;
  }
};
exports.ShapeUtils = ShapeUtils;
function removeDupEndPts(points) {
  const l = points.length;
  if (l > 2 && points[l - 1].equals(points[0])) {
    points.pop();
  }
}
function addContour(vertices, contour) {
  for (let i = 0; i < contour.length; i++) {
    vertices.push(contour[i].x);
    vertices.push(contour[i].y);
  }
}

/**
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  depth: <float>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
 *  bevelOffset: <float>, // how far from shape outline does bevel start
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.Curve> // curve to extrude shape along
 *
 *  UVGenerator: <Object> // object that provides UV generator functions
 *
 * }
 */

class ExtrudeGeometry extends BufferGeometry {
  constructor(shapes, options) {
    super();
    this.type = 'ExtrudeGeometry';
    this.parameters = {
      shapes: shapes,
      options: options
    };
    shapes = Array.isArray(shapes) ? shapes : [shapes];
    const scope = this;
    const verticesArray = [];
    const uvArray = [];
    for (let i = 0, l = shapes.length; i < l; i++) {
      const shape = shapes[i];
      addShape(shape);
    }

    // build geometry

    this.setAttribute('position', new Float32BufferAttribute(verticesArray, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvArray, 2));
    this.computeVertexNormals();

    // functions

    function addShape(shape) {
      const placeholder = [];

      // options

      const curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
      const steps = options.steps !== undefined ? options.steps : 1;
      let depth = options.depth !== undefined ? options.depth : 100;
      let bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
      let bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
      let bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
      let bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
      let bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
      const extrudePath = options.extrudePath;
      const uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;

      // deprecated options

      if (options.amount !== undefined) {
        console.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.');
        depth = options.amount;
      }

      //

      let extrudePts,
        extrudeByPath = false;
      let splineTube, binormal, normal, position2;
      if (extrudePath) {
        extrudePts = extrudePath.getSpacedPoints(steps);
        extrudeByPath = true;
        bevelEnabled = false; // bevels not supported for path extrusion

        // SETUP TNB variables

        // TODO1 - have a .isClosed in spline?

        splineTube = extrudePath.computeFrenetFrames(steps, false);

        // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

        binormal = new Vector3();
        normal = new Vector3();
        position2 = new Vector3();
      }

      // Safeguards if bevels are not enabled

      if (!bevelEnabled) {
        bevelSegments = 0;
        bevelThickness = 0;
        bevelSize = 0;
        bevelOffset = 0;
      }

      // Variables initialization

      const shapePoints = shape.extractPoints(curveSegments);
      let vertices = shapePoints.shape;
      const holes = shapePoints.holes;
      const reverse = !ShapeUtils.isClockWise(vertices);
      if (reverse) {
        vertices = vertices.reverse();

        // Maybe we should also check if holes are in the opposite direction, just to be safe ...

        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          if (ShapeUtils.isClockWise(ahole)) {
            holes[h] = ahole.reverse();
          }
        }
      }
      const faces = ShapeUtils.triangulateShape(vertices, holes);

      /* Vertices */

      const contour = vertices; // vertices has all points but contour has only points of circumference

      for (let h = 0, hl = holes.length; h < hl; h++) {
        const ahole = holes[h];
        vertices = vertices.concat(ahole);
      }
      function scalePt2(pt, vec, size) {
        if (!vec) console.error('THREE.ExtrudeGeometry: vec does not exist');
        return vec.clone().multiplyScalar(size).add(pt);
      }
      const vlen = vertices.length,
        flen = faces.length;

      // Find directions for point movement

      function getBevelVec(inPt, inPrev, inNext) {
        // computes for inPt the corresponding point inPt' on a new contour
        //   shifted by 1 unit (length of normalized vector) to the left
        // if we walk along contour clockwise, this new contour is outside the old one
        //
        // inPt' is the intersection of the two lines parallel to the two
        //  adjacent edges of inPt at a distance of 1 unit on the left side.

        let v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt

        // good reading for geometry algorithms (here: line-line intersection)
        // http://geomalgorithms.com/a05-_intersect-1.html

        const v_prev_x = inPt.x - inPrev.x,
          v_prev_y = inPt.y - inPrev.y;
        const v_next_x = inNext.x - inPt.x,
          v_next_y = inNext.y - inPt.y;
        const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;

        // check for collinear edges
        const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
        if (Math.abs(collinear0) > Number.EPSILON) {
          // not collinear

          // length of vectors for normalizing

          const v_prev_len = Math.sqrt(v_prev_lensq);
          const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);

          // shift adjacent points by unit vectors to the left

          const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
          const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
          const ptNextShift_x = inNext.x - v_next_y / v_next_len;
          const ptNextShift_y = inNext.y + v_next_x / v_next_len;

          // scaling factor for v_prev to intersection point

          const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);

          // vector from inPt to intersection point

          v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
          v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;

          // Don't normalize!, otherwise sharp corners become ugly
          //  but prevent crazy spikes
          const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
          if (v_trans_lensq <= 2) {
            return new Vector2(v_trans_x, v_trans_y);
          } else {
            shrink_by = Math.sqrt(v_trans_lensq / 2);
          }
        } else {
          // handle special case of collinear edges

          let direction_eq = false; // assumes: opposite

          if (v_prev_x > Number.EPSILON) {
            if (v_next_x > Number.EPSILON) {
              direction_eq = true;
            }
          } else {
            if (v_prev_x < -Number.EPSILON) {
              if (v_next_x < -Number.EPSILON) {
                direction_eq = true;
              }
            } else {
              if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                direction_eq = true;
              }
            }
          }
          if (direction_eq) {
            // console.log("Warning: lines are a straight sequence");
            v_trans_x = -v_prev_y;
            v_trans_y = v_prev_x;
            shrink_by = Math.sqrt(v_prev_lensq);
          } else {
            // console.log("Warning: lines are a straight spike");
            v_trans_x = v_prev_x;
            v_trans_y = v_prev_y;
            shrink_by = Math.sqrt(v_prev_lensq / 2);
          }
        }
        return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
      }
      const contourMovements = [];
      for (let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
        if (j === il) j = 0;
        if (k === il) k = 0;

        //  (j)---(i)---(k)
        // console.log('i,j,k', i, j , k)

        contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
      }
      const holesMovements = [];
      let oneHoleMovements,
        verticesMovements = contourMovements.concat();
      for (let h = 0, hl = holes.length; h < hl; h++) {
        const ahole = holes[h];
        oneHoleMovements = [];
        for (let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
          if (j === il) j = 0;
          if (k === il) k = 0;

          //  (j)---(i)---(k)
          oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
        }
        holesMovements.push(oneHoleMovements);
        verticesMovements = verticesMovements.concat(oneHoleMovements);
      }

      // Loop bevelSegments, 1 for the front, 1 for the back

      for (let b = 0; b < bevelSegments; b++) {
        //for ( b = bevelSegments; b > 0; b -- ) {

        const t = b / bevelSegments;
        const z = bevelThickness * Math.cos(t * Math.PI / 2);
        const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;

        // contract shape

        for (let i = 0, il = contour.length; i < il; i++) {
          const vert = scalePt2(contour[i], contourMovements[i], bs);
          v(vert.x, vert.y, -z);
        }

        // expand holes

        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          oneHoleMovements = holesMovements[h];
          for (let i = 0, il = ahole.length; i < il; i++) {
            const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
            v(vert.x, vert.y, -z);
          }
        }
      }
      const bs = bevelSize + bevelOffset;

      // Back facing vertices

      for (let i = 0; i < vlen; i++) {
        const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
        if (!extrudeByPath) {
          v(vert.x, vert.y, 0);
        } else {
          // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

          normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
          binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
          position2.copy(extrudePts[0]).add(normal).add(binormal);
          v(position2.x, position2.y, position2.z);
        }
      }

      // Add stepped vertices...
      // Including front facing vertices

      for (let s = 1; s <= steps; s++) {
        for (let i = 0; i < vlen; i++) {
          const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
          if (!extrudeByPath) {
            v(vert.x, vert.y, depth / steps * s);
          } else {
            // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

            normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
            binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
            position2.copy(extrudePts[s]).add(normal).add(binormal);
            v(position2.x, position2.y, position2.z);
          }
        }
      }

      // Add bevel segments planes

      //for ( b = 1; b <= bevelSegments; b ++ ) {
      for (let b = bevelSegments - 1; b >= 0; b--) {
        const t = b / bevelSegments;
        const z = bevelThickness * Math.cos(t * Math.PI / 2);
        const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;

        // contract shape

        for (let i = 0, il = contour.length; i < il; i++) {
          const vert = scalePt2(contour[i], contourMovements[i], bs);
          v(vert.x, vert.y, depth + z);
        }

        // expand holes

        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          oneHoleMovements = holesMovements[h];
          for (let i = 0, il = ahole.length; i < il; i++) {
            const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
            if (!extrudeByPath) {
              v(vert.x, vert.y, depth + z);
            } else {
              v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
            }
          }
        }
      }

      /* Faces */

      // Top and bottom faces

      buildLidFaces();

      // Sides faces

      buildSideFaces();

      /////  Internal functions

      function buildLidFaces() {
        const start = verticesArray.length / 3;
        if (bevelEnabled) {
          let layer = 0; // steps + 1
          let offset = vlen * layer;

          // Bottom faces

          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[2] + offset, face[1] + offset, face[0] + offset);
          }
          layer = steps + bevelSegments * 2;
          offset = vlen * layer;

          // Top faces

          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[0] + offset, face[1] + offset, face[2] + offset);
          }
        } else {
          // Bottom faces

          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[2], face[1], face[0]);
          }

          // Top faces

          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
          }
        }
        scope.addGroup(start, verticesArray.length / 3 - start, 0);
      }

      // Create faces for the z-sides of the shape

      function buildSideFaces() {
        const start = verticesArray.length / 3;
        let layeroffset = 0;
        sidewalls(contour, layeroffset);
        layeroffset += contour.length;
        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          sidewalls(ahole, layeroffset);

          //, true
          layeroffset += ahole.length;
        }
        scope.addGroup(start, verticesArray.length / 3 - start, 1);
      }
      function sidewalls(contour, layeroffset) {
        let i = contour.length;
        while (--i >= 0) {
          const j = i;
          let k = i - 1;
          if (k < 0) k = contour.length - 1;

          //console.log('b', i,j, i-1, k,vertices.length);

          for (let s = 0, sl = steps + bevelSegments * 2; s < sl; s++) {
            const slen1 = vlen * s;
            const slen2 = vlen * (s + 1);
            const a = layeroffset + j + slen1,
              b = layeroffset + k + slen1,
              c = layeroffset + k + slen2,
              d = layeroffset + j + slen2;
            f4(a, b, c, d);
          }
        }
      }
      function v(x, y, z) {
        placeholder.push(x);
        placeholder.push(y);
        placeholder.push(z);
      }
      function f3(a, b, c) {
        addVertex(a);
        addVertex(b);
        addVertex(c);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[2]);
      }
      function f4(a, b, c, d) {
        addVertex(a);
        addVertex(b);
        addVertex(d);
        addVertex(b);
        addVertex(c);
        addVertex(d);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[3]);
        addUV(uvs[1]);
        addUV(uvs[2]);
        addUV(uvs[3]);
      }
      function addVertex(index) {
        verticesArray.push(placeholder[index * 3 + 0]);
        verticesArray.push(placeholder[index * 3 + 1]);
        verticesArray.push(placeholder[index * 3 + 2]);
      }
      function addUV(vector2) {
        uvArray.push(vector2.x);
        uvArray.push(vector2.y);
      }
    }
  }
  toJSON() {
    const data = BufferGeometry.prototype.toJSON.call(this);
    const shapes = this.parameters.shapes;
    const options = this.parameters.options;
    return toJSON(shapes, options, data);
  }
}
exports.ExtrudeGeometry = exports.ExtrudeBufferGeometry = ExtrudeGeometry;
const WorldUVGenerator = {
  generateTopUV: function (geometry, vertices, indexA, indexB, indexC) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    return [new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y)];
  },
  generateSideWallUV: function (geometry, vertices, indexA, indexB, indexC, indexD) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const a_z = vertices[indexA * 3 + 2];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const b_z = vertices[indexB * 3 + 2];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    const c_z = vertices[indexC * 3 + 2];
    const d_x = vertices[indexD * 3];
    const d_y = vertices[indexD * 3 + 1];
    const d_z = vertices[indexD * 3 + 2];
    if (Math.abs(a_y - b_y) < 0.01) {
      return [new Vector2(a_x, 1 - a_z), new Vector2(b_x, 1 - b_z), new Vector2(c_x, 1 - c_z), new Vector2(d_x, 1 - d_z)];
    } else {
      return [new Vector2(a_y, 1 - a_z), new Vector2(b_y, 1 - b_z), new Vector2(c_y, 1 - c_z), new Vector2(d_y, 1 - d_z)];
    }
  }
};
function toJSON(shapes, options, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (let i = 0, l = shapes.length; i < l; i++) {
      const shape = shapes[i];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  if (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();
  return data;
}
class IcosahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const t = (1 + Math.sqrt(5)) / 2;
    const vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1];
    const indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
    super(vertices, indices, radius, detail);
    this.type = 'IcosahedronGeometry';
    this.parameters = {
      radius: radius,
      detail: detail
    };
  }
}
exports.IcosahedronGeometry = exports.IcosahedronBufferGeometry = IcosahedronGeometry;
class LatheGeometry extends BufferGeometry {
  constructor(points, segments = 12, phiStart = 0, phiLength = Math.PI * 2) {
    super();
    this.type = 'LatheGeometry';
    this.parameters = {
      points: points,
      segments: segments,
      phiStart: phiStart,
      phiLength: phiLength
    };
    segments = Math.floor(segments);

    // clamp phiLength so it's in range of [ 0, 2PI ]

    phiLength = MathUtils.clamp(phiLength, 0, Math.PI * 2);

    // buffers

    const indices = [];
    const vertices = [];
    const uvs = [];

    // helper variables

    const inverseSegments = 1.0 / segments;
    const vertex = new Vector3();
    const uv = new Vector2();

    // generate vertices and uvs

    for (let i = 0; i <= segments; i++) {
      const phi = phiStart + i * inverseSegments * phiLength;
      const sin = Math.sin(phi);
      const cos = Math.cos(phi);
      for (let j = 0; j <= points.length - 1; j++) {
        // vertex

        vertex.x = points[j].x * sin;
        vertex.y = points[j].y;
        vertex.z = points[j].x * cos;
        vertices.push(vertex.x, vertex.y, vertex.z);

        // uv

        uv.x = i / segments;
        uv.y = j / (points.length - 1);
        uvs.push(uv.x, uv.y);
      }
    }

    // indices

    for (let i = 0; i < segments; i++) {
      for (let j = 0; j < points.length - 1; j++) {
        const base = j + i * points.length;
        const a = base;
        const b = base + points.length;
        const c = base + points.length + 1;
        const d = base + 1;

        // faces

        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }

    // build geometry

    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

    // generate normals

    this.computeVertexNormals();

    // if the geometry is closed, we need to average the normals along the seam.
    // because the corresponding vertices are identical (but still have different UVs).

    if (phiLength === Math.PI * 2) {
      const normals = this.attributes.normal.array;
      const n1 = new Vector3();
      const n2 = new Vector3();
      const n = new Vector3();

      // this is the buffer offset for the last line of vertices

      const base = segments * points.length * 3;
      for (let i = 0, j = 0; i < points.length; i++, j += 3) {
        // select the normal of the vertex in the first line

        n1.x = normals[j + 0];
        n1.y = normals[j + 1];
        n1.z = normals[j + 2];

        // select the normal of the vertex in the last line

        n2.x = normals[base + j + 0];
        n2.y = normals[base + j + 1];
        n2.z = normals[base + j + 2];

        // average normals

        n.addVectors(n1, n2).normalize();

        // assign the new values to both normals

        normals[j + 0] = normals[base + j + 0] = n.x;
        normals[j + 1] = normals[base + j + 1] = n.y;
        normals[j + 2] = normals[base + j + 2] = n.z;
      }
    }
  }
}
exports.LatheGeometry = exports.LatheBufferGeometry = LatheGeometry;
class OctahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];
    const indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
    super(vertices, indices, radius, detail);
    this.type = 'OctahedronGeometry';
    this.parameters = {
      radius: radius,
      detail: detail
    };
  }
}

/**
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html
 */
exports.OctahedronGeometry = exports.OctahedronBufferGeometry = OctahedronGeometry;
function ParametricGeometry(func, slices, stacks) {
  BufferGeometry.call(this);
  this.type = 'ParametricGeometry';
  this.parameters = {
    func: func,
    slices: slices,
    stacks: stacks
  };

  // buffers

  const indices = [];
  const vertices = [];
  const normals = [];
  const uvs = [];
  const EPS = 0.00001;
  const normal = new Vector3();
  const p0 = new Vector3(),
    p1 = new Vector3();
  const pu = new Vector3(),
    pv = new Vector3();
  if (func.length < 3) {
    console.error('THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.');
  }

  // generate vertices, normals and uvs

  const sliceCount = slices + 1;
  for (let i = 0; i <= stacks; i++) {
    const v = i / stacks;
    for (let j = 0; j <= slices; j++) {
      const u = j / slices;

      // vertex

      func(u, v, p0);
      vertices.push(p0.x, p0.y, p0.z);

      // normal

      // approximate tangent vectors via finite differences

      if (u - EPS >= 0) {
        func(u - EPS, v, p1);
        pu.subVectors(p0, p1);
      } else {
        func(u + EPS, v, p1);
        pu.subVectors(p1, p0);
      }
      if (v - EPS >= 0) {
        func(u, v - EPS, p1);
        pv.subVectors(p0, p1);
      } else {
        func(u, v + EPS, p1);
        pv.subVectors(p1, p0);
      }

      // cross product of tangent vectors returns surface normal

      normal.crossVectors(pu, pv).normalize();
      normals.push(normal.x, normal.y, normal.z);

      // uv

      uvs.push(u, v);
    }
  }

  // generate indices

  for (let i = 0; i < stacks; i++) {
    for (let j = 0; j < slices; j++) {
      const a = i * sliceCount + j;
      const b = i * sliceCount + j + 1;
      const c = (i + 1) * sliceCount + j + 1;
      const d = (i + 1) * sliceCount + j;

      // faces one and two

      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  }

  // build geometry

  this.setIndex(indices);
  this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
  this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
  this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
}
ParametricGeometry.prototype = Object.create(BufferGeometry.prototype);
ParametricGeometry.prototype.constructor = ParametricGeometry;
class RingGeometry extends BufferGeometry {
  constructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = 'RingGeometry';
    this.parameters = {
      innerRadius: innerRadius,
      outerRadius: outerRadius,
      thetaSegments: thetaSegments,
      phiSegments: phiSegments,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    thetaSegments = Math.max(3, thetaSegments);
    phiSegments = Math.max(1, phiSegments);

    // buffers

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];

    // some helper variables

    let radius = innerRadius;
    const radiusStep = (outerRadius - innerRadius) / phiSegments;
    const vertex = new Vector3();
    const uv = new Vector2();

    // generate vertices, normals and uvs

    for (let j = 0; j <= phiSegments; j++) {
      for (let i = 0; i <= thetaSegments; i++) {
        // values are generate from the inside of the ring to the outside

        const segment = thetaStart + i / thetaSegments * thetaLength;

        // vertex

        vertex.x = radius * Math.cos(segment);
        vertex.y = radius * Math.sin(segment);
        vertices.push(vertex.x, vertex.y, vertex.z);

        // normal

        normals.push(0, 0, 1);

        // uv

        uv.x = (vertex.x / outerRadius + 1) / 2;
        uv.y = (vertex.y / outerRadius + 1) / 2;
        uvs.push(uv.x, uv.y);
      }

      // increase the radius for next row of vertices

      radius += radiusStep;
    }

    // indices

    for (let j = 0; j < phiSegments; j++) {
      const thetaSegmentLevel = j * (thetaSegments + 1);
      for (let i = 0; i < thetaSegments; i++) {
        const segment = i + thetaSegmentLevel;
        const a = segment;
        const b = segment + thetaSegments + 1;
        const c = segment + thetaSegments + 2;
        const d = segment + 1;

        // faces

        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }

    // build geometry

    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
  }
}
exports.RingGeometry = exports.RingBufferGeometry = RingGeometry;
class ShapeGeometry extends BufferGeometry {
  constructor(shapes, curveSegments = 12) {
    super();
    this.type = 'ShapeGeometry';
    this.parameters = {
      shapes: shapes,
      curveSegments: curveSegments
    };

    // buffers

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];

    // helper variables

    let groupStart = 0;
    let groupCount = 0;

    // allow single and array values for "shapes" parameter

    if (Array.isArray(shapes) === false) {
      addShape(shapes);
    } else {
      for (let i = 0; i < shapes.length; i++) {
        addShape(shapes[i]);
        this.addGroup(groupStart, groupCount, i); // enables MultiMaterial support

        groupStart += groupCount;
        groupCount = 0;
      }
    }

    // build geometry

    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

    // helper functions

    function addShape(shape) {
      const indexOffset = vertices.length / 3;
      const points = shape.extractPoints(curveSegments);
      let shapeVertices = points.shape;
      const shapeHoles = points.holes;

      // check direction of vertices

      if (ShapeUtils.isClockWise(shapeVertices) === false) {
        shapeVertices = shapeVertices.reverse();
      }
      for (let i = 0, l = shapeHoles.length; i < l; i++) {
        const shapeHole = shapeHoles[i];
        if (ShapeUtils.isClockWise(shapeHole) === true) {
          shapeHoles[i] = shapeHole.reverse();
        }
      }
      const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);

      // join vertices of inner and outer paths to a single array

      for (let i = 0, l = shapeHoles.length; i < l; i++) {
        const shapeHole = shapeHoles[i];
        shapeVertices = shapeVertices.concat(shapeHole);
      }

      // vertices, normals, uvs

      for (let i = 0, l = shapeVertices.length; i < l; i++) {
        const vertex = shapeVertices[i];
        vertices.push(vertex.x, vertex.y, 0);
        normals.push(0, 0, 1);
        uvs.push(vertex.x, vertex.y); // world uvs
      }

      // incides

      for (let i = 0, l = faces.length; i < l; i++) {
        const face = faces[i];
        const a = face[0] + indexOffset;
        const b = face[1] + indexOffset;
        const c = face[2] + indexOffset;
        indices.push(a, b, c);
        groupCount += 3;
      }
    }
  }
  toJSON() {
    const data = BufferGeometry.prototype.toJSON.call(this);
    const shapes = this.parameters.shapes;
    return toJSON$1(shapes, data);
  }
}
exports.ShapeGeometry = exports.ShapeBufferGeometry = ShapeGeometry;
function toJSON$1(shapes, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (let i = 0, l = shapes.length; i < l; i++) {
      const shape = shapes[i];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  return data;
}
class SphereGeometry extends BufferGeometry {
  constructor(radius = 1, widthSegments = 8, heightSegments = 6, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
    super();
    this.type = 'SphereGeometry';
    this.parameters = {
      radius: radius,
      widthSegments: widthSegments,
      heightSegments: heightSegments,
      phiStart: phiStart,
      phiLength: phiLength,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    widthSegments = Math.max(3, Math.floor(widthSegments));
    heightSegments = Math.max(2, Math.floor(heightSegments));
    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
    let index = 0;
    const grid = [];
    const vertex = new Vector3();
    const normal = new Vector3();

    // buffers

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];

    // generate vertices, normals and uvs

    for (let iy = 0; iy <= heightSegments; iy++) {
      const verticesRow = [];
      const v = iy / heightSegments;

      // special case for the poles

      let uOffset = 0;
      if (iy == 0 && thetaStart == 0) {
        uOffset = 0.5 / widthSegments;
      } else if (iy == heightSegments && thetaEnd == Math.PI) {
        uOffset = -0.5 / widthSegments;
      }
      for (let ix = 0; ix <= widthSegments; ix++) {
        const u = ix / widthSegments;

        // vertex

        vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
        vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertices.push(vertex.x, vertex.y, vertex.z);

        // normal

        normal.copy(vertex).normalize();
        normals.push(normal.x, normal.y, normal.z);

        // uv

        uvs.push(u + uOffset, 1 - v);
        verticesRow.push(index++);
      }
      grid.push(verticesRow);
    }

    // indices

    for (let iy = 0; iy < heightSegments; iy++) {
      for (let ix = 0; ix < widthSegments; ix++) {
        const a = grid[iy][ix + 1];
        const b = grid[iy][ix];
        const c = grid[iy + 1][ix];
        const d = grid[iy + 1][ix + 1];
        if (iy !== 0 || thetaStart > 0) indices.push(a, b, d);
        if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);
      }
    }

    // build geometry

    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
  }
}
exports.SphereGeometry = exports.SphereBufferGeometry = SphereGeometry;
class TetrahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];
    const indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
    super(vertices, indices, radius, detail);
    this.type = 'TetrahedronGeometry';
    this.parameters = {
      radius: radius,
      detail: detail
    };
  }
}

/**
 * Text = 3D Text
 *
 * parameters = {
 *  font: <THREE.Font>, // font
 *
 *  size: <float>, // size of the text
 *  height: <float>, // thickness to extrude text
 *  curveSegments: <int>, // number of points on the curves
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into text bevel goes
 *  bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel
 *  bevelOffset: <float> // how far from text outline does bevel start
 * }
 */
exports.TetrahedronGeometry = exports.TetrahedronBufferGeometry = TetrahedronGeometry;
class TextGeometry extends ExtrudeGeometry {
  constructor(text, parameters = {}) {
    const font = parameters.font;
    if (!(font && font.isFont)) {
      console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');
      return new BufferGeometry();
    }
    const shapes = font.generateShapes(text, parameters.size);

    // translate parameters to ExtrudeGeometry API

    parameters.depth = parameters.height !== undefined ? parameters.height : 50;

    // defaults

    if (parameters.bevelThickness === undefined) parameters.bevelThickness = 10;
    if (parameters.bevelSize === undefined) parameters.bevelSize = 8;
    if (parameters.bevelEnabled === undefined) parameters.bevelEnabled = false;
    super(shapes, parameters);
    this.type = 'TextGeometry';
  }
}
exports.TextGeometry = exports.TextBufferGeometry = TextGeometry;
class TorusGeometry extends BufferGeometry {
  constructor(radius = 1, tube = 0.4, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2) {
    super();
    this.type = 'TorusGeometry';
    this.parameters = {
      radius: radius,
      tube: tube,
      radialSegments: radialSegments,
      tubularSegments: tubularSegments,
      arc: arc
    };
    radialSegments = Math.floor(radialSegments);
    tubularSegments = Math.floor(tubularSegments);

    // buffers

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];

    // helper variables

    const center = new Vector3();
    const vertex = new Vector3();
    const normal = new Vector3();

    // generate vertices, normals and uvs

    for (let j = 0; j <= radialSegments; j++) {
      for (let i = 0; i <= tubularSegments; i++) {
        const u = i / tubularSegments * arc;
        const v = j / radialSegments * Math.PI * 2;

        // vertex

        vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
        vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
        vertex.z = tube * Math.sin(v);
        vertices.push(vertex.x, vertex.y, vertex.z);

        // normal

        center.x = radius * Math.cos(u);
        center.y = radius * Math.sin(u);
        normal.subVectors(vertex, center).normalize();
        normals.push(normal.x, normal.y, normal.z);

        // uv

        uvs.push(i / tubularSegments);
        uvs.push(j / radialSegments);
      }
    }

    // generate indices

    for (let j = 1; j <= radialSegments; j++) {
      for (let i = 1; i <= tubularSegments; i++) {
        // indices

        const a = (tubularSegments + 1) * j + i - 1;
        const b = (tubularSegments + 1) * (j - 1) + i - 1;
        const c = (tubularSegments + 1) * (j - 1) + i;
        const d = (tubularSegments + 1) * j + i;

        // faces

        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }

    // build geometry

    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
  }
}
exports.TorusGeometry = exports.TorusBufferGeometry = TorusGeometry;
class TorusKnotGeometry extends BufferGeometry {
  constructor(radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3) {
    super();
    this.type = 'TorusKnotGeometry';
    this.parameters = {
      radius: radius,
      tube: tube,
      tubularSegments: tubularSegments,
      radialSegments: radialSegments,
      p: p,
      q: q
    };
    tubularSegments = Math.floor(tubularSegments);
    radialSegments = Math.floor(radialSegments);

    // buffers

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];

    // helper variables

    const vertex = new Vector3();
    const normal = new Vector3();
    const P1 = new Vector3();
    const P2 = new Vector3();
    const B = new Vector3();
    const T = new Vector3();
    const N = new Vector3();

    // generate vertices, normals and uvs

    for (let i = 0; i <= tubularSegments; ++i) {
      // the radian "u" is used to calculate the position on the torus curve of the current tubular segement

      const u = i / tubularSegments * p * Math.PI * 2;

      // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
      // these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

      calculatePositionOnCurve(u, p, q, radius, P1);
      calculatePositionOnCurve(u + 0.01, p, q, radius, P2);

      // calculate orthonormal basis

      T.subVectors(P2, P1);
      N.addVectors(P2, P1);
      B.crossVectors(T, N);
      N.crossVectors(B, T);

      // normalize B, N. T can be ignored, we don't use it

      B.normalize();
      N.normalize();
      for (let j = 0; j <= radialSegments; ++j) {
        // now calculate the vertices. they are nothing more than an extrusion of the torus curve.
        // because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

        const v = j / radialSegments * Math.PI * 2;
        const cx = -tube * Math.cos(v);
        const cy = tube * Math.sin(v);

        // now calculate the final vertex position.
        // first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

        vertex.x = P1.x + (cx * N.x + cy * B.x);
        vertex.y = P1.y + (cx * N.y + cy * B.y);
        vertex.z = P1.z + (cx * N.z + cy * B.z);
        vertices.push(vertex.x, vertex.y, vertex.z);

        // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

        normal.subVectors(vertex, P1).normalize();
        normals.push(normal.x, normal.y, normal.z);

        // uv

        uvs.push(i / tubularSegments);
        uvs.push(j / radialSegments);
      }
    }

    // generate indices

    for (let j = 1; j <= tubularSegments; j++) {
      for (let i = 1; i <= radialSegments; i++) {
        // indices

        const a = (radialSegments + 1) * (j - 1) + (i - 1);
        const b = (radialSegments + 1) * j + (i - 1);
        const c = (radialSegments + 1) * j + i;
        const d = (radialSegments + 1) * (j - 1) + i;

        // faces

        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }

    // build geometry

    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

    // this function calculates the current position on the torus curve

    function calculatePositionOnCurve(u, p, q, radius, position) {
      const cu = Math.cos(u);
      const su = Math.sin(u);
      const quOverP = q / p * u;
      const cs = Math.cos(quOverP);
      position.x = radius * (2 + cs) * 0.5 * cu;
      position.y = radius * (2 + cs) * su * 0.5;
      position.z = radius * Math.sin(quOverP) * 0.5;
    }
  }
}
exports.TorusKnotGeometry = exports.TorusKnotBufferGeometry = TorusKnotGeometry;
class TubeGeometry extends BufferGeometry {
  constructor(path, tubularSegments = 64, radius = 1, radialSegments = 8, closed = false) {
    super();
    this.type = 'TubeGeometry';
    this.parameters = {
      path: path,
      tubularSegments: tubularSegments,
      radius: radius,
      radialSegments: radialSegments,
      closed: closed
    };
    const frames = path.computeFrenetFrames(tubularSegments, closed);

    // expose internals

    this.tangents = frames.tangents;
    this.normals = frames.normals;
    this.binormals = frames.binormals;

    // helper variables

    const vertex = new Vector3();
    const normal = new Vector3();
    const uv = new Vector2();
    let P = new Vector3();

    // buffer

    const vertices = [];
    const normals = [];
    const uvs = [];
    const indices = [];

    // create buffer data

    generateBufferData();

    // build geometry

    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

    // functions

    function generateBufferData() {
      for (let i = 0; i < tubularSegments; i++) {
        generateSegment(i);
      }

      // if the geometry is not closed, generate the last row of vertices and normals
      // at the regular position on the given path
      //
      // if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

      generateSegment(closed === false ? tubularSegments : 0);

      // uvs are generated in a separate function.
      // this makes it easy compute correct values for closed geometries

      generateUVs();

      // finally create faces

      generateIndices();
    }
    function generateSegment(i) {
      // we use getPointAt to sample evenly distributed points from the given path

      P = path.getPointAt(i / tubularSegments, P);

      // retrieve corresponding normal and binormal

      const N = frames.normals[i];
      const B = frames.binormals[i];

      // generate normals and vertices for the current segment

      for (let j = 0; j <= radialSegments; j++) {
        const v = j / radialSegments * Math.PI * 2;
        const sin = Math.sin(v);
        const cos = -Math.cos(v);

        // normal

        normal.x = cos * N.x + sin * B.x;
        normal.y = cos * N.y + sin * B.y;
        normal.z = cos * N.z + sin * B.z;
        normal.normalize();
        normals.push(normal.x, normal.y, normal.z);

        // vertex

        vertex.x = P.x + radius * normal.x;
        vertex.y = P.y + radius * normal.y;
        vertex.z = P.z + radius * normal.z;
        vertices.push(vertex.x, vertex.y, vertex.z);
      }
    }
    function generateIndices() {
      for (let j = 1; j <= tubularSegments; j++) {
        for (let i = 1; i <= radialSegments; i++) {
          const a = (radialSegments + 1) * (j - 1) + (i - 1);
          const b = (radialSegments + 1) * j + (i - 1);
          const c = (radialSegments + 1) * j + i;
          const d = (radialSegments + 1) * (j - 1) + i;

          // faces

          indices.push(a, b, d);
          indices.push(b, c, d);
        }
      }
    }
    function generateUVs() {
      for (let i = 0; i <= tubularSegments; i++) {
        for (let j = 0; j <= radialSegments; j++) {
          uv.x = i / tubularSegments;
          uv.y = j / radialSegments;
          uvs.push(uv.x, uv.y);
        }
      }
    }
  }
  toJSON() {
    const data = BufferGeometry.prototype.toJSON.call(this);
    data.path = this.parameters.path.toJSON();
    return data;
  }
}
exports.TubeGeometry = exports.TubeBufferGeometry = TubeGeometry;
class WireframeGeometry extends BufferGeometry {
  constructor(geometry) {
    super();
    this.type = 'WireframeGeometry';
    if (geometry.isGeometry === true) {
      console.error('THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
      return;
    }

    // buffer

    const vertices = [];

    // helper variables

    const edge = [0, 0],
      edges = {};
    const vertex = new Vector3();
    if (geometry.index !== null) {
      // indexed BufferGeometry

      const position = geometry.attributes.position;
      const indices = geometry.index;
      let groups = geometry.groups;
      if (groups.length === 0) {
        groups = [{
          start: 0,
          count: indices.count,
          materialIndex: 0
        }];
      }

      // create a data structure that contains all eges without duplicates

      for (let o = 0, ol = groups.length; o < ol; ++o) {
        const group = groups[o];
        const start = group.start;
        const count = group.count;
        for (let i = start, l = start + count; i < l; i += 3) {
          for (let j = 0; j < 3; j++) {
            const edge1 = indices.getX(i + j);
            const edge2 = indices.getX(i + (j + 1) % 3);
            edge[0] = Math.min(edge1, edge2); // sorting prevents duplicates
            edge[1] = Math.max(edge1, edge2);
            const key = edge[0] + ',' + edge[1];
            if (edges[key] === undefined) {
              edges[key] = {
                index1: edge[0],
                index2: edge[1]
              };
            }
          }
        }
      }

      // generate vertices

      for (const key in edges) {
        const e = edges[key];
        vertex.fromBufferAttribute(position, e.index1);
        vertices.push(vertex.x, vertex.y, vertex.z);
        vertex.fromBufferAttribute(position, e.index2);
        vertices.push(vertex.x, vertex.y, vertex.z);
      }
    } else {
      // non-indexed BufferGeometry

      const position = geometry.attributes.position;
      for (let i = 0, l = position.count / 3; i < l; i++) {
        for (let j = 0; j < 3; j++) {
          // three edges per triangle, an edge is represented as (index1, index2)
          // e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)

          const index1 = 3 * i + j;
          vertex.fromBufferAttribute(position, index1);
          vertices.push(vertex.x, vertex.y, vertex.z);
          const index2 = 3 * i + (j + 1) % 3;
          vertex.fromBufferAttribute(position, index2);
          vertices.push(vertex.x, vertex.y, vertex.z);
        }
      }
    }

    // build geometry

    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
  }
}
exports.WireframeGeometry = WireframeGeometry;
var Geometries = /*#__PURE__*/Object.freeze({
  __proto__: null,
  BoxGeometry: BoxGeometry,
  BoxBufferGeometry: BoxGeometry,
  CircleGeometry: CircleGeometry,
  CircleBufferGeometry: CircleGeometry,
  ConeGeometry: ConeGeometry,
  ConeBufferGeometry: ConeGeometry,
  CylinderGeometry: CylinderGeometry,
  CylinderBufferGeometry: CylinderGeometry,
  DodecahedronGeometry: DodecahedronGeometry,
  DodecahedronBufferGeometry: DodecahedronGeometry,
  EdgesGeometry: EdgesGeometry,
  ExtrudeGeometry: ExtrudeGeometry,
  ExtrudeBufferGeometry: ExtrudeGeometry,
  IcosahedronGeometry: IcosahedronGeometry,
  IcosahedronBufferGeometry: IcosahedronGeometry,
  LatheGeometry: LatheGeometry,
  LatheBufferGeometry: LatheGeometry,
  OctahedronGeometry: OctahedronGeometry,
  OctahedronBufferGeometry: OctahedronGeometry,
  ParametricGeometry: ParametricGeometry,
  ParametricBufferGeometry: ParametricGeometry,
  PlaneGeometry: PlaneGeometry,
  PlaneBufferGeometry: PlaneGeometry,
  PolyhedronGeometry: PolyhedronGeometry,
  PolyhedronBufferGeometry: PolyhedronGeometry,
  RingGeometry: RingGeometry,
  RingBufferGeometry: RingGeometry,
  ShapeGeometry: ShapeGeometry,
  ShapeBufferGeometry: ShapeGeometry,
  SphereGeometry: SphereGeometry,
  SphereBufferGeometry: SphereGeometry,
  TetrahedronGeometry: TetrahedronGeometry,
  TetrahedronBufferGeometry: TetrahedronGeometry,
  TextGeometry: TextGeometry,
  TextBufferGeometry: TextGeometry,
  TorusGeometry: TorusGeometry,
  TorusBufferGeometry: TorusGeometry,
  TorusKnotGeometry: TorusKnotGeometry,
  TorusKnotBufferGeometry: TorusKnotGeometry,
  TubeGeometry: TubeGeometry,
  TubeBufferGeometry: TubeGeometry,
  WireframeGeometry: WireframeGeometry
});

/**
 * parameters = {
 *  color: <THREE.Color>
 * }
 */

function ShadowMaterial(parameters) {
  Material.call(this);
  this.type = 'ShadowMaterial';
  this.color = new Color(0x000000);
  this.transparent = true;
  this.setValues(parameters);
}
ShadowMaterial.prototype = Object.create(Material.prototype);
ShadowMaterial.prototype.constructor = ShadowMaterial;
ShadowMaterial.prototype.isShadowMaterial = true;
ShadowMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  return this;
};
function RawShaderMaterial(parameters) {
  ShaderMaterial.call(this, parameters);
  this.type = 'RawShaderMaterial';
}
RawShaderMaterial.prototype = Object.create(ShaderMaterial.prototype);
RawShaderMaterial.prototype.constructor = RawShaderMaterial;
RawShaderMaterial.prototype.isRawShaderMaterial = true;

/**
 * parameters = {
 *  color: <hex>,
 *  roughness: <float>,
 *  metalness: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  roughnessMap: new THREE.Texture( <Image> ),
 *
 *  metalnessMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  envMapIntensity: <float>
 *
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshStandardMaterial(parameters) {
  Material.call(this);
  this.defines = {
    'STANDARD': ''
  };
  this.type = 'MeshStandardMaterial';
  this.color = new Color(0xffffff); // diffuse
  this.roughness = 1.0;
  this.metalness = 0.0;
  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1.0;
  this.aoMap = null;
  this.aoMapIntensity = 1.0;
  this.emissive = new Color(0x000000);
  this.emissiveIntensity = 1.0;
  this.emissiveMap = null;
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalMapType = TangentSpaceNormalMap;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.roughnessMap = null;
  this.metalnessMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.envMapIntensity = 1.0;
  this.refractionRatio = 0.98;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.vertexTangents = false;
  this.setValues(parameters);
}
MeshStandardMaterial.prototype = Object.create(Material.prototype);
MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;
MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
MeshStandardMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.defines = {
    'STANDARD': ''
  };
  this.color.copy(source.color);
  this.roughness = source.roughness;
  this.metalness = source.metalness;
  this.map = source.map;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.emissive.copy(source.emissive);
  this.emissiveMap = source.emissiveMap;
  this.emissiveIntensity = source.emissiveIntensity;
  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;
  this.normalMap = source.normalMap;
  this.normalMapType = source.normalMapType;
  this.normalScale.copy(source.normalScale);
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.roughnessMap = source.roughnessMap;
  this.metalnessMap = source.metalnessMap;
  this.alphaMap = source.alphaMap;
  this.envMap = source.envMap;
  this.envMapIntensity = source.envMapIntensity;
  this.refractionRatio = source.refractionRatio;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  this.vertexTangents = source.vertexTangents;
  return this;
};

/**
 * parameters = {
 *  clearcoat: <float>,
 *  clearcoatMap: new THREE.Texture( <Image> ),
 *  clearcoatRoughness: <float>,
 *  clearcoatRoughnessMap: new THREE.Texture( <Image> ),
 *  clearcoatNormalScale: <Vector2>,
 *  clearcoatNormalMap: new THREE.Texture( <Image> ),
 *
 *  reflectivity: <float>,
 *  ior: <float>,
 *
 *  sheen: <Color>,
 *
 *  transmission: <float>,
 *  transmissionMap: new THREE.Texture( <Image> )
 * }
 */

function MeshPhysicalMaterial(parameters) {
  MeshStandardMaterial.call(this);
  this.defines = {
    'STANDARD': '',
    'PHYSICAL': ''
  };
  this.type = 'MeshPhysicalMaterial';
  this.clearcoat = 0.0;
  this.clearcoatMap = null;
  this.clearcoatRoughness = 0.0;
  this.clearcoatRoughnessMap = null;
  this.clearcoatNormalScale = new Vector2(1, 1);
  this.clearcoatNormalMap = null;
  this.reflectivity = 0.5; // maps to F0 = 0.04

  Object.defineProperty(this, 'ior', {
    get: function () {
      return (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity);
    },
    set: function (ior) {
      this.reflectivity = MathUtils.clamp(2.5 * (ior - 1) / (ior + 1), 0, 1);
    }
  });
  this.sheen = null; // null will disable sheen bsdf

  this.transmission = 0.0;
  this.transmissionMap = null;
  this.setValues(parameters);
}
MeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial.prototype);
MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;
MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
MeshPhysicalMaterial.prototype.copy = function (source) {
  MeshStandardMaterial.prototype.copy.call(this, source);
  this.defines = {
    'STANDARD': '',
    'PHYSICAL': ''
  };
  this.clearcoat = source.clearcoat;
  this.clearcoatMap = source.clearcoatMap;
  this.clearcoatRoughness = source.clearcoatRoughness;
  this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
  this.clearcoatNormalMap = source.clearcoatNormalMap;
  this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
  this.reflectivity = source.reflectivity;
  if (source.sheen) {
    this.sheen = (this.sheen || new Color()).copy(source.sheen);
  } else {
    this.sheen = null;
  }
  this.transmission = source.transmission;
  this.transmissionMap = source.transmissionMap;
  return this;
};

/**
 * parameters = {
 *  color: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.MultiplyOperation,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshPhongMaterial(parameters) {
  Material.call(this);
  this.type = 'MeshPhongMaterial';
  this.color = new Color(0xffffff); // diffuse
  this.specular = new Color(0x111111);
  this.shininess = 30;
  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1.0;
  this.aoMap = null;
  this.aoMapIntensity = 1.0;
  this.emissive = new Color(0x000000);
  this.emissiveIntensity = 1.0;
  this.emissiveMap = null;
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalMapType = TangentSpaceNormalMap;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.specularMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.combine = MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
}
MeshPhongMaterial.prototype = Object.create(Material.prototype);
MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;
MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
MeshPhongMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.specular.copy(source.specular);
  this.shininess = source.shininess;
  this.map = source.map;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.emissive.copy(source.emissive);
  this.emissiveMap = source.emissiveMap;
  this.emissiveIntensity = source.emissiveIntensity;
  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;
  this.normalMap = source.normalMap;
  this.normalMapType = source.normalMapType;
  this.normalScale.copy(source.normalScale);
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.specularMap = source.specularMap;
  this.alphaMap = source.alphaMap;
  this.envMap = source.envMap;
  this.combine = source.combine;
  this.reflectivity = source.reflectivity;
  this.refractionRatio = source.refractionRatio;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  return this;
};

/**
 * parameters = {
 *  color: <hex>,
 *
 *  map: new THREE.Texture( <Image> ),
 *  gradientMap: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshToonMaterial(parameters) {
  Material.call(this);
  this.defines = {
    'TOON': ''
  };
  this.type = 'MeshToonMaterial';
  this.color = new Color(0xffffff);
  this.map = null;
  this.gradientMap = null;
  this.lightMap = null;
  this.lightMapIntensity = 1.0;
  this.aoMap = null;
  this.aoMapIntensity = 1.0;
  this.emissive = new Color(0x000000);
  this.emissiveIntensity = 1.0;
  this.emissiveMap = null;
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalMapType = TangentSpaceNormalMap;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.alphaMap = null;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
}
MeshToonMaterial.prototype = Object.create(Material.prototype);
MeshToonMaterial.prototype.constructor = MeshToonMaterial;
MeshToonMaterial.prototype.isMeshToonMaterial = true;
MeshToonMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.map = source.map;
  this.gradientMap = source.gradientMap;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.emissive.copy(source.emissive);
  this.emissiveMap = source.emissiveMap;
  this.emissiveIntensity = source.emissiveIntensity;
  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;
  this.normalMap = source.normalMap;
  this.normalMapType = source.normalMapType;
  this.normalScale.copy(source.normalScale);
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.alphaMap = source.alphaMap;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  return this;
};

/**
 * parameters = {
 *  opacity: <float>,
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshNormalMaterial(parameters) {
  Material.call(this);
  this.type = 'MeshNormalMaterial';
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalMapType = TangentSpaceNormalMap;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.fog = false;
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
}
MeshNormalMaterial.prototype = Object.create(Material.prototype);
MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;
MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
MeshNormalMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;
  this.normalMap = source.normalMap;
  this.normalMapType = source.normalMapType;
  this.normalScale.copy(source.normalScale);
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  return this;
};

/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshLambertMaterial(parameters) {
  Material.call(this);
  this.type = 'MeshLambertMaterial';
  this.color = new Color(0xffffff); // diffuse

  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1.0;
  this.aoMap = null;
  this.aoMapIntensity = 1.0;
  this.emissive = new Color(0x000000);
  this.emissiveIntensity = 1.0;
  this.emissiveMap = null;
  this.specularMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.combine = MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
}
MeshLambertMaterial.prototype = Object.create(Material.prototype);
MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;
MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
MeshLambertMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.map = source.map;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.emissive.copy(source.emissive);
  this.emissiveMap = source.emissiveMap;
  this.emissiveIntensity = source.emissiveIntensity;
  this.specularMap = source.specularMap;
  this.alphaMap = source.alphaMap;
  this.envMap = source.envMap;
  this.combine = source.combine;
  this.reflectivity = source.reflectivity;
  this.refractionRatio = source.refractionRatio;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  return this;
};

/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  matcap: new THREE.Texture( <Image> ),
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshMatcapMaterial(parameters) {
  Material.call(this);
  this.defines = {
    'MATCAP': ''
  };
  this.type = 'MeshMatcapMaterial';
  this.color = new Color(0xffffff); // diffuse

  this.matcap = null;
  this.map = null;
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalMapType = TangentSpaceNormalMap;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.alphaMap = null;
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
}
MeshMatcapMaterial.prototype = Object.create(Material.prototype);
MeshMatcapMaterial.prototype.constructor = MeshMatcapMaterial;
MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;
MeshMatcapMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.defines = {
    'MATCAP': ''
  };
  this.color.copy(source.color);
  this.matcap = source.matcap;
  this.map = source.map;
  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;
  this.normalMap = source.normalMap;
  this.normalMapType = source.normalMapType;
  this.normalScale.copy(source.normalScale);
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.alphaMap = source.alphaMap;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  return this;
};

/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>
 * }
 */

function LineDashedMaterial(parameters) {
  LineBasicMaterial.call(this);
  this.type = 'LineDashedMaterial';
  this.scale = 1;
  this.dashSize = 3;
  this.gapSize = 1;
  this.setValues(parameters);
}
LineDashedMaterial.prototype = Object.create(LineBasicMaterial.prototype);
LineDashedMaterial.prototype.constructor = LineDashedMaterial;
LineDashedMaterial.prototype.isLineDashedMaterial = true;
LineDashedMaterial.prototype.copy = function (source) {
  LineBasicMaterial.prototype.copy.call(this, source);
  this.scale = source.scale;
  this.dashSize = source.dashSize;
  this.gapSize = source.gapSize;
  return this;
};
var Materials = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ShadowMaterial: ShadowMaterial,
  SpriteMaterial: SpriteMaterial,
  RawShaderMaterial: RawShaderMaterial,
  ShaderMaterial: ShaderMaterial,
  PointsMaterial: PointsMaterial,
  MeshPhysicalMaterial: MeshPhysicalMaterial,
  MeshStandardMaterial: MeshStandardMaterial,
  MeshPhongMaterial: MeshPhongMaterial,
  MeshToonMaterial: MeshToonMaterial,
  MeshNormalMaterial: MeshNormalMaterial,
  MeshLambertMaterial: MeshLambertMaterial,
  MeshDepthMaterial: MeshDepthMaterial,
  MeshDistanceMaterial: MeshDistanceMaterial,
  MeshBasicMaterial: MeshBasicMaterial,
  MeshMatcapMaterial: MeshMatcapMaterial,
  LineDashedMaterial: LineDashedMaterial,
  LineBasicMaterial: LineBasicMaterial,
  Material: Material
});
const AnimationUtils = {
  // same as Array.prototype.slice, but also works on typed arrays
  arraySlice: function (array, from, to) {
    if (AnimationUtils.isTypedArray(array)) {
      // in ios9 array.subarray(from, undefined) will return empty array
      // but array.subarray(from) or array.subarray(from, len) is correct
      return new array.constructor(array.subarray(from, to !== undefined ? to : array.length));
    }
    return array.slice(from, to);
  },
  // converts an array to a specific type
  convertArray: function (array, type, forceClone) {
    if (!array ||
    // let 'undefined' and 'null' pass
    !forceClone && array.constructor === type) return array;
    if (typeof type.BYTES_PER_ELEMENT === 'number') {
      return new type(array); // create typed array
    }

    return Array.prototype.slice.call(array); // create Array
  },

  isTypedArray: function (object) {
    return ArrayBuffer.isView(object) && !(object instanceof DataView);
  },
  // returns an array by which times and values can be sorted
  getKeyframeOrder: function (times) {
    function compareTime(i, j) {
      return times[i] - times[j];
    }
    const n = times.length;
    const result = new Array(n);
    for (let i = 0; i !== n; ++i) result[i] = i;
    result.sort(compareTime);
    return result;
  },
  // uses the array previously returned by 'getKeyframeOrder' to sort data
  sortedArray: function (values, stride, order) {
    const nValues = values.length;
    const result = new values.constructor(nValues);
    for (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
      const srcOffset = order[i] * stride;
      for (let j = 0; j !== stride; ++j) {
        result[dstOffset++] = values[srcOffset + j];
      }
    }
    return result;
  },
  // function for parsing AOS keyframe formats
  flattenJSON: function (jsonKeys, times, values, valuePropertyName) {
    let i = 1,
      key = jsonKeys[0];
    while (key !== undefined && key[valuePropertyName] === undefined) {
      key = jsonKeys[i++];
    }
    if (key === undefined) return; // no data

    let value = key[valuePropertyName];
    if (value === undefined) return; // no data

    if (Array.isArray(value)) {
      do {
        value = key[valuePropertyName];
        if (value !== undefined) {
          times.push(key.time);
          values.push.apply(values, value); // push all elements
        }

        key = jsonKeys[i++];
      } while (key !== undefined);
    } else if (value.toArray !== undefined) {
      // ...assume THREE.Math-ish

      do {
        value = key[valuePropertyName];
        if (value !== undefined) {
          times.push(key.time);
          value.toArray(values, values.length);
        }
        key = jsonKeys[i++];
      } while (key !== undefined);
    } else {
      // otherwise push as-is

      do {
        value = key[valuePropertyName];
        if (value !== undefined) {
          times.push(key.time);
          values.push(value);
        }
        key = jsonKeys[i++];
      } while (key !== undefined);
    }
  },
  subclip: function (sourceClip, name, startFrame, endFrame, fps = 30) {
    const clip = sourceClip.clone();
    clip.name = name;
    const tracks = [];
    for (let i = 0; i < clip.tracks.length; ++i) {
      const track = clip.tracks[i];
      const valueSize = track.getValueSize();
      const times = [];
      const values = [];
      for (let j = 0; j < track.times.length; ++j) {
        const frame = track.times[j] * fps;
        if (frame < startFrame || frame >= endFrame) continue;
        times.push(track.times[j]);
        for (let k = 0; k < valueSize; ++k) {
          values.push(track.values[j * valueSize + k]);
        }
      }
      if (times.length === 0) continue;
      track.times = AnimationUtils.convertArray(times, track.times.constructor);
      track.values = AnimationUtils.convertArray(values, track.values.constructor);
      tracks.push(track);
    }
    clip.tracks = tracks;

    // find minimum .times value across all tracks in the trimmed clip

    let minStartTime = Infinity;
    for (let i = 0; i < clip.tracks.length; ++i) {
      if (minStartTime > clip.tracks[i].times[0]) {
        minStartTime = clip.tracks[i].times[0];
      }
    }

    // shift all tracks such that clip begins at t=0

    for (let i = 0; i < clip.tracks.length; ++i) {
      clip.tracks[i].shift(-1 * minStartTime);
    }
    clip.resetDuration();
    return clip;
  },
  makeClipAdditive: function (targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
    if (fps <= 0) fps = 30;
    const numTracks = referenceClip.tracks.length;
    const referenceTime = referenceFrame / fps;

    // Make each track's values relative to the values at the reference frame
    for (let i = 0; i < numTracks; ++i) {
      const referenceTrack = referenceClip.tracks[i];
      const referenceTrackType = referenceTrack.ValueTypeName;

      // Skip this track if it's non-numeric
      if (referenceTrackType === 'bool' || referenceTrackType === 'string') continue;

      // Find the track in the target clip whose name and type matches the reference track
      const targetTrack = targetClip.tracks.find(function (track) {
        return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
      });
      if (targetTrack === undefined) continue;
      let referenceOffset = 0;
      const referenceValueSize = referenceTrack.getValueSize();
      if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
        referenceOffset = referenceValueSize / 3;
      }
      let targetOffset = 0;
      const targetValueSize = targetTrack.getValueSize();
      if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
        targetOffset = targetValueSize / 3;
      }
      const lastIndex = referenceTrack.times.length - 1;
      let referenceValue;

      // Find the value to subtract out of the track
      if (referenceTime <= referenceTrack.times[0]) {
        // Reference frame is earlier than the first keyframe, so just use the first keyframe
        const startIndex = referenceOffset;
        const endIndex = referenceValueSize - referenceOffset;
        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
      } else if (referenceTime >= referenceTrack.times[lastIndex]) {
        // Reference frame is after the last keyframe, so just use the last keyframe
        const startIndex = lastIndex * referenceValueSize + referenceOffset;
        const endIndex = startIndex + referenceValueSize - referenceOffset;
        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
      } else {
        // Interpolate to the reference value
        const interpolant = referenceTrack.createInterpolant();
        const startIndex = referenceOffset;
        const endIndex = referenceValueSize - referenceOffset;
        interpolant.evaluate(referenceTime);
        referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);
      }

      // Conjugate the quaternion
      if (referenceTrackType === 'quaternion') {
        const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
        referenceQuat.toArray(referenceValue);
      }

      // Subtract the reference value from all of the track values

      const numTimes = targetTrack.times.length;
      for (let j = 0; j < numTimes; ++j) {
        const valueStart = j * targetValueSize + targetOffset;
        if (referenceTrackType === 'quaternion') {
          // Multiply the conjugate for quaternion track types
          Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
        } else {
          const valueEnd = targetValueSize - targetOffset * 2;

          // Subtract each value for all other numeric track types
          for (let k = 0; k < valueEnd; ++k) {
            targetTrack.values[valueStart + k] -= referenceValue[k];
          }
        }
      }
    }
    targetClip.blendMode = AdditiveAnimationBlendMode;
    return targetClip;
  }
};

/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 * 		http://www.oodesign.com/template-method-pattern.html
 *
 */
exports.AnimationUtils = AnimationUtils;
function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  this.parameterPositions = parameterPositions;
  this._cachedIndex = 0;
  this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);
  this.sampleValues = sampleValues;
  this.valueSize = sampleSize;
}
Object.assign(Interpolant.prototype, {
  evaluate: function (t) {
    const pp = this.parameterPositions;
    let i1 = this._cachedIndex,
      t1 = pp[i1],
      t0 = pp[i1 - 1];
    validate_interval: {
      seek: {
        let right;
        linear_scan: {
          //- See http://jsperf.com/comparison-to-undefined/3
          //- slower code:
          //-
          //- 				if ( t >= t1 || t1 === undefined ) {
          forward_scan: if (!(t < t1)) {
            for (let giveUpAt = i1 + 2;;) {
              if (t1 === undefined) {
                if (t < t0) break forward_scan;

                // after end

                i1 = pp.length;
                this._cachedIndex = i1;
                return this.afterEnd_(i1 - 1, t, t0);
              }
              if (i1 === giveUpAt) break; // this loop

              t0 = t1;
              t1 = pp[++i1];
              if (t < t1) {
                // we have arrived at the sought interval
                break seek;
              }
            }

            // prepare binary search on the right side of the index
            right = pp.length;
            break linear_scan;
          }

          //- slower code:
          //-					if ( t < t0 || t0 === undefined ) {
          if (!(t >= t0)) {
            // looping?

            const t1global = pp[1];
            if (t < t1global) {
              i1 = 2; // + 1, using the scan for the details
              t0 = t1global;
            }

            // linear reverse scan

            for (let giveUpAt = i1 - 2;;) {
              if (t0 === undefined) {
                // before start

                this._cachedIndex = 0;
                return this.beforeStart_(0, t, t1);
              }
              if (i1 === giveUpAt) break; // this loop

              t1 = t0;
              t0 = pp[--i1 - 1];
              if (t >= t0) {
                // we have arrived at the sought interval
                break seek;
              }
            }

            // prepare binary search on the left side of the index
            right = i1;
            i1 = 0;
            break linear_scan;
          }

          // the interval is valid

          break validate_interval;
        } // linear scan

        // binary search

        while (i1 < right) {
          const mid = i1 + right >>> 1;
          if (t < pp[mid]) {
            right = mid;
          } else {
            i1 = mid + 1;
          }
        }
        t1 = pp[i1];
        t0 = pp[i1 - 1];

        // check boundary cases, again

        if (t0 === undefined) {
          this._cachedIndex = 0;
          return this.beforeStart_(0, t, t1);
        }
        if (t1 === undefined) {
          i1 = pp.length;
          this._cachedIndex = i1;
          return this.afterEnd_(i1 - 1, t0, t);
        }
      } // seek

      this._cachedIndex = i1;
      this.intervalChanged_(i1, t0, t1);
    } // validate_interval

    return this.interpolate_(i1, t0, t, t1);
  },
  settings: null,
  // optional, subclass-specific settings structure
  // Note: The indirection allows central control of many interpolants.

  // --- Protected interface

  DefaultSettings_: {},
  getSettings_: function () {
    return this.settings || this.DefaultSettings_;
  },
  copySampleValue_: function (index) {
    // copies a sample value to the result buffer

    const result = this.resultBuffer,
      values = this.sampleValues,
      stride = this.valueSize,
      offset = index * stride;
    for (let i = 0; i !== stride; ++i) {
      result[i] = values[offset + i];
    }
    return result;
  },
  // Template methods for derived classes:

  interpolate_: function /* i1, t0, t, t1 */
  () {
    throw new Error('call to abstract method');
    // implementations shall return this.resultBuffer
  },

  intervalChanged_: function /* i1, t0, t1 */
  () {

    // empty
  }
});

// DECLARE ALIAS AFTER assign prototype
Object.assign(Interpolant.prototype, {
  //( 0, t, t0 ), returns this.resultBuffer
  beforeStart_: Interpolant.prototype.copySampleValue_,
  //( N-1, tN-1, t ), returns this.resultBuffer
  afterEnd_: Interpolant.prototype.copySampleValue_
});

/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 */

function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
  this._weightPrev = -0;
  this._offsetPrev = -0;
  this._weightNext = -0;
  this._offsetNext = -0;
}
CubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: CubicInterpolant,
  DefaultSettings_: {
    endingStart: ZeroCurvatureEnding,
    endingEnd: ZeroCurvatureEnding
  },
  intervalChanged_: function (i1, t0, t1) {
    const pp = this.parameterPositions;
    let iPrev = i1 - 2,
      iNext = i1 + 1,
      tPrev = pp[iPrev],
      tNext = pp[iNext];
    if (tPrev === undefined) {
      switch (this.getSettings_().endingStart) {
        case ZeroSlopeEnding:
          // f'(t0) = 0
          iPrev = i1;
          tPrev = 2 * t0 - t1;
          break;
        case WrapAroundEnding:
          // use the other end of the curve
          iPrev = pp.length - 2;
          tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
          break;
        default:
          // ZeroCurvatureEnding

          // f''(t0) = 0 a.k.a. Natural Spline
          iPrev = i1;
          tPrev = t1;
      }
    }
    if (tNext === undefined) {
      switch (this.getSettings_().endingEnd) {
        case ZeroSlopeEnding:
          // f'(tN) = 0
          iNext = i1;
          tNext = 2 * t1 - t0;
          break;
        case WrapAroundEnding:
          // use the other end of the curve
          iNext = 1;
          tNext = t1 + pp[1] - pp[0];
          break;
        default:
          // ZeroCurvatureEnding

          // f''(tN) = 0, a.k.a. Natural Spline
          iNext = i1 - 1;
          tNext = t0;
      }
    }
    const halfDt = (t1 - t0) * 0.5,
      stride = this.valueSize;
    this._weightPrev = halfDt / (t0 - tPrev);
    this._weightNext = halfDt / (tNext - t1);
    this._offsetPrev = iPrev * stride;
    this._offsetNext = iNext * stride;
  },
  interpolate_: function (i1, t0, t, t1) {
    const result = this.resultBuffer,
      values = this.sampleValues,
      stride = this.valueSize,
      o1 = i1 * stride,
      o0 = o1 - stride,
      oP = this._offsetPrev,
      oN = this._offsetNext,
      wP = this._weightPrev,
      wN = this._weightNext,
      p = (t - t0) / (t1 - t0),
      pp = p * p,
      ppp = pp * p;

    // evaluate polynomials

    const sP = -wP * ppp + 2 * wP * pp - wP * p;
    const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
    const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
    const sN = wN * ppp - wN * pp;

    // combine data linearly

    for (let i = 0; i !== stride; ++i) {
      result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
    }
    return result;
  }
});
function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
LinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: LinearInterpolant,
  interpolate_: function (i1, t0, t, t1) {
    const result = this.resultBuffer,
      values = this.sampleValues,
      stride = this.valueSize,
      offset1 = i1 * stride,
      offset0 = offset1 - stride,
      weight1 = (t - t0) / (t1 - t0),
      weight0 = 1 - weight1;
    for (let i = 0; i !== stride; ++i) {
      result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
    }
    return result;
  }
});

/**
 *
 * Interpolant that evaluates to the sample value at the position preceeding
 * the parameter.
 */

function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: DiscreteInterpolant,
  interpolate_: function (i1 /*, t0, t, t1 */) {
    return this.copySampleValue_(i1 - 1);
  }
});
function KeyframeTrack(name, times, values, interpolation) {
  if (name === undefined) throw new Error('THREE.KeyframeTrack: track name is undefined');
  if (times === undefined || times.length === 0) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name);
  this.name = name;
  this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
  this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
  this.setInterpolation(interpolation || this.DefaultInterpolation);
}

// Static methods

Object.assign(KeyframeTrack, {
  // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):

  toJSON: function (track) {
    const trackType = track.constructor;
    let json;

    // derived classes can define a static toJSON method
    if (trackType.toJSON !== undefined) {
      json = trackType.toJSON(track);
    } else {
      // by default, we assume the data can be serialized as-is
      json = {
        'name': track.name,
        'times': AnimationUtils.convertArray(track.times, Array),
        'values': AnimationUtils.convertArray(track.values, Array)
      };
      const interpolation = track.getInterpolation();
      if (interpolation !== track.DefaultInterpolation) {
        json.interpolation = interpolation;
      }
    }
    json.type = track.ValueTypeName; // mandatory

    return json;
  }
});
Object.assign(KeyframeTrack.prototype, {
  constructor: KeyframeTrack,
  TimeBufferType: Float32Array,
  ValueBufferType: Float32Array,
  DefaultInterpolation: InterpolateLinear,
  InterpolantFactoryMethodDiscrete: function (result) {
    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
  },
  InterpolantFactoryMethodLinear: function (result) {
    return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
  },
  InterpolantFactoryMethodSmooth: function (result) {
    return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
  },
  setInterpolation: function (interpolation) {
    let factoryMethod;
    switch (interpolation) {
      case InterpolateDiscrete:
        factoryMethod = this.InterpolantFactoryMethodDiscrete;
        break;
      case InterpolateLinear:
        factoryMethod = this.InterpolantFactoryMethodLinear;
        break;
      case InterpolateSmooth:
        factoryMethod = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (factoryMethod === undefined) {
      const message = 'unsupported interpolation for ' + this.ValueTypeName + ' keyframe track named ' + this.name;
      if (this.createInterpolant === undefined) {
        // fall back to default, unless the default itself is messed up
        if (interpolation !== this.DefaultInterpolation) {
          this.setInterpolation(this.DefaultInterpolation);
        } else {
          throw new Error(message); // fatal, in this case
        }
      }

      console.warn('THREE.KeyframeTrack:', message);
      return this;
    }
    this.createInterpolant = factoryMethod;
    return this;
  },
  getInterpolation: function () {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return InterpolateDiscrete;
      case this.InterpolantFactoryMethodLinear:
        return InterpolateLinear;
      case this.InterpolantFactoryMethodSmooth:
        return InterpolateSmooth;
    }
  },
  getValueSize: function () {
    return this.values.length / this.times.length;
  },
  // move all keyframes either forwards or backwards in time
  shift: function (timeOffset) {
    if (timeOffset !== 0.0) {
      const times = this.times;
      for (let i = 0, n = times.length; i !== n; ++i) {
        times[i] += timeOffset;
      }
    }
    return this;
  },
  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale: function (timeScale) {
    if (timeScale !== 1.0) {
      const times = this.times;
      for (let i = 0, n = times.length; i !== n; ++i) {
        times[i] *= timeScale;
      }
    }
    return this;
  },
  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim: function (startTime, endTime) {
    const times = this.times,
      nKeys = times.length;
    let from = 0,
      to = nKeys - 1;
    while (from !== nKeys && times[from] < startTime) {
      ++from;
    }
    while (to !== -1 && times[to] > endTime) {
      --to;
    }
    ++to; // inclusive -> exclusive bound

    if (from !== 0 || to !== nKeys) {
      // empty tracks are forbidden, so keep at least one keyframe
      if (from >= to) {
        to = Math.max(to, 1);
        from = to - 1;
      }
      const stride = this.getValueSize();
      this.times = AnimationUtils.arraySlice(times, from, to);
      this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
    }
    return this;
  },
  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate: function () {
    let valid = true;
    const valueSize = this.getValueSize();
    if (valueSize - Math.floor(valueSize) !== 0) {
      console.error('THREE.KeyframeTrack: Invalid value size in track.', this);
      valid = false;
    }
    const times = this.times,
      values = this.values,
      nKeys = times.length;
    if (nKeys === 0) {
      console.error('THREE.KeyframeTrack: Track is empty.', this);
      valid = false;
    }
    let prevTime = null;
    for (let i = 0; i !== nKeys; i++) {
      const currTime = times[i];
      if (typeof currTime === 'number' && isNaN(currTime)) {
        console.error('THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime);
        valid = false;
        break;
      }
      if (prevTime !== null && prevTime > currTime) {
        console.error('THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime);
        valid = false;
        break;
      }
      prevTime = currTime;
    }
    if (values !== undefined) {
      if (AnimationUtils.isTypedArray(values)) {
        for (let i = 0, n = values.length; i !== n; ++i) {
          const value = values[i];
          if (isNaN(value)) {
            console.error('THREE.KeyframeTrack: Value is not a valid number.', this, i, value);
            valid = false;
            break;
          }
        }
      }
    }
    return valid;
  },
  // removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize: function () {
    // times or values may be shared with other tracks, so overwriting is unsafe
    const times = AnimationUtils.arraySlice(this.times),
      values = AnimationUtils.arraySlice(this.values),
      stride = this.getValueSize(),
      smoothInterpolation = this.getInterpolation() === InterpolateSmooth,
      lastIndex = times.length - 1;
    let writeIndex = 1;
    for (let i = 1; i < lastIndex; ++i) {
      let keep = false;
      const time = times[i];
      const timeNext = times[i + 1];

      // remove adjacent keyframes scheduled at the same time

      if (time !== timeNext && (i !== 1 || time !== times[0])) {
        if (!smoothInterpolation) {
          // remove unnecessary keyframes same as their neighbors

          const offset = i * stride,
            offsetP = offset - stride,
            offsetN = offset + stride;
          for (let j = 0; j !== stride; ++j) {
            const value = values[offset + j];
            if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
              keep = true;
              break;
            }
          }
        } else {
          keep = true;
        }
      }

      // in-place compaction

      if (keep) {
        if (i !== writeIndex) {
          times[writeIndex] = times[i];
          const readOffset = i * stride,
            writeOffset = writeIndex * stride;
          for (let j = 0; j !== stride; ++j) {
            values[writeOffset + j] = values[readOffset + j];
          }
        }
        ++writeIndex;
      }
    }

    // flush last keyframe (compaction looks ahead)

    if (lastIndex > 0) {
      times[writeIndex] = times[lastIndex];
      for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
        values[writeOffset + j] = values[readOffset + j];
      }
      ++writeIndex;
    }
    if (writeIndex !== times.length) {
      this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
      this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
    } else {
      this.times = times;
      this.values = values;
    }
    return this;
  },
  clone: function () {
    const times = AnimationUtils.arraySlice(this.times, 0);
    const values = AnimationUtils.arraySlice(this.values, 0);
    const TypedKeyframeTrack = this.constructor;
    const track = new TypedKeyframeTrack(this.name, times, values);

    // Interpolant argument to constructor is not saved, so copy the factory method directly.
    track.createInterpolant = this.createInterpolant;
    return track;
  }
});

/**
 * A Track of Boolean keyframe values.
 */

function BooleanKeyframeTrack(name, times, values) {
  KeyframeTrack.call(this, name, times, values);
}
BooleanKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: BooleanKeyframeTrack,
  ValueTypeName: 'bool',
  ValueBufferType: Array,
  DefaultInterpolation: InterpolateDiscrete,
  InterpolantFactoryMethodLinear: undefined,
  InterpolantFactoryMethodSmooth: undefined

  // Note: Actually this track could have a optimized / compressed
  // representation of a single value and a custom interpolant that
  // computes "firstValue ^ isOdd( index )".
});

/**
 * A Track of keyframe values that represent color.
 */

function ColorKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrack.call(this, name, times, values, interpolation);
}
ColorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: ColorKeyframeTrack,
  ValueTypeName: 'color'

  // ValueBufferType is inherited

  // DefaultInterpolation is inherited

  // Note: Very basic implementation and nothing special yet.
  // However, this is the place for color space parameterization.
});

/**
 * A Track of numeric keyframe values.
 */

function NumberKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrack.call(this, name, times, values, interpolation);
}
NumberKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: NumberKeyframeTrack,
  ValueTypeName: 'number'

  // ValueBufferType is inherited

  // DefaultInterpolation is inherited
});

/**
 * Spherical linear unit quaternion interpolant.
 */

function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: QuaternionLinearInterpolant,
  interpolate_: function (i1, t0, t, t1) {
    const result = this.resultBuffer,
      values = this.sampleValues,
      stride = this.valueSize,
      alpha = (t - t0) / (t1 - t0);
    let offset = i1 * stride;
    for (let end = offset + stride; offset !== end; offset += 4) {
      Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
    }
    return result;
  }
});

/**
 * A Track of quaternion keyframe values.
 */

function QuaternionKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrack.call(this, name, times, values, interpolation);
}
QuaternionKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: QuaternionKeyframeTrack,
  ValueTypeName: 'quaternion',
  // ValueBufferType is inherited

  DefaultInterpolation: InterpolateLinear,
  InterpolantFactoryMethodLinear: function (result) {
    return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
  },
  InterpolantFactoryMethodSmooth: undefined // not yet implemented
});

/**
 * A Track that interpolates Strings
 */

function StringKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrack.call(this, name, times, values, interpolation);
}
StringKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: StringKeyframeTrack,
  ValueTypeName: 'string',
  ValueBufferType: Array,
  DefaultInterpolation: InterpolateDiscrete,
  InterpolantFactoryMethodLinear: undefined,
  InterpolantFactoryMethodSmooth: undefined
});

/**
 * A Track of vectored keyframe values.
 */

function VectorKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrack.call(this, name, times, values, interpolation);
}
VectorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: VectorKeyframeTrack,
  ValueTypeName: 'vector'

  // ValueBufferType is inherited

  // DefaultInterpolation is inherited
});

function AnimationClip(name, duration = -1, tracks, blendMode = NormalAnimationBlendMode) {
  this.name = name;
  this.tracks = tracks;
  this.duration = duration;
  this.blendMode = blendMode;
  this.uuid = MathUtils.generateUUID();

  // this means it should figure out its duration by scanning the tracks
  if (this.duration < 0) {
    this.resetDuration();
  }
}
function getTrackTypeForValueTypeName(typeName) {
  switch (typeName.toLowerCase()) {
    case 'scalar':
    case 'double':
    case 'float':
    case 'number':
    case 'integer':
      return NumberKeyframeTrack;
    case 'vector':
    case 'vector2':
    case 'vector3':
    case 'vector4':
      return VectorKeyframeTrack;
    case 'color':
      return ColorKeyframeTrack;
    case 'quaternion':
      return QuaternionKeyframeTrack;
    case 'bool':
    case 'boolean':
      return BooleanKeyframeTrack;
    case 'string':
      return StringKeyframeTrack;
  }
  throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);
}
function parseKeyframeTrack(json) {
  if (json.type === undefined) {
    throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
  }
  const trackType = getTrackTypeForValueTypeName(json.type);
  if (json.times === undefined) {
    const times = [],
      values = [];
    AnimationUtils.flattenJSON(json.keys, times, values, 'value');
    json.times = times;
    json.values = values;
  }

  // derived classes can define a static parse method
  if (trackType.parse !== undefined) {
    return trackType.parse(json);
  } else {
    // by default, we assume a constructor compatible with the base
    return new trackType(json.name, json.times, json.values, json.interpolation);
  }
}
Object.assign(AnimationClip, {
  parse: function (json) {
    const tracks = [],
      jsonTracks = json.tracks,
      frameTime = 1.0 / (json.fps || 1.0);
    for (let i = 0, n = jsonTracks.length; i !== n; ++i) {
      tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));
    }
    const clip = new AnimationClip(json.name, json.duration, tracks, json.blendMode);
    clip.uuid = json.uuid;
    return clip;
  },
  toJSON: function (clip) {
    const tracks = [],
      clipTracks = clip.tracks;
    const json = {
      'name': clip.name,
      'duration': clip.duration,
      'tracks': tracks,
      'uuid': clip.uuid,
      'blendMode': clip.blendMode
    };
    for (let i = 0, n = clipTracks.length; i !== n; ++i) {
      tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
    }
    return json;
  },
  CreateFromMorphTargetSequence: function (name, morphTargetSequence, fps, noLoop) {
    const numMorphTargets = morphTargetSequence.length;
    const tracks = [];
    for (let i = 0; i < numMorphTargets; i++) {
      let times = [];
      let values = [];
      times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);
      values.push(0, 1, 0);
      const order = AnimationUtils.getKeyframeOrder(times);
      times = AnimationUtils.sortedArray(times, 1, order);
      values = AnimationUtils.sortedArray(values, 1, order);

      // if there is a key at the first frame, duplicate it as the
      // last frame as well for perfect loop.
      if (!noLoop && times[0] === 0) {
        times.push(numMorphTargets);
        values.push(values[0]);
      }
      tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i].name + ']', times, values).scale(1.0 / fps));
    }
    return new AnimationClip(name, -1, tracks);
  },
  findByName: function (objectOrClipArray, name) {
    let clipArray = objectOrClipArray;
    if (!Array.isArray(objectOrClipArray)) {
      const o = objectOrClipArray;
      clipArray = o.geometry && o.geometry.animations || o.animations;
    }
    for (let i = 0; i < clipArray.length; i++) {
      if (clipArray[i].name === name) {
        return clipArray[i];
      }
    }
    return null;
  },
  CreateClipsFromMorphTargetSequences: function (morphTargets, fps, noLoop) {
    const animationToMorphTargets = {};

    // tested with https://regex101.com/ on trick sequences
    // such flamingo_flyA_003, flamingo_run1_003, crdeath0059
    const pattern = /^([\w-]*?)([\d]+)$/;

    // sort morph target names into animation groups based
    // patterns like Walk_001, Walk_002, Run_001, Run_002
    for (let i = 0, il = morphTargets.length; i < il; i++) {
      const morphTarget = morphTargets[i];
      const parts = morphTarget.name.match(pattern);
      if (parts && parts.length > 1) {
        const name = parts[1];
        let animationMorphTargets = animationToMorphTargets[name];
        if (!animationMorphTargets) {
          animationToMorphTargets[name] = animationMorphTargets = [];
        }
        animationMorphTargets.push(morphTarget);
      }
    }
    const clips = [];
    for (const name in animationToMorphTargets) {
      clips.push(AnimationClip.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
    }
    return clips;
  },
  // parse the animation.hierarchy format
  parseAnimation: function (animation, bones) {
    if (!animation) {
      console.error('THREE.AnimationClip: No animation in JSONLoader data.');
      return null;
    }
    const addNonemptyTrack = function (trackType, trackName, animationKeys, propertyName, destTracks) {
      // only return track if there are actually keys.
      if (animationKeys.length !== 0) {
        const times = [];
        const values = [];
        AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);

        // empty keys are filtered out, so check again
        if (times.length !== 0) {
          destTracks.push(new trackType(trackName, times, values));
        }
      }
    };
    const tracks = [];
    const clipName = animation.name || 'default';
    const fps = animation.fps || 30;
    const blendMode = animation.blendMode;

    // automatic length determination in AnimationClip.
    let duration = animation.length || -1;
    const hierarchyTracks = animation.hierarchy || [];
    for (let h = 0; h < hierarchyTracks.length; h++) {
      const animationKeys = hierarchyTracks[h].keys;

      // skip empty tracks
      if (!animationKeys || animationKeys.length === 0) continue;

      // process morph targets
      if (animationKeys[0].morphTargets) {
        // figure out all morph targets used in this track
        const morphTargetNames = {};
        let k;
        for (k = 0; k < animationKeys.length; k++) {
          if (animationKeys[k].morphTargets) {
            for (let m = 0; m < animationKeys[k].morphTargets.length; m++) {
              morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
            }
          }
        }

        // create a track for each morph target with all zero
        // morphTargetInfluences except for the keys in which
        // the morphTarget is named.
        for (const morphTargetName in morphTargetNames) {
          const times = [];
          const values = [];
          for (let m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
            const animationKey = animationKeys[k];
            times.push(animationKey.time);
            values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
          }
          tracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));
        }
        duration = morphTargetNames.length * (fps || 1.0);
      } else {
        // ...assume skeletal animation

        const boneName = '.bones[' + bones[h].name + ']';
        addNonemptyTrack(VectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks);
        addNonemptyTrack(QuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks);
        addNonemptyTrack(VectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks);
      }
    }
    if (tracks.length === 0) {
      return null;
    }
    const clip = new AnimationClip(clipName, duration, tracks, blendMode);
    return clip;
  }
});
Object.assign(AnimationClip.prototype, {
  resetDuration: function () {
    const tracks = this.tracks;
    let duration = 0;
    for (let i = 0, n = tracks.length; i !== n; ++i) {
      const track = this.tracks[i];
      duration = Math.max(duration, track.times[track.times.length - 1]);
    }
    this.duration = duration;
    return this;
  },
  trim: function () {
    for (let i = 0; i < this.tracks.length; i++) {
      this.tracks[i].trim(0, this.duration);
    }
    return this;
  },
  validate: function () {
    let valid = true;
    for (let i = 0; i < this.tracks.length; i++) {
      valid = valid && this.tracks[i].validate();
    }
    return valid;
  },
  optimize: function () {
    for (let i = 0; i < this.tracks.length; i++) {
      this.tracks[i].optimize();
    }
    return this;
  },
  clone: function () {
    const tracks = [];
    for (let i = 0; i < this.tracks.length; i++) {
      tracks.push(this.tracks[i].clone());
    }
    return new AnimationClip(this.name, this.duration, tracks, this.blendMode);
  },
  toJSON: function () {
    return AnimationClip.toJSON(this);
  }
});
const Cache = {
  enabled: false,
  files: {},
  add: function (key, file) {
    if (this.enabled === false) return;

    // console.log( 'THREE.Cache', 'Adding key:', key );

    this.files[key] = file;
  },
  get: function (key) {
    if (this.enabled === false) return;

    // console.log( 'THREE.Cache', 'Checking key:', key );

    return this.files[key];
  },
  remove: function (key) {
    delete this.files[key];
  },
  clear: function () {
    this.files = {};
  }
};
exports.Cache = Cache;
function LoadingManager(onLoad, onProgress, onError) {
  const scope = this;
  let isLoading = false;
  let itemsLoaded = 0;
  let itemsTotal = 0;
  let urlModifier = undefined;
  const handlers = [];

  // Refer to #5689 for the reason why we don't set .onStart
  // in the constructor

  this.onStart = undefined;
  this.onLoad = onLoad;
  this.onProgress = onProgress;
  this.onError = onError;
  this.itemStart = function (url) {
    itemsTotal++;
    if (isLoading === false) {
      if (scope.onStart !== undefined) {
        scope.onStart(url, itemsLoaded, itemsTotal);
      }
    }
    isLoading = true;
  };
  this.itemEnd = function (url) {
    itemsLoaded++;
    if (scope.onProgress !== undefined) {
      scope.onProgress(url, itemsLoaded, itemsTotal);
    }
    if (itemsLoaded === itemsTotal) {
      isLoading = false;
      if (scope.onLoad !== undefined) {
        scope.onLoad();
      }
    }
  };
  this.itemError = function (url) {
    if (scope.onError !== undefined) {
      scope.onError(url);
    }
  };
  this.resolveURL = function (url) {
    if (urlModifier) {
      return urlModifier(url);
    }
    return url;
  };
  this.setURLModifier = function (transform) {
    urlModifier = transform;
    return this;
  };
  this.addHandler = function (regex, loader) {
    handlers.push(regex, loader);
    return this;
  };
  this.removeHandler = function (regex) {
    const index = handlers.indexOf(regex);
    if (index !== -1) {
      handlers.splice(index, 2);
    }
    return this;
  };
  this.getHandler = function (file) {
    for (let i = 0, l = handlers.length; i < l; i += 2) {
      const regex = handlers[i];
      const loader = handlers[i + 1];
      if (regex.global) regex.lastIndex = 0; // see #17920

      if (regex.test(file)) {
        return loader;
      }
    }
    return null;
  };
}
const DefaultLoadingManager = new LoadingManager();
exports.DefaultLoadingManager = DefaultLoadingManager;
function Loader(manager) {
  this.manager = manager !== undefined ? manager : DefaultLoadingManager;
  this.crossOrigin = 'anonymous';
  this.withCredentials = false;
  this.path = '';
  this.resourcePath = '';
  this.requestHeader = {};
}
Object.assign(Loader.prototype, {
  load: function /* url, onLoad, onProgress, onError */ () {},
  loadAsync: function (url, onProgress) {
    const scope = this;
    return new Promise(function (resolve, reject) {
      scope.load(url, resolve, onProgress, reject);
    });
  },
  parse: function /* data */ () {},
  setCrossOrigin: function (crossOrigin) {
    this.crossOrigin = crossOrigin;
    return this;
  },
  setWithCredentials: function (value) {
    this.withCredentials = value;
    return this;
  },
  setPath: function (path) {
    this.path = path;
    return this;
  },
  setResourcePath: function (resourcePath) {
    this.resourcePath = resourcePath;
    return this;
  },
  setRequestHeader: function (requestHeader) {
    this.requestHeader = requestHeader;
    return this;
  }
});
const loading = {};
function FileLoader(manager) {
  Loader.call(this, manager);
}
FileLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: FileLoader,
  load: function (url, onLoad, onProgress, onError) {
    if (url === undefined) url = '';
    if (this.path !== undefined) url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== undefined) {
      scope.manager.itemStart(url);
      setTimeout(function () {
        if (onLoad) onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }

    // Check if request is duplicate

    if (loading[url] !== undefined) {
      loading[url].push({
        onLoad: onLoad,
        onProgress: onProgress,
        onError: onError
      });
      return;
    }

    // Check for data: URI
    const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
    const dataUriRegexResult = url.match(dataUriRegex);
    let request;

    // Safari can not handle Data URIs through XMLHttpRequest so process manually
    if (dataUriRegexResult) {
      const mimeType = dataUriRegexResult[1];
      const isBase64 = !!dataUriRegexResult[2];
      let data = dataUriRegexResult[3];
      data = decodeURIComponent(data);
      if (isBase64) data = atob(data);
      try {
        let response;
        const responseType = (this.responseType || '').toLowerCase();
        switch (responseType) {
          case 'arraybuffer':
          case 'blob':
            const view = new Uint8Array(data.length);
            for (let i = 0; i < data.length; i++) {
              view[i] = data.charCodeAt(i);
            }
            if (responseType === 'blob') {
              response = new Blob([view.buffer], {
                type: mimeType
              });
            } else {
              response = view.buffer;
            }
            break;
          case 'document':
            const parser = new DOMParser();
            response = parser.parseFromString(data, mimeType);
            break;
          case 'json':
            response = JSON.parse(data);
            break;
          default:
            // 'text' or other

            response = data;
            break;
        }

        // Wait for next browser tick like standard XMLHttpRequest event dispatching does
        setTimeout(function () {
          if (onLoad) onLoad(response);
          scope.manager.itemEnd(url);
        }, 0);
      } catch (error) {
        // Wait for next browser tick like standard XMLHttpRequest event dispatching does
        setTimeout(function () {
          if (onError) onError(error);
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }, 0);
      }
    } else {
      // Initialise array for duplicate requests

      loading[url] = [];
      loading[url].push({
        onLoad: onLoad,
        onProgress: onProgress,
        onError: onError
      });
      request = new XMLHttpRequest();
      request.open('GET', url, true);
      request.addEventListener('load', function (event) {
        const response = this.response;
        const callbacks = loading[url];
        delete loading[url];
        if (this.status === 200 || this.status === 0) {
          // Some browsers return HTTP Status 0 when using non-http protocol
          // e.g. 'file://' or 'data://'. Handle as success.

          if (this.status === 0) console.warn('THREE.FileLoader: HTTP Status 0 received.');

          // Add to cache only on HTTP success, so that we do not cache
          // error response bodies as proper responses to requests.
          Cache.add(url, response);
          for (let i = 0, il = callbacks.length; i < il; i++) {
            const callback = callbacks[i];
            if (callback.onLoad) callback.onLoad(response);
          }
          scope.manager.itemEnd(url);
        } else {
          for (let i = 0, il = callbacks.length; i < il; i++) {
            const callback = callbacks[i];
            if (callback.onError) callback.onError(event);
          }
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }
      }, false);
      request.addEventListener('progress', function (event) {
        const callbacks = loading[url];
        for (let i = 0, il = callbacks.length; i < il; i++) {
          const callback = callbacks[i];
          if (callback.onProgress) callback.onProgress(event);
        }
      }, false);
      request.addEventListener('error', function (event) {
        const callbacks = loading[url];
        delete loading[url];
        for (let i = 0, il = callbacks.length; i < il; i++) {
          const callback = callbacks[i];
          if (callback.onError) callback.onError(event);
        }
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      }, false);
      request.addEventListener('abort', function (event) {
        const callbacks = loading[url];
        delete loading[url];
        for (let i = 0, il = callbacks.length; i < il; i++) {
          const callback = callbacks[i];
          if (callback.onError) callback.onError(event);
        }
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      }, false);
      if (this.responseType !== undefined) request.responseType = this.responseType;
      if (this.withCredentials !== undefined) request.withCredentials = this.withCredentials;
      if (request.overrideMimeType) request.overrideMimeType(this.mimeType !== undefined ? this.mimeType : 'text/plain');
      for (const header in this.requestHeader) {
        request.setRequestHeader(header, this.requestHeader[header]);
      }
      request.send(null);
    }
    scope.manager.itemStart(url);
    return request;
  },
  setResponseType: function (value) {
    this.responseType = value;
    return this;
  },
  setMimeType: function (value) {
    this.mimeType = value;
    return this;
  }
});
function AnimationLoader(manager) {
  Loader.call(this, manager);
}
AnimationLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: AnimationLoader,
  load: function (url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(scope.manager);
    loader.setPath(scope.path);
    loader.setRequestHeader(scope.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function (text) {
      try {
        onLoad(scope.parse(JSON.parse(text)));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  },
  parse: function (json) {
    const animations = [];
    for (let i = 0; i < json.length; i++) {
      const clip = AnimationClip.parse(json[i]);
      animations.push(clip);
    }
    return animations;
  }
});

/**
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */

function CompressedTextureLoader(manager) {
  Loader.call(this, manager);
}
CompressedTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: CompressedTextureLoader,
  load: function (url, onLoad, onProgress, onError) {
    const scope = this;
    const images = [];
    const texture = new CompressedTexture();
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType('arraybuffer');
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    let loaded = 0;
    function loadTexture(i) {
      loader.load(url[i], function (buffer) {
        const texDatas = scope.parse(buffer, true);
        images[i] = {
          width: texDatas.width,
          height: texDatas.height,
          format: texDatas.format,
          mipmaps: texDatas.mipmaps
        };
        loaded += 1;
        if (loaded === 6) {
          if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;
          texture.image = images;
          texture.format = texDatas.format;
          texture.needsUpdate = true;
          if (onLoad) onLoad(texture);
        }
      }, onProgress, onError);
    }
    if (Array.isArray(url)) {
      for (let i = 0, il = url.length; i < il; ++i) {
        loadTexture(i);
      }
    } else {
      // compressed cubemap texture stored in a single DDS file

      loader.load(url, function (buffer) {
        const texDatas = scope.parse(buffer, true);
        if (texDatas.isCubemap) {
          const faces = texDatas.mipmaps.length / texDatas.mipmapCount;
          for (let f = 0; f < faces; f++) {
            images[f] = {
              mipmaps: []
            };
            for (let i = 0; i < texDatas.mipmapCount; i++) {
              images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
              images[f].format = texDatas.format;
              images[f].width = texDatas.width;
              images[f].height = texDatas.height;
            }
          }
          texture.image = images;
        } else {
          texture.image.width = texDatas.width;
          texture.image.height = texDatas.height;
          texture.mipmaps = texDatas.mipmaps;
        }
        if (texDatas.mipmapCount === 1) {
          texture.minFilter = LinearFilter;
        }
        texture.format = texDatas.format;
        texture.needsUpdate = true;
        if (onLoad) onLoad(texture);
      }, onProgress, onError);
    }
    return texture;
  }
});
function ImageLoader(manager) {
  Loader.call(this, manager);
}
ImageLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: ImageLoader,
  load: function (url, onLoad, onProgress, onError) {
    if (this.path !== undefined) url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== undefined) {
      scope.manager.itemStart(url);
      setTimeout(function () {
        if (onLoad) onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    const image = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');
    function onImageLoad() {
      image.removeEventListener('load', onImageLoad, false);
      image.removeEventListener('error', onImageError, false);
      Cache.add(url, this);
      if (onLoad) onLoad(this);
      scope.manager.itemEnd(url);
    }
    function onImageError(event) {
      image.removeEventListener('load', onImageLoad, false);
      image.removeEventListener('error', onImageError, false);
      if (onError) onError(event);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    }
    image.addEventListener('load', onImageLoad, false);
    image.addEventListener('error', onImageError, false);
    if (url.substr(0, 5) !== 'data:') {
      if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;
    }
    scope.manager.itemStart(url);
    image.src = url;
    return image;
  }
});
function CubeTextureLoader(manager) {
  Loader.call(this, manager);
}
CubeTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: CubeTextureLoader,
  load: function (urls, onLoad, onProgress, onError) {
    const texture = new CubeTexture();
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    let loaded = 0;
    function loadTexture(i) {
      loader.load(urls[i], function (image) {
        texture.images[i] = image;
        loaded++;
        if (loaded === 6) {
          texture.needsUpdate = true;
          if (onLoad) onLoad(texture);
        }
      }, undefined, onError);
    }
    for (let i = 0; i < urls.length; ++i) {
      loadTexture(i);
    }
    return texture;
  }
});

/**
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */

function DataTextureLoader(manager) {
  Loader.call(this, manager);
}
DataTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: DataTextureLoader,
  load: function (url, onLoad, onProgress, onError) {
    const scope = this;
    const texture = new DataTexture();
    const loader = new FileLoader(this.manager);
    loader.setResponseType('arraybuffer');
    loader.setRequestHeader(this.requestHeader);
    loader.setPath(this.path);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function (buffer) {
      const texData = scope.parse(buffer);
      if (!texData) return;
      if (texData.image !== undefined) {
        texture.image = texData.image;
      } else if (texData.data !== undefined) {
        texture.image.width = texData.width;
        texture.image.height = texData.height;
        texture.image.data = texData.data;
      }
      texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
      texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;
      texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
      texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;
      texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;
      if (texData.encoding !== undefined) {
        texture.encoding = texData.encoding;
      }
      if (texData.flipY !== undefined) {
        texture.flipY = texData.flipY;
      }
      if (texData.format !== undefined) {
        texture.format = texData.format;
      }
      if (texData.type !== undefined) {
        texture.type = texData.type;
      }
      if (texData.mipmaps !== undefined) {
        texture.mipmaps = texData.mipmaps;
        texture.minFilter = LinearMipmapLinearFilter; // presumably...
      }

      if (texData.mipmapCount === 1) {
        texture.minFilter = LinearFilter;
      }
      texture.needsUpdate = true;
      if (onLoad) onLoad(texture, texData);
    }, onProgress, onError);
    return texture;
  }
});
function TextureLoader(manager) {
  Loader.call(this, manager);
}
TextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: TextureLoader,
  load: function (url, onLoad, onProgress, onError) {
    const texture = new Texture();
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    loader.load(url, function (image) {
      texture.image = image;

      // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
      const isJPEG = url.search(/\.jpe?g($|\?)/i) > 0 || url.search(/^data\:image\/jpeg/) === 0;
      texture.format = isJPEG ? RGBFormat : RGBAFormat;
      texture.needsUpdate = true;
      if (onLoad !== undefined) {
        onLoad(texture);
      }
    }, onProgress, onError);
    return texture;
  }
});

/**
 * Extensible curve object.
 *
 * Some common of curve methods:
 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following curves inherit from THREE.Curve:
 *
 * -- 2D curves --
 * THREE.ArcCurve
 * THREE.CubicBezierCurve
 * THREE.EllipseCurve
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.SplineCurve
 *
 * -- 3D curves --
 * THREE.CatmullRomCurve3
 * THREE.CubicBezierCurve3
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath.
 *
 **/

function Curve() {
  this.type = 'Curve';
  this.arcLengthDivisions = 200;
}
Object.assign(Curve.prototype, {
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]

  getPoint: function /* t, optionalTarget */
  () {
    console.warn('THREE.Curve: .getPoint() not implemented.');
    return null;
  },
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]

  getPointAt: function (u, optionalTarget) {
    const t = this.getUtoTmapping(u);
    return this.getPoint(t, optionalTarget);
  },
  // Get sequence of points using getPoint( t )

  getPoints: function (divisions = 5) {
    const points = [];
    for (let d = 0; d <= divisions; d++) {
      points.push(this.getPoint(d / divisions));
    }
    return points;
  },
  // Get sequence of points using getPointAt( u )

  getSpacedPoints: function (divisions = 5) {
    const points = [];
    for (let d = 0; d <= divisions; d++) {
      points.push(this.getPointAt(d / divisions));
    }
    return points;
  },
  // Get total curve arc length

  getLength: function () {
    const lengths = this.getLengths();
    return lengths[lengths.length - 1];
  },
  // Get list of cumulative segment lengths

  getLengths: function (divisions) {
    if (divisions === undefined) divisions = this.arcLengthDivisions;
    if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
      return this.cacheArcLengths;
    }
    this.needsUpdate = false;
    const cache = [];
    let current,
      last = this.getPoint(0);
    let sum = 0;
    cache.push(0);
    for (let p = 1; p <= divisions; p++) {
      current = this.getPoint(p / divisions);
      sum += current.distanceTo(last);
      cache.push(sum);
      last = current;
    }
    this.cacheArcLengths = cache;
    return cache; // { sums: cache, sum: sum }; Sum is in the last element.
  },

  updateArcLengths: function () {
    this.needsUpdate = true;
    this.getLengths();
  },
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

  getUtoTmapping: function (u, distance) {
    const arcLengths = this.getLengths();
    let i = 0;
    const il = arcLengths.length;
    let targetArcLength; // The targeted u distance value to get

    if (distance) {
      targetArcLength = distance;
    } else {
      targetArcLength = u * arcLengths[il - 1];
    }

    // binary search for the index with largest value smaller than target u distance

    let low = 0,
      high = il - 1,
      comparison;
    while (low <= high) {
      i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

      comparison = arcLengths[i] - targetArcLength;
      if (comparison < 0) {
        low = i + 1;
      } else if (comparison > 0) {
        high = i - 1;
      } else {
        high = i;
        break;

        // DONE
      }
    }

    i = high;
    if (arcLengths[i] === targetArcLength) {
      return i / (il - 1);
    }

    // we could get finer grain at lengths, or use simple interpolation between two points

    const lengthBefore = arcLengths[i];
    const lengthAfter = arcLengths[i + 1];
    const segmentLength = lengthAfter - lengthBefore;

    // determine where we are between the 'before' and 'after' points

    const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;

    // add that fractional amount to t

    const t = (i + segmentFraction) / (il - 1);
    return t;
  },
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation

  getTangent: function (t, optionalTarget) {
    const delta = 0.0001;
    let t1 = t - delta;
    let t2 = t + delta;

    // Capping in case of danger

    if (t1 < 0) t1 = 0;
    if (t2 > 1) t2 = 1;
    const pt1 = this.getPoint(t1);
    const pt2 = this.getPoint(t2);
    const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
    tangent.copy(pt2).sub(pt1).normalize();
    return tangent;
  },
  getTangentAt: function (u, optionalTarget) {
    const t = this.getUtoTmapping(u);
    return this.getTangent(t, optionalTarget);
  },
  computeFrenetFrames: function (segments, closed) {
    // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

    const normal = new Vector3();
    const tangents = [];
    const normals = [];
    const binormals = [];
    const vec = new Vector3();
    const mat = new Matrix4();

    // compute the tangent vectors for each segment on the curve

    for (let i = 0; i <= segments; i++) {
      const u = i / segments;
      tangents[i] = this.getTangentAt(u, new Vector3());
      tangents[i].normalize();
    }

    // select an initial normal vector perpendicular to the first tangent vector,
    // and in the direction of the minimum tangent xyz component

    normals[0] = new Vector3();
    binormals[0] = new Vector3();
    let min = Number.MAX_VALUE;
    const tx = Math.abs(tangents[0].x);
    const ty = Math.abs(tangents[0].y);
    const tz = Math.abs(tangents[0].z);
    if (tx <= min) {
      min = tx;
      normal.set(1, 0, 0);
    }
    if (ty <= min) {
      min = ty;
      normal.set(0, 1, 0);
    }
    if (tz <= min) {
      normal.set(0, 0, 1);
    }
    vec.crossVectors(tangents[0], normal).normalize();
    normals[0].crossVectors(tangents[0], vec);
    binormals[0].crossVectors(tangents[0], normals[0]);

    // compute the slowly-varying normal and binormal vectors for each segment on the curve

    for (let i = 1; i <= segments; i++) {
      normals[i] = normals[i - 1].clone();
      binormals[i] = binormals[i - 1].clone();
      vec.crossVectors(tangents[i - 1], tangents[i]);
      if (vec.length() > Number.EPSILON) {
        vec.normalize();
        const theta = Math.acos(MathUtils.clamp(tangents[i - 1].dot(tangents[i]), -1, 1)); // clamp for floating pt errors

        normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
      }
      binormals[i].crossVectors(tangents[i], normals[i]);
    }

    // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

    if (closed === true) {
      let theta = Math.acos(MathUtils.clamp(normals[0].dot(normals[segments]), -1, 1));
      theta /= segments;
      if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
        theta = -theta;
      }
      for (let i = 1; i <= segments; i++) {
        // twist a little...
        normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
        binormals[i].crossVectors(tangents[i], normals[i]);
      }
    }
    return {
      tangents: tangents,
      normals: normals,
      binormals: binormals
    };
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (source) {
    this.arcLengthDivisions = source.arcLengthDivisions;
    return this;
  },
  toJSON: function () {
    const data = {
      metadata: {
        version: 4.5,
        type: 'Curve',
        generator: 'Curve.toJSON'
      }
    };
    data.arcLengthDivisions = this.arcLengthDivisions;
    data.type = this.type;
    return data;
  },
  fromJSON: function (json) {
    this.arcLengthDivisions = json.arcLengthDivisions;
    return this;
  }
});
function EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
  Curve.call(this);
  this.type = 'EllipseCurve';
  this.aX = aX || 0;
  this.aY = aY || 0;
  this.xRadius = xRadius || 1;
  this.yRadius = yRadius || 1;
  this.aStartAngle = aStartAngle || 0;
  this.aEndAngle = aEndAngle || 2 * Math.PI;
  this.aClockwise = aClockwise || false;
  this.aRotation = aRotation || 0;
}
EllipseCurve.prototype = Object.create(Curve.prototype);
EllipseCurve.prototype.constructor = EllipseCurve;
EllipseCurve.prototype.isEllipseCurve = true;
EllipseCurve.prototype.getPoint = function (t, optionalTarget) {
  const point = optionalTarget || new Vector2();
  const twoPi = Math.PI * 2;
  let deltaAngle = this.aEndAngle - this.aStartAngle;
  const samePoints = Math.abs(deltaAngle) < Number.EPSILON;

  // ensures that deltaAngle is 0 .. 2 PI
  while (deltaAngle < 0) deltaAngle += twoPi;
  while (deltaAngle > twoPi) deltaAngle -= twoPi;
  if (deltaAngle < Number.EPSILON) {
    if (samePoints) {
      deltaAngle = 0;
    } else {
      deltaAngle = twoPi;
    }
  }
  if (this.aClockwise === true && !samePoints) {
    if (deltaAngle === twoPi) {
      deltaAngle = -twoPi;
    } else {
      deltaAngle = deltaAngle - twoPi;
    }
  }
  const angle = this.aStartAngle + t * deltaAngle;
  let x = this.aX + this.xRadius * Math.cos(angle);
  let y = this.aY + this.yRadius * Math.sin(angle);
  if (this.aRotation !== 0) {
    const cos = Math.cos(this.aRotation);
    const sin = Math.sin(this.aRotation);
    const tx = x - this.aX;
    const ty = y - this.aY;

    // Rotate the point about the center of the ellipse.
    x = tx * cos - ty * sin + this.aX;
    y = tx * sin + ty * cos + this.aY;
  }
  return point.set(x, y);
};
EllipseCurve.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.aX = source.aX;
  this.aY = source.aY;
  this.xRadius = source.xRadius;
  this.yRadius = source.yRadius;
  this.aStartAngle = source.aStartAngle;
  this.aEndAngle = source.aEndAngle;
  this.aClockwise = source.aClockwise;
  this.aRotation = source.aRotation;
  return this;
};
EllipseCurve.prototype.toJSON = function () {
  const data = Curve.prototype.toJSON.call(this);
  data.aX = this.aX;
  data.aY = this.aY;
  data.xRadius = this.xRadius;
  data.yRadius = this.yRadius;
  data.aStartAngle = this.aStartAngle;
  data.aEndAngle = this.aEndAngle;
  data.aClockwise = this.aClockwise;
  data.aRotation = this.aRotation;
  return data;
};
EllipseCurve.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.aX = json.aX;
  this.aY = json.aY;
  this.xRadius = json.xRadius;
  this.yRadius = json.yRadius;
  this.aStartAngle = json.aStartAngle;
  this.aEndAngle = json.aEndAngle;
  this.aClockwise = json.aClockwise;
  this.aRotation = json.aRotation;
  return this;
};
function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
  EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
  this.type = 'ArcCurve';
}
ArcCurve.prototype = Object.create(EllipseCurve.prototype);
ArcCurve.prototype.constructor = ArcCurve;
ArcCurve.prototype.isArcCurve = true;

/**
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */

/*
Based on an optimized c++ solution in
 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
 - http://ideone.com/NoEbVM

This CubicPoly class could be used for reusing some variables and calculations,
but for three.js curve use, it could be possible inlined and flatten into a single function call
which can be placed in CurveUtils.
*/

function CubicPoly() {
  let c0 = 0,
    c1 = 0,
    c2 = 0,
    c3 = 0;

  /*
   * Compute coefficients for a cubic polynomial
   *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
   * such that
   *   p(0) = x0, p(1) = x1
   *  and
   *   p'(0) = t0, p'(1) = t1.
   */
  function init(x0, x1, t0, t1) {
    c0 = x0;
    c1 = t0;
    c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
    c3 = 2 * x0 - 2 * x1 + t0 + t1;
  }
  return {
    initCatmullRom: function (x0, x1, x2, x3, tension) {
      init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
    },
    initNonuniformCatmullRom: function (x0, x1, x2, x3, dt0, dt1, dt2) {
      // compute tangents when parameterized in [t1,t2]
      let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
      let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;

      // rescale tangents for parametrization in [0,1]
      t1 *= dt1;
      t2 *= dt1;
      init(x1, x2, t1, t2);
    },
    calc: function (t) {
      const t2 = t * t;
      const t3 = t2 * t;
      return c0 + c1 * t + c2 * t2 + c3 * t3;
    }
  };
}

//

const tmp = new Vector3();
const px = new CubicPoly(),
  py = new CubicPoly(),
  pz = new CubicPoly();
function CatmullRomCurve3(points = [], closed = false, curveType = 'centripetal', tension = 0.5) {
  Curve.call(this);
  this.type = 'CatmullRomCurve3';
  this.points = points;
  this.closed = closed;
  this.curveType = curveType;
  this.tension = tension;
}
CatmullRomCurve3.prototype = Object.create(Curve.prototype);
CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;
CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
CatmullRomCurve3.prototype.getPoint = function (t, optionalTarget = new Vector3()) {
  const point = optionalTarget;
  const points = this.points;
  const l = points.length;
  const p = (l - (this.closed ? 0 : 1)) * t;
  let intPoint = Math.floor(p);
  let weight = p - intPoint;
  if (this.closed) {
    intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
  } else if (weight === 0 && intPoint === l - 1) {
    intPoint = l - 2;
    weight = 1;
  }
  let p0, p3; // 4 points (p1 & p2 defined below)

  if (this.closed || intPoint > 0) {
    p0 = points[(intPoint - 1) % l];
  } else {
    // extrapolate first point
    tmp.subVectors(points[0], points[1]).add(points[0]);
    p0 = tmp;
  }
  const p1 = points[intPoint % l];
  const p2 = points[(intPoint + 1) % l];
  if (this.closed || intPoint + 2 < l) {
    p3 = points[(intPoint + 2) % l];
  } else {
    // extrapolate last point
    tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
    p3 = tmp;
  }
  if (this.curveType === 'centripetal' || this.curveType === 'chordal') {
    // init Centripetal / Chordal Catmull-Rom
    const pow = this.curveType === 'chordal' ? 0.5 : 0.25;
    let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
    let dt1 = Math.pow(p1.distanceToSquared(p2), pow);
    let dt2 = Math.pow(p2.distanceToSquared(p3), pow);

    // safety check for repeated points
    if (dt1 < 1e-4) dt1 = 1.0;
    if (dt0 < 1e-4) dt0 = dt1;
    if (dt2 < 1e-4) dt2 = dt1;
    px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
    py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
    pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
  } else if (this.curveType === 'catmullrom') {
    px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
    py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
    pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
  }
  point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
  return point;
};
CatmullRomCurve3.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.points = [];
  for (let i = 0, l = source.points.length; i < l; i++) {
    const point = source.points[i];
    this.points.push(point.clone());
  }
  this.closed = source.closed;
  this.curveType = source.curveType;
  this.tension = source.tension;
  return this;
};
CatmullRomCurve3.prototype.toJSON = function () {
  const data = Curve.prototype.toJSON.call(this);
  data.points = [];
  for (let i = 0, l = this.points.length; i < l; i++) {
    const point = this.points[i];
    data.points.push(point.toArray());
  }
  data.closed = this.closed;
  data.curveType = this.curveType;
  data.tension = this.tension;
  return data;
};
CatmullRomCurve3.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.points = [];
  for (let i = 0, l = json.points.length; i < l; i++) {
    const point = json.points[i];
    this.points.push(new Vector3().fromArray(point));
  }
  this.closed = json.closed;
  this.curveType = json.curveType;
  this.tension = json.tension;
  return this;
};

/**
 * Bezier Curves formulas obtained from
 * http://en.wikipedia.org/wiki/Bézier_curve
 */

function CatmullRom(t, p0, p1, p2, p3) {
  const v0 = (p2 - p0) * 0.5;
  const v1 = (p3 - p1) * 0.5;
  const t2 = t * t;
  const t3 = t * t2;
  return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
}

//

function QuadraticBezierP0(t, p) {
  const k = 1 - t;
  return k * k * p;
}
function QuadraticBezierP1(t, p) {
  return 2 * (1 - t) * t * p;
}
function QuadraticBezierP2(t, p) {
  return t * t * p;
}
function QuadraticBezier(t, p0, p1, p2) {
  return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
}

//

function CubicBezierP0(t, p) {
  const k = 1 - t;
  return k * k * k * p;
}
function CubicBezierP1(t, p) {
  const k = 1 - t;
  return 3 * k * k * t * p;
}
function CubicBezierP2(t, p) {
  return 3 * (1 - t) * t * t * p;
}
function CubicBezierP3(t, p) {
  return t * t * t * p;
}
function CubicBezier(t, p0, p1, p2, p3) {
  return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
}
function CubicBezierCurve(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {
  Curve.call(this);
  this.type = 'CubicBezierCurve';
  this.v0 = v0;
  this.v1 = v1;
  this.v2 = v2;
  this.v3 = v3;
}
CubicBezierCurve.prototype = Object.create(Curve.prototype);
CubicBezierCurve.prototype.constructor = CubicBezierCurve;
CubicBezierCurve.prototype.isCubicBezierCurve = true;
CubicBezierCurve.prototype.getPoint = function (t, optionalTarget = new Vector2()) {
  const point = optionalTarget;
  const v0 = this.v0,
    v1 = this.v1,
    v2 = this.v2,
    v3 = this.v3;
  point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
  return point;
};
CubicBezierCurve.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.v0.copy(source.v0);
  this.v1.copy(source.v1);
  this.v2.copy(source.v2);
  this.v3.copy(source.v3);
  return this;
};
CubicBezierCurve.prototype.toJSON = function () {
  const data = Curve.prototype.toJSON.call(this);
  data.v0 = this.v0.toArray();
  data.v1 = this.v1.toArray();
  data.v2 = this.v2.toArray();
  data.v3 = this.v3.toArray();
  return data;
};
CubicBezierCurve.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.v0.fromArray(json.v0);
  this.v1.fromArray(json.v1);
  this.v2.fromArray(json.v2);
  this.v3.fromArray(json.v3);
  return this;
};
function CubicBezierCurve3(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()) {
  Curve.call(this);
  this.type = 'CubicBezierCurve3';
  this.v0 = v0;
  this.v1 = v1;
  this.v2 = v2;
  this.v3 = v3;
}
CubicBezierCurve3.prototype = Object.create(Curve.prototype);
CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;
CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
CubicBezierCurve3.prototype.getPoint = function (t, optionalTarget = new Vector3()) {
  const point = optionalTarget;
  const v0 = this.v0,
    v1 = this.v1,
    v2 = this.v2,
    v3 = this.v3;
  point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
  return point;
};
CubicBezierCurve3.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.v0.copy(source.v0);
  this.v1.copy(source.v1);
  this.v2.copy(source.v2);
  this.v3.copy(source.v3);
  return this;
};
CubicBezierCurve3.prototype.toJSON = function () {
  const data = Curve.prototype.toJSON.call(this);
  data.v0 = this.v0.toArray();
  data.v1 = this.v1.toArray();
  data.v2 = this.v2.toArray();
  data.v3 = this.v3.toArray();
  return data;
};
CubicBezierCurve3.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.v0.fromArray(json.v0);
  this.v1.fromArray(json.v1);
  this.v2.fromArray(json.v2);
  this.v3.fromArray(json.v3);
  return this;
};
function LineCurve(v1 = new Vector2(), v2 = new Vector2()) {
  Curve.call(this);
  this.type = 'LineCurve';
  this.v1 = v1;
  this.v2 = v2;
}
LineCurve.prototype = Object.create(Curve.prototype);
LineCurve.prototype.constructor = LineCurve;
LineCurve.prototype.isLineCurve = true;
LineCurve.prototype.getPoint = function (t, optionalTarget = new Vector2()) {
  const point = optionalTarget;
  if (t === 1) {
    point.copy(this.v2);
  } else {
    point.copy(this.v2).sub(this.v1);
    point.multiplyScalar(t).add(this.v1);
  }
  return point;
};

// Line curve is linear, so we can overwrite default getPointAt

LineCurve.prototype.getPointAt = function (u, optionalTarget) {
  return this.getPoint(u, optionalTarget);
};
LineCurve.prototype.getTangent = function (t, optionalTarget) {
  const tangent = optionalTarget || new Vector2();
  tangent.copy(this.v2).sub(this.v1).normalize();
  return tangent;
};
LineCurve.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.v1.copy(source.v1);
  this.v2.copy(source.v2);
  return this;
};
LineCurve.prototype.toJSON = function () {
  const data = Curve.prototype.toJSON.call(this);
  data.v1 = this.v1.toArray();
  data.v2 = this.v2.toArray();
  return data;
};
LineCurve.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.v1.fromArray(json.v1);
  this.v2.fromArray(json.v2);
  return this;
};
function LineCurve3(v1 = new Vector3(), v2 = new Vector3()) {
  Curve.call(this);
  this.type = 'LineCurve3';
  this.v1 = v1;
  this.v2 = v2;
}
LineCurve3.prototype = Object.create(Curve.prototype);
LineCurve3.prototype.constructor = LineCurve3;
LineCurve3.prototype.isLineCurve3 = true;
LineCurve3.prototype.getPoint = function (t, optionalTarget = new Vector3()) {
  const point = optionalTarget;
  if (t === 1) {
    point.copy(this.v2);
  } else {
    point.copy(this.v2).sub(this.v1);
    point.multiplyScalar(t).add(this.v1);
  }
  return point;
};

// Line curve is linear, so we can overwrite default getPointAt

LineCurve3.prototype.getPointAt = function (u, optionalTarget) {
  return this.getPoint(u, optionalTarget);
};
LineCurve3.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.v1.copy(source.v1);
  this.v2.copy(source.v2);
  return this;
};
LineCurve3.prototype.toJSON = function () {
  const data = Curve.prototype.toJSON.call(this);
  data.v1 = this.v1.toArray();
  data.v2 = this.v2.toArray();
  return data;
};
LineCurve3.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.v1.fromArray(json.v1);
  this.v2.fromArray(json.v2);
  return this;
};
function QuadraticBezierCurve(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {
  Curve.call(this);
  this.type = 'QuadraticBezierCurve';
  this.v0 = v0;
  this.v1 = v1;
  this.v2 = v2;
}
QuadraticBezierCurve.prototype = Object.create(Curve.prototype);
QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;
QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
QuadraticBezierCurve.prototype.getPoint = function (t, optionalTarget = new Vector2()) {
  const point = optionalTarget;
  const v0 = this.v0,
    v1 = this.v1,
    v2 = this.v2;
  point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
  return point;
};
QuadraticBezierCurve.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.v0.copy(source.v0);
  this.v1.copy(source.v1);
  this.v2.copy(source.v2);
  return this;
};
QuadraticBezierCurve.prototype.toJSON = function () {
  const data = Curve.prototype.toJSON.call(this);
  data.v0 = this.v0.toArray();
  data.v1 = this.v1.toArray();
  data.v2 = this.v2.toArray();
  return data;
};
QuadraticBezierCurve.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.v0.fromArray(json.v0);
  this.v1.fromArray(json.v1);
  this.v2.fromArray(json.v2);
  return this;
};
function QuadraticBezierCurve3(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {
  Curve.call(this);
  this.type = 'QuadraticBezierCurve3';
  this.v0 = v0;
  this.v1 = v1;
  this.v2 = v2;
}
QuadraticBezierCurve3.prototype = Object.create(Curve.prototype);
QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;
QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
QuadraticBezierCurve3.prototype.getPoint = function (t, optionalTarget = new Vector3()) {
  const point = optionalTarget;
  const v0 = this.v0,
    v1 = this.v1,
    v2 = this.v2;
  point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));
  return point;
};
QuadraticBezierCurve3.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.v0.copy(source.v0);
  this.v1.copy(source.v1);
  this.v2.copy(source.v2);
  return this;
};
QuadraticBezierCurve3.prototype.toJSON = function () {
  const data = Curve.prototype.toJSON.call(this);
  data.v0 = this.v0.toArray();
  data.v1 = this.v1.toArray();
  data.v2 = this.v2.toArray();
  return data;
};
QuadraticBezierCurve3.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.v0.fromArray(json.v0);
  this.v1.fromArray(json.v1);
  this.v2.fromArray(json.v2);
  return this;
};
function SplineCurve(points = []) {
  Curve.call(this);
  this.type = 'SplineCurve';
  this.points = points;
}
SplineCurve.prototype = Object.create(Curve.prototype);
SplineCurve.prototype.constructor = SplineCurve;
SplineCurve.prototype.isSplineCurve = true;
SplineCurve.prototype.getPoint = function (t, optionalTarget = new Vector2()) {
  const point = optionalTarget;
  const points = this.points;
  const p = (points.length - 1) * t;
  const intPoint = Math.floor(p);
  const weight = p - intPoint;
  const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
  const p1 = points[intPoint];
  const p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
  const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
  point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
  return point;
};
SplineCurve.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.points = [];
  for (let i = 0, l = source.points.length; i < l; i++) {
    const point = source.points[i];
    this.points.push(point.clone());
  }
  return this;
};
SplineCurve.prototype.toJSON = function () {
  const data = Curve.prototype.toJSON.call(this);
  data.points = [];
  for (let i = 0, l = this.points.length; i < l; i++) {
    const point = this.points[i];
    data.points.push(point.toArray());
  }
  return data;
};
SplineCurve.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.points = [];
  for (let i = 0, l = json.points.length; i < l; i++) {
    const point = json.points[i];
    this.points.push(new Vector2().fromArray(point));
  }
  return this;
};
var Curves = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ArcCurve: ArcCurve,
  CatmullRomCurve3: CatmullRomCurve3,
  CubicBezierCurve: CubicBezierCurve,
  CubicBezierCurve3: CubicBezierCurve3,
  EllipseCurve: EllipseCurve,
  LineCurve: LineCurve,
  LineCurve3: LineCurve3,
  QuadraticBezierCurve: QuadraticBezierCurve,
  QuadraticBezierCurve3: QuadraticBezierCurve3,
  SplineCurve: SplineCurve
});

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

function CurvePath() {
  Curve.call(this);
  this.type = 'CurvePath';
  this.curves = [];
  this.autoClose = false; // Automatically closes the path
}

CurvePath.prototype = Object.assign(Object.create(Curve.prototype), {
  constructor: CurvePath,
  add: function (curve) {
    this.curves.push(curve);
  },
  closePath: function () {
    // Add a line curve if start and end of lines are not connected
    const startPoint = this.curves[0].getPoint(0);
    const endPoint = this.curves[this.curves.length - 1].getPoint(1);
    if (!startPoint.equals(endPoint)) {
      this.curves.push(new LineCurve(endPoint, startPoint));
    }
  },
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:

  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')

  getPoint: function (t) {
    const d = t * this.getLength();
    const curveLengths = this.getCurveLengths();
    let i = 0;

    // To think about boundaries points.

    while (i < curveLengths.length) {
      if (curveLengths[i] >= d) {
        const diff = curveLengths[i] - d;
        const curve = this.curves[i];
        const segmentLength = curve.getLength();
        const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
        return curve.getPointAt(u);
      }
      i++;
    }
    return null;

    // loop where sum != 0, sum > d , sum+1 <d
  },

  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength

  getLength: function () {
    const lens = this.getCurveLengths();
    return lens[lens.length - 1];
  },
  // cacheLengths must be recalculated.
  updateArcLengths: function () {
    this.needsUpdate = true;
    this.cacheLengths = null;
    this.getCurveLengths();
  },
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.

  getCurveLengths: function () {
    // We use cache values if curves and cache array are same length

    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
      return this.cacheLengths;
    }

    // Get length of sub-curve
    // Push sums into cached array

    const lengths = [];
    let sums = 0;
    for (let i = 0, l = this.curves.length; i < l; i++) {
      sums += this.curves[i].getLength();
      lengths.push(sums);
    }
    this.cacheLengths = lengths;
    return lengths;
  },
  getSpacedPoints: function (divisions = 40) {
    const points = [];
    for (let i = 0; i <= divisions; i++) {
      points.push(this.getPoint(i / divisions));
    }
    if (this.autoClose) {
      points.push(points[0]);
    }
    return points;
  },
  getPoints: function (divisions = 12) {
    const points = [];
    let last;
    for (let i = 0, curves = this.curves; i < curves.length; i++) {
      const curve = curves[i];
      const resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
      const pts = curve.getPoints(resolution);
      for (let j = 0; j < pts.length; j++) {
        const point = pts[j];
        if (last && last.equals(point)) continue; // ensures no consecutive points are duplicates

        points.push(point);
        last = point;
      }
    }
    if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
      points.push(points[0]);
    }
    return points;
  },
  copy: function (source) {
    Curve.prototype.copy.call(this, source);
    this.curves = [];
    for (let i = 0, l = source.curves.length; i < l; i++) {
      const curve = source.curves[i];
      this.curves.push(curve.clone());
    }
    this.autoClose = source.autoClose;
    return this;
  },
  toJSON: function () {
    const data = Curve.prototype.toJSON.call(this);
    data.autoClose = this.autoClose;
    data.curves = [];
    for (let i = 0, l = this.curves.length; i < l; i++) {
      const curve = this.curves[i];
      data.curves.push(curve.toJSON());
    }
    return data;
  },
  fromJSON: function (json) {
    Curve.prototype.fromJSON.call(this, json);
    this.autoClose = json.autoClose;
    this.curves = [];
    for (let i = 0, l = json.curves.length; i < l; i++) {
      const curve = json.curves[i];
      this.curves.push(new Curves[curve.type]().fromJSON(curve));
    }
    return this;
  }
});
function Path(points) {
  CurvePath.call(this);
  this.type = 'Path';
  this.currentPoint = new Vector2();
  if (points) {
    this.setFromPoints(points);
  }
}
Path.prototype = Object.assign(Object.create(CurvePath.prototype), {
  constructor: Path,
  setFromPoints: function (points) {
    this.moveTo(points[0].x, points[0].y);
    for (let i = 1, l = points.length; i < l; i++) {
      this.lineTo(points[i].x, points[i].y);
    }
    return this;
  },
  moveTo: function (x, y) {
    this.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?

    return this;
  },
  lineTo: function (x, y) {
    const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
    this.curves.push(curve);
    this.currentPoint.set(x, y);
    return this;
  },
  quadraticCurveTo: function (aCPx, aCPy, aX, aY) {
    const curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  },
  bezierCurveTo: function (aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    const curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  },
  splineThru: function (pts /*Array of Vector*/) {
    const npts = [this.currentPoint.clone()].concat(pts);
    const curve = new SplineCurve(npts);
    this.curves.push(curve);
    this.currentPoint.copy(pts[pts.length - 1]);
    return this;
  },
  arc: function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
    return this;
  },
  absarc: function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    return this;
  },
  ellipse: function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    return this;
  },
  absellipse: function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    if (this.curves.length > 0) {
      // if a previous curve is present, attempt to join
      const firstPoint = curve.getPoint(0);
      if (!firstPoint.equals(this.currentPoint)) {
        this.lineTo(firstPoint.x, firstPoint.y);
      }
    }
    this.curves.push(curve);
    const lastPoint = curve.getPoint(1);
    this.currentPoint.copy(lastPoint);
    return this;
  },
  copy: function (source) {
    CurvePath.prototype.copy.call(this, source);
    this.currentPoint.copy(source.currentPoint);
    return this;
  },
  toJSON: function () {
    const data = CurvePath.prototype.toJSON.call(this);
    data.currentPoint = this.currentPoint.toArray();
    return data;
  },
  fromJSON: function (json) {
    CurvePath.prototype.fromJSON.call(this, json);
    this.currentPoint.fromArray(json.currentPoint);
    return this;
  }
});
function Shape(points) {
  Path.call(this, points);
  this.uuid = MathUtils.generateUUID();
  this.type = 'Shape';
  this.holes = [];
}
Shape.prototype = Object.assign(Object.create(Path.prototype), {
  constructor: Shape,
  getPointsHoles: function (divisions) {
    const holesPts = [];
    for (let i = 0, l = this.holes.length; i < l; i++) {
      holesPts[i] = this.holes[i].getPoints(divisions);
    }
    return holesPts;
  },
  // get points of shape and holes (keypoints based on segments parameter)

  extractPoints: function (divisions) {
    return {
      shape: this.getPoints(divisions),
      holes: this.getPointsHoles(divisions)
    };
  },
  copy: function (source) {
    Path.prototype.copy.call(this, source);
    this.holes = [];
    for (let i = 0, l = source.holes.length; i < l; i++) {
      const hole = source.holes[i];
      this.holes.push(hole.clone());
    }
    return this;
  },
  toJSON: function () {
    const data = Path.prototype.toJSON.call(this);
    data.uuid = this.uuid;
    data.holes = [];
    for (let i = 0, l = this.holes.length; i < l; i++) {
      const hole = this.holes[i];
      data.holes.push(hole.toJSON());
    }
    return data;
  },
  fromJSON: function (json) {
    Path.prototype.fromJSON.call(this, json);
    this.uuid = json.uuid;
    this.holes = [];
    for (let i = 0, l = json.holes.length; i < l; i++) {
      const hole = json.holes[i];
      this.holes.push(new Path().fromJSON(hole));
    }
    return this;
  }
});
function Light(color, intensity = 1) {
  Object3D.call(this);
  this.type = 'Light';
  this.color = new Color(color);
  this.intensity = intensity;
}
Light.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Light,
  isLight: true,
  copy: function (source) {
    Object3D.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.intensity = source.intensity;
    return this;
  },
  toJSON: function (meta) {
    const data = Object3D.prototype.toJSON.call(this, meta);
    data.object.color = this.color.getHex();
    data.object.intensity = this.intensity;
    if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();
    if (this.distance !== undefined) data.object.distance = this.distance;
    if (this.angle !== undefined) data.object.angle = this.angle;
    if (this.decay !== undefined) data.object.decay = this.decay;
    if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;
    if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();
    return data;
  }
});
function HemisphereLight(skyColor, groundColor, intensity) {
  Light.call(this, skyColor, intensity);
  this.type = 'HemisphereLight';
  this.position.copy(Object3D.DefaultUp);
  this.updateMatrix();
  this.groundColor = new Color(groundColor);
}
HemisphereLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: HemisphereLight,
  isHemisphereLight: true,
  copy: function (source) {
    Light.prototype.copy.call(this, source);
    this.groundColor.copy(source.groundColor);
    return this;
  }
});
function LightShadow(camera) {
  this.camera = camera;
  this.bias = 0;
  this.normalBias = 0;
  this.radius = 1;
  this.mapSize = new Vector2(512, 512);
  this.map = null;
  this.mapPass = null;
  this.matrix = new Matrix4();
  this.autoUpdate = true;
  this.needsUpdate = false;
  this._frustum = new Frustum();
  this._frameExtents = new Vector2(1, 1);
  this._viewportCount = 1;
  this._viewports = [new Vector4(0, 0, 1, 1)];
}
Object.assign(LightShadow.prototype, {
  _projScreenMatrix: new Matrix4(),
  _lightPositionWorld: new Vector3(),
  _lookTarget: new Vector3(),
  getViewportCount: function () {
    return this._viewportCount;
  },
  getFrustum: function () {
    return this._frustum;
  },
  updateMatrices: function (light) {
    const shadowCamera = this.camera,
      shadowMatrix = this.matrix,
      projScreenMatrix = this._projScreenMatrix,
      lookTarget = this._lookTarget,
      lightPositionWorld = this._lightPositionWorld;
    lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
    shadowCamera.position.copy(lightPositionWorld);
    lookTarget.setFromMatrixPosition(light.target.matrixWorld);
    shadowCamera.lookAt(lookTarget);
    shadowCamera.updateMatrixWorld();
    projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(projScreenMatrix);
    shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
    shadowMatrix.multiply(shadowCamera.projectionMatrix);
    shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
  },
  getViewport: function (viewportIndex) {
    return this._viewports[viewportIndex];
  },
  getFrameExtents: function () {
    return this._frameExtents;
  },
  copy: function (source) {
    this.camera = source.camera.clone();
    this.bias = source.bias;
    this.radius = source.radius;
    this.mapSize.copy(source.mapSize);
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  toJSON: function () {
    const object = {};
    if (this.bias !== 0) object.bias = this.bias;
    if (this.normalBias !== 0) object.normalBias = this.normalBias;
    if (this.radius !== 1) object.radius = this.radius;
    if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
    object.camera = this.camera.toJSON(false).object;
    delete object.camera.matrix;
    return object;
  }
});
function SpotLightShadow() {
  LightShadow.call(this, new PerspectiveCamera(50, 1, 0.5, 500));
  this.focus = 1;
}
SpotLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
  constructor: SpotLightShadow,
  isSpotLightShadow: true,
  updateMatrices: function (light) {
    const camera = this.camera;
    const fov = MathUtils.RAD2DEG * 2 * light.angle * this.focus;
    const aspect = this.mapSize.width / this.mapSize.height;
    const far = light.distance || camera.far;
    if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {
      camera.fov = fov;
      camera.aspect = aspect;
      camera.far = far;
      camera.updateProjectionMatrix();
    }
    LightShadow.prototype.updateMatrices.call(this, light);
  }
});
function SpotLight(color, intensity, distance, angle, penumbra, decay) {
  Light.call(this, color, intensity);
  this.type = 'SpotLight';
  this.position.copy(Object3D.DefaultUp);
  this.updateMatrix();
  this.target = new Object3D();
  Object.defineProperty(this, 'power', {
    get: function () {
      // intensity = power per solid angle.
      // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
      return this.intensity * Math.PI;
    },
    set: function (power) {
      // intensity = power per solid angle.
      // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
      this.intensity = power / Math.PI;
    }
  });
  this.distance = distance !== undefined ? distance : 0;
  this.angle = angle !== undefined ? angle : Math.PI / 3;
  this.penumbra = penumbra !== undefined ? penumbra : 0;
  this.decay = decay !== undefined ? decay : 1; // for physically correct lights, should be 2.

  this.shadow = new SpotLightShadow();
}
SpotLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: SpotLight,
  isSpotLight: true,
  copy: function (source) {
    Light.prototype.copy.call(this, source);
    this.distance = source.distance;
    this.angle = source.angle;
    this.penumbra = source.penumbra;
    this.decay = source.decay;
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
});
function PointLightShadow() {
  LightShadow.call(this, new PerspectiveCamera(90, 1, 0.5, 500));
  this._frameExtents = new Vector2(4, 2);
  this._viewportCount = 6;
  this._viewports = [
  // These viewports map a cube-map onto a 2D texture with the
  // following orientation:
  //
  //  xzXZ
  //   y Y
  //
  // X - Positive x direction
  // x - Negative x direction
  // Y - Positive y direction
  // y - Negative y direction
  // Z - Positive z direction
  // z - Negative z direction

  // positive X
  new Vector4(2, 1, 1, 1),
  // negative X
  new Vector4(0, 1, 1, 1),
  // positive Z
  new Vector4(3, 1, 1, 1),
  // negative Z
  new Vector4(1, 1, 1, 1),
  // positive Y
  new Vector4(3, 0, 1, 1),
  // negative Y
  new Vector4(1, 0, 1, 1)];
  this._cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)];
  this._cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)];
}
PointLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
  constructor: PointLightShadow,
  isPointLightShadow: true,
  updateMatrices: function (light, viewportIndex = 0) {
    const camera = this.camera,
      shadowMatrix = this.matrix,
      lightPositionWorld = this._lightPositionWorld,
      lookTarget = this._lookTarget,
      projScreenMatrix = this._projScreenMatrix;
    lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
    camera.position.copy(lightPositionWorld);
    lookTarget.copy(camera.position);
    lookTarget.add(this._cubeDirections[viewportIndex]);
    camera.up.copy(this._cubeUps[viewportIndex]);
    camera.lookAt(lookTarget);
    camera.updateMatrixWorld();
    shadowMatrix.makeTranslation(-lightPositionWorld.x, -lightPositionWorld.y, -lightPositionWorld.z);
    projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(projScreenMatrix);
  }
});
function PointLight(color, intensity, distance, decay) {
  Light.call(this, color, intensity);
  this.type = 'PointLight';
  Object.defineProperty(this, 'power', {
    get: function () {
      // intensity = power per solid angle.
      // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
      return this.intensity * 4 * Math.PI;
    },
    set: function (power) {
      // intensity = power per solid angle.
      // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
      this.intensity = power / (4 * Math.PI);
    }
  });
  this.distance = distance !== undefined ? distance : 0;
  this.decay = decay !== undefined ? decay : 1; // for physically correct lights, should be 2.

  this.shadow = new PointLightShadow();
}
PointLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: PointLight,
  isPointLight: true,
  copy: function (source) {
    Light.prototype.copy.call(this, source);
    this.distance = source.distance;
    this.decay = source.decay;
    this.shadow = source.shadow.clone();
    return this;
  }
});
function OrthographicCamera(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2000) {
  Camera.call(this);
  this.type = 'OrthographicCamera';
  this.zoom = 1;
  this.view = null;
  this.left = left;
  this.right = right;
  this.top = top;
  this.bottom = bottom;
  this.near = near;
  this.far = far;
  this.updateProjectionMatrix();
}
OrthographicCamera.prototype = Object.assign(Object.create(Camera.prototype), {
  constructor: OrthographicCamera,
  isOrthographicCamera: true,
  copy: function (source, recursive) {
    Camera.prototype.copy.call(this, source, recursive);
    this.left = source.left;
    this.right = source.right;
    this.top = source.top;
    this.bottom = source.bottom;
    this.near = source.near;
    this.far = source.far;
    this.zoom = source.zoom;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    return this;
  },
  setViewOffset: function (fullWidth, fullHeight, x, y, width, height) {
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  },
  clearViewOffset: function () {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  },
  updateProjectionMatrix: function () {
    const dx = (this.right - this.left) / (2 * this.zoom);
    const dy = (this.top - this.bottom) / (2 * this.zoom);
    const cx = (this.right + this.left) / 2;
    const cy = (this.top + this.bottom) / 2;
    let left = cx - dx;
    let right = cx + dx;
    let top = cy + dy;
    let bottom = cy - dy;
    if (this.view !== null && this.view.enabled) {
      const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
      const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      left += scaleW * this.view.offsetX;
      right = left + scaleW * this.view.width;
      top -= scaleH * this.view.offsetY;
      bottom = top - scaleH * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  },
  toJSON: function (meta) {
    const data = Object3D.prototype.toJSON.call(this, meta);
    data.object.zoom = this.zoom;
    data.object.left = this.left;
    data.object.right = this.right;
    data.object.top = this.top;
    data.object.bottom = this.bottom;
    data.object.near = this.near;
    data.object.far = this.far;
    if (this.view !== null) data.object.view = Object.assign({}, this.view);
    return data;
  }
});
function DirectionalLightShadow() {
  LightShadow.call(this, new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
}
DirectionalLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
  constructor: DirectionalLightShadow,
  isDirectionalLightShadow: true,
  updateMatrices: function (light) {
    LightShadow.prototype.updateMatrices.call(this, light);
  }
});
function DirectionalLight(color, intensity) {
  Light.call(this, color, intensity);
  this.type = 'DirectionalLight';
  this.position.copy(Object3D.DefaultUp);
  this.updateMatrix();
  this.target = new Object3D();
  this.shadow = new DirectionalLightShadow();
}
DirectionalLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: DirectionalLight,
  isDirectionalLight: true,
  copy: function (source) {
    Light.prototype.copy.call(this, source);
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
});
function AmbientLight(color, intensity) {
  Light.call(this, color, intensity);
  this.type = 'AmbientLight';
}
AmbientLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: AmbientLight,
  isAmbientLight: true
});
function RectAreaLight(color, intensity, width, height) {
  Light.call(this, color, intensity);
  this.type = 'RectAreaLight';
  this.width = width !== undefined ? width : 10;
  this.height = height !== undefined ? height : 10;
}
RectAreaLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: RectAreaLight,
  isRectAreaLight: true,
  copy: function (source) {
    Light.prototype.copy.call(this, source);
    this.width = source.width;
    this.height = source.height;
    return this;
  },
  toJSON: function (meta) {
    const data = Light.prototype.toJSON.call(this, meta);
    data.object.width = this.width;
    data.object.height = this.height;
    return data;
  }
});

/**
 * Primary reference:
 *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
 *
 * Secondary reference:
 *   https://www.ppsloan.org/publications/StupidSH36.pdf
 */

// 3-band SH defined by 9 coefficients

class SphericalHarmonics3 {
  constructor() {
    Object.defineProperty(this, 'isSphericalHarmonics3', {
      value: true
    });
    this.coefficients = [];
    for (let i = 0; i < 9; i++) {
      this.coefficients.push(new Vector3());
    }
  }
  set(coefficients) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].copy(coefficients[i]);
    }
    return this;
  }
  zero() {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].set(0, 0, 0);
    }
    return this;
  }

  // get the radiance in the direction of the normal
  // target is a Vector3
  getAt(normal, target) {
    // normal is assumed to be unit length

    const x = normal.x,
      y = normal.y,
      z = normal.z;
    const coeff = this.coefficients;

    // band 0
    target.copy(coeff[0]).multiplyScalar(0.282095);

    // band 1
    target.addScaledVector(coeff[1], 0.488603 * y);
    target.addScaledVector(coeff[2], 0.488603 * z);
    target.addScaledVector(coeff[3], 0.488603 * x);

    // band 2
    target.addScaledVector(coeff[4], 1.092548 * (x * y));
    target.addScaledVector(coeff[5], 1.092548 * (y * z));
    target.addScaledVector(coeff[6], 0.315392 * (3.0 * z * z - 1.0));
    target.addScaledVector(coeff[7], 1.092548 * (x * z));
    target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));
    return target;
  }

  // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
  // target is a Vector3
  // https://graphics.stanford.edu/papers/envmap/envmap.pdf
  getIrradianceAt(normal, target) {
    // normal is assumed to be unit length

    const x = normal.x,
      y = normal.y,
      z = normal.z;
    const coeff = this.coefficients;

    // band 0
    target.copy(coeff[0]).multiplyScalar(0.886227); // π * 0.282095

    // band 1
    target.addScaledVector(coeff[1], 2.0 * 0.511664 * y); // ( 2 * π / 3 ) * 0.488603
    target.addScaledVector(coeff[2], 2.0 * 0.511664 * z);
    target.addScaledVector(coeff[3], 2.0 * 0.511664 * x);

    // band 2
    target.addScaledVector(coeff[4], 2.0 * 0.429043 * x * y); // ( π / 4 ) * 1.092548
    target.addScaledVector(coeff[5], 2.0 * 0.429043 * y * z);
    target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708); // ( π / 4 ) * 0.315392 * 3
    target.addScaledVector(coeff[7], 2.0 * 0.429043 * x * z);
    target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y)); // ( π / 4 ) * 0.546274

    return target;
  }
  add(sh) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].add(sh.coefficients[i]);
    }
    return this;
  }
  addScaledSH(sh, s) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].addScaledVector(sh.coefficients[i], s);
    }
    return this;
  }
  scale(s) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].multiplyScalar(s);
    }
    return this;
  }
  lerp(sh, alpha) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].lerp(sh.coefficients[i], alpha);
    }
    return this;
  }
  equals(sh) {
    for (let i = 0; i < 9; i++) {
      if (!this.coefficients[i].equals(sh.coefficients[i])) {
        return false;
      }
    }
    return true;
  }
  copy(sh) {
    return this.set(sh.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(array, offset = 0) {
    const coefficients = this.coefficients;
    for (let i = 0; i < 9; i++) {
      coefficients[i].fromArray(array, offset + i * 3);
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const coefficients = this.coefficients;
    for (let i = 0; i < 9; i++) {
      coefficients[i].toArray(array, offset + i * 3);
    }
    return array;
  }

  // evaluate the basis functions
  // shBasis is an Array[ 9 ]
  static getBasisAt(normal, shBasis) {
    // normal is assumed to be unit length

    const x = normal.x,
      y = normal.y,
      z = normal.z;

    // band 0
    shBasis[0] = 0.282095;

    // band 1
    shBasis[1] = 0.488603 * y;
    shBasis[2] = 0.488603 * z;
    shBasis[3] = 0.488603 * x;

    // band 2
    shBasis[4] = 1.092548 * x * y;
    shBasis[5] = 1.092548 * y * z;
    shBasis[6] = 0.315392 * (3 * z * z - 1);
    shBasis[7] = 1.092548 * x * z;
    shBasis[8] = 0.546274 * (x * x - y * y);
  }
}
exports.SphericalHarmonics3 = SphericalHarmonics3;
function LightProbe(sh, intensity) {
  Light.call(this, undefined, intensity);
  this.type = 'LightProbe';
  this.sh = sh !== undefined ? sh : new SphericalHarmonics3();
}
LightProbe.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: LightProbe,
  isLightProbe: true,
  copy: function (source) {
    Light.prototype.copy.call(this, source);
    this.sh.copy(source.sh);
    return this;
  },
  fromJSON: function (json) {
    this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();
    this.sh.fromArray(json.sh);
    return this;
  },
  toJSON: function (meta) {
    const data = Light.prototype.toJSON.call(this, meta);
    data.object.sh = this.sh.toArray();
    return data;
  }
});
function MaterialLoader(manager) {
  Loader.call(this, manager);
  this.textures = {};
}
MaterialLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: MaterialLoader,
  load: function (url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(scope.manager);
    loader.setPath(scope.path);
    loader.setRequestHeader(scope.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function (text) {
      try {
        onLoad(scope.parse(JSON.parse(text)));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  },
  parse: function (json) {
    const textures = this.textures;
    function getTexture(name) {
      if (textures[name] === undefined) {
        console.warn('THREE.MaterialLoader: Undefined texture', name);
      }
      return textures[name];
    }
    const material = new Materials[json.type]();
    if (json.uuid !== undefined) material.uuid = json.uuid;
    if (json.name !== undefined) material.name = json.name;
    if (json.color !== undefined && material.color !== undefined) material.color.setHex(json.color);
    if (json.roughness !== undefined) material.roughness = json.roughness;
    if (json.metalness !== undefined) material.metalness = json.metalness;
    if (json.sheen !== undefined) material.sheen = new Color().setHex(json.sheen);
    if (json.emissive !== undefined && material.emissive !== undefined) material.emissive.setHex(json.emissive);
    if (json.specular !== undefined && material.specular !== undefined) material.specular.setHex(json.specular);
    if (json.shininess !== undefined) material.shininess = json.shininess;
    if (json.clearcoat !== undefined) material.clearcoat = json.clearcoat;
    if (json.clearcoatRoughness !== undefined) material.clearcoatRoughness = json.clearcoatRoughness;
    if (json.fog !== undefined) material.fog = json.fog;
    if (json.flatShading !== undefined) material.flatShading = json.flatShading;
    if (json.blending !== undefined) material.blending = json.blending;
    if (json.combine !== undefined) material.combine = json.combine;
    if (json.side !== undefined) material.side = json.side;
    if (json.opacity !== undefined) material.opacity = json.opacity;
    if (json.transparent !== undefined) material.transparent = json.transparent;
    if (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;
    if (json.depthTest !== undefined) material.depthTest = json.depthTest;
    if (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;
    if (json.colorWrite !== undefined) material.colorWrite = json.colorWrite;
    if (json.stencilWrite !== undefined) material.stencilWrite = json.stencilWrite;
    if (json.stencilWriteMask !== undefined) material.stencilWriteMask = json.stencilWriteMask;
    if (json.stencilFunc !== undefined) material.stencilFunc = json.stencilFunc;
    if (json.stencilRef !== undefined) material.stencilRef = json.stencilRef;
    if (json.stencilFuncMask !== undefined) material.stencilFuncMask = json.stencilFuncMask;
    if (json.stencilFail !== undefined) material.stencilFail = json.stencilFail;
    if (json.stencilZFail !== undefined) material.stencilZFail = json.stencilZFail;
    if (json.stencilZPass !== undefined) material.stencilZPass = json.stencilZPass;
    if (json.wireframe !== undefined) material.wireframe = json.wireframe;
    if (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth;
    if (json.wireframeLinecap !== undefined) material.wireframeLinecap = json.wireframeLinecap;
    if (json.wireframeLinejoin !== undefined) material.wireframeLinejoin = json.wireframeLinejoin;
    if (json.rotation !== undefined) material.rotation = json.rotation;
    if (json.linewidth !== 1) material.linewidth = json.linewidth;
    if (json.dashSize !== undefined) material.dashSize = json.dashSize;
    if (json.gapSize !== undefined) material.gapSize = json.gapSize;
    if (json.scale !== undefined) material.scale = json.scale;
    if (json.polygonOffset !== undefined) material.polygonOffset = json.polygonOffset;
    if (json.polygonOffsetFactor !== undefined) material.polygonOffsetFactor = json.polygonOffsetFactor;
    if (json.polygonOffsetUnits !== undefined) material.polygonOffsetUnits = json.polygonOffsetUnits;
    if (json.skinning !== undefined) material.skinning = json.skinning;
    if (json.morphTargets !== undefined) material.morphTargets = json.morphTargets;
    if (json.morphNormals !== undefined) material.morphNormals = json.morphNormals;
    if (json.dithering !== undefined) material.dithering = json.dithering;
    if (json.vertexTangents !== undefined) material.vertexTangents = json.vertexTangents;
    if (json.visible !== undefined) material.visible = json.visible;
    if (json.toneMapped !== undefined) material.toneMapped = json.toneMapped;
    if (json.userData !== undefined) material.userData = json.userData;
    if (json.vertexColors !== undefined) {
      if (typeof json.vertexColors === 'number') {
        material.vertexColors = json.vertexColors > 0 ? true : false;
      } else {
        material.vertexColors = json.vertexColors;
      }
    }

    // Shader Material

    if (json.uniforms !== undefined) {
      for (const name in json.uniforms) {
        const uniform = json.uniforms[name];
        material.uniforms[name] = {};
        switch (uniform.type) {
          case 't':
            material.uniforms[name].value = getTexture(uniform.value);
            break;
          case 'c':
            material.uniforms[name].value = new Color().setHex(uniform.value);
            break;
          case 'v2':
            material.uniforms[name].value = new Vector2().fromArray(uniform.value);
            break;
          case 'v3':
            material.uniforms[name].value = new Vector3().fromArray(uniform.value);
            break;
          case 'v4':
            material.uniforms[name].value = new Vector4().fromArray(uniform.value);
            break;
          case 'm3':
            material.uniforms[name].value = new Matrix3().fromArray(uniform.value);
            break;
          case 'm4':
            material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
            break;
          default:
            material.uniforms[name].value = uniform.value;
        }
      }
    }
    if (json.defines !== undefined) material.defines = json.defines;
    if (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;
    if (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;
    if (json.extensions !== undefined) {
      for (const key in json.extensions) {
        material.extensions[key] = json.extensions[key];
      }
    }

    // Deprecated

    if (json.shading !== undefined) material.flatShading = json.shading === 1; // THREE.FlatShading

    // for PointsMaterial

    if (json.size !== undefined) material.size = json.size;
    if (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation;

    // maps

    if (json.map !== undefined) material.map = getTexture(json.map);
    if (json.matcap !== undefined) material.matcap = getTexture(json.matcap);
    if (json.alphaMap !== undefined) material.alphaMap = getTexture(json.alphaMap);
    if (json.bumpMap !== undefined) material.bumpMap = getTexture(json.bumpMap);
    if (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;
    if (json.normalMap !== undefined) material.normalMap = getTexture(json.normalMap);
    if (json.normalMapType !== undefined) material.normalMapType = json.normalMapType;
    if (json.normalScale !== undefined) {
      let normalScale = json.normalScale;
      if (Array.isArray(normalScale) === false) {
        // Blender exporter used to export a scalar. See #7459

        normalScale = [normalScale, normalScale];
      }
      material.normalScale = new Vector2().fromArray(normalScale);
    }
    if (json.displacementMap !== undefined) material.displacementMap = getTexture(json.displacementMap);
    if (json.displacementScale !== undefined) material.displacementScale = json.displacementScale;
    if (json.displacementBias !== undefined) material.displacementBias = json.displacementBias;
    if (json.roughnessMap !== undefined) material.roughnessMap = getTexture(json.roughnessMap);
    if (json.metalnessMap !== undefined) material.metalnessMap = getTexture(json.metalnessMap);
    if (json.emissiveMap !== undefined) material.emissiveMap = getTexture(json.emissiveMap);
    if (json.emissiveIntensity !== undefined) material.emissiveIntensity = json.emissiveIntensity;
    if (json.specularMap !== undefined) material.specularMap = getTexture(json.specularMap);
    if (json.envMap !== undefined) material.envMap = getTexture(json.envMap);
    if (json.envMapIntensity !== undefined) material.envMapIntensity = json.envMapIntensity;
    if (json.reflectivity !== undefined) material.reflectivity = json.reflectivity;
    if (json.refractionRatio !== undefined) material.refractionRatio = json.refractionRatio;
    if (json.lightMap !== undefined) material.lightMap = getTexture(json.lightMap);
    if (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity;
    if (json.aoMap !== undefined) material.aoMap = getTexture(json.aoMap);
    if (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity;
    if (json.gradientMap !== undefined) material.gradientMap = getTexture(json.gradientMap);
    if (json.clearcoatMap !== undefined) material.clearcoatMap = getTexture(json.clearcoatMap);
    if (json.clearcoatRoughnessMap !== undefined) material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
    if (json.clearcoatNormalMap !== undefined) material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
    if (json.clearcoatNormalScale !== undefined) material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);
    if (json.transmission !== undefined) material.transmission = json.transmission;
    if (json.transmissionMap !== undefined) material.transmissionMap = getTexture(json.transmissionMap);
    return material;
  },
  setTextures: function (value) {
    this.textures = value;
    return this;
  }
});
const LoaderUtils = {
  decodeText: function (array) {
    if (typeof TextDecoder !== 'undefined') {
      return new TextDecoder().decode(array);
    }

    // Avoid the String.fromCharCode.apply(null, array) shortcut, which
    // throws a "maximum call stack size exceeded" error for large arrays.

    let s = '';
    for (let i = 0, il = array.length; i < il; i++) {
      // Implicitly assumes little-endian.
      s += String.fromCharCode(array[i]);
    }
    try {
      // merges multi-byte utf-8 characters.

      return decodeURIComponent(escape(s));
    } catch (e) {
      // see #16358

      return s;
    }
  },
  extractUrlBase: function (url) {
    const index = url.lastIndexOf('/');
    if (index === -1) return './';
    return url.substr(0, index + 1);
  }
};
exports.LoaderUtils = LoaderUtils;
function InstancedBufferGeometry() {
  BufferGeometry.call(this);
  this.type = 'InstancedBufferGeometry';
  this.instanceCount = Infinity;
}
InstancedBufferGeometry.prototype = Object.assign(Object.create(BufferGeometry.prototype), {
  constructor: InstancedBufferGeometry,
  isInstancedBufferGeometry: true,
  copy: function (source) {
    BufferGeometry.prototype.copy.call(this, source);
    this.instanceCount = source.instanceCount;
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  toJSON: function () {
    const data = BufferGeometry.prototype.toJSON.call(this);
    data.instanceCount = this.instanceCount;
    data.isInstancedBufferGeometry = true;
    return data;
  }
});
function InstancedBufferAttribute(array, itemSize, normalized, meshPerAttribute) {
  if (typeof normalized === 'number') {
    meshPerAttribute = normalized;
    normalized = false;
    console.error('THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.');
  }
  BufferAttribute.call(this, array, itemSize, normalized);
  this.meshPerAttribute = meshPerAttribute || 1;
}
InstancedBufferAttribute.prototype = Object.assign(Object.create(BufferAttribute.prototype), {
  constructor: InstancedBufferAttribute,
  isInstancedBufferAttribute: true,
  copy: function (source) {
    BufferAttribute.prototype.copy.call(this, source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  },
  toJSON: function () {
    const data = BufferAttribute.prototype.toJSON.call(this);
    data.meshPerAttribute = this.meshPerAttribute;
    data.isInstancedBufferAttribute = true;
    return data;
  }
});
function BufferGeometryLoader(manager) {
  Loader.call(this, manager);
}
BufferGeometryLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: BufferGeometryLoader,
  load: function (url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(scope.manager);
    loader.setPath(scope.path);
    loader.setRequestHeader(scope.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function (text) {
      try {
        onLoad(scope.parse(JSON.parse(text)));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  },
  parse: function (json) {
    const interleavedBufferMap = {};
    const arrayBufferMap = {};
    function getInterleavedBuffer(json, uuid) {
      if (interleavedBufferMap[uuid] !== undefined) return interleavedBufferMap[uuid];
      const interleavedBuffers = json.interleavedBuffers;
      const interleavedBuffer = interleavedBuffers[uuid];
      const buffer = getArrayBuffer(json, interleavedBuffer.buffer);
      const array = getTypedArray(interleavedBuffer.type, buffer);
      const ib = new InterleavedBuffer(array, interleavedBuffer.stride);
      ib.uuid = interleavedBuffer.uuid;
      interleavedBufferMap[uuid] = ib;
      return ib;
    }
    function getArrayBuffer(json, uuid) {
      if (arrayBufferMap[uuid] !== undefined) return arrayBufferMap[uuid];
      const arrayBuffers = json.arrayBuffers;
      const arrayBuffer = arrayBuffers[uuid];
      const ab = new Uint32Array(arrayBuffer).buffer;
      arrayBufferMap[uuid] = ab;
      return ab;
    }
    const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
    const index = json.data.index;
    if (index !== undefined) {
      const typedArray = getTypedArray(index.type, index.array);
      geometry.setIndex(new BufferAttribute(typedArray, 1));
    }
    const attributes = json.data.attributes;
    for (const key in attributes) {
      const attribute = attributes[key];
      let bufferAttribute;
      if (attribute.isInterleavedBufferAttribute) {
        const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
        bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
      } else {
        const typedArray = getTypedArray(attribute.type, attribute.array);
        const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
        bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);
      }
      if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
      geometry.setAttribute(key, bufferAttribute);
    }
    const morphAttributes = json.data.morphAttributes;
    if (morphAttributes) {
      for (const key in morphAttributes) {
        const attributeArray = morphAttributes[key];
        const array = [];
        for (let i = 0, il = attributeArray.length; i < il; i++) {
          const attribute = attributeArray[i];
          let bufferAttribute;
          if (attribute.isInterleavedBufferAttribute) {
            const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
            bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
          } else {
            const typedArray = getTypedArray(attribute.type, attribute.array);
            bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);
          }
          if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
          array.push(bufferAttribute);
        }
        geometry.morphAttributes[key] = array;
      }
    }
    const morphTargetsRelative = json.data.morphTargetsRelative;
    if (morphTargetsRelative) {
      geometry.morphTargetsRelative = true;
    }
    const groups = json.data.groups || json.data.drawcalls || json.data.offsets;
    if (groups !== undefined) {
      for (let i = 0, n = groups.length; i !== n; ++i) {
        const group = groups[i];
        geometry.addGroup(group.start, group.count, group.materialIndex);
      }
    }
    const boundingSphere = json.data.boundingSphere;
    if (boundingSphere !== undefined) {
      const center = new Vector3();
      if (boundingSphere.center !== undefined) {
        center.fromArray(boundingSphere.center);
      }
      geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
    }
    if (json.name) geometry.name = json.name;
    if (json.userData) geometry.userData = json.userData;
    return geometry;
  }
});
class ObjectLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;
    this.resourcePath = this.resourcePath || path;
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function (text) {
      let json = null;
      try {
        json = JSON.parse(text);
      } catch (error) {
        if (onError !== undefined) onError(error);
        console.error('THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message);
        return;
      }
      const metadata = json.metadata;
      if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {
        console.error('THREE.ObjectLoader: Can\'t load ' + url);
        return;
      }
      scope.parse(json, onLoad);
    }, onProgress, onError);
  }
  parse(json, onLoad) {
    const animations = this.parseAnimations(json.animations);
    const shapes = this.parseShapes(json.shapes);
    const geometries = this.parseGeometries(json.geometries, shapes);
    const images = this.parseImages(json.images, function () {
      if (onLoad !== undefined) onLoad(object);
    });
    const textures = this.parseTextures(json.textures, images);
    const materials = this.parseMaterials(json.materials, textures);
    const object = this.parseObject(json.object, geometries, materials, animations);
    const skeletons = this.parseSkeletons(json.skeletons, object);
    this.bindSkeletons(object, skeletons);

    //

    if (onLoad !== undefined) {
      let hasImages = false;
      for (const uuid in images) {
        if (images[uuid] instanceof HTMLImageElement) {
          hasImages = true;
          break;
        }
      }
      if (hasImages === false) onLoad(object);
    }
    return object;
  }
  parseShapes(json) {
    const shapes = {};
    if (json !== undefined) {
      for (let i = 0, l = json.length; i < l; i++) {
        const shape = new Shape().fromJSON(json[i]);
        shapes[shape.uuid] = shape;
      }
    }
    return shapes;
  }
  parseSkeletons(json, object) {
    const skeletons = {};
    const bones = {};

    // generate bone lookup table

    object.traverse(function (child) {
      if (child.isBone) bones[child.uuid] = child;
    });

    // create skeletons

    if (json !== undefined) {
      for (let i = 0, l = json.length; i < l; i++) {
        const skeleton = new Skeleton().fromJSON(json[i], bones);
        skeletons[skeleton.uuid] = skeleton;
      }
    }
    return skeletons;
  }
  parseGeometries(json, shapes) {
    const geometries = {};
    let geometryShapes;
    if (json !== undefined) {
      const bufferGeometryLoader = new BufferGeometryLoader();
      for (let i = 0, l = json.length; i < l; i++) {
        let geometry;
        const data = json[i];
        switch (data.type) {
          case 'PlaneGeometry':
          case 'PlaneBufferGeometry':
            geometry = new Geometries[data.type](data.width, data.height, data.widthSegments, data.heightSegments);
            break;
          case 'BoxGeometry':
          case 'BoxBufferGeometry':
            geometry = new Geometries[data.type](data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
            break;
          case 'CircleGeometry':
          case 'CircleBufferGeometry':
            geometry = new Geometries[data.type](data.radius, data.segments, data.thetaStart, data.thetaLength);
            break;
          case 'CylinderGeometry':
          case 'CylinderBufferGeometry':
            geometry = new Geometries[data.type](data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
            break;
          case 'ConeGeometry':
          case 'ConeBufferGeometry':
            geometry = new Geometries[data.type](data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
            break;
          case 'SphereGeometry':
          case 'SphereBufferGeometry':
            geometry = new Geometries[data.type](data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
            break;
          case 'DodecahedronGeometry':
          case 'DodecahedronBufferGeometry':
          case 'IcosahedronGeometry':
          case 'IcosahedronBufferGeometry':
          case 'OctahedronGeometry':
          case 'OctahedronBufferGeometry':
          case 'TetrahedronGeometry':
          case 'TetrahedronBufferGeometry':
            geometry = new Geometries[data.type](data.radius, data.detail);
            break;
          case 'RingGeometry':
          case 'RingBufferGeometry':
            geometry = new Geometries[data.type](data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
            break;
          case 'TorusGeometry':
          case 'TorusBufferGeometry':
            geometry = new Geometries[data.type](data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
            break;
          case 'TorusKnotGeometry':
          case 'TorusKnotBufferGeometry':
            geometry = new Geometries[data.type](data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
            break;
          case 'TubeGeometry':
          case 'TubeBufferGeometry':
            // This only works for built-in curves (e.g. CatmullRomCurve3).
            // User defined curves or instances of CurvePath will not be deserialized.
            geometry = new Geometries[data.type](new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);
            break;
          case 'LatheGeometry':
          case 'LatheBufferGeometry':
            geometry = new Geometries[data.type](data.points, data.segments, data.phiStart, data.phiLength);
            break;
          case 'PolyhedronGeometry':
          case 'PolyhedronBufferGeometry':
            geometry = new Geometries[data.type](data.vertices, data.indices, data.radius, data.details);
            break;
          case 'ShapeGeometry':
          case 'ShapeBufferGeometry':
            geometryShapes = [];
            for (let j = 0, jl = data.shapes.length; j < jl; j++) {
              const shape = shapes[data.shapes[j]];
              geometryShapes.push(shape);
            }
            geometry = new Geometries[data.type](geometryShapes, data.curveSegments);
            break;
          case 'ExtrudeGeometry':
          case 'ExtrudeBufferGeometry':
            geometryShapes = [];
            for (let j = 0, jl = data.shapes.length; j < jl; j++) {
              const shape = shapes[data.shapes[j]];
              geometryShapes.push(shape);
            }
            const extrudePath = data.options.extrudePath;
            if (extrudePath !== undefined) {
              data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
            }
            geometry = new Geometries[data.type](geometryShapes, data.options);
            break;
          case 'BufferGeometry':
          case 'InstancedBufferGeometry':
            geometry = bufferGeometryLoader.parse(data);
            break;
          case 'Geometry':
            console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');
            break;
          default:
            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"');
            continue;
        }
        geometry.uuid = data.uuid;
        if (data.name !== undefined) geometry.name = data.name;
        if (geometry.isBufferGeometry === true && data.userData !== undefined) geometry.userData = data.userData;
        geometries[data.uuid] = geometry;
      }
    }
    return geometries;
  }
  parseMaterials(json, textures) {
    const cache = {}; // MultiMaterial
    const materials = {};
    if (json !== undefined) {
      const loader = new MaterialLoader();
      loader.setTextures(textures);
      for (let i = 0, l = json.length; i < l; i++) {
        const data = json[i];
        if (data.type === 'MultiMaterial') {
          // Deprecated

          const array = [];
          for (let j = 0; j < data.materials.length; j++) {
            const material = data.materials[j];
            if (cache[material.uuid] === undefined) {
              cache[material.uuid] = loader.parse(material);
            }
            array.push(cache[material.uuid]);
          }
          materials[data.uuid] = array;
        } else {
          if (cache[data.uuid] === undefined) {
            cache[data.uuid] = loader.parse(data);
          }
          materials[data.uuid] = cache[data.uuid];
        }
      }
    }
    return materials;
  }
  parseAnimations(json) {
    const animations = {};
    if (json !== undefined) {
      for (let i = 0; i < json.length; i++) {
        const data = json[i];
        const clip = AnimationClip.parse(data);
        animations[clip.uuid] = clip;
      }
    }
    return animations;
  }
  parseImages(json, onLoad) {
    const scope = this;
    const images = {};
    let loader;
    function loadImage(url) {
      scope.manager.itemStart(url);
      return loader.load(url, function () {
        scope.manager.itemEnd(url);
      }, undefined, function () {
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      });
    }
    function deserializeImage(image) {
      if (typeof image === 'string') {
        const url = image;
        const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
        return loadImage(path);
      } else {
        if (image.data) {
          return {
            data: getTypedArray(image.type, image.data),
            width: image.width,
            height: image.height
          };
        } else {
          return null;
        }
      }
    }
    if (json !== undefined && json.length > 0) {
      const manager = new LoadingManager(onLoad);
      loader = new ImageLoader(manager);
      loader.setCrossOrigin(this.crossOrigin);
      for (let i = 0, il = json.length; i < il; i++) {
        const image = json[i];
        const url = image.url;
        if (Array.isArray(url)) {
          // load array of images e.g CubeTexture

          images[image.uuid] = [];
          for (let j = 0, jl = url.length; j < jl; j++) {
            const currentUrl = url[j];
            const deserializedImage = deserializeImage(currentUrl);
            if (deserializedImage !== null) {
              if (deserializedImage instanceof HTMLImageElement) {
                images[image.uuid].push(deserializedImage);
              } else {
                // special case: handle array of data textures for cube textures

                images[image.uuid].push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
              }
            }
          }
        } else {
          // load single image

          const deserializedImage = deserializeImage(image.url);
          if (deserializedImage !== null) {
            images[image.uuid] = deserializedImage;
          }
        }
      }
    }
    return images;
  }
  parseTextures(json, images) {
    function parseConstant(value, type) {
      if (typeof value === 'number') return value;
      console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);
      return type[value];
    }
    const textures = {};
    if (json !== undefined) {
      for (let i = 0, l = json.length; i < l; i++) {
        const data = json[i];
        if (data.image === undefined) {
          console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
        }
        if (images[data.image] === undefined) {
          console.warn('THREE.ObjectLoader: Undefined image', data.image);
        }
        let texture;
        const image = images[data.image];
        if (Array.isArray(image)) {
          texture = new CubeTexture(image);
          if (image.length === 6) texture.needsUpdate = true;
        } else {
          if (image && image.data) {
            texture = new DataTexture(image.data, image.width, image.height);
          } else {
            texture = new Texture(image);
          }
          if (image) texture.needsUpdate = true; // textures can have undefined image data
        }

        texture.uuid = data.uuid;
        if (data.name !== undefined) texture.name = data.name;
        if (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
        if (data.offset !== undefined) texture.offset.fromArray(data.offset);
        if (data.repeat !== undefined) texture.repeat.fromArray(data.repeat);
        if (data.center !== undefined) texture.center.fromArray(data.center);
        if (data.rotation !== undefined) texture.rotation = data.rotation;
        if (data.wrap !== undefined) {
          texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
          texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
        }
        if (data.format !== undefined) texture.format = data.format;
        if (data.type !== undefined) texture.type = data.type;
        if (data.encoding !== undefined) texture.encoding = data.encoding;
        if (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
        if (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
        if (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;
        if (data.flipY !== undefined) texture.flipY = data.flipY;
        if (data.premultiplyAlpha !== undefined) texture.premultiplyAlpha = data.premultiplyAlpha;
        if (data.unpackAlignment !== undefined) texture.unpackAlignment = data.unpackAlignment;
        textures[data.uuid] = texture;
      }
    }
    return textures;
  }
  parseObject(data, geometries, materials, animations) {
    let object;
    function getGeometry(name) {
      if (geometries[name] === undefined) {
        console.warn('THREE.ObjectLoader: Undefined geometry', name);
      }
      return geometries[name];
    }
    function getMaterial(name) {
      if (name === undefined) return undefined;
      if (Array.isArray(name)) {
        const array = [];
        for (let i = 0, l = name.length; i < l; i++) {
          const uuid = name[i];
          if (materials[uuid] === undefined) {
            console.warn('THREE.ObjectLoader: Undefined material', uuid);
          }
          array.push(materials[uuid]);
        }
        return array;
      }
      if (materials[name] === undefined) {
        console.warn('THREE.ObjectLoader: Undefined material', name);
      }
      return materials[name];
    }
    let geometry, material;
    switch (data.type) {
      case 'Scene':
        object = new Scene();
        if (data.background !== undefined) {
          if (Number.isInteger(data.background)) {
            object.background = new Color(data.background);
          }
        }
        if (data.fog !== undefined) {
          if (data.fog.type === 'Fog') {
            object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
          } else if (data.fog.type === 'FogExp2') {
            object.fog = new FogExp2(data.fog.color, data.fog.density);
          }
        }
        break;
      case 'PerspectiveCamera':
        object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
        if (data.focus !== undefined) object.focus = data.focus;
        if (data.zoom !== undefined) object.zoom = data.zoom;
        if (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;
        if (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;
        if (data.view !== undefined) object.view = Object.assign({}, data.view);
        break;
      case 'OrthographicCamera':
        object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
        if (data.zoom !== undefined) object.zoom = data.zoom;
        if (data.view !== undefined) object.view = Object.assign({}, data.view);
        break;
      case 'AmbientLight':
        object = new AmbientLight(data.color, data.intensity);
        break;
      case 'DirectionalLight':
        object = new DirectionalLight(data.color, data.intensity);
        break;
      case 'PointLight':
        object = new PointLight(data.color, data.intensity, data.distance, data.decay);
        break;
      case 'RectAreaLight':
        object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
        break;
      case 'SpotLight':
        object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
        break;
      case 'HemisphereLight':
        object = new HemisphereLight(data.color, data.groundColor, data.intensity);
        break;
      case 'LightProbe':
        object = new LightProbe().fromJSON(data);
        break;
      case 'SkinnedMesh':
        geometry = getGeometry(data.geometry);
        material = getMaterial(data.material);
        object = new SkinnedMesh(geometry, material);
        if (data.bindMode !== undefined) object.bindMode = data.bindMode;
        if (data.bindMatrix !== undefined) object.bindMatrix.fromArray(data.bindMatrix);
        if (data.skeleton !== undefined) object.skeleton = data.skeleton;
        break;
      case 'Mesh':
        geometry = getGeometry(data.geometry);
        material = getMaterial(data.material);
        object = new Mesh(geometry, material);
        break;
      case 'InstancedMesh':
        geometry = getGeometry(data.geometry);
        material = getMaterial(data.material);
        const count = data.count;
        const instanceMatrix = data.instanceMatrix;
        object = new InstancedMesh(geometry, material, count);
        object.instanceMatrix = new BufferAttribute(new Float32Array(instanceMatrix.array), 16);
        break;
      case 'LOD':
        object = new LOD();
        break;
      case 'Line':
        object = new Line(getGeometry(data.geometry), getMaterial(data.material));
        break;
      case 'LineLoop':
        object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
        break;
      case 'LineSegments':
        object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
        break;
      case 'PointCloud':
      case 'Points':
        object = new Points(getGeometry(data.geometry), getMaterial(data.material));
        break;
      case 'Sprite':
        object = new Sprite(getMaterial(data.material));
        break;
      case 'Group':
        object = new Group();
        break;
      case 'Bone':
        object = new Bone();
        break;
      default:
        object = new Object3D();
    }
    object.uuid = data.uuid;
    if (data.name !== undefined) object.name = data.name;
    if (data.matrix !== undefined) {
      object.matrix.fromArray(data.matrix);
      if (data.matrixAutoUpdate !== undefined) object.matrixAutoUpdate = data.matrixAutoUpdate;
      if (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale);
    } else {
      if (data.position !== undefined) object.position.fromArray(data.position);
      if (data.rotation !== undefined) object.rotation.fromArray(data.rotation);
      if (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion);
      if (data.scale !== undefined) object.scale.fromArray(data.scale);
    }
    if (data.castShadow !== undefined) object.castShadow = data.castShadow;
    if (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;
    if (data.shadow) {
      if (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias;
      if (data.shadow.normalBias !== undefined) object.shadow.normalBias = data.shadow.normalBias;
      if (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius;
      if (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize);
      if (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera);
    }
    if (data.visible !== undefined) object.visible = data.visible;
    if (data.frustumCulled !== undefined) object.frustumCulled = data.frustumCulled;
    if (data.renderOrder !== undefined) object.renderOrder = data.renderOrder;
    if (data.userData !== undefined) object.userData = data.userData;
    if (data.layers !== undefined) object.layers.mask = data.layers;
    if (data.children !== undefined) {
      const children = data.children;
      for (let i = 0; i < children.length; i++) {
        object.add(this.parseObject(children[i], geometries, materials, animations));
      }
    }
    if (data.animations !== undefined) {
      const objectAnimations = data.animations;
      for (let i = 0; i < objectAnimations.length; i++) {
        const uuid = objectAnimations[i];
        object.animations.push(animations[uuid]);
      }
    }
    if (data.type === 'LOD') {
      if (data.autoUpdate !== undefined) object.autoUpdate = data.autoUpdate;
      const levels = data.levels;
      for (let l = 0; l < levels.length; l++) {
        const level = levels[l];
        const child = object.getObjectByProperty('uuid', level.object);
        if (child !== undefined) {
          object.addLevel(child, level.distance);
        }
      }
    }
    return object;
  }
  bindSkeletons(object, skeletons) {
    if (Object.keys(skeletons).length === 0) return;
    object.traverse(function (child) {
      if (child.isSkinnedMesh === true && child.skeleton !== undefined) {
        const skeleton = skeletons[child.skeleton];
        if (skeleton === undefined) {
          console.warn('THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton);
        } else {
          child.bind(skeleton, child.bindMatrix);
        }
      }
    });
  }

  /* DEPRECATED */

  setTexturePath(value) {
    console.warn('THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().');
    return this.setResourcePath(value);
  }
}
exports.ObjectLoader = ObjectLoader;
const TEXTURE_MAPPING = {
  UVMapping: UVMapping,
  CubeReflectionMapping: CubeReflectionMapping,
  CubeRefractionMapping: CubeRefractionMapping,
  EquirectangularReflectionMapping: EquirectangularReflectionMapping,
  EquirectangularRefractionMapping: EquirectangularRefractionMapping,
  CubeUVReflectionMapping: CubeUVReflectionMapping,
  CubeUVRefractionMapping: CubeUVRefractionMapping
};
const TEXTURE_WRAPPING = {
  RepeatWrapping: RepeatWrapping,
  ClampToEdgeWrapping: ClampToEdgeWrapping,
  MirroredRepeatWrapping: MirroredRepeatWrapping
};
const TEXTURE_FILTER = {
  NearestFilter: NearestFilter,
  NearestMipmapNearestFilter: NearestMipmapNearestFilter,
  NearestMipmapLinearFilter: NearestMipmapLinearFilter,
  LinearFilter: LinearFilter,
  LinearMipmapNearestFilter: LinearMipmapNearestFilter,
  LinearMipmapLinearFilter: LinearMipmapLinearFilter
};
function ImageBitmapLoader(manager) {
  if (typeof createImageBitmap === 'undefined') {
    console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');
  }
  if (typeof fetch === 'undefined') {
    console.warn('THREE.ImageBitmapLoader: fetch() not supported.');
  }
  Loader.call(this, manager);
  this.options = {
    premultiplyAlpha: 'none'
  };
}
ImageBitmapLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: ImageBitmapLoader,
  isImageBitmapLoader: true,
  setOptions: function setOptions(options) {
    this.options = options;
    return this;
  },
  load: function (url, onLoad, onProgress, onError) {
    if (url === undefined) url = '';
    if (this.path !== undefined) url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== undefined) {
      scope.manager.itemStart(url);
      setTimeout(function () {
        if (onLoad) onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    const fetchOptions = {};
    fetchOptions.credentials = this.crossOrigin === 'anonymous' ? 'same-origin' : 'include';
    fetch(url, fetchOptions).then(function (res) {
      return res.blob();
    }).then(function (blob) {
      return createImageBitmap(blob, scope.options);
    }).then(function (imageBitmap) {
      Cache.add(url, imageBitmap);
      if (onLoad) onLoad(imageBitmap);
      scope.manager.itemEnd(url);
    }).catch(function (e) {
      if (onError) onError(e);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    });
    scope.manager.itemStart(url);
  }
});
function ShapePath() {
  this.type = 'ShapePath';
  this.color = new Color();
  this.subPaths = [];
  this.currentPath = null;
}
Object.assign(ShapePath.prototype, {
  moveTo: function (x, y) {
    this.currentPath = new Path();
    this.subPaths.push(this.currentPath);
    this.currentPath.moveTo(x, y);
    return this;
  },
  lineTo: function (x, y) {
    this.currentPath.lineTo(x, y);
    return this;
  },
  quadraticCurveTo: function (aCPx, aCPy, aX, aY) {
    this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
    return this;
  },
  bezierCurveTo: function (aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
    return this;
  },
  splineThru: function (pts) {
    this.currentPath.splineThru(pts);
    return this;
  },
  toShapes: function (isCCW, noHoles) {
    function toShapesNoHoles(inSubpaths) {
      const shapes = [];
      for (let i = 0, l = inSubpaths.length; i < l; i++) {
        const tmpPath = inSubpaths[i];
        const tmpShape = new Shape();
        tmpShape.curves = tmpPath.curves;
        shapes.push(tmpShape);
      }
      return shapes;
    }
    function isPointInsidePolygon(inPt, inPolygon) {
      const polyLen = inPolygon.length;

      // inPt on polygon contour => immediate success    or
      // toggling of inside/outside at every single! intersection point of an edge
      //  with the horizontal line through inPt, left of inPt
      //  not counting lowerY endpoints of edges and whole edges on that line
      let inside = false;
      for (let p = polyLen - 1, q = 0; q < polyLen; p = q++) {
        let edgeLowPt = inPolygon[p];
        let edgeHighPt = inPolygon[q];
        let edgeDx = edgeHighPt.x - edgeLowPt.x;
        let edgeDy = edgeHighPt.y - edgeLowPt.y;
        if (Math.abs(edgeDy) > Number.EPSILON) {
          // not parallel
          if (edgeDy < 0) {
            edgeLowPt = inPolygon[q];
            edgeDx = -edgeDx;
            edgeHighPt = inPolygon[p];
            edgeDy = -edgeDy;
          }
          if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;
          if (inPt.y === edgeLowPt.y) {
            if (inPt.x === edgeLowPt.x) return true; // inPt is on contour ?
            // continue;				// no intersection or edgeLowPt => doesn't count !!!
          } else {
            const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
            if (perpEdge === 0) return true; // inPt is on contour ?
            if (perpEdge < 0) continue;
            inside = !inside; // true intersection left of inPt
          }
        } else {
          // parallel or collinear
          if (inPt.y !== edgeLowPt.y) continue; // parallel
          // edge lies on the same horizontal line as inPt
          if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true; // inPt: Point on contour !
          // continue;
        }
      }

      return inside;
    }
    const isClockWise = ShapeUtils.isClockWise;
    const subPaths = this.subPaths;
    if (subPaths.length === 0) return [];
    if (noHoles === true) return toShapesNoHoles(subPaths);
    let solid, tmpPath, tmpShape;
    const shapes = [];
    if (subPaths.length === 1) {
      tmpPath = subPaths[0];
      tmpShape = new Shape();
      tmpShape.curves = tmpPath.curves;
      shapes.push(tmpShape);
      return shapes;
    }
    let holesFirst = !isClockWise(subPaths[0].getPoints());
    holesFirst = isCCW ? !holesFirst : holesFirst;

    // console.log("Holes first", holesFirst);

    const betterShapeHoles = [];
    const newShapes = [];
    let newShapeHoles = [];
    let mainIdx = 0;
    let tmpPoints;
    newShapes[mainIdx] = undefined;
    newShapeHoles[mainIdx] = [];
    for (let i = 0, l = subPaths.length; i < l; i++) {
      tmpPath = subPaths[i];
      tmpPoints = tmpPath.getPoints();
      solid = isClockWise(tmpPoints);
      solid = isCCW ? !solid : solid;
      if (solid) {
        if (!holesFirst && newShapes[mainIdx]) mainIdx++;
        newShapes[mainIdx] = {
          s: new Shape(),
          p: tmpPoints
        };
        newShapes[mainIdx].s.curves = tmpPath.curves;
        if (holesFirst) mainIdx++;
        newShapeHoles[mainIdx] = [];

        //console.log('cw', i);
      } else {
        newShapeHoles[mainIdx].push({
          h: tmpPath,
          p: tmpPoints[0]
        });

        //console.log('ccw', i);
      }
    }

    // only Holes? -> probably all Shapes with wrong orientation
    if (!newShapes[0]) return toShapesNoHoles(subPaths);
    if (newShapes.length > 1) {
      let ambiguous = false;
      const toChange = [];
      for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
        betterShapeHoles[sIdx] = [];
      }
      for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
        const sho = newShapeHoles[sIdx];
        for (let hIdx = 0; hIdx < sho.length; hIdx++) {
          const ho = sho[hIdx];
          let hole_unassigned = true;
          for (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
            if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
              if (sIdx !== s2Idx) toChange.push({
                froms: sIdx,
                tos: s2Idx,
                hole: hIdx
              });
              if (hole_unassigned) {
                hole_unassigned = false;
                betterShapeHoles[s2Idx].push(ho);
              } else {
                ambiguous = true;
              }
            }
          }
          if (hole_unassigned) {
            betterShapeHoles[sIdx].push(ho);
          }
        }
      }
      // console.log("ambiguous: ", ambiguous);

      if (toChange.length > 0) {
        // console.log("to change: ", toChange);
        if (!ambiguous) newShapeHoles = betterShapeHoles;
      }
    }
    let tmpHoles;
    for (let i = 0, il = newShapes.length; i < il; i++) {
      tmpShape = newShapes[i].s;
      shapes.push(tmpShape);
      tmpHoles = newShapeHoles[i];
      for (let j = 0, jl = tmpHoles.length; j < jl; j++) {
        tmpShape.holes.push(tmpHoles[j].h);
      }
    }

    //console.log("shape", shapes);

    return shapes;
  }
});
class Font {
  constructor(data) {
    Object.defineProperty(this, 'isFont', {
      value: true
    });
    this.type = 'Font';
    this.data = data;
  }
  generateShapes(text, size = 100) {
    const shapes = [];
    const paths = createPaths(text, size, this.data);
    for (let p = 0, pl = paths.length; p < pl; p++) {
      Array.prototype.push.apply(shapes, paths[p].toShapes());
    }
    return shapes;
  }
}
exports.Font = Font;
function createPaths(text, size, data) {
  const chars = Array.from ? Array.from(text) : String(text).split(''); // workaround for IE11, see #13988
  const scale = size / data.resolution;
  const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
  const paths = [];
  let offsetX = 0,
    offsetY = 0;
  for (let i = 0; i < chars.length; i++) {
    const char = chars[i];
    if (char === '\n') {
      offsetX = 0;
      offsetY -= line_height;
    } else {
      const ret = createPath(char, scale, offsetX, offsetY, data);
      offsetX += ret.offsetX;
      paths.push(ret.path);
    }
  }
  return paths;
}
function createPath(char, scale, offsetX, offsetY, data) {
  const glyph = data.glyphs[char] || data.glyphs['?'];
  if (!glyph) {
    console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + '.');
    return;
  }
  const path = new ShapePath();
  let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
  if (glyph.o) {
    const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));
    for (let i = 0, l = outline.length; i < l;) {
      const action = outline[i++];
      switch (action) {
        case 'm':
          // moveTo

          x = outline[i++] * scale + offsetX;
          y = outline[i++] * scale + offsetY;
          path.moveTo(x, y);
          break;
        case 'l':
          // lineTo

          x = outline[i++] * scale + offsetX;
          y = outline[i++] * scale + offsetY;
          path.lineTo(x, y);
          break;
        case 'q':
          // quadraticCurveTo

          cpx = outline[i++] * scale + offsetX;
          cpy = outline[i++] * scale + offsetY;
          cpx1 = outline[i++] * scale + offsetX;
          cpy1 = outline[i++] * scale + offsetY;
          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
          break;
        case 'b':
          // bezierCurveTo

          cpx = outline[i++] * scale + offsetX;
          cpy = outline[i++] * scale + offsetY;
          cpx1 = outline[i++] * scale + offsetX;
          cpy1 = outline[i++] * scale + offsetY;
          cpx2 = outline[i++] * scale + offsetX;
          cpy2 = outline[i++] * scale + offsetY;
          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
          break;
      }
    }
  }
  return {
    offsetX: glyph.ha * scale,
    path: path
  };
}
function FontLoader(manager) {
  Loader.call(this, manager);
}
FontLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: FontLoader,
  load: function (url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function (text) {
      let json;
      try {
        json = JSON.parse(text);
      } catch (e) {
        console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');
        json = JSON.parse(text.substring(65, text.length - 2));
      }
      const font = scope.parse(json);
      if (onLoad) onLoad(font);
    }, onProgress, onError);
  },
  parse: function (json) {
    return new Font(json);
  }
});
let _context;
const AudioContext = {
  getContext: function () {
    if (_context === undefined) {
      _context = new (window.AudioContext || window.webkitAudioContext)();
    }
    return _context;
  },
  setContext: function (value) {
    _context = value;
  }
};
exports.AudioContext = AudioContext;
function AudioLoader(manager) {
  Loader.call(this, manager);
}
AudioLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: AudioLoader,
  load: function (url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(scope.manager);
    loader.setResponseType('arraybuffer');
    loader.setPath(scope.path);
    loader.setRequestHeader(scope.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function (buffer) {
      try {
        // Create a copy of the buffer. The `decodeAudioData` method
        // detaches the buffer when complete, preventing reuse.
        const bufferCopy = buffer.slice(0);
        const context = AudioContext.getContext();
        context.decodeAudioData(bufferCopy, function (audioBuffer) {
          onLoad(audioBuffer);
        });
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
});
function HemisphereLightProbe(skyColor, groundColor, intensity) {
  LightProbe.call(this, undefined, intensity);
  const color1 = new Color().set(skyColor);
  const color2 = new Color().set(groundColor);
  const sky = new Vector3(color1.r, color1.g, color1.b);
  const ground = new Vector3(color2.r, color2.g, color2.b);

  // without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );
  const c0 = Math.sqrt(Math.PI);
  const c1 = c0 * Math.sqrt(0.75);
  this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
  this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
}
HemisphereLightProbe.prototype = Object.assign(Object.create(LightProbe.prototype), {
  constructor: HemisphereLightProbe,
  isHemisphereLightProbe: true,
  copy: function (source) {
    // modifying colors not currently supported

    LightProbe.prototype.copy.call(this, source);
    return this;
  },
  toJSON: function (meta) {
    const data = LightProbe.prototype.toJSON.call(this, meta);

    // data.sh = this.sh.toArray(); // todo

    return data;
  }
});
function AmbientLightProbe(color, intensity) {
  LightProbe.call(this, undefined, intensity);
  const color1 = new Color().set(color);

  // without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );
  this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
}
AmbientLightProbe.prototype = Object.assign(Object.create(LightProbe.prototype), {
  constructor: AmbientLightProbe,
  isAmbientLightProbe: true,
  copy: function (source) {
    // modifying color not currently supported

    LightProbe.prototype.copy.call(this, source);
    return this;
  },
  toJSON: function (meta) {
    const data = LightProbe.prototype.toJSON.call(this, meta);

    // data.sh = this.sh.toArray(); // todo

    return data;
  }
});
const _eyeRight = new Matrix4();
const _eyeLeft = new Matrix4();
function StereoCamera() {
  this.type = 'StereoCamera';
  this.aspect = 1;
  this.eyeSep = 0.064;
  this.cameraL = new PerspectiveCamera();
  this.cameraL.layers.enable(1);
  this.cameraL.matrixAutoUpdate = false;
  this.cameraR = new PerspectiveCamera();
  this.cameraR.layers.enable(2);
  this.cameraR.matrixAutoUpdate = false;
  this._cache = {
    focus: null,
    fov: null,
    aspect: null,
    near: null,
    far: null,
    zoom: null,
    eyeSep: null
  };
}
Object.assign(StereoCamera.prototype, {
  update: function (camera) {
    const cache = this._cache;
    const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;
    if (needsUpdate) {
      cache.focus = camera.focus;
      cache.fov = camera.fov;
      cache.aspect = camera.aspect * this.aspect;
      cache.near = camera.near;
      cache.far = camera.far;
      cache.zoom = camera.zoom;
      cache.eyeSep = this.eyeSep;

      // Off-axis stereoscopic effect based on
      // http://paulbourke.net/stereographics/stereorender/

      const projectionMatrix = camera.projectionMatrix.clone();
      const eyeSepHalf = cache.eyeSep / 2;
      const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
      const ymax = cache.near * Math.tan(MathUtils.DEG2RAD * cache.fov * 0.5) / cache.zoom;
      let xmin, xmax;

      // translate xOffset

      _eyeLeft.elements[12] = -eyeSepHalf;
      _eyeRight.elements[12] = eyeSepHalf;

      // for left eye

      xmin = -ymax * cache.aspect + eyeSepOnProjection;
      xmax = ymax * cache.aspect + eyeSepOnProjection;
      projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
      projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
      this.cameraL.projectionMatrix.copy(projectionMatrix);

      // for right eye

      xmin = -ymax * cache.aspect - eyeSepOnProjection;
      xmax = ymax * cache.aspect - eyeSepOnProjection;
      projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
      projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
      this.cameraR.projectionMatrix.copy(projectionMatrix);
    }
    this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
    this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
  }
});
class Clock {
  constructor(autoStart) {
    this.autoStart = autoStart !== undefined ? autoStart : true;
    this.startTime = 0;
    this.oldTime = 0;
    this.elapsedTime = 0;
    this.running = false;
  }
  start() {
    this.startTime = now();
    this.oldTime = this.startTime;
    this.elapsedTime = 0;
    this.running = true;
  }
  stop() {
    this.getElapsedTime();
    this.running = false;
    this.autoStart = false;
  }
  getElapsedTime() {
    this.getDelta();
    return this.elapsedTime;
  }
  getDelta() {
    let diff = 0;
    if (this.autoStart && !this.running) {
      this.start();
      return 0;
    }
    if (this.running) {
      const newTime = now();
      diff = (newTime - this.oldTime) / 1000;
      this.oldTime = newTime;
      this.elapsedTime += diff;
    }
    return diff;
  }
}
exports.Clock = Clock;
function now() {
  return (typeof performance === 'undefined' ? Date : performance).now(); // see #10732
}

const _position$2 = /*@__PURE__*/new Vector3();
const _quaternion$3 = /*@__PURE__*/new Quaternion();
const _scale$1 = /*@__PURE__*/new Vector3();
const _orientation = /*@__PURE__*/new Vector3();
class AudioListener extends Object3D {
  constructor() {
    super();
    this.type = 'AudioListener';
    this.context = AudioContext.getContext();
    this.gain = this.context.createGain();
    this.gain.connect(this.context.destination);
    this.filter = null;
    this.timeDelta = 0;

    // private

    this._clock = new Clock();
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    if (this.filter !== null) {
      this.gain.disconnect(this.filter);
      this.filter.disconnect(this.context.destination);
      this.gain.connect(this.context.destination);
      this.filter = null;
    }
    return this;
  }
  getFilter() {
    return this.filter;
  }
  setFilter(value) {
    if (this.filter !== null) {
      this.gain.disconnect(this.filter);
      this.filter.disconnect(this.context.destination);
    } else {
      this.gain.disconnect(this.context.destination);
    }
    this.filter = value;
    this.gain.connect(this.filter);
    this.filter.connect(this.context.destination);
    return this;
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(value) {
    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
    return this;
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    const listener = this.context.listener;
    const up = this.up;
    this.timeDelta = this._clock.getDelta();
    this.matrixWorld.decompose(_position$2, _quaternion$3, _scale$1);
    _orientation.set(0, 0, -1).applyQuaternion(_quaternion$3);
    if (listener.positionX) {
      // code path for Chrome (see #14393)

      const endTime = this.context.currentTime + this.timeDelta;
      listener.positionX.linearRampToValueAtTime(_position$2.x, endTime);
      listener.positionY.linearRampToValueAtTime(_position$2.y, endTime);
      listener.positionZ.linearRampToValueAtTime(_position$2.z, endTime);
      listener.forwardX.linearRampToValueAtTime(_orientation.x, endTime);
      listener.forwardY.linearRampToValueAtTime(_orientation.y, endTime);
      listener.forwardZ.linearRampToValueAtTime(_orientation.z, endTime);
      listener.upX.linearRampToValueAtTime(up.x, endTime);
      listener.upY.linearRampToValueAtTime(up.y, endTime);
      listener.upZ.linearRampToValueAtTime(up.z, endTime);
    } else {
      listener.setPosition(_position$2.x, _position$2.y, _position$2.z);
      listener.setOrientation(_orientation.x, _orientation.y, _orientation.z, up.x, up.y, up.z);
    }
  }
}
exports.AudioListener = AudioListener;
class Audio extends Object3D {
  constructor(listener) {
    super();
    this.type = 'Audio';
    this.listener = listener;
    this.context = listener.context;
    this.gain = this.context.createGain();
    this.gain.connect(listener.getInput());
    this.autoplay = false;
    this.buffer = null;
    this.detune = 0;
    this.loop = false;
    this.loopStart = 0;
    this.loopEnd = 0;
    this.offset = 0;
    this.duration = undefined;
    this.playbackRate = 1;
    this.isPlaying = false;
    this.hasPlaybackControl = true;
    this.source = null;
    this.sourceType = 'empty';
    this._startedAt = 0;
    this._progress = 0;
    this._connected = false;
    this.filters = [];
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(audioNode) {
    this.hasPlaybackControl = false;
    this.sourceType = 'audioNode';
    this.source = audioNode;
    this.connect();
    return this;
  }
  setMediaElementSource(mediaElement) {
    this.hasPlaybackControl = false;
    this.sourceType = 'mediaNode';
    this.source = this.context.createMediaElementSource(mediaElement);
    this.connect();
    return this;
  }
  setMediaStreamSource(mediaStream) {
    this.hasPlaybackControl = false;
    this.sourceType = 'mediaStreamNode';
    this.source = this.context.createMediaStreamSource(mediaStream);
    this.connect();
    return this;
  }
  setBuffer(audioBuffer) {
    this.buffer = audioBuffer;
    this.sourceType = 'buffer';
    if (this.autoplay) this.play();
    return this;
  }
  play(delay = 0) {
    if (this.isPlaying === true) {
      console.warn('THREE.Audio: Audio is already playing.');
      return;
    }
    if (this.hasPlaybackControl === false) {
      console.warn('THREE.Audio: this Audio has no playback control.');
      return;
    }
    this._startedAt = this.context.currentTime + delay;
    const source = this.context.createBufferSource();
    source.buffer = this.buffer;
    source.loop = this.loop;
    source.loopStart = this.loopStart;
    source.loopEnd = this.loopEnd;
    source.onended = this.onEnded.bind(this);
    source.start(this._startedAt, this._progress + this.offset, this.duration);
    this.isPlaying = true;
    this.source = source;
    this.setDetune(this.detune);
    this.setPlaybackRate(this.playbackRate);
    return this.connect();
  }
  pause() {
    if (this.hasPlaybackControl === false) {
      console.warn('THREE.Audio: this Audio has no playback control.');
      return;
    }
    if (this.isPlaying === true) {
      // update current progress

      this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
      if (this.loop === true) {
        // ensure _progress does not exceed duration with looped audios

        this._progress = this._progress % (this.duration || this.buffer.duration);
      }
      this.source.stop();
      this.source.onended = null;
      this.isPlaying = false;
    }
    return this;
  }
  stop() {
    if (this.hasPlaybackControl === false) {
      console.warn('THREE.Audio: this Audio has no playback control.');
      return;
    }
    this._progress = 0;
    this.source.stop();
    this.source.onended = null;
    this.isPlaying = false;
    return this;
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let i = 1, l = this.filters.length; i < l; i++) {
        this.filters[i - 1].connect(this.filters[i]);
      }
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else {
      this.source.connect(this.getOutput());
    }
    this._connected = true;
    return this;
  }
  disconnect() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (let i = 1, l = this.filters.length; i < l; i++) {
        this.filters[i - 1].disconnect(this.filters[i]);
      }
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else {
      this.source.disconnect(this.getOutput());
    }
    this._connected = false;
    return this;
  }
  getFilters() {
    return this.filters;
  }
  setFilters(value) {
    if (!value) value = [];
    if (this._connected === true) {
      this.disconnect();
      this.filters = value.slice();
      this.connect();
    } else {
      this.filters = value.slice();
    }
    return this;
  }
  setDetune(value) {
    this.detune = value;
    if (this.source.detune === undefined) return; // only set detune when available

    if (this.isPlaying === true) {
      this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
    }
    return this;
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(filter) {
    return this.setFilters(filter ? [filter] : []);
  }
  setPlaybackRate(value) {
    if (this.hasPlaybackControl === false) {
      console.warn('THREE.Audio: this Audio has no playback control.');
      return;
    }
    this.playbackRate = value;
    if (this.isPlaying === true) {
      this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
    }
    return this;
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = false;
  }
  getLoop() {
    if (this.hasPlaybackControl === false) {
      console.warn('THREE.Audio: this Audio has no playback control.');
      return false;
    }
    return this.loop;
  }
  setLoop(value) {
    if (this.hasPlaybackControl === false) {
      console.warn('THREE.Audio: this Audio has no playback control.');
      return;
    }
    this.loop = value;
    if (this.isPlaying === true) {
      this.source.loop = this.loop;
    }
    return this;
  }
  setLoopStart(value) {
    this.loopStart = value;
    return this;
  }
  setLoopEnd(value) {
    this.loopEnd = value;
    return this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(value) {
    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
    return this;
  }
}
exports.Audio = Audio;
const _position$3 = /*@__PURE__*/new Vector3();
const _quaternion$4 = /*@__PURE__*/new Quaternion();
const _scale$2 = /*@__PURE__*/new Vector3();
const _orientation$1 = /*@__PURE__*/new Vector3();
class PositionalAudio extends Audio {
  constructor(listener) {
    super(listener);
    this.panner = this.context.createPanner();
    this.panner.panningModel = 'HRTF';
    this.panner.connect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(value) {
    this.panner.refDistance = value;
    return this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(value) {
    this.panner.rolloffFactor = value;
    return this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(value) {
    this.panner.distanceModel = value;
    return this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(value) {
    this.panner.maxDistance = value;
    return this;
  }
  setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
    this.panner.coneInnerAngle = coneInnerAngle;
    this.panner.coneOuterAngle = coneOuterAngle;
    this.panner.coneOuterGain = coneOuterGain;
    return this;
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (this.hasPlaybackControl === true && this.isPlaying === false) return;
    this.matrixWorld.decompose(_position$3, _quaternion$4, _scale$2);
    _orientation$1.set(0, 0, 1).applyQuaternion(_quaternion$4);
    const panner = this.panner;
    if (panner.positionX) {
      // code path for Chrome and Firefox (see #14393)

      const endTime = this.context.currentTime + this.listener.timeDelta;
      panner.positionX.linearRampToValueAtTime(_position$3.x, endTime);
      panner.positionY.linearRampToValueAtTime(_position$3.y, endTime);
      panner.positionZ.linearRampToValueAtTime(_position$3.z, endTime);
      panner.orientationX.linearRampToValueAtTime(_orientation$1.x, endTime);
      panner.orientationY.linearRampToValueAtTime(_orientation$1.y, endTime);
      panner.orientationZ.linearRampToValueAtTime(_orientation$1.z, endTime);
    } else {
      panner.setPosition(_position$3.x, _position$3.y, _position$3.z);
      panner.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z);
    }
  }
}
exports.PositionalAudio = PositionalAudio;
class AudioAnalyser {
  constructor(audio, fftSize = 2048) {
    this.analyser = audio.context.createAnalyser();
    this.analyser.fftSize = fftSize;
    this.data = new Uint8Array(this.analyser.frequencyBinCount);
    audio.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    this.analyser.getByteFrequencyData(this.data);
    return this.data;
  }
  getAverageFrequency() {
    let value = 0;
    const data = this.getFrequencyData();
    for (let i = 0; i < data.length; i++) {
      value += data[i];
    }
    return value / data.length;
  }
}
exports.AudioAnalyser = AudioAnalyser;
function PropertyMixer(binding, typeName, valueSize) {
  this.binding = binding;
  this.valueSize = valueSize;
  let mixFunction, mixFunctionAdditive, setIdentity;

  // buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
  //
  // interpolators can use .buffer as their .result
  // the data then goes to 'incoming'
  //
  // 'accu0' and 'accu1' are used frame-interleaved for
  // the cumulative result and are compared to detect
  // changes
  //
  // 'orig' stores the original state of the property
  //
  // 'add' is used for additive cumulative results
  //
  // 'work' is optional and is only present for quaternion types. It is used
  // to store intermediate quaternion multiplication results

  switch (typeName) {
    case 'quaternion':
      mixFunction = this._slerp;
      mixFunctionAdditive = this._slerpAdditive;
      setIdentity = this._setAdditiveIdentityQuaternion;
      this.buffer = new Float64Array(valueSize * 6);
      this._workIndex = 5;
      break;
    case 'string':
    case 'bool':
      mixFunction = this._select;

      // Use the regular mix function and for additive on these types,
      // additive is not relevant for non-numeric types
      mixFunctionAdditive = this._select;
      setIdentity = this._setAdditiveIdentityOther;
      this.buffer = new Array(valueSize * 5);
      break;
    default:
      mixFunction = this._lerp;
      mixFunctionAdditive = this._lerpAdditive;
      setIdentity = this._setAdditiveIdentityNumeric;
      this.buffer = new Float64Array(valueSize * 5);
  }
  this._mixBufferRegion = mixFunction;
  this._mixBufferRegionAdditive = mixFunctionAdditive;
  this._setIdentity = setIdentity;
  this._origIndex = 3;
  this._addIndex = 4;
  this.cumulativeWeight = 0;
  this.cumulativeWeightAdditive = 0;
  this.useCount = 0;
  this.referenceCount = 0;
}
Object.assign(PropertyMixer.prototype, {
  // accumulate data in the 'incoming' region into 'accu<i>'
  accumulate: function (accuIndex, weight) {
    // note: happily accumulating nothing when weight = 0, the caller knows
    // the weight and shouldn't have made the call in the first place

    const buffer = this.buffer,
      stride = this.valueSize,
      offset = accuIndex * stride + stride;
    let currentWeight = this.cumulativeWeight;
    if (currentWeight === 0) {
      // accuN := incoming * weight

      for (let i = 0; i !== stride; ++i) {
        buffer[offset + i] = buffer[i];
      }
      currentWeight = weight;
    } else {
      // accuN := accuN + incoming * weight

      currentWeight += weight;
      const mix = weight / currentWeight;
      this._mixBufferRegion(buffer, offset, 0, mix, stride);
    }
    this.cumulativeWeight = currentWeight;
  },
  // accumulate data in the 'incoming' region into 'add'
  accumulateAdditive: function (weight) {
    const buffer = this.buffer,
      stride = this.valueSize,
      offset = stride * this._addIndex;
    if (this.cumulativeWeightAdditive === 0) {
      // add = identity

      this._setIdentity();
    }

    // add := add + incoming * weight

    this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
    this.cumulativeWeightAdditive += weight;
  },
  // apply the state of 'accu<i>' to the binding when accus differ
  apply: function (accuIndex) {
    const stride = this.valueSize,
      buffer = this.buffer,
      offset = accuIndex * stride + stride,
      weight = this.cumulativeWeight,
      weightAdditive = this.cumulativeWeightAdditive,
      binding = this.binding;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
    if (weight < 1) {
      // accuN := accuN + original * ( 1 - cumulativeWeight )

      const originalValueOffset = stride * this._origIndex;
      this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
    }
    if (weightAdditive > 0) {
      // accuN := accuN + additive accuN

      this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
    }
    for (let i = stride, e = stride + stride; i !== e; ++i) {
      if (buffer[i] !== buffer[i + stride]) {
        // value has changed -> update scene graph

        binding.setValue(buffer, offset);
        break;
      }
    }
  },
  // remember the state of the bound property and copy it to both accus
  saveOriginalState: function () {
    const binding = this.binding;
    const buffer = this.buffer,
      stride = this.valueSize,
      originalValueOffset = stride * this._origIndex;
    binding.getValue(buffer, originalValueOffset);

    // accu[0..1] := orig -- initially detect changes against the original
    for (let i = stride, e = originalValueOffset; i !== e; ++i) {
      buffer[i] = buffer[originalValueOffset + i % stride];
    }

    // Add to identity for additive
    this._setIdentity();
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
  },
  // apply the state previously taken via 'saveOriginalState' to the binding
  restoreOriginalState: function () {
    const originalValueOffset = this.valueSize * 3;
    this.binding.setValue(this.buffer, originalValueOffset);
  },
  _setAdditiveIdentityNumeric: function () {
    const startIndex = this._addIndex * this.valueSize;
    const endIndex = startIndex + this.valueSize;
    for (let i = startIndex; i < endIndex; i++) {
      this.buffer[i] = 0;
    }
  },
  _setAdditiveIdentityQuaternion: function () {
    this._setAdditiveIdentityNumeric();
    this.buffer[this._addIndex * this.valueSize + 3] = 1;
  },
  _setAdditiveIdentityOther: function () {
    const startIndex = this._origIndex * this.valueSize;
    const targetIndex = this._addIndex * this.valueSize;
    for (let i = 0; i < this.valueSize; i++) {
      this.buffer[targetIndex + i] = this.buffer[startIndex + i];
    }
  },
  // mix functions

  _select: function (buffer, dstOffset, srcOffset, t, stride) {
    if (t >= 0.5) {
      for (let i = 0; i !== stride; ++i) {
        buffer[dstOffset + i] = buffer[srcOffset + i];
      }
    }
  },
  _slerp: function (buffer, dstOffset, srcOffset, t) {
    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
  },
  _slerpAdditive: function (buffer, dstOffset, srcOffset, t, stride) {
    const workOffset = this._workIndex * stride;

    // Store result in intermediate buffer offset
    Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);

    // Slerp to the intermediate result
    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);
  },
  _lerp: function (buffer, dstOffset, srcOffset, t, stride) {
    const s = 1 - t;
    for (let i = 0; i !== stride; ++i) {
      const j = dstOffset + i;
      buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
    }
  },
  _lerpAdditive: function (buffer, dstOffset, srcOffset, t, stride) {
    for (let i = 0; i !== stride; ++i) {
      const j = dstOffset + i;
      buffer[j] = buffer[j] + buffer[srcOffset + i] * t;
    }
  }
});

// Characters [].:/ are reserved for track binding syntax.
const _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
const _reservedRe = new RegExp('[' + _RESERVED_CHARS_RE + ']', 'g');

// Attempts to allow node names from any language. ES5's `\w` regexp matches
// only latin characters, and the unicode \p{L} is not yet supported. So
// instead, we exclude reserved characters and match everything else.
const _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
const _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace('\\.', '') + ']';

// Parent directories, delimited by '/' or ':'. Currently unused, but must
// be matched to parse the rest of the track name.
const _directoryRe = /((?:WC+[\/:])*)/.source.replace('WC', _wordChar);

// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
const _nodeRe = /(WCOD+)?/.source.replace('WCOD', _wordCharOrDot);

// Object on target node, and accessor. May not contain reserved
// characters. Accessor may contain any character except closing bracket.
const _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', _wordChar);

// Property and accessor. May not contain reserved characters. Accessor may
// contain any non-bracket characters.
const _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', _wordChar);
const _trackRe = new RegExp('' + '^' + _directoryRe + _nodeRe + _objectRe + _propertyRe + '$');
const _supportedObjectNames = ['material', 'materials', 'bones'];
function Composite(targetGroup, path, optionalParsedPath) {
  const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
  this._targetGroup = targetGroup;
  this._bindings = targetGroup.subscribe_(path, parsedPath);
}
Object.assign(Composite.prototype, {
  getValue: function (array, offset) {
    this.bind(); // bind all binding

    const firstValidIndex = this._targetGroup.nCachedObjects_,
      binding = this._bindings[firstValidIndex];

    // and only call .getValue on the first
    if (binding !== undefined) binding.getValue(array, offset);
  },
  setValue: function (array, offset) {
    const bindings = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].setValue(array, offset);
    }
  },
  bind: function () {
    const bindings = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].bind();
    }
  },
  unbind: function () {
    const bindings = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].unbind();
    }
  }
});
function PropertyBinding(rootNode, path, parsedPath) {
  this.path = path;
  this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
  this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
  this.rootNode = rootNode;
}
Object.assign(PropertyBinding, {
  Composite: Composite,
  create: function (root, path, parsedPath) {
    if (!(root && root.isAnimationObjectGroup)) {
      return new PropertyBinding(root, path, parsedPath);
    } else {
      return new PropertyBinding.Composite(root, path, parsedPath);
    }
  },
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name Node name to be sanitized.
   * @return {string}
   */
  sanitizeNodeName: function (name) {
    return name.replace(/\s/g, '_').replace(_reservedRe, '');
  },
  parseTrackName: function (trackName) {
    const matches = _trackRe.exec(trackName);
    if (!matches) {
      throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName);
    }
    const results = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: matches[2],
      objectName: matches[3],
      objectIndex: matches[4],
      propertyName: matches[5],
      // required
      propertyIndex: matches[6]
    };
    const lastDot = results.nodeName && results.nodeName.lastIndexOf('.');
    if (lastDot !== undefined && lastDot !== -1) {
      const objectName = results.nodeName.substring(lastDot + 1);

      // Object names must be checked against an allowlist. Otherwise, there
      // is no way to parse 'foo.bar.baz': 'baz' must be a property, but
      // 'bar' could be the objectName, or part of a nodeName (which can
      // include '.' characters).
      if (_supportedObjectNames.indexOf(objectName) !== -1) {
        results.nodeName = results.nodeName.substring(0, lastDot);
        results.objectName = objectName;
      }
    }
    if (results.propertyName === null || results.propertyName.length === 0) {
      throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);
    }
    return results;
  },
  findNode: function (root, nodeName) {
    if (!nodeName || nodeName === '' || nodeName === '.' || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
      return root;
    }

    // search into skeleton bones.
    if (root.skeleton) {
      const bone = root.skeleton.getBoneByName(nodeName);
      if (bone !== undefined) {
        return bone;
      }
    }

    // search into node subtree.
    if (root.children) {
      const searchNodeSubtree = function (children) {
        for (let i = 0; i < children.length; i++) {
          const childNode = children[i];
          if (childNode.name === nodeName || childNode.uuid === nodeName) {
            return childNode;
          }
          const result = searchNodeSubtree(childNode.children);
          if (result) return result;
        }
        return null;
      };
      const subTreeNode = searchNodeSubtree(root.children);
      if (subTreeNode) {
        return subTreeNode;
      }
    }
    return null;
  }
});
Object.assign(PropertyBinding.prototype, {
  // prototype, continued

  // these are used to "bind" a nonexistent property
  _getValue_unavailable: function () {},
  _setValue_unavailable: function () {},
  BindingType: {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
  },
  Versioning: {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
  },
  GetterByBindingType: [function getValue_direct(buffer, offset) {
    buffer[offset] = this.node[this.propertyName];
  }, function getValue_array(buffer, offset) {
    const source = this.resolvedProperty;
    for (let i = 0, n = source.length; i !== n; ++i) {
      buffer[offset++] = source[i];
    }
  }, function getValue_arrayElement(buffer, offset) {
    buffer[offset] = this.resolvedProperty[this.propertyIndex];
  }, function getValue_toArray(buffer, offset) {
    this.resolvedProperty.toArray(buffer, offset);
  }],
  SetterByBindingTypeAndVersioning: [[
  // Direct

  function setValue_direct(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
  }, function setValue_direct_setNeedsUpdate(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
    this.targetObject.needsUpdate = true;
  }, function setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }], [
  // EntireArray

  function setValue_array(buffer, offset) {
    const dest = this.resolvedProperty;
    for (let i = 0, n = dest.length; i !== n; ++i) {
      dest[i] = buffer[offset++];
    }
  }, function setValue_array_setNeedsUpdate(buffer, offset) {
    const dest = this.resolvedProperty;
    for (let i = 0, n = dest.length; i !== n; ++i) {
      dest[i] = buffer[offset++];
    }
    this.targetObject.needsUpdate = true;
  }, function setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
    const dest = this.resolvedProperty;
    for (let i = 0, n = dest.length; i !== n; ++i) {
      dest[i] = buffer[offset++];
    }
    this.targetObject.matrixWorldNeedsUpdate = true;
  }], [
  // ArrayElement

  function setValue_arrayElement(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
  }, function setValue_arrayElement_setNeedsUpdate(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
    this.targetObject.needsUpdate = true;
  }, function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }], [
  // HasToFromArray

  function setValue_fromArray(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
  }, function setValue_fromArray_setNeedsUpdate(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
    this.targetObject.needsUpdate = true;
  }, function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
    this.targetObject.matrixWorldNeedsUpdate = true;
  }]],
  getValue: function getValue_unbound(targetArray, offset) {
    this.bind();
    this.getValue(targetArray, offset);

    // Note: This class uses a State pattern on a per-method basis:
    // 'bind' sets 'this.getValue' / 'setValue' and shadows the
    // prototype version of these methods with one that represents
    // the bound state. When the property is not found, the methods
    // become no-ops.
  },

  setValue: function getValue_unbound(sourceArray, offset) {
    this.bind();
    this.setValue(sourceArray, offset);
  },
  // create getter / setter pair for a property in the scene graph
  bind: function () {
    let targetObject = this.node;
    const parsedPath = this.parsedPath;
    const objectName = parsedPath.objectName;
    const propertyName = parsedPath.propertyName;
    let propertyIndex = parsedPath.propertyIndex;
    if (!targetObject) {
      targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
      this.node = targetObject;
    }

    // set fail state so we can just 'return' on error
    this.getValue = this._getValue_unavailable;
    this.setValue = this._setValue_unavailable;

    // ensure there is a value node
    if (!targetObject) {
      console.error('THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.');
      return;
    }
    if (objectName) {
      let objectIndex = parsedPath.objectIndex;

      // special cases were we need to reach deeper into the hierarchy to get the face materials....
      switch (objectName) {
        case 'materials':
          if (!targetObject.material) {
            console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
            return;
          }
          if (!targetObject.material.materials) {
            console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);
            return;
          }
          targetObject = targetObject.material.materials;
          break;
        case 'bones':
          if (!targetObject.skeleton) {
            console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);
            return;
          }

          // potential future optimization: skip this if propertyIndex is already an integer
          // and convert the integer string to a true integer.

          targetObject = targetObject.skeleton.bones;

          // support resolving morphTarget names into indices.
          for (let i = 0; i < targetObject.length; i++) {
            if (targetObject[i].name === objectIndex) {
              objectIndex = i;
              break;
            }
          }
          break;
        default:
          if (targetObject[objectName] === undefined) {
            console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);
            return;
          }
          targetObject = targetObject[objectName];
      }
      if (objectIndex !== undefined) {
        if (targetObject[objectIndex] === undefined) {
          console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);
          return;
        }
        targetObject = targetObject[objectIndex];
      }
    }

    // resolve property
    const nodeProperty = targetObject[propertyName];
    if (nodeProperty === undefined) {
      const nodeName = parsedPath.nodeName;
      console.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName + '.' + propertyName + ' but it wasn\'t found.', targetObject);
      return;
    }

    // determine versioning scheme
    let versioning = this.Versioning.None;
    this.targetObject = targetObject;
    if (targetObject.needsUpdate !== undefined) {
      // material

      versioning = this.Versioning.NeedsUpdate;
    } else if (targetObject.matrixWorldNeedsUpdate !== undefined) {
      // node transform

      versioning = this.Versioning.MatrixWorldNeedsUpdate;
    }

    // determine how the property gets bound
    let bindingType = this.BindingType.Direct;
    if (propertyIndex !== undefined) {
      // access a sub element of the property array (only primitives are supported right now)

      if (propertyName === 'morphTargetInfluences') {
        // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

        // support resolving morphTarget names into indices.
        if (!targetObject.geometry) {
          console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);
          return;
        }
        if (targetObject.geometry.isBufferGeometry) {
          if (!targetObject.geometry.morphAttributes) {
            console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);
            return;
          }
          if (targetObject.morphTargetDictionary[propertyIndex] !== undefined) {
            propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
          }
        } else {
          console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this);
          return;
        }
      }
      bindingType = this.BindingType.ArrayElement;
      this.resolvedProperty = nodeProperty;
      this.propertyIndex = propertyIndex;
    } else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
      // must use copy for Object3D.Euler/Quaternion

      bindingType = this.BindingType.HasFromToArray;
      this.resolvedProperty = nodeProperty;
    } else if (Array.isArray(nodeProperty)) {
      bindingType = this.BindingType.EntireArray;
      this.resolvedProperty = nodeProperty;
    } else {
      this.propertyName = propertyName;
    }

    // select getter / setter
    this.getValue = this.GetterByBindingType[bindingType];
    this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
  },
  unbind: function () {
    this.node = null;

    // back to the prototype version of getValue / setValue
    // note: avoiding to mutate the shape of 'this' via 'delete'
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
});

// DECLARE ALIAS AFTER assign prototype
Object.assign(PropertyBinding.prototype, {
  // initial state of these methods that calls 'bind'
  _getValue_unbound: PropertyBinding.prototype.getValue,
  _setValue_unbound: PropertyBinding.prototype.setValue
});

/**
 *
 * A group of objects that receives a shared animation state.
 *
 * Usage:
 *
 *  - Add objects you would otherwise pass as 'root' to the
 *    constructor or the .clipAction method of AnimationMixer.
 *
 *  - Instead pass this object as 'root'.
 *
 *  - You can also add and remove objects later when the mixer
 *    is running.
 *
 * Note:
 *
 *    Objects of this class appear as one object to the mixer,
 *    so cache control of the individual objects must be done
 *    on the group.
 *
 * Limitation:
 *
 *  - The animated properties must be compatible among the
 *    all objects in the group.
 *
 *  - A single property can either be controlled through a
 *    target group or directly, but not both.
 */

function AnimationObjectGroup() {
  this.uuid = MathUtils.generateUUID();

  // cached objects followed by the active ones
  this._objects = Array.prototype.slice.call(arguments);
  this.nCachedObjects_ = 0; // threshold
  // note: read by PropertyBinding.Composite

  const indices = {};
  this._indicesByUUID = indices; // for bookkeeping

  for (let i = 0, n = arguments.length; i !== n; ++i) {
    indices[arguments[i].uuid] = i;
  }
  this._paths = []; // inside: string
  this._parsedPaths = []; // inside: { we don't care, here }
  this._bindings = []; // inside: Array< PropertyBinding >
  this._bindingsIndicesByPath = {}; // inside: indices in these arrays

  const scope = this;
  this.stats = {
    objects: {
      get total() {
        return scope._objects.length;
      },
      get inUse() {
        return this.total - scope.nCachedObjects_;
      }
    },
    get bindingsPerObject() {
      return scope._bindings.length;
    }
  };
}
Object.assign(AnimationObjectGroup.prototype, {
  isAnimationObjectGroup: true,
  add: function () {
    const objects = this._objects,
      indicesByUUID = this._indicesByUUID,
      paths = this._paths,
      parsedPaths = this._parsedPaths,
      bindings = this._bindings,
      nBindings = bindings.length;
    let knownObject = undefined,
      nObjects = objects.length,
      nCachedObjects = this.nCachedObjects_;
    for (let i = 0, n = arguments.length; i !== n; ++i) {
      const object = arguments[i],
        uuid = object.uuid;
      let index = indicesByUUID[uuid];
      if (index === undefined) {
        // unknown object -> add it to the ACTIVE region

        index = nObjects++;
        indicesByUUID[uuid] = index;
        objects.push(object);

        // accounting is done, now do the same for all bindings

        for (let j = 0, m = nBindings; j !== m; ++j) {
          bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
        }
      } else if (index < nCachedObjects) {
        knownObject = objects[index];

        // move existing object to the ACTIVE region

        const firstActiveIndex = --nCachedObjects,
          lastCachedObject = objects[firstActiveIndex];
        indicesByUUID[lastCachedObject.uuid] = index;
        objects[index] = lastCachedObject;
        indicesByUUID[uuid] = firstActiveIndex;
        objects[firstActiveIndex] = object;

        // accounting is done, now do the same for all bindings

        for (let j = 0, m = nBindings; j !== m; ++j) {
          const bindingsForPath = bindings[j],
            lastCached = bindingsForPath[firstActiveIndex];
          let binding = bindingsForPath[index];
          bindingsForPath[index] = lastCached;
          if (binding === undefined) {
            // since we do not bother to create new bindings
            // for objects that are cached, the binding may
            // or may not exist

            binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
          }
          bindingsForPath[firstActiveIndex] = binding;
        }
      } else if (objects[index] !== knownObject) {
        console.error('THREE.AnimationObjectGroup: Different objects with the same UUID ' + 'detected. Clean the caches or recreate your infrastructure when reloading scenes.');
      } // else the object is already where we want it to be
    } // for arguments

    this.nCachedObjects_ = nCachedObjects;
  },
  remove: function () {
    const objects = this._objects,
      indicesByUUID = this._indicesByUUID,
      bindings = this._bindings,
      nBindings = bindings.length;
    let nCachedObjects = this.nCachedObjects_;
    for (let i = 0, n = arguments.length; i !== n; ++i) {
      const object = arguments[i],
        uuid = object.uuid,
        index = indicesByUUID[uuid];
      if (index !== undefined && index >= nCachedObjects) {
        // move existing object into the CACHED region

        const lastCachedIndex = nCachedObjects++,
          firstActiveObject = objects[lastCachedIndex];
        indicesByUUID[firstActiveObject.uuid] = index;
        objects[index] = firstActiveObject;
        indicesByUUID[uuid] = lastCachedIndex;
        objects[lastCachedIndex] = object;

        // accounting is done, now do the same for all bindings

        for (let j = 0, m = nBindings; j !== m; ++j) {
          const bindingsForPath = bindings[j],
            firstActive = bindingsForPath[lastCachedIndex],
            binding = bindingsForPath[index];
          bindingsForPath[index] = firstActive;
          bindingsForPath[lastCachedIndex] = binding;
        }
      }
    } // for arguments

    this.nCachedObjects_ = nCachedObjects;
  },
  // remove & forget
  uncache: function () {
    const objects = this._objects,
      indicesByUUID = this._indicesByUUID,
      bindings = this._bindings,
      nBindings = bindings.length;
    let nCachedObjects = this.nCachedObjects_,
      nObjects = objects.length;
    for (let i = 0, n = arguments.length; i !== n; ++i) {
      const object = arguments[i],
        uuid = object.uuid,
        index = indicesByUUID[uuid];
      if (index !== undefined) {
        delete indicesByUUID[uuid];
        if (index < nCachedObjects) {
          // object is cached, shrink the CACHED region

          const firstActiveIndex = --nCachedObjects,
            lastCachedObject = objects[firstActiveIndex],
            lastIndex = --nObjects,
            lastObject = objects[lastIndex];

          // last cached object takes this object's place
          indicesByUUID[lastCachedObject.uuid] = index;
          objects[index] = lastCachedObject;

          // last object goes to the activated slot and pop
          indicesByUUID[lastObject.uuid] = firstActiveIndex;
          objects[firstActiveIndex] = lastObject;
          objects.pop();

          // accounting is done, now do the same for all bindings

          for (let j = 0, m = nBindings; j !== m; ++j) {
            const bindingsForPath = bindings[j],
              lastCached = bindingsForPath[firstActiveIndex],
              last = bindingsForPath[lastIndex];
            bindingsForPath[index] = lastCached;
            bindingsForPath[firstActiveIndex] = last;
            bindingsForPath.pop();
          }
        } else {
          // object is active, just swap with the last and pop

          const lastIndex = --nObjects,
            lastObject = objects[lastIndex];
          if (lastIndex > 0) {
            indicesByUUID[lastObject.uuid] = index;
          }
          objects[index] = lastObject;
          objects.pop();

          // accounting is done, now do the same for all bindings

          for (let j = 0, m = nBindings; j !== m; ++j) {
            const bindingsForPath = bindings[j];
            bindingsForPath[index] = bindingsForPath[lastIndex];
            bindingsForPath.pop();
          }
        } // cached or active
      } // if object is known
    } // for arguments

    this.nCachedObjects_ = nCachedObjects;
  },
  // Internal interface used by befriended PropertyBinding.Composite:

  subscribe_: function (path, parsedPath) {
    // returns an array of bindings for the given path that is changed
    // according to the contained objects in the group

    const indicesByPath = this._bindingsIndicesByPath;
    let index = indicesByPath[path];
    const bindings = this._bindings;
    if (index !== undefined) return bindings[index];
    const paths = this._paths,
      parsedPaths = this._parsedPaths,
      objects = this._objects,
      nObjects = objects.length,
      nCachedObjects = this.nCachedObjects_,
      bindingsForPath = new Array(nObjects);
    index = bindings.length;
    indicesByPath[path] = index;
    paths.push(path);
    parsedPaths.push(parsedPath);
    bindings.push(bindingsForPath);
    for (let i = nCachedObjects, n = objects.length; i !== n; ++i) {
      const object = objects[i];
      bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
    }
    return bindingsForPath;
  },
  unsubscribe_: function (path) {
    // tells the group to forget about a property path and no longer
    // update the array previously obtained with 'subscribe_'

    const indicesByPath = this._bindingsIndicesByPath,
      index = indicesByPath[path];
    if (index !== undefined) {
      const paths = this._paths,
        parsedPaths = this._parsedPaths,
        bindings = this._bindings,
        lastBindingsIndex = bindings.length - 1,
        lastBindings = bindings[lastBindingsIndex],
        lastBindingsPath = path[lastBindingsIndex];
      indicesByPath[lastBindingsPath] = index;
      bindings[index] = lastBindings;
      bindings.pop();
      parsedPaths[index] = parsedPaths[lastBindingsIndex];
      parsedPaths.pop();
      paths[index] = paths[lastBindingsIndex];
      paths.pop();
    }
  }
});
class AnimationAction {
  constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
    this._mixer = mixer;
    this._clip = clip;
    this._localRoot = localRoot;
    this.blendMode = blendMode;
    const tracks = clip.tracks,
      nTracks = tracks.length,
      interpolants = new Array(nTracks);
    const interpolantSettings = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };
    for (let i = 0; i !== nTracks; ++i) {
      const interpolant = tracks[i].createInterpolant(null);
      interpolants[i] = interpolant;
      interpolant.settings = interpolantSettings;
    }
    this._interpolantSettings = interpolantSettings;
    this._interpolants = interpolants; // bound by the mixer

    // inside: PropertyMixer (managed by the mixer)
    this._propertyBindings = new Array(nTracks);
    this._cacheIndex = null; // for the memory manager
    this._byClipCacheIndex = null; // for the memory manager

    this._timeScaleInterpolant = null;
    this._weightInterpolant = null;
    this.loop = LoopRepeat;
    this._loopCount = -1;

    // global mixer time when the action is to be started
    // it's set back to 'null' upon start of the action
    this._startTime = null;

    // scaled local time of the action
    // gets clamped or wrapped to 0..clip.duration according to loop
    this.time = 0;
    this.timeScale = 1;
    this._effectiveTimeScale = 1;
    this.weight = 1;
    this._effectiveWeight = 1;
    this.repetitions = Infinity; // no. of repetitions when looping

    this.paused = false; // true -> zero effective time scale
    this.enabled = true; // false -> zero effective weight

    this.clampWhenFinished = false; // keep feeding the last frame?

    this.zeroSlopeAtStart = true; // for smooth interpolation w/o separate
    this.zeroSlopeAtEnd = true; // clips for start, loop and end
  }

  // State & Scheduling

  play() {
    this._mixer._activateAction(this);
    return this;
  }
  stop() {
    this._mixer._deactivateAction(this);
    return this.reset();
  }
  reset() {
    this.paused = false;
    this.enabled = true;
    this.time = 0; // restart clip
    this._loopCount = -1; // forget previous loops
    this._startTime = null; // forget scheduling

    return this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }

  // return true when play has been called
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(time) {
    this._startTime = time;
    return this;
  }
  setLoop(mode, repetitions) {
    this.loop = mode;
    this.repetitions = repetitions;
    return this;
  }

  // Weight

  // set the weight stopping any scheduled fading
  // although .enabled = false yields an effective weight of zero, this
  // method does *not* change .enabled, because it would be confusing
  setEffectiveWeight(weight) {
    this.weight = weight;

    // note: same logic as when updated at runtime
    this._effectiveWeight = this.enabled ? weight : 0;
    return this.stopFading();
  }

  // return the weight considering fading and .enabled
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(duration) {
    return this._scheduleFading(duration, 0, 1);
  }
  fadeOut(duration) {
    return this._scheduleFading(duration, 1, 0);
  }
  crossFadeFrom(fadeOutAction, duration, warp) {
    fadeOutAction.fadeOut(duration);
    this.fadeIn(duration);
    if (warp) {
      const fadeInDuration = this._clip.duration,
        fadeOutDuration = fadeOutAction._clip.duration,
        startEndRatio = fadeOutDuration / fadeInDuration,
        endStartRatio = fadeInDuration / fadeOutDuration;
      fadeOutAction.warp(1.0, startEndRatio, duration);
      this.warp(endStartRatio, 1.0, duration);
    }
    return this;
  }
  crossFadeTo(fadeInAction, duration, warp) {
    return fadeInAction.crossFadeFrom(this, duration, warp);
  }
  stopFading() {
    const weightInterpolant = this._weightInterpolant;
    if (weightInterpolant !== null) {
      this._weightInterpolant = null;
      this._mixer._takeBackControlInterpolant(weightInterpolant);
    }
    return this;
  }

  // Time Scale Control

  // set the time scale stopping any scheduled warping
  // although .paused = true yields an effective time scale of zero, this
  // method does *not* change .paused, because it would be confusing
  setEffectiveTimeScale(timeScale) {
    this.timeScale = timeScale;
    this._effectiveTimeScale = this.paused ? 0 : timeScale;
    return this.stopWarping();
  }

  // return the time scale considering warping and .paused
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(duration) {
    this.timeScale = this._clip.duration / duration;
    return this.stopWarping();
  }
  syncWith(action) {
    this.time = action.time;
    this.timeScale = action.timeScale;
    return this.stopWarping();
  }
  halt(duration) {
    return this.warp(this._effectiveTimeScale, 0, duration);
  }
  warp(startTimeScale, endTimeScale, duration) {
    const mixer = this._mixer,
      now = mixer.time,
      timeScale = this.timeScale;
    let interpolant = this._timeScaleInterpolant;
    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._timeScaleInterpolant = interpolant;
    }
    const times = interpolant.parameterPositions,
      values = interpolant.sampleValues;
    times[0] = now;
    times[1] = now + duration;
    values[0] = startTimeScale / timeScale;
    values[1] = endTimeScale / timeScale;
    return this;
  }
  stopWarping() {
    const timeScaleInterpolant = this._timeScaleInterpolant;
    if (timeScaleInterpolant !== null) {
      this._timeScaleInterpolant = null;
      this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
    }
    return this;
  }

  // Object Accessors

  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }

  // Interna

  _update(time, deltaTime, timeDirection, accuIndex) {
    // called by the mixer

    if (!this.enabled) {
      // call ._updateWeight() to update ._effectiveWeight

      this._updateWeight(time);
      return;
    }
    const startTime = this._startTime;
    if (startTime !== null) {
      // check for scheduled start of action

      const timeRunning = (time - startTime) * timeDirection;
      if (timeRunning < 0 || timeDirection === 0) {
        return; // yet to come / don't decide when delta = 0
      }

      // start

      this._startTime = null; // unschedule
      deltaTime = timeDirection * timeRunning;
    }

    // apply time scale and advance time

    deltaTime *= this._updateTimeScale(time);
    const clipTime = this._updateTime(deltaTime);

    // note: _updateTime may disable the action resulting in
    // an effective weight of 0

    const weight = this._updateWeight(time);
    if (weight > 0) {
      const interpolants = this._interpolants;
      const propertyMixers = this._propertyBindings;
      switch (this.blendMode) {
        case AdditiveAnimationBlendMode:
          for (let j = 0, m = interpolants.length; j !== m; ++j) {
            interpolants[j].evaluate(clipTime);
            propertyMixers[j].accumulateAdditive(weight);
          }
          break;
        case NormalAnimationBlendMode:
        default:
          for (let j = 0, m = interpolants.length; j !== m; ++j) {
            interpolants[j].evaluate(clipTime);
            propertyMixers[j].accumulate(accuIndex, weight);
          }
      }
    }
  }
  _updateWeight(time) {
    let weight = 0;
    if (this.enabled) {
      weight = this.weight;
      const interpolant = this._weightInterpolant;
      if (interpolant !== null) {
        const interpolantValue = interpolant.evaluate(time)[0];
        weight *= interpolantValue;
        if (time > interpolant.parameterPositions[1]) {
          this.stopFading();
          if (interpolantValue === 0) {
            // faded out, disable
            this.enabled = false;
          }
        }
      }
    }
    this._effectiveWeight = weight;
    return weight;
  }
  _updateTimeScale(time) {
    let timeScale = 0;
    if (!this.paused) {
      timeScale = this.timeScale;
      const interpolant = this._timeScaleInterpolant;
      if (interpolant !== null) {
        const interpolantValue = interpolant.evaluate(time)[0];
        timeScale *= interpolantValue;
        if (time > interpolant.parameterPositions[1]) {
          this.stopWarping();
          if (timeScale === 0) {
            // motion has halted, pause
            this.paused = true;
          } else {
            // warp done - apply final time scale
            this.timeScale = timeScale;
          }
        }
      }
    }
    this._effectiveTimeScale = timeScale;
    return timeScale;
  }
  _updateTime(deltaTime) {
    const duration = this._clip.duration;
    const loop = this.loop;
    let time = this.time + deltaTime;
    let loopCount = this._loopCount;
    const pingPong = loop === LoopPingPong;
    if (deltaTime === 0) {
      if (loopCount === -1) return time;
      return pingPong && (loopCount & 1) === 1 ? duration - time : time;
    }
    if (loop === LoopOnce) {
      if (loopCount === -1) {
        // just started

        this._loopCount = 0;
        this._setEndings(true, true, false);
      }
      handle_stop: {
        if (time >= duration) {
          time = duration;
        } else if (time < 0) {
          time = 0;
        } else {
          this.time = time;
          break handle_stop;
        }
        if (this.clampWhenFinished) this.paused = true;else this.enabled = false;
        this.time = time;
        this._mixer.dispatchEvent({
          type: 'finished',
          action: this,
          direction: deltaTime < 0 ? -1 : 1
        });
      }
    } else {
      // repetitive Repeat or PingPong

      if (loopCount === -1) {
        // just started

        if (deltaTime >= 0) {
          loopCount = 0;
          this._setEndings(true, this.repetitions === 0, pingPong);
        } else {
          // when looping in reverse direction, the initial
          // transition through zero counts as a repetition,
          // so leave loopCount at -1

          this._setEndings(this.repetitions === 0, true, pingPong);
        }
      }
      if (time >= duration || time < 0) {
        // wrap around

        const loopDelta = Math.floor(time / duration); // signed
        time -= duration * loopDelta;
        loopCount += Math.abs(loopDelta);
        const pending = this.repetitions - loopCount;
        if (pending <= 0) {
          // have to stop (switch state, clamp time, fire event)

          if (this.clampWhenFinished) this.paused = true;else this.enabled = false;
          time = deltaTime > 0 ? duration : 0;
          this.time = time;
          this._mixer.dispatchEvent({
            type: 'finished',
            action: this,
            direction: deltaTime > 0 ? 1 : -1
          });
        } else {
          // keep running

          if (pending === 1) {
            // entering the last round

            const atStart = deltaTime < 0;
            this._setEndings(atStart, !atStart, pingPong);
          } else {
            this._setEndings(false, false, pingPong);
          }
          this._loopCount = loopCount;
          this.time = time;
          this._mixer.dispatchEvent({
            type: 'loop',
            action: this,
            loopDelta: loopDelta
          });
        }
      } else {
        this.time = time;
      }
      if (pingPong && (loopCount & 1) === 1) {
        // invert time for the "pong round"

        return duration - time;
      }
    }
    return time;
  }
  _setEndings(atStart, atEnd, pingPong) {
    const settings = this._interpolantSettings;
    if (pingPong) {
      settings.endingStart = ZeroSlopeEnding;
      settings.endingEnd = ZeroSlopeEnding;
    } else {
      // assuming for LoopOnce atStart == atEnd == true

      if (atStart) {
        settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingStart = WrapAroundEnding;
      }
      if (atEnd) {
        settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingEnd = WrapAroundEnding;
      }
    }
  }
  _scheduleFading(duration, weightNow, weightThen) {
    const mixer = this._mixer,
      now = mixer.time;
    let interpolant = this._weightInterpolant;
    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._weightInterpolant = interpolant;
    }
    const times = interpolant.parameterPositions,
      values = interpolant.sampleValues;
    times[0] = now;
    values[0] = weightNow;
    times[1] = now + duration;
    values[1] = weightThen;
    return this;
  }
}
function AnimationMixer(root) {
  this._root = root;
  this._initMemoryManager();
  this._accuIndex = 0;
  this.time = 0;
  this.timeScale = 1.0;
}
AnimationMixer.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: AnimationMixer,
  _bindAction: function (action, prototypeAction) {
    const root = action._localRoot || this._root,
      tracks = action._clip.tracks,
      nTracks = tracks.length,
      bindings = action._propertyBindings,
      interpolants = action._interpolants,
      rootUuid = root.uuid,
      bindingsByRoot = this._bindingsByRootAndName;
    let bindingsByName = bindingsByRoot[rootUuid];
    if (bindingsByName === undefined) {
      bindingsByName = {};
      bindingsByRoot[rootUuid] = bindingsByName;
    }
    for (let i = 0; i !== nTracks; ++i) {
      const track = tracks[i],
        trackName = track.name;
      let binding = bindingsByName[trackName];
      if (binding !== undefined) {
        bindings[i] = binding;
      } else {
        binding = bindings[i];
        if (binding !== undefined) {
          // existing binding, make sure the cache knows

          if (binding._cacheIndex === null) {
            ++binding.referenceCount;
            this._addInactiveBinding(binding, rootUuid, trackName);
          }
          continue;
        }
        const path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
        binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
        ++binding.referenceCount;
        this._addInactiveBinding(binding, rootUuid, trackName);
        bindings[i] = binding;
      }
      interpolants[i].resultBuffer = binding.buffer;
    }
  },
  _activateAction: function (action) {
    if (!this._isActiveAction(action)) {
      if (action._cacheIndex === null) {
        // this action has been forgotten by the cache, but the user
        // appears to be still using it -> rebind

        const rootUuid = (action._localRoot || this._root).uuid,
          clipUuid = action._clip.uuid,
          actionsForClip = this._actionsByClip[clipUuid];
        this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
        this._addInactiveAction(action, clipUuid, rootUuid);
      }
      const bindings = action._propertyBindings;

      // increment reference counts / sort out state
      for (let i = 0, n = bindings.length; i !== n; ++i) {
        const binding = bindings[i];
        if (binding.useCount++ === 0) {
          this._lendBinding(binding);
          binding.saveOriginalState();
        }
      }
      this._lendAction(action);
    }
  },
  _deactivateAction: function (action) {
    if (this._isActiveAction(action)) {
      const bindings = action._propertyBindings;

      // decrement reference counts / sort out state
      for (let i = 0, n = bindings.length; i !== n; ++i) {
        const binding = bindings[i];
        if (--binding.useCount === 0) {
          binding.restoreOriginalState();
          this._takeBackBinding(binding);
        }
      }
      this._takeBackAction(action);
    }
  },
  // Memory manager

  _initMemoryManager: function () {
    this._actions = []; // 'nActiveActions' followed by inactive ones
    this._nActiveActions = 0;
    this._actionsByClip = {};
    // inside:
    // {
    // 	knownActions: Array< AnimationAction > - used as prototypes
    // 	actionByRoot: AnimationAction - lookup
    // }

    this._bindings = []; // 'nActiveBindings' followed by inactive ones
    this._nActiveBindings = 0;
    this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >

    this._controlInterpolants = []; // same game as above
    this._nActiveControlInterpolants = 0;
    const scope = this;
    this.stats = {
      actions: {
        get total() {
          return scope._actions.length;
        },
        get inUse() {
          return scope._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return scope._bindings.length;
        },
        get inUse() {
          return scope._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return scope._controlInterpolants.length;
        },
        get inUse() {
          return scope._nActiveControlInterpolants;
        }
      }
    };
  },
  // Memory management for AnimationAction objects

  _isActiveAction: function (action) {
    const index = action._cacheIndex;
    return index !== null && index < this._nActiveActions;
  },
  _addInactiveAction: function (action, clipUuid, rootUuid) {
    const actions = this._actions,
      actionsByClip = this._actionsByClip;
    let actionsForClip = actionsByClip[clipUuid];
    if (actionsForClip === undefined) {
      actionsForClip = {
        knownActions: [action],
        actionByRoot: {}
      };
      action._byClipCacheIndex = 0;
      actionsByClip[clipUuid] = actionsForClip;
    } else {
      const knownActions = actionsForClip.knownActions;
      action._byClipCacheIndex = knownActions.length;
      knownActions.push(action);
    }
    action._cacheIndex = actions.length;
    actions.push(action);
    actionsForClip.actionByRoot[rootUuid] = action;
  },
  _removeInactiveAction: function (action) {
    const actions = this._actions,
      lastInactiveAction = actions[actions.length - 1],
      cacheIndex = action._cacheIndex;
    lastInactiveAction._cacheIndex = cacheIndex;
    actions[cacheIndex] = lastInactiveAction;
    actions.pop();
    action._cacheIndex = null;
    const clipUuid = action._clip.uuid,
      actionsByClip = this._actionsByClip,
      actionsForClip = actionsByClip[clipUuid],
      knownActionsForClip = actionsForClip.knownActions,
      lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1],
      byClipCacheIndex = action._byClipCacheIndex;
    lastKnownAction._byClipCacheIndex = byClipCacheIndex;
    knownActionsForClip[byClipCacheIndex] = lastKnownAction;
    knownActionsForClip.pop();
    action._byClipCacheIndex = null;
    const actionByRoot = actionsForClip.actionByRoot,
      rootUuid = (action._localRoot || this._root).uuid;
    delete actionByRoot[rootUuid];
    if (knownActionsForClip.length === 0) {
      delete actionsByClip[clipUuid];
    }
    this._removeInactiveBindingsForAction(action);
  },
  _removeInactiveBindingsForAction: function (action) {
    const bindings = action._propertyBindings;
    for (let i = 0, n = bindings.length; i !== n; ++i) {
      const binding = bindings[i];
      if (--binding.referenceCount === 0) {
        this._removeInactiveBinding(binding);
      }
    }
  },
  _lendAction: function (action) {
    // [ active actions |  inactive actions  ]
    // [  active actions >| inactive actions ]
    //                 s        a
    //                  <-swap->
    //                 a        s

    const actions = this._actions,
      prevIndex = action._cacheIndex,
      lastActiveIndex = this._nActiveActions++,
      firstInactiveAction = actions[lastActiveIndex];
    action._cacheIndex = lastActiveIndex;
    actions[lastActiveIndex] = action;
    firstInactiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = firstInactiveAction;
  },
  _takeBackAction: function (action) {
    // [  active actions  | inactive actions ]
    // [ active actions |< inactive actions  ]
    //        a        s
    //         <-swap->
    //        s        a

    const actions = this._actions,
      prevIndex = action._cacheIndex,
      firstInactiveIndex = --this._nActiveActions,
      lastActiveAction = actions[firstInactiveIndex];
    action._cacheIndex = firstInactiveIndex;
    actions[firstInactiveIndex] = action;
    lastActiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = lastActiveAction;
  },
  // Memory management for PropertyMixer objects

  _addInactiveBinding: function (binding, rootUuid, trackName) {
    const bindingsByRoot = this._bindingsByRootAndName,
      bindings = this._bindings;
    let bindingByName = bindingsByRoot[rootUuid];
    if (bindingByName === undefined) {
      bindingByName = {};
      bindingsByRoot[rootUuid] = bindingByName;
    }
    bindingByName[trackName] = binding;
    binding._cacheIndex = bindings.length;
    bindings.push(binding);
  },
  _removeInactiveBinding: function (binding) {
    const bindings = this._bindings,
      propBinding = binding.binding,
      rootUuid = propBinding.rootNode.uuid,
      trackName = propBinding.path,
      bindingsByRoot = this._bindingsByRootAndName,
      bindingByName = bindingsByRoot[rootUuid],
      lastInactiveBinding = bindings[bindings.length - 1],
      cacheIndex = binding._cacheIndex;
    lastInactiveBinding._cacheIndex = cacheIndex;
    bindings[cacheIndex] = lastInactiveBinding;
    bindings.pop();
    delete bindingByName[trackName];
    if (Object.keys(bindingByName).length === 0) {
      delete bindingsByRoot[rootUuid];
    }
  },
  _lendBinding: function (binding) {
    const bindings = this._bindings,
      prevIndex = binding._cacheIndex,
      lastActiveIndex = this._nActiveBindings++,
      firstInactiveBinding = bindings[lastActiveIndex];
    binding._cacheIndex = lastActiveIndex;
    bindings[lastActiveIndex] = binding;
    firstInactiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = firstInactiveBinding;
  },
  _takeBackBinding: function (binding) {
    const bindings = this._bindings,
      prevIndex = binding._cacheIndex,
      firstInactiveIndex = --this._nActiveBindings,
      lastActiveBinding = bindings[firstInactiveIndex];
    binding._cacheIndex = firstInactiveIndex;
    bindings[firstInactiveIndex] = binding;
    lastActiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = lastActiveBinding;
  },
  // Memory management of Interpolants for weight and time scale

  _lendControlInterpolant: function () {
    const interpolants = this._controlInterpolants,
      lastActiveIndex = this._nActiveControlInterpolants++;
    let interpolant = interpolants[lastActiveIndex];
    if (interpolant === undefined) {
      interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
      interpolant.__cacheIndex = lastActiveIndex;
      interpolants[lastActiveIndex] = interpolant;
    }
    return interpolant;
  },
  _takeBackControlInterpolant: function (interpolant) {
    const interpolants = this._controlInterpolants,
      prevIndex = interpolant.__cacheIndex,
      firstInactiveIndex = --this._nActiveControlInterpolants,
      lastActiveInterpolant = interpolants[firstInactiveIndex];
    interpolant.__cacheIndex = firstInactiveIndex;
    interpolants[firstInactiveIndex] = interpolant;
    lastActiveInterpolant.__cacheIndex = prevIndex;
    interpolants[prevIndex] = lastActiveInterpolant;
  },
  _controlInterpolantsResultBuffer: new Float32Array(1),
  // return an action for a clip optionally using a custom root target
  // object (this method allocates a lot of dynamic memory in case a
  // previously unknown clip/root combination is specified)
  clipAction: function (clip, optionalRoot, blendMode) {
    const root = optionalRoot || this._root,
      rootUuid = root.uuid;
    let clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip;
    const clipUuid = clipObject !== null ? clipObject.uuid : clip;
    const actionsForClip = this._actionsByClip[clipUuid];
    let prototypeAction = null;
    if (blendMode === undefined) {
      if (clipObject !== null) {
        blendMode = clipObject.blendMode;
      } else {
        blendMode = NormalAnimationBlendMode;
      }
    }
    if (actionsForClip !== undefined) {
      const existingAction = actionsForClip.actionByRoot[rootUuid];
      if (existingAction !== undefined && existingAction.blendMode === blendMode) {
        return existingAction;
      }

      // we know the clip, so we don't have to parse all
      // the bindings again but can just copy
      prototypeAction = actionsForClip.knownActions[0];

      // also, take the clip from the prototype action
      if (clipObject === null) clipObject = prototypeAction._clip;
    }

    // clip must be known when specified via string
    if (clipObject === null) return null;

    // allocate all resources required to run it
    const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
    this._bindAction(newAction, prototypeAction);

    // and make the action known to the memory manager
    this._addInactiveAction(newAction, clipUuid, rootUuid);
    return newAction;
  },
  // get an existing action
  existingAction: function (clip, optionalRoot) {
    const root = optionalRoot || this._root,
      rootUuid = root.uuid,
      clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip,
      clipUuid = clipObject ? clipObject.uuid : clip,
      actionsForClip = this._actionsByClip[clipUuid];
    if (actionsForClip !== undefined) {
      return actionsForClip.actionByRoot[rootUuid] || null;
    }
    return null;
  },
  // deactivates all previously scheduled actions
  stopAllAction: function () {
    const actions = this._actions,
      nActions = this._nActiveActions;
    for (let i = nActions - 1; i >= 0; --i) {
      actions[i].stop();
    }
    return this;
  },
  // advance the time and update apply the animation
  update: function (deltaTime) {
    deltaTime *= this.timeScale;
    const actions = this._actions,
      nActions = this._nActiveActions,
      time = this.time += deltaTime,
      timeDirection = Math.sign(deltaTime),
      accuIndex = this._accuIndex ^= 1;

    // run active actions

    for (let i = 0; i !== nActions; ++i) {
      const action = actions[i];
      action._update(time, deltaTime, timeDirection, accuIndex);
    }

    // update scene graph

    const bindings = this._bindings,
      nBindings = this._nActiveBindings;
    for (let i = 0; i !== nBindings; ++i) {
      bindings[i].apply(accuIndex);
    }
    return this;
  },
  // Allows you to seek to a specific time in an animation.
  setTime: function (timeInSeconds) {
    this.time = 0; // Zero out time attribute for AnimationMixer object;
    for (let i = 0; i < this._actions.length; i++) {
      this._actions[i].time = 0; // Zero out time attribute for all associated AnimationAction objects.
    }

    return this.update(timeInSeconds); // Update used to set exact time. Returns "this" AnimationMixer object.
  },

  // return this mixer's root target object
  getRoot: function () {
    return this._root;
  },
  // free all resources specific to a particular clip
  uncacheClip: function (clip) {
    const actions = this._actions,
      clipUuid = clip.uuid,
      actionsByClip = this._actionsByClip,
      actionsForClip = actionsByClip[clipUuid];
    if (actionsForClip !== undefined) {
      // note: just calling _removeInactiveAction would mess up the
      // iteration state and also require updating the state we can
      // just throw away

      const actionsToRemove = actionsForClip.knownActions;
      for (let i = 0, n = actionsToRemove.length; i !== n; ++i) {
        const action = actionsToRemove[i];
        this._deactivateAction(action);
        const cacheIndex = action._cacheIndex,
          lastInactiveAction = actions[actions.length - 1];
        action._cacheIndex = null;
        action._byClipCacheIndex = null;
        lastInactiveAction._cacheIndex = cacheIndex;
        actions[cacheIndex] = lastInactiveAction;
        actions.pop();
        this._removeInactiveBindingsForAction(action);
      }
      delete actionsByClip[clipUuid];
    }
  },
  // free all resources specific to a particular root target object
  uncacheRoot: function (root) {
    const rootUuid = root.uuid,
      actionsByClip = this._actionsByClip;
    for (const clipUuid in actionsByClip) {
      const actionByRoot = actionsByClip[clipUuid].actionByRoot,
        action = actionByRoot[rootUuid];
      if (action !== undefined) {
        this._deactivateAction(action);
        this._removeInactiveAction(action);
      }
    }
    const bindingsByRoot = this._bindingsByRootAndName,
      bindingByName = bindingsByRoot[rootUuid];
    if (bindingByName !== undefined) {
      for (const trackName in bindingByName) {
        const binding = bindingByName[trackName];
        binding.restoreOriginalState();
        this._removeInactiveBinding(binding);
      }
    }
  },
  // remove a targeted clip from the cache
  uncacheAction: function (clip, optionalRoot) {
    const action = this.existingAction(clip, optionalRoot);
    if (action !== null) {
      this._deactivateAction(action);
      this._removeInactiveAction(action);
    }
  }
});
class Uniform {
  constructor(value) {
    if (typeof value === 'string') {
      console.warn('THREE.Uniform: Type parameter is no longer needed.');
      value = arguments[1];
    }
    this.value = value;
  }
  clone() {
    return new Uniform(this.value.clone === undefined ? this.value : this.value.clone());
  }
}
exports.Uniform = Uniform;
function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
  InterleavedBuffer.call(this, array, stride);
  this.meshPerAttribute = meshPerAttribute || 1;
}
InstancedInterleavedBuffer.prototype = Object.assign(Object.create(InterleavedBuffer.prototype), {
  constructor: InstancedInterleavedBuffer,
  isInstancedInterleavedBuffer: true,
  copy: function (source) {
    InterleavedBuffer.prototype.copy.call(this, source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  },
  clone: function (data) {
    const ib = InterleavedBuffer.prototype.clone.call(this, data);
    ib.meshPerAttribute = this.meshPerAttribute;
    return ib;
  },
  toJSON: function (data) {
    const json = InterleavedBuffer.prototype.toJSON.call(this, data);
    json.isInstancedInterleavedBuffer = true;
    json.meshPerAttribute = this.meshPerAttribute;
    return json;
  }
});
function GLBufferAttribute(buffer, type, itemSize, elementSize, count) {
  this.buffer = buffer;
  this.type = type;
  this.itemSize = itemSize;
  this.elementSize = elementSize;
  this.count = count;
  this.version = 0;
}
Object.defineProperty(GLBufferAttribute.prototype, 'needsUpdate', {
  set: function (value) {
    if (value === true) this.version++;
  }
});
Object.assign(GLBufferAttribute.prototype, {
  isGLBufferAttribute: true,
  setBuffer: function (buffer) {
    this.buffer = buffer;
    return this;
  },
  setType: function (type, elementSize) {
    this.type = type;
    this.elementSize = elementSize;
    return this;
  },
  setItemSize: function (itemSize) {
    this.itemSize = itemSize;
    return this;
  },
  setCount: function (count) {
    this.count = count;
    return this;
  }
});
function Raycaster(origin, direction, near, far) {
  this.ray = new Ray(origin, direction);
  // direction is assumed to be normalized (for accurate distance calculations)

  this.near = near || 0;
  this.far = far || Infinity;
  this.camera = null;
  this.layers = new Layers();
  this.params = {
    Mesh: {},
    Line: {
      threshold: 1
    },
    LOD: {},
    Points: {
      threshold: 1
    },
    Sprite: {}
  };
  Object.defineProperties(this.params, {
    PointCloud: {
      get: function () {
        console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.');
        return this.Points;
      }
    }
  });
}
function ascSort(a, b) {
  return a.distance - b.distance;
}
function intersectObject(object, raycaster, intersects, recursive) {
  if (object.layers.test(raycaster.layers)) {
    object.raycast(raycaster, intersects);
  }
  if (recursive === true) {
    const children = object.children;
    for (let i = 0, l = children.length; i < l; i++) {
      intersectObject(children[i], raycaster, intersects, true);
    }
  }
}
Object.assign(Raycaster.prototype, {
  set: function (origin, direction) {
    // direction is assumed to be normalized (for accurate distance calculations)

    this.ray.set(origin, direction);
  },
  setFromCamera: function (coords, camera) {
    if (camera && camera.isPerspectiveCamera) {
      this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
      this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
      this.camera = camera;
    } else if (camera && camera.isOrthographicCamera) {
      this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera
      this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
      this.camera = camera;
    } else {
      console.error('THREE.Raycaster: Unsupported camera type: ' + camera.type);
    }
  },
  intersectObject: function (object, recursive, optionalTarget) {
    const intersects = optionalTarget || [];
    intersectObject(object, this, intersects, recursive);
    intersects.sort(ascSort);
    return intersects;
  },
  intersectObjects: function (objects, recursive, optionalTarget) {
    const intersects = optionalTarget || [];
    if (Array.isArray(objects) === false) {
      console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');
      return intersects;
    }
    for (let i = 0, l = objects.length; i < l; i++) {
      intersectObject(objects[i], this, intersects, recursive);
    }
    intersects.sort(ascSort);
    return intersects;
  }
});

/**
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
 * The azimuthal angle (theta) is measured from the positive z-axis.
 */

class Spherical {
  constructor(radius = 1, phi = 0, theta = 0) {
    this.radius = radius;
    this.phi = phi; // polar angle
    this.theta = theta; // azimuthal angle

    return this;
  }
  set(radius, phi, theta) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(other) {
    this.radius = other.radius;
    this.phi = other.phi;
    this.theta = other.theta;
    return this;
  }

  // restrict phi to be betwee EPS and PI-EPS
  makeSafe() {
    const EPS = 0.000001;
    this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
    return this;
  }
  setFromVector3(v) {
    return this.setFromCartesianCoords(v.x, v.y, v.z);
  }
  setFromCartesianCoords(x, y, z) {
    this.radius = Math.sqrt(x * x + y * y + z * z);
    if (this.radius === 0) {
      this.theta = 0;
      this.phi = 0;
    } else {
      this.theta = Math.atan2(x, z);
      this.phi = Math.acos(MathUtils.clamp(y / this.radius, -1, 1));
    }
    return this;
  }
}

/**
 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
 */
exports.Spherical = Spherical;
class Cylindrical {
  constructor(radius, theta, y) {
    this.radius = radius !== undefined ? radius : 1.0; // distance from the origin to a point in the x-z plane
    this.theta = theta !== undefined ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
    this.y = y !== undefined ? y : 0; // height above the x-z plane

    return this;
  }
  set(radius, theta, y) {
    this.radius = radius;
    this.theta = theta;
    this.y = y;
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(other) {
    this.radius = other.radius;
    this.theta = other.theta;
    this.y = other.y;
    return this;
  }
  setFromVector3(v) {
    return this.setFromCartesianCoords(v.x, v.y, v.z);
  }
  setFromCartesianCoords(x, y, z) {
    this.radius = Math.sqrt(x * x + z * z);
    this.theta = Math.atan2(x, z);
    this.y = y;
    return this;
  }
}
exports.Cylindrical = Cylindrical;
const _vector$8 = /*@__PURE__*/new Vector2();
class Box2 {
  constructor(min, max) {
    Object.defineProperty(this, 'isBox2', {
      value: true
    });
    this.min = min !== undefined ? min : new Vector2(+Infinity, +Infinity);
    this.max = max !== undefined ? max : new Vector2(-Infinity, -Infinity);
  }
  set(min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  }
  setFromPoints(points) {
    this.makeEmpty();
    for (let i = 0, il = points.length; i < il; i++) {
      this.expandByPoint(points[i]);
    }
    return this;
  }
  setFromCenterAndSize(center, size) {
    const halfSize = _vector$8.copy(size).multiplyScalar(0.5);
    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }
  makeEmpty() {
    this.min.x = this.min.y = +Infinity;
    this.max.x = this.max.y = -Infinity;
    return this;
  }
  isEmpty() {
    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(target) {
    if (target === undefined) {
      console.warn('THREE.Box2: .getCenter() target is now required');
      target = new Vector2();
    }
    return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(target) {
    if (target === undefined) {
      console.warn('THREE.Box2: .getSize() target is now required');
      target = new Vector2();
    }
    return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
  }
  expandByPoint(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  }
  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }
  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }
  containsPoint(point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
  }
  containsBox(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
  }
  getParameter(point, target) {
    // This can potentially have a divide by zero if the box
    // has a size dimension of 0.

    if (target === undefined) {
      console.warn('THREE.Box2: .getParameter() target is now required');
      target = new Vector2();
    }
    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
  }
  intersectsBox(box) {
    // using 4 splitting planes to rule out intersections

    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
  }
  clampPoint(point, target) {
    if (target === undefined) {
      console.warn('THREE.Box2: .clampPoint() target is now required');
      target = new Vector2();
    }
    return target.copy(point).clamp(this.min, this.max);
  }
  distanceToPoint(point) {
    const clampedPoint = _vector$8.copy(point).clamp(this.min, this.max);
    return clampedPoint.sub(point).length();
  }
  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    return this;
  }
  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }
  translate(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  }
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
}
exports.Box2 = Box2;
const _startP = /*@__PURE__*/new Vector3();
const _startEnd = /*@__PURE__*/new Vector3();
class Line3 {
  constructor(start, end) {
    this.start = start !== undefined ? start : new Vector3();
    this.end = end !== undefined ? end : new Vector3();
  }
  set(start, end) {
    this.start.copy(start);
    this.end.copy(end);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(line) {
    this.start.copy(line.start);
    this.end.copy(line.end);
    return this;
  }
  getCenter(target) {
    if (target === undefined) {
      console.warn('THREE.Line3: .getCenter() target is now required');
      target = new Vector3();
    }
    return target.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(target) {
    if (target === undefined) {
      console.warn('THREE.Line3: .delta() target is now required');
      target = new Vector3();
    }
    return target.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(t, target) {
    if (target === undefined) {
      console.warn('THREE.Line3: .at() target is now required');
      target = new Vector3();
    }
    return this.delta(target).multiplyScalar(t).add(this.start);
  }
  closestPointToPointParameter(point, clampToLine) {
    _startP.subVectors(point, this.start);
    _startEnd.subVectors(this.end, this.start);
    const startEnd2 = _startEnd.dot(_startEnd);
    const startEnd_startP = _startEnd.dot(_startP);
    let t = startEnd_startP / startEnd2;
    if (clampToLine) {
      t = MathUtils.clamp(t, 0, 1);
    }
    return t;
  }
  closestPointToPoint(point, clampToLine, target) {
    const t = this.closestPointToPointParameter(point, clampToLine);
    if (target === undefined) {
      console.warn('THREE.Line3: .closestPointToPoint() target is now required');
      target = new Vector3();
    }
    return this.delta(target).multiplyScalar(t).add(this.start);
  }
  applyMatrix4(matrix) {
    this.start.applyMatrix4(matrix);
    this.end.applyMatrix4(matrix);
    return this;
  }
  equals(line) {
    return line.start.equals(this.start) && line.end.equals(this.end);
  }
}
exports.Line3 = Line3;
function ImmediateRenderObject(material) {
  Object3D.call(this);
  this.material = material;
  this.render = function /* renderCallback */ () {};
  this.hasPositions = false;
  this.hasNormals = false;
  this.hasColors = false;
  this.hasUvs = false;
  this.positionArray = null;
  this.normalArray = null;
  this.colorArray = null;
  this.uvArray = null;
  this.count = 0;
}
ImmediateRenderObject.prototype = Object.create(Object3D.prototype);
ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;
ImmediateRenderObject.prototype.isImmediateRenderObject = true;
const _vector$9 = /*@__PURE__*/new Vector3();
class SpotLightHelper extends Object3D {
  constructor(light, color) {
    super();
    this.light = light;
    this.light.updateMatrixWorld();
    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.color = color;
    const geometry = new BufferGeometry();
    const positions = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
    for (let i = 0, j = 1, l = 32; i < l; i++, j++) {
      const p1 = i / l * Math.PI * 2;
      const p2 = j / l * Math.PI * 2;
      positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
    }
    geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
    const material = new LineBasicMaterial({
      fog: false,
      toneMapped: false
    });
    this.cone = new LineSegments(geometry, material);
    this.add(this.cone);
    this.update();
  }
  dispose() {
    this.cone.geometry.dispose();
    this.cone.material.dispose();
  }
  update() {
    this.light.updateMatrixWorld();
    const coneLength = this.light.distance ? this.light.distance : 1000;
    const coneWidth = coneLength * Math.tan(this.light.angle);
    this.cone.scale.set(coneWidth, coneWidth, coneLength);
    _vector$9.setFromMatrixPosition(this.light.target.matrixWorld);
    this.cone.lookAt(_vector$9);
    if (this.color !== undefined) {
      this.cone.material.color.set(this.color);
    } else {
      this.cone.material.color.copy(this.light.color);
    }
  }
}
exports.SpotLightHelper = SpotLightHelper;
const _vector$a = /*@__PURE__*/new Vector3();
const _boneMatrix = /*@__PURE__*/new Matrix4();
const _matrixWorldInv = /*@__PURE__*/new Matrix4();
class SkeletonHelper extends LineSegments {
  constructor(object) {
    const bones = getBoneList(object);
    const geometry = new BufferGeometry();
    const vertices = [];
    const colors = [];
    const color1 = new Color(0, 0, 1);
    const color2 = new Color(0, 1, 0);
    for (let i = 0; i < bones.length; i++) {
      const bone = bones[i];
      if (bone.parent && bone.parent.isBone) {
        vertices.push(0, 0, 0);
        vertices.push(0, 0, 0);
        colors.push(color1.r, color1.g, color1.b);
        colors.push(color2.r, color2.g, color2.b);
      }
    }
    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
    const material = new LineBasicMaterial({
      vertexColors: true,
      depthTest: false,
      depthWrite: false,
      toneMapped: false,
      transparent: true
    });
    super(geometry, material);
    this.type = 'SkeletonHelper';
    this.isSkeletonHelper = true;
    this.root = object;
    this.bones = bones;
    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;
  }
  updateMatrixWorld(force) {
    const bones = this.bones;
    const geometry = this.geometry;
    const position = geometry.getAttribute('position');
    _matrixWorldInv.copy(this.root.matrixWorld).invert();
    for (let i = 0, j = 0; i < bones.length; i++) {
      const bone = bones[i];
      if (bone.parent && bone.parent.isBone) {
        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
        _vector$a.setFromMatrixPosition(_boneMatrix);
        position.setXYZ(j, _vector$a.x, _vector$a.y, _vector$a.z);
        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
        _vector$a.setFromMatrixPosition(_boneMatrix);
        position.setXYZ(j + 1, _vector$a.x, _vector$a.y, _vector$a.z);
        j += 2;
      }
    }
    geometry.getAttribute('position').needsUpdate = true;
    super.updateMatrixWorld(force);
  }
}
exports.SkeletonHelper = SkeletonHelper;
function getBoneList(object) {
  const boneList = [];
  if (object && object.isBone) {
    boneList.push(object);
  }
  for (let i = 0; i < object.children.length; i++) {
    boneList.push.apply(boneList, getBoneList(object.children[i]));
  }
  return boneList;
}
class PointLightHelper extends Mesh {
  constructor(light, sphereSize, color) {
    const geometry = new SphereGeometry(sphereSize, 4, 2);
    const material = new MeshBasicMaterial({
      wireframe: true,
      fog: false,
      toneMapped: false
    });
    super(geometry, material);
    this.light = light;
    this.light.updateMatrixWorld();
    this.color = color;
    this.type = 'PointLightHelper';
    this.matrix = this.light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.update();

    /*
    // TODO: delete this comment?
    const distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );
    const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );
    this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
    this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );
    const d = light.distance;
    if ( d === 0.0 ) {
    	this.lightDistance.visible = false;
    } else {
    	this.lightDistance.scale.set( d, d, d );
    }
    this.add( this.lightDistance );
    */
  }

  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
  update() {
    if (this.color !== undefined) {
      this.material.color.set(this.color);
    } else {
      this.material.color.copy(this.light.color);
    }

    /*
    const d = this.light.distance;
    	if ( d === 0.0 ) {
    		this.lightDistance.visible = false;
    	} else {
    		this.lightDistance.visible = true;
    	this.lightDistance.scale.set( d, d, d );
    	}
    */
  }
}
exports.PointLightHelper = PointLightHelper;
const _vector$b = /*@__PURE__*/new Vector3();
const _color1 = /*@__PURE__*/new Color();
const _color2 = /*@__PURE__*/new Color();
class HemisphereLightHelper extends Object3D {
  constructor(light, size, color) {
    super();
    this.light = light;
    this.light.updateMatrixWorld();
    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.color = color;
    const geometry = new OctahedronGeometry(size);
    geometry.rotateY(Math.PI * 0.5);
    this.material = new MeshBasicMaterial({
      wireframe: true,
      fog: false,
      toneMapped: false
    });
    if (this.color === undefined) this.material.vertexColors = true;
    const position = geometry.getAttribute('position');
    const colors = new Float32Array(position.count * 3);
    geometry.setAttribute('color', new BufferAttribute(colors, 3));
    this.add(new Mesh(geometry, this.material));
    this.update();
  }
  dispose() {
    this.children[0].geometry.dispose();
    this.children[0].material.dispose();
  }
  update() {
    const mesh = this.children[0];
    if (this.color !== undefined) {
      this.material.color.set(this.color);
    } else {
      const colors = mesh.geometry.getAttribute('color');
      _color1.copy(this.light.color);
      _color2.copy(this.light.groundColor);
      for (let i = 0, l = colors.count; i < l; i++) {
        const color = i < l / 2 ? _color1 : _color2;
        colors.setXYZ(i, color.r, color.g, color.b);
      }
      colors.needsUpdate = true;
    }
    mesh.lookAt(_vector$b.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
exports.HemisphereLightHelper = HemisphereLightHelper;
class GridHelper extends LineSegments {
  constructor(size = 10, divisions = 10, color1 = 0x444444, color2 = 0x888888) {
    color1 = new Color(color1);
    color2 = new Color(color2);
    const center = divisions / 2;
    const step = size / divisions;
    const halfSize = size / 2;
    const vertices = [],
      colors = [];
    for (let i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {
      vertices.push(-halfSize, 0, k, halfSize, 0, k);
      vertices.push(k, 0, -halfSize, k, 0, halfSize);
      const color = i === center ? color1 : color2;
      color.toArray(colors, j);
      j += 3;
      color.toArray(colors, j);
      j += 3;
      color.toArray(colors, j);
      j += 3;
      color.toArray(colors, j);
      j += 3;
    }
    const geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
    const material = new LineBasicMaterial({
      vertexColors: true,
      toneMapped: false
    });
    super(geometry, material);
    this.type = 'GridHelper';
  }
}
exports.GridHelper = GridHelper;
class PolarGridHelper extends LineSegments {
  constructor(radius = 10, radials = 16, circles = 8, divisions = 64, color1 = 0x444444, color2 = 0x888888) {
    color1 = new Color(color1);
    color2 = new Color(color2);
    const vertices = [];
    const colors = [];

    // create the radials

    for (let i = 0; i <= radials; i++) {
      const v = i / radials * (Math.PI * 2);
      const x = Math.sin(v) * radius;
      const z = Math.cos(v) * radius;
      vertices.push(0, 0, 0);
      vertices.push(x, 0, z);
      const color = i & 1 ? color1 : color2;
      colors.push(color.r, color.g, color.b);
      colors.push(color.r, color.g, color.b);
    }

    // create the circles

    for (let i = 0; i <= circles; i++) {
      const color = i & 1 ? color1 : color2;
      const r = radius - radius / circles * i;
      for (let j = 0; j < divisions; j++) {
        // first vertex

        let v = j / divisions * (Math.PI * 2);
        let x = Math.sin(v) * r;
        let z = Math.cos(v) * r;
        vertices.push(x, 0, z);
        colors.push(color.r, color.g, color.b);

        // second vertex

        v = (j + 1) / divisions * (Math.PI * 2);
        x = Math.sin(v) * r;
        z = Math.cos(v) * r;
        vertices.push(x, 0, z);
        colors.push(color.r, color.g, color.b);
      }
    }
    const geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
    const material = new LineBasicMaterial({
      vertexColors: true,
      toneMapped: false
    });
    super(geometry, material);
    this.type = 'PolarGridHelper';
  }
}
exports.PolarGridHelper = PolarGridHelper;
const _v1$6 = /*@__PURE__*/new Vector3();
const _v2$3 = /*@__PURE__*/new Vector3();
const _v3$1 = /*@__PURE__*/new Vector3();
class DirectionalLightHelper extends Object3D {
  constructor(light, size, color) {
    super();
    this.light = light;
    this.light.updateMatrixWorld();
    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.color = color;
    if (size === undefined) size = 1;
    let geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute([-size, size, 0, size, size, 0, size, -size, 0, -size, -size, 0, -size, size, 0], 3));
    const material = new LineBasicMaterial({
      fog: false,
      toneMapped: false
    });
    this.lightPlane = new Line(geometry, material);
    this.add(this.lightPlane);
    geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
    this.targetLine = new Line(geometry, material);
    this.add(this.targetLine);
    this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose();
    this.lightPlane.material.dispose();
    this.targetLine.geometry.dispose();
    this.targetLine.material.dispose();
  }
  update() {
    _v1$6.setFromMatrixPosition(this.light.matrixWorld);
    _v2$3.setFromMatrixPosition(this.light.target.matrixWorld);
    _v3$1.subVectors(_v2$3, _v1$6);
    this.lightPlane.lookAt(_v2$3);
    if (this.color !== undefined) {
      this.lightPlane.material.color.set(this.color);
      this.targetLine.material.color.set(this.color);
    } else {
      this.lightPlane.material.color.copy(this.light.color);
      this.targetLine.material.color.copy(this.light.color);
    }
    this.targetLine.lookAt(_v2$3);
    this.targetLine.scale.z = _v3$1.length();
  }
}
exports.DirectionalLightHelper = DirectionalLightHelper;
const _vector$c = /*@__PURE__*/new Vector3();
const _camera = /*@__PURE__*/new Camera();

/**
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */

class CameraHelper extends LineSegments {
  constructor(camera) {
    const geometry = new BufferGeometry();
    const material = new LineBasicMaterial({
      color: 0xffffff,
      vertexColors: true,
      toneMapped: false
    });
    const vertices = [];
    const colors = [];
    const pointMap = {};

    // colors

    const colorFrustum = new Color(0xffaa00);
    const colorCone = new Color(0xff0000);
    const colorUp = new Color(0x00aaff);
    const colorTarget = new Color(0xffffff);
    const colorCross = new Color(0x333333);

    // near

    addLine('n1', 'n2', colorFrustum);
    addLine('n2', 'n4', colorFrustum);
    addLine('n4', 'n3', colorFrustum);
    addLine('n3', 'n1', colorFrustum);

    // far

    addLine('f1', 'f2', colorFrustum);
    addLine('f2', 'f4', colorFrustum);
    addLine('f4', 'f3', colorFrustum);
    addLine('f3', 'f1', colorFrustum);

    // sides

    addLine('n1', 'f1', colorFrustum);
    addLine('n2', 'f2', colorFrustum);
    addLine('n3', 'f3', colorFrustum);
    addLine('n4', 'f4', colorFrustum);

    // cone

    addLine('p', 'n1', colorCone);
    addLine('p', 'n2', colorCone);
    addLine('p', 'n3', colorCone);
    addLine('p', 'n4', colorCone);

    // up

    addLine('u1', 'u2', colorUp);
    addLine('u2', 'u3', colorUp);
    addLine('u3', 'u1', colorUp);

    // target

    addLine('c', 't', colorTarget);
    addLine('p', 'c', colorCross);

    // cross

    addLine('cn1', 'cn2', colorCross);
    addLine('cn3', 'cn4', colorCross);
    addLine('cf1', 'cf2', colorCross);
    addLine('cf3', 'cf4', colorCross);
    function addLine(a, b, color) {
      addPoint(a, color);
      addPoint(b, color);
    }
    function addPoint(id, color) {
      vertices.push(0, 0, 0);
      colors.push(color.r, color.g, color.b);
      if (pointMap[id] === undefined) {
        pointMap[id] = [];
      }
      pointMap[id].push(vertices.length / 3 - 1);
    }
    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
    super(geometry, material);
    this.type = 'CameraHelper';
    this.camera = camera;
    if (this.camera.updateProjectionMatrix) this.camera.updateProjectionMatrix();
    this.matrix = camera.matrixWorld;
    this.matrixAutoUpdate = false;
    this.pointMap = pointMap;
    this.update();
  }
  update() {
    const geometry = this.geometry;
    const pointMap = this.pointMap;
    const w = 1,
      h = 1;

    // we need just camera projection matrix inverse
    // world matrix must be identity

    _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);

    // center / target

    setPoint('c', pointMap, geometry, _camera, 0, 0, -1);
    setPoint('t', pointMap, geometry, _camera, 0, 0, 1);

    // near

    setPoint('n1', pointMap, geometry, _camera, -w, -h, -1);
    setPoint('n2', pointMap, geometry, _camera, w, -h, -1);
    setPoint('n3', pointMap, geometry, _camera, -w, h, -1);
    setPoint('n4', pointMap, geometry, _camera, w, h, -1);

    // far

    setPoint('f1', pointMap, geometry, _camera, -w, -h, 1);
    setPoint('f2', pointMap, geometry, _camera, w, -h, 1);
    setPoint('f3', pointMap, geometry, _camera, -w, h, 1);
    setPoint('f4', pointMap, geometry, _camera, w, h, 1);

    // up

    setPoint('u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, -1);
    setPoint('u2', pointMap, geometry, _camera, -w * 0.7, h * 1.1, -1);
    setPoint('u3', pointMap, geometry, _camera, 0, h * 2, -1);

    // cross

    setPoint('cf1', pointMap, geometry, _camera, -w, 0, 1);
    setPoint('cf2', pointMap, geometry, _camera, w, 0, 1);
    setPoint('cf3', pointMap, geometry, _camera, 0, -h, 1);
    setPoint('cf4', pointMap, geometry, _camera, 0, h, 1);
    setPoint('cn1', pointMap, geometry, _camera, -w, 0, -1);
    setPoint('cn2', pointMap, geometry, _camera, w, 0, -1);
    setPoint('cn3', pointMap, geometry, _camera, 0, -h, -1);
    setPoint('cn4', pointMap, geometry, _camera, 0, h, -1);
    geometry.getAttribute('position').needsUpdate = true;
  }
}
exports.CameraHelper = CameraHelper;
function setPoint(point, pointMap, geometry, camera, x, y, z) {
  _vector$c.set(x, y, z).unproject(camera);
  const points = pointMap[point];
  if (points !== undefined) {
    const position = geometry.getAttribute('position');
    for (let i = 0, l = points.length; i < l; i++) {
      position.setXYZ(points[i], _vector$c.x, _vector$c.y, _vector$c.z);
    }
  }
}
const _box$3 = /*@__PURE__*/new Box3();
class BoxHelper extends LineSegments {
  constructor(object, color = 0xffff00) {
    const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
    const positions = new Float32Array(8 * 3);
    const geometry = new BufferGeometry();
    geometry.setIndex(new BufferAttribute(indices, 1));
    geometry.setAttribute('position', new BufferAttribute(positions, 3));
    super(geometry, new LineBasicMaterial({
      color: color,
      toneMapped: false
    }));
    this.object = object;
    this.type = 'BoxHelper';
    this.matrixAutoUpdate = false;
    this.update();
  }
  update(object) {
    if (object !== undefined) {
      console.warn('THREE.BoxHelper: .update() has no longer arguments.');
    }
    if (this.object !== undefined) {
      _box$3.setFromObject(this.object);
    }
    if (_box$3.isEmpty()) return;
    const min = _box$3.min;
    const max = _box$3.max;

    /*
    	5____4
    1/___0/|
    | 6__|_7
    2/___3/
    	0: max.x, max.y, max.z
    1: min.x, max.y, max.z
    2: min.x, min.y, max.z
    3: max.x, min.y, max.z
    4: max.x, max.y, min.z
    5: min.x, max.y, min.z
    6: min.x, min.y, min.z
    7: max.x, min.y, min.z
    */

    const position = this.geometry.attributes.position;
    const array = position.array;
    array[0] = max.x;
    array[1] = max.y;
    array[2] = max.z;
    array[3] = min.x;
    array[4] = max.y;
    array[5] = max.z;
    array[6] = min.x;
    array[7] = min.y;
    array[8] = max.z;
    array[9] = max.x;
    array[10] = min.y;
    array[11] = max.z;
    array[12] = max.x;
    array[13] = max.y;
    array[14] = min.z;
    array[15] = min.x;
    array[16] = max.y;
    array[17] = min.z;
    array[18] = min.x;
    array[19] = min.y;
    array[20] = min.z;
    array[21] = max.x;
    array[22] = min.y;
    array[23] = min.z;
    position.needsUpdate = true;
    this.geometry.computeBoundingSphere();
  }
  setFromObject(object) {
    this.object = object;
    this.update();
    return this;
  }
  copy(source) {
    LineSegments.prototype.copy.call(this, source);
    this.object = source.object;
    return this;
  }
}
exports.BoxHelper = BoxHelper;
class Box3Helper extends LineSegments {
  constructor(box, color = 0xffff00) {
    const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
    const positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
    const geometry = new BufferGeometry();
    geometry.setIndex(new BufferAttribute(indices, 1));
    geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
    super(geometry, new LineBasicMaterial({
      color: color,
      toneMapped: false
    }));
    this.box = box;
    this.type = 'Box3Helper';
    this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(force) {
    const box = this.box;
    if (box.isEmpty()) return;
    box.getCenter(this.position);
    box.getSize(this.scale);
    this.scale.multiplyScalar(0.5);
    super.updateMatrixWorld(force);
  }
}
exports.Box3Helper = Box3Helper;
class PlaneHelper extends Line {
  constructor(plane, size = 1, hex = 0xffff00) {
    const color = hex;
    const positions = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0];
    const geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
    geometry.computeBoundingSphere();
    super(geometry, new LineBasicMaterial({
      color: color,
      toneMapped: false
    }));
    this.type = 'PlaneHelper';
    this.plane = plane;
    this.size = size;
    const positions2 = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1];
    const geometry2 = new BufferGeometry();
    geometry2.setAttribute('position', new Float32BufferAttribute(positions2, 3));
    geometry2.computeBoundingSphere();
    this.add(new Mesh(geometry2, new MeshBasicMaterial({
      color: color,
      opacity: 0.2,
      transparent: true,
      depthWrite: false,
      toneMapped: false
    })));
  }
  updateMatrixWorld(force) {
    let scale = -this.plane.constant;
    if (Math.abs(scale) < 1e-8) scale = 1e-8; // sign does not matter

    this.scale.set(0.5 * this.size, 0.5 * this.size, scale);
    this.children[0].material.side = scale < 0 ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here

    this.lookAt(this.plane.normal);
    super.updateMatrixWorld(force);
  }
}
exports.PlaneHelper = PlaneHelper;
const _axis = /*@__PURE__*/new Vector3();
let _lineGeometry, _coneGeometry;
class ArrowHelper extends Object3D {
  constructor(dir, origin, length, color, headLength, headWidth) {
    super();
    // dir is assumed to be normalized

    this.type = 'ArrowHelper';
    if (dir === undefined) dir = new Vector3(0, 0, 1);
    if (origin === undefined) origin = new Vector3(0, 0, 0);
    if (length === undefined) length = 1;
    if (color === undefined) color = 0xffff00;
    if (headLength === undefined) headLength = 0.2 * length;
    if (headWidth === undefined) headWidth = 0.2 * headLength;
    if (_lineGeometry === undefined) {
      _lineGeometry = new BufferGeometry();
      _lineGeometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));
      _coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1);
      _coneGeometry.translate(0, -0.5, 0);
    }
    this.position.copy(origin);
    this.line = new Line(_lineGeometry, new LineBasicMaterial({
      color: color,
      toneMapped: false
    }));
    this.line.matrixAutoUpdate = false;
    this.add(this.line);
    this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({
      color: color,
      toneMapped: false
    }));
    this.cone.matrixAutoUpdate = false;
    this.add(this.cone);
    this.setDirection(dir);
    this.setLength(length, headLength, headWidth);
  }
  setDirection(dir) {
    // dir is assumed to be normalized

    if (dir.y > 0.99999) {
      this.quaternion.set(0, 0, 0, 1);
    } else if (dir.y < -0.99999) {
      this.quaternion.set(1, 0, 0, 0);
    } else {
      _axis.set(dir.z, 0, -dir.x).normalize();
      const radians = Math.acos(dir.y);
      this.quaternion.setFromAxisAngle(_axis, radians);
    }
  }
  setLength(length, headLength, headWidth) {
    if (headLength === undefined) headLength = 0.2 * length;
    if (headWidth === undefined) headWidth = 0.2 * headLength;
    this.line.scale.set(1, Math.max(0.0001, length - headLength), 1); // see #17458
    this.line.updateMatrix();
    this.cone.scale.set(headWidth, headLength, headWidth);
    this.cone.position.y = length;
    this.cone.updateMatrix();
  }
  setColor(color) {
    this.line.material.color.set(color);
    this.cone.material.color.set(color);
  }
  copy(source) {
    super.copy(source, false);
    this.line.copy(source.line);
    this.cone.copy(source.cone);
    return this;
  }
}
exports.ArrowHelper = ArrowHelper;
class AxesHelper extends LineSegments {
  constructor(size = 1) {
    const vertices = [0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size];
    const colors = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1];
    const geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
    const material = new LineBasicMaterial({
      vertexColors: true,
      toneMapped: false
    });
    super(geometry, material);
    this.type = 'AxesHelper';
  }
}
exports.AxesHelper = AxesHelper;
const _floatView = new Float32Array(1);
const _int32View = new Int32Array(_floatView.buffer);
const DataUtils = {
  // Converts float32 to float16 (stored as uint16 value).

  toHalfFloat: function (val) {
    // Source: http://gamedev.stackexchange.com/questions/17326/conversion-of-a-number-from-single-precision-floating-point-representation-to-a/17410#17410

    /* This method is faster than the OpenEXR implementation (very often
    * used, eg. in Ogre), with the additional benefit of rounding, inspired
    * by James Tursa?s half-precision code. */

    _floatView[0] = val;
    const x = _int32View[0];
    let bits = x >> 16 & 0x8000; /* Get the sign */
    let m = x >> 12 & 0x07ff; /* Keep one extra bit for rounding */
    const e = x >> 23 & 0xff; /* Using int is faster here */

    /* If zero, or denormal, or exponent underflows too much for a denormal
    	* half, return signed zero. */
    if (e < 103) return bits;

    /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */
    if (e > 142) {
      bits |= 0x7c00;
      /* If exponent was 0xff and one mantissa bit was set, it means NaN,
      			* not Inf, so make sure we set one mantissa bit too. */
      bits |= (e == 255 ? 0 : 1) && x & 0x007fffff;
      return bits;
    }

    /* If exponent underflows but not too much, return a denormal */
    if (e < 113) {
      m |= 0x0800;
      /* Extra rounding may overflow and set mantissa to 0 and exponent
      	* to 1, which is OK. */
      bits |= (m >> 114 - e) + (m >> 113 - e & 1);
      return bits;
    }
    bits |= e - 112 << 10 | m >> 1;
    /* Extra rounding. An overflow will set mantissa to 0 and increment
    	* the exponent, which is OK. */
    bits += m & 1;
    return bits;
  }
};
exports.DataUtils = DataUtils;
const LOD_MIN = 4;
const LOD_MAX = 8;
const SIZE_MAX = Math.pow(2, LOD_MAX);

// The standard deviations (radians) associated with the extra mips. These are
// chosen to approximate a Trowbridge-Reitz distribution function times the
// geometric shadowing function. These sigma values squared must match the
// variance #defines in cube_uv_reflection_fragment.glsl.js.
const EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
const TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;

// The maximum length of the blur for loop. Smaller sigmas will use fewer
// samples and exit early, but not recompile the shader.
const MAX_SAMPLES = 20;
const ENCODINGS = {
  [LinearEncoding]: 0,
  [sRGBEncoding]: 1,
  [RGBEEncoding]: 2,
  [RGBM7Encoding]: 3,
  [RGBM16Encoding]: 4,
  [RGBDEncoding]: 5,
  [GammaEncoding]: 6
};
const backgroundMaterial = new MeshBasicMaterial({
  side: BackSide,
  depthWrite: false,
  depthTest: false
});
const backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
const _flatCamera = /*@__PURE__*/new OrthographicCamera();
const {
  _lodPlanes,
  _sizeLods,
  _sigmas
} = /*@__PURE__*/_createPlanes();
const _clearColor = /*@__PURE__*/new Color();
let _oldTarget = null;

// Golden Ratio
const PHI = (1 + Math.sqrt(5)) / 2;
const INV_PHI = 1 / PHI;

// Vertices of a dodecahedron (except the opposites, which represent the
// same axis), used as axis directions evenly spread on a sphere.
const _axisDirections = [/*@__PURE__*/new Vector3(1, 1, 1), /*@__PURE__*/new Vector3(-1, 1, 1), /*@__PURE__*/new Vector3(1, 1, -1), /*@__PURE__*/new Vector3(-1, 1, -1), /*@__PURE__*/new Vector3(0, PHI, INV_PHI), /*@__PURE__*/new Vector3(0, PHI, -INV_PHI), /*@__PURE__*/new Vector3(INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(-INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(PHI, INV_PHI, 0), /*@__PURE__*/new Vector3(-PHI, INV_PHI, 0)];

/**
 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
 * (PMREM) from a cubeMap environment texture. This allows different levels of
 * blur to be quickly accessed based on material roughness. It is packed into a
 * special CubeUV format that allows us to perform custom interpolation so that
 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
 * higher roughness levels. In this way we maintain resolution to smoothly
 * interpolate diffuse lighting while limiting sampling computation.
 */

function convertLinearToRGBE(color) {
  const maxComponent = Math.max(color.r, color.g, color.b);
  const fExp = Math.min(Math.max(Math.ceil(Math.log2(maxComponent)), -128.0), 127.0);
  color.multiplyScalar(Math.pow(2.0, -fExp));
  const alpha = (fExp + 128.0) / 255.0;
  return alpha;
}
class PMREMGenerator {
  constructor(renderer) {
    this._renderer = renderer;
    this._pingPongRenderTarget = null;
    this._blurMaterial = _getBlurShader(MAX_SAMPLES);
    this._equirectShader = null;
    this._cubemapShader = null;
    this._compileMaterial(this._blurMaterial);
  }

  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(scene, sigma = 0, near = 0.1, far = 100) {
    _oldTarget = this._renderer.getRenderTarget();
    const cubeUVRenderTarget = this._allocateTargets();
    this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
    if (sigma > 0) {
      this._blur(cubeUVRenderTarget, 0, 0, sigma);
    }
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }

  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromEquirectangular(equirectangular) {
    return this._fromTexture(equirectangular);
  }

  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromCubemap(cubemap) {
    return this._fromTexture(cubemap);
  }

  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    if (this._cubemapShader === null) {
      this._cubemapShader = _getCubemapShader();
      this._compileMaterial(this._cubemapShader);
    }
  }

  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    if (this._equirectShader === null) {
      this._equirectShader = _getEquirectShader();
      this._compileMaterial(this._equirectShader);
    }
  }

  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._blurMaterial.dispose();
    if (this._cubemapShader !== null) this._cubemapShader.dispose();
    if (this._equirectShader !== null) this._equirectShader.dispose();
    for (let i = 0; i < _lodPlanes.length; i++) {
      _lodPlanes[i].dispose();
    }
  }

  // private interface

  _cleanup(outputTarget) {
    this._pingPongRenderTarget.dispose();
    this._renderer.setRenderTarget(_oldTarget);
    outputTarget.scissorTest = false;
    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
  }
  _fromTexture(texture) {
    _oldTarget = this._renderer.getRenderTarget();
    const cubeUVRenderTarget = this._allocateTargets(texture);
    this._textureToCubeUV(texture, cubeUVRenderTarget);
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  _allocateTargets(texture) {
    // warning: null texture is valid

    const params = {
      magFilter: NearestFilter,
      minFilter: NearestFilter,
      generateMipmaps: false,
      type: UnsignedByteType,
      format: RGBEFormat,
      encoding: _isLDR(texture) ? texture.encoding : RGBEEncoding,
      depthBuffer: false
    };
    const cubeUVRenderTarget = _createRenderTarget(params);
    cubeUVRenderTarget.depthBuffer = texture ? false : true;
    this._pingPongRenderTarget = _createRenderTarget(params);
    return cubeUVRenderTarget;
  }
  _compileMaterial(material) {
    const tmpMesh = new Mesh(_lodPlanes[0], material);
    this._renderer.compile(tmpMesh, _flatCamera);
  }
  _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
    const fov = 90;
    const aspect = 1;
    const cubeCamera = new PerspectiveCamera(fov, aspect, near, far);
    const upSign = [1, -1, 1, 1, 1, 1];
    const forwardSign = [1, 1, 1, -1, -1, -1];
    const renderer = this._renderer;
    const originalAutoClear = renderer.autoClear;
    const outputEncoding = renderer.outputEncoding;
    const toneMapping = renderer.toneMapping;
    renderer.getClearColor(_clearColor);
    renderer.toneMapping = NoToneMapping;
    renderer.outputEncoding = LinearEncoding;
    renderer.autoClear = false;
    let useSolidColor = false;
    const background = scene.background;
    if (background) {
      if (background.isColor) {
        backgroundMaterial.color.copy(background).convertSRGBToLinear();
        scene.background = null;
        const alpha = convertLinearToRGBE(backgroundMaterial.color);
        backgroundMaterial.opacity = alpha;
        useSolidColor = true;
      }
    } else {
      backgroundMaterial.color.copy(_clearColor).convertSRGBToLinear();
      const alpha = convertLinearToRGBE(backgroundMaterial.color);
      backgroundMaterial.opacity = alpha;
      useSolidColor = true;
    }
    for (let i = 0; i < 6; i++) {
      const col = i % 3;
      if (col == 0) {
        cubeCamera.up.set(0, upSign[i], 0);
        cubeCamera.lookAt(forwardSign[i], 0, 0);
      } else if (col == 1) {
        cubeCamera.up.set(0, 0, upSign[i]);
        cubeCamera.lookAt(0, forwardSign[i], 0);
      } else {
        cubeCamera.up.set(0, upSign[i], 0);
        cubeCamera.lookAt(0, 0, forwardSign[i]);
      }
      _setViewport(cubeUVRenderTarget, col * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX);
      renderer.setRenderTarget(cubeUVRenderTarget);
      if (useSolidColor) {
        renderer.render(backgroundBox, cubeCamera);
      }
      renderer.render(scene, cubeCamera);
    }
    renderer.toneMapping = toneMapping;
    renderer.outputEncoding = outputEncoding;
    renderer.autoClear = originalAutoClear;
  }
  _textureToCubeUV(texture, cubeUVRenderTarget) {
    const renderer = this._renderer;
    if (texture.isCubeTexture) {
      if (this._cubemapShader == null) {
        this._cubemapShader = _getCubemapShader();
      }
    } else {
      if (this._equirectShader == null) {
        this._equirectShader = _getEquirectShader();
      }
    }
    const material = texture.isCubeTexture ? this._cubemapShader : this._equirectShader;
    const mesh = new Mesh(_lodPlanes[0], material);
    const uniforms = material.uniforms;
    uniforms['envMap'].value = texture;
    if (!texture.isCubeTexture) {
      uniforms['texelSize'].value.set(1.0 / texture.image.width, 1.0 / texture.image.height);
    }
    uniforms['inputEncoding'].value = ENCODINGS[texture.encoding];
    uniforms['outputEncoding'].value = ENCODINGS[cubeUVRenderTarget.texture.encoding];
    _setViewport(cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX);
    renderer.setRenderTarget(cubeUVRenderTarget);
    renderer.render(mesh, _flatCamera);
  }
  _applyPMREM(cubeUVRenderTarget) {
    const renderer = this._renderer;
    const autoClear = renderer.autoClear;
    renderer.autoClear = false;
    for (let i = 1; i < TOTAL_LODS; i++) {
      const sigma = Math.sqrt(_sigmas[i] * _sigmas[i] - _sigmas[i - 1] * _sigmas[i - 1]);
      const poleAxis = _axisDirections[(i - 1) % _axisDirections.length];
      this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);
    }
    renderer.autoClear = autoClear;
  }

  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
    const pingPongRenderTarget = this._pingPongRenderTarget;
    this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, 'latitudinal', poleAxis);
    this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, 'longitudinal', poleAxis);
  }
  _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
    const renderer = this._renderer;
    const blurMaterial = this._blurMaterial;
    if (direction !== 'latitudinal' && direction !== 'longitudinal') {
      console.error('blur direction must be either latitudinal or longitudinal!');
    }

    // Number of standard deviations at which to cut off the discrete approximation.
    const STANDARD_DEVIATIONS = 3;
    const blurMesh = new Mesh(_lodPlanes[lodOut], blurMaterial);
    const blurUniforms = blurMaterial.uniforms;
    const pixels = _sizeLods[lodIn] - 1;
    const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
    const sigmaPixels = sigmaRadians / radiansPerPixel;
    const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
    if (samples > MAX_SAMPLES) {
      console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
    }
    const weights = [];
    let sum = 0;
    for (let i = 0; i < MAX_SAMPLES; ++i) {
      const x = i / sigmaPixels;
      const weight = Math.exp(-x * x / 2);
      weights.push(weight);
      if (i == 0) {
        sum += weight;
      } else if (i < samples) {
        sum += 2 * weight;
      }
    }
    for (let i = 0; i < weights.length; i++) {
      weights[i] = weights[i] / sum;
    }
    blurUniforms['envMap'].value = targetIn.texture;
    blurUniforms['samples'].value = samples;
    blurUniforms['weights'].value = weights;
    blurUniforms['latitudinal'].value = direction === 'latitudinal';
    if (poleAxis) {
      blurUniforms['poleAxis'].value = poleAxis;
    }
    blurUniforms['dTheta'].value = radiansPerPixel;
    blurUniforms['mipInt'].value = LOD_MAX - lodIn;
    blurUniforms['inputEncoding'].value = ENCODINGS[targetIn.texture.encoding];
    blurUniforms['outputEncoding'].value = ENCODINGS[targetIn.texture.encoding];
    const outputSize = _sizeLods[lodOut];
    const x = 3 * Math.max(0, SIZE_MAX - 2 * outputSize);
    const y = (lodOut === 0 ? 0 : 2 * SIZE_MAX) + 2 * outputSize * (lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0);
    _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);
    renderer.setRenderTarget(targetOut);
    renderer.render(blurMesh, _flatCamera);
  }
}
exports.PMREMGenerator = PMREMGenerator;
function _isLDR(texture) {
  if (texture === undefined || texture.type !== UnsignedByteType) return false;
  return texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;
}
function _createPlanes() {
  const _lodPlanes = [];
  const _sizeLods = [];
  const _sigmas = [];
  let lod = LOD_MAX;
  for (let i = 0; i < TOTAL_LODS; i++) {
    const sizeLod = Math.pow(2, lod);
    _sizeLods.push(sizeLod);
    let sigma = 1.0 / sizeLod;
    if (i > LOD_MAX - LOD_MIN) {
      sigma = EXTRA_LOD_SIGMA[i - LOD_MAX + LOD_MIN - 1];
    } else if (i == 0) {
      sigma = 0;
    }
    _sigmas.push(sigma);
    const texelSize = 1.0 / (sizeLod - 1);
    const min = -texelSize / 2;
    const max = 1 + texelSize / 2;
    const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
    const cubeFaces = 6;
    const vertices = 6;
    const positionSize = 3;
    const uvSize = 2;
    const faceIndexSize = 1;
    const position = new Float32Array(positionSize * vertices * cubeFaces);
    const uv = new Float32Array(uvSize * vertices * cubeFaces);
    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
    for (let face = 0; face < cubeFaces; face++) {
      const x = face % 3 * 2 / 3 - 1;
      const y = face > 2 ? 0 : -1;
      const coordinates = [x, y, 0, x + 2 / 3, y, 0, x + 2 / 3, y + 1, 0, x, y, 0, x + 2 / 3, y + 1, 0, x, y + 1, 0];
      position.set(coordinates, positionSize * vertices * face);
      uv.set(uv1, uvSize * vertices * face);
      const fill = [face, face, face, face, face, face];
      faceIndex.set(fill, faceIndexSize * vertices * face);
    }
    const planes = new BufferGeometry();
    planes.setAttribute('position', new BufferAttribute(position, positionSize));
    planes.setAttribute('uv', new BufferAttribute(uv, uvSize));
    planes.setAttribute('faceIndex', new BufferAttribute(faceIndex, faceIndexSize));
    _lodPlanes.push(planes);
    if (lod > LOD_MIN) {
      lod--;
    }
  }
  return {
    _lodPlanes,
    _sizeLods,
    _sigmas
  };
}
function _createRenderTarget(params) {
  const cubeUVRenderTarget = new WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, params);
  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
  cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
  cubeUVRenderTarget.scissorTest = true;
  return cubeUVRenderTarget;
}
function _setViewport(target, x, y, width, height) {
  target.viewport.set(x, y, width, height);
  target.scissor.set(x, y, width, height);
}
function _getBlurShader(maxSamples) {
  const weights = new Float32Array(maxSamples);
  const poleAxis = new Vector3(0, 1, 0);
  const shaderMaterial = new RawShaderMaterial({
    name: 'SphericalGaussianBlur',
    defines: {
      'n': maxSamples
    },
    uniforms: {
      'envMap': {
        value: null
      },
      'samples': {
        value: 1
      },
      'weights': {
        value: weights
      },
      'latitudinal': {
        value: false
      },
      'dTheta': {
        value: 0
      },
      'mipInt': {
        value: 0
      },
      'poleAxis': {
        value: poleAxis
      },
      'inputEncoding': {
        value: ENCODINGS[LinearEncoding]
      },
      'outputEncoding': {
        value: ENCODINGS[LinearEncoding]
      }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${_getEncodings()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}
function _getEquirectShader() {
  const texelSize = new Vector2(1, 1);
  const shaderMaterial = new RawShaderMaterial({
    name: 'EquirectangularToCubeUV',
    uniforms: {
      'envMap': {
        value: null
      },
      'texelSize': {
        value: texelSize
      },
      'inputEncoding': {
        value: ENCODINGS[LinearEncoding]
      },
      'outputEncoding': {
        value: ENCODINGS[LinearEncoding]
      }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${_getEncodings()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}
function _getCubemapShader() {
  const shaderMaterial = new RawShaderMaterial({
    name: 'CubemapToCubeUV',
    uniforms: {
      'envMap': {
        value: null
      },
      'inputEncoding': {
        value: ENCODINGS[LinearEncoding]
      },
      'outputEncoding': {
        value: ENCODINGS[LinearEncoding]
      }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${_getEncodings()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}
function _getCommonVertexShader() {
  return (/* glsl */`

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function _getEncodings() {
  return (/* glsl */`

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`
  );
}
function Face4(a, b, c, d, normal, color, materialIndex) {
  console.warn('THREE.Face4 has been removed. A THREE.Face3 will be created instead.');
  return new Face3(a, b, c, normal, color, materialIndex);
}
const LineStrip = 0;
exports.LineStrip = LineStrip;
const LinePieces = 1;
exports.LinePieces = LinePieces;
const NoColors = 0;
exports.NoColors = NoColors;
const FaceColors = 1;
exports.FaceColors = FaceColors;
const VertexColors = 2;
exports.VertexColors = VertexColors;
function MeshFaceMaterial(materials) {
  console.warn('THREE.MeshFaceMaterial has been removed. Use an Array instead.');
  return materials;
}
function MultiMaterial(materials = []) {
  console.warn('THREE.MultiMaterial has been removed. Use an Array instead.');
  materials.isMultiMaterial = true;
  materials.materials = materials;
  materials.clone = function () {
    return materials.slice();
  };
  return materials;
}
function PointCloud(geometry, material) {
  console.warn('THREE.PointCloud has been renamed to THREE.Points.');
  return new Points(geometry, material);
}
function Particle(material) {
  console.warn('THREE.Particle has been renamed to THREE.Sprite.');
  return new Sprite(material);
}
function ParticleSystem(geometry, material) {
  console.warn('THREE.ParticleSystem has been renamed to THREE.Points.');
  return new Points(geometry, material);
}
function PointCloudMaterial(parameters) {
  console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');
  return new PointsMaterial(parameters);
}
function ParticleBasicMaterial(parameters) {
  console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');
  return new PointsMaterial(parameters);
}
function ParticleSystemMaterial(parameters) {
  console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');
  return new PointsMaterial(parameters);
}
function Vertex(x, y, z) {
  console.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.');
  return new Vector3(x, y, z);
}

//

function DynamicBufferAttribute(array, itemSize) {
  console.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.');
  return new BufferAttribute(array, itemSize).setUsage(DynamicDrawUsage);
}
function Int8Attribute(array, itemSize) {
  console.warn('THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.');
  return new Int8BufferAttribute(array, itemSize);
}
function Uint8Attribute(array, itemSize) {
  console.warn('THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.');
  return new Uint8BufferAttribute(array, itemSize);
}
function Uint8ClampedAttribute(array, itemSize) {
  console.warn('THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.');
  return new Uint8ClampedBufferAttribute(array, itemSize);
}
function Int16Attribute(array, itemSize) {
  console.warn('THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.');
  return new Int16BufferAttribute(array, itemSize);
}
function Uint16Attribute(array, itemSize) {
  console.warn('THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.');
  return new Uint16BufferAttribute(array, itemSize);
}
function Int32Attribute(array, itemSize) {
  console.warn('THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.');
  return new Int32BufferAttribute(array, itemSize);
}
function Uint32Attribute(array, itemSize) {
  console.warn('THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.');
  return new Uint32BufferAttribute(array, itemSize);
}
function Float32Attribute(array, itemSize) {
  console.warn('THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.');
  return new Float32BufferAttribute(array, itemSize);
}
function Float64Attribute(array, itemSize) {
  console.warn('THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.');
  return new Float64BufferAttribute(array, itemSize);
}

//

Curve.create = function (construct, getPoint) {
  console.log('THREE.Curve.create() has been deprecated');
  construct.prototype = Object.create(Curve.prototype);
  construct.prototype.constructor = construct;
  construct.prototype.getPoint = getPoint;
  return construct;
};

//

Object.assign(Path.prototype, {
  fromPoints: function (points) {
    console.warn('THREE.Path: .fromPoints() has been renamed to .setFromPoints().');
    return this.setFromPoints(points);
  }
});

//

function ClosedSplineCurve3(points) {
  console.warn('THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');
  CatmullRomCurve3.call(this, points);
  this.type = 'catmullrom';
  this.closed = true;
}
ClosedSplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype);

//

function SplineCurve3(points) {
  console.warn('THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');
  CatmullRomCurve3.call(this, points);
  this.type = 'catmullrom';
}
SplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype);

//

function Spline(points) {
  console.warn('THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.');
  CatmullRomCurve3.call(this, points);
  this.type = 'catmullrom';
}
Spline.prototype = Object.create(CatmullRomCurve3.prototype);
Object.assign(Spline.prototype, {
  initFromArray: function /* a */
  () {
    console.error('THREE.Spline: .initFromArray() has been removed.');
  },
  getControlPointsArray: function /* optionalTarget */
  () {
    console.error('THREE.Spline: .getControlPointsArray() has been removed.');
  },
  reparametrizeByArcLength: function /* samplingCoef */
  () {
    console.error('THREE.Spline: .reparametrizeByArcLength() has been removed.');
  }
});

//

function AxisHelper(size) {
  console.warn('THREE.AxisHelper has been renamed to THREE.AxesHelper.');
  return new AxesHelper(size);
}
function BoundingBoxHelper(object, color) {
  console.warn('THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.');
  return new BoxHelper(object, color);
}
function EdgesHelper(object, hex) {
  console.warn('THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.');
  return new LineSegments(new EdgesGeometry(object.geometry), new LineBasicMaterial({
    color: hex !== undefined ? hex : 0xffffff
  }));
}
GridHelper.prototype.setColors = function () {
  console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');
};
SkeletonHelper.prototype.update = function () {
  console.error('THREE.SkeletonHelper: update() no longer needs to be called.');
};
function WireframeHelper(object, hex) {
  console.warn('THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.');
  return new LineSegments(new WireframeGeometry(object.geometry), new LineBasicMaterial({
    color: hex !== undefined ? hex : 0xffffff
  }));
}

//

Object.assign(Loader.prototype, {
  extractUrlBase: function (url) {
    console.warn('THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.');
    return LoaderUtils.extractUrlBase(url);
  }
});
Loader.Handlers = {
  add: function /* regex, loader */
  () {
    console.error('THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.');
  },
  get: function /* file */
  () {
    console.error('THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.');
  }
};
function XHRLoader(manager) {
  console.warn('THREE.XHRLoader has been renamed to THREE.FileLoader.');
  return new FileLoader(manager);
}
function BinaryTextureLoader(manager) {
  console.warn('THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.');
  return new DataTextureLoader(manager);
}

//

Object.assign(Box2.prototype, {
  center: function (optionalTarget) {
    console.warn('THREE.Box2: .center() has been renamed to .getCenter().');
    return this.getCenter(optionalTarget);
  },
  empty: function () {
    console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');
    return this.isEmpty();
  },
  isIntersectionBox: function (box) {
    console.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');
    return this.intersectsBox(box);
  },
  size: function (optionalTarget) {
    console.warn('THREE.Box2: .size() has been renamed to .getSize().');
    return this.getSize(optionalTarget);
  }
});
Object.assign(Box3.prototype, {
  center: function (optionalTarget) {
    console.warn('THREE.Box3: .center() has been renamed to .getCenter().');
    return this.getCenter(optionalTarget);
  },
  empty: function () {
    console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');
    return this.isEmpty();
  },
  isIntersectionBox: function (box) {
    console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');
    return this.intersectsBox(box);
  },
  isIntersectionSphere: function (sphere) {
    console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');
    return this.intersectsSphere(sphere);
  },
  size: function (optionalTarget) {
    console.warn('THREE.Box3: .size() has been renamed to .getSize().');
    return this.getSize(optionalTarget);
  }
});
Object.assign(Sphere.prototype, {
  empty: function () {
    console.warn('THREE.Sphere: .empty() has been renamed to .isEmpty().');
    return this.isEmpty();
  }
});
Frustum.prototype.setFromMatrix = function (m) {
  console.warn('THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().');
  return this.setFromProjectionMatrix(m);
};
Line3.prototype.center = function (optionalTarget) {
  console.warn('THREE.Line3: .center() has been renamed to .getCenter().');
  return this.getCenter(optionalTarget);
};
Object.assign(MathUtils, {
  random16: function () {
    console.warn('THREE.Math: .random16() has been deprecated. Use Math.random() instead.');
    return Math.random();
  },
  nearestPowerOfTwo: function (value) {
    console.warn('THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().');
    return MathUtils.floorPowerOfTwo(value);
  },
  nextPowerOfTwo: function (value) {
    console.warn('THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().');
    return MathUtils.ceilPowerOfTwo(value);
  }
});
Object.assign(Matrix3.prototype, {
  flattenToArrayOffset: function (array, offset) {
    console.warn('THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.');
    return this.toArray(array, offset);
  },
  multiplyVector3: function (vector) {
    console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');
    return vector.applyMatrix3(this);
  },
  multiplyVector3Array: function /* a */
  () {
    console.error('THREE.Matrix3: .multiplyVector3Array() has been removed.');
  },
  applyToBufferAttribute: function (attribute) {
    console.warn('THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.');
    return attribute.applyMatrix3(this);
  },
  applyToVector3Array: function /* array, offset, length */
  () {
    console.error('THREE.Matrix3: .applyToVector3Array() has been removed.');
  },
  getInverse: function (matrix) {
    console.warn('THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.');
    return this.copy(matrix).invert();
  }
});
Object.assign(Matrix4.prototype, {
  extractPosition: function (m) {
    console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');
    return this.copyPosition(m);
  },
  flattenToArrayOffset: function (array, offset) {
    console.warn('THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.');
    return this.toArray(array, offset);
  },
  getPosition: function () {
    console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');
    return new Vector3().setFromMatrixColumn(this, 3);
  },
  setRotationFromQuaternion: function (q) {
    console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');
    return this.makeRotationFromQuaternion(q);
  },
  multiplyToArray: function () {
    console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');
  },
  multiplyVector3: function (vector) {
    console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.');
    return vector.applyMatrix4(this);
  },
  multiplyVector4: function (vector) {
    console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');
    return vector.applyMatrix4(this);
  },
  multiplyVector3Array: function /* a */
  () {
    console.error('THREE.Matrix4: .multiplyVector3Array() has been removed.');
  },
  rotateAxis: function (v) {
    console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');
    v.transformDirection(this);
  },
  crossVector: function (vector) {
    console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');
    return vector.applyMatrix4(this);
  },
  translate: function () {
    console.error('THREE.Matrix4: .translate() has been removed.');
  },
  rotateX: function () {
    console.error('THREE.Matrix4: .rotateX() has been removed.');
  },
  rotateY: function () {
    console.error('THREE.Matrix4: .rotateY() has been removed.');
  },
  rotateZ: function () {
    console.error('THREE.Matrix4: .rotateZ() has been removed.');
  },
  rotateByAxis: function () {
    console.error('THREE.Matrix4: .rotateByAxis() has been removed.');
  },
  applyToBufferAttribute: function (attribute) {
    console.warn('THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.');
    return attribute.applyMatrix4(this);
  },
  applyToVector3Array: function /* array, offset, length */
  () {
    console.error('THREE.Matrix4: .applyToVector3Array() has been removed.');
  },
  makeFrustum: function (left, right, bottom, top, near, far) {
    console.warn('THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.');
    return this.makePerspective(left, right, top, bottom, near, far);
  },
  getInverse: function (matrix) {
    console.warn('THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.');
    return this.copy(matrix).invert();
  }
});
Plane.prototype.isIntersectionLine = function (line) {
  console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');
  return this.intersectsLine(line);
};
Object.assign(Quaternion.prototype, {
  multiplyVector3: function (vector) {
    console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');
    return vector.applyQuaternion(this);
  },
  inverse: function () {
    console.warn('THREE.Quaternion: .inverse() has been renamed to invert().');
    return this.invert();
  }
});
Object.assign(Ray.prototype, {
  isIntersectionBox: function (box) {
    console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');
    return this.intersectsBox(box);
  },
  isIntersectionPlane: function (plane) {
    console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');
    return this.intersectsPlane(plane);
  },
  isIntersectionSphere: function (sphere) {
    console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');
    return this.intersectsSphere(sphere);
  }
});
Object.assign(Triangle.prototype, {
  area: function () {
    console.warn('THREE.Triangle: .area() has been renamed to .getArea().');
    return this.getArea();
  },
  barycoordFromPoint: function (point, target) {
    console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
    return this.getBarycoord(point, target);
  },
  midpoint: function (target) {
    console.warn('THREE.Triangle: .midpoint() has been renamed to .getMidpoint().');
    return this.getMidpoint(target);
  },
  normal: function (target) {
    console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
    return this.getNormal(target);
  },
  plane: function (target) {
    console.warn('THREE.Triangle: .plane() has been renamed to .getPlane().');
    return this.getPlane(target);
  }
});
Object.assign(Triangle, {
  barycoordFromPoint: function (point, a, b, c, target) {
    console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
    return Triangle.getBarycoord(point, a, b, c, target);
  },
  normal: function (a, b, c, target) {
    console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
    return Triangle.getNormal(a, b, c, target);
  }
});
Object.assign(Shape.prototype, {
  extractAllPoints: function (divisions) {
    console.warn('THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.');
    return this.extractPoints(divisions);
  },
  extrude: function (options) {
    console.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.');
    return new ExtrudeGeometry(this, options);
  },
  makeGeometry: function (options) {
    console.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.');
    return new ShapeGeometry(this, options);
  }
});
Object.assign(Vector2.prototype, {
  fromAttribute: function (attribute, index, offset) {
    console.warn('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().');
    return this.fromBufferAttribute(attribute, index, offset);
  },
  distanceToManhattan: function (v) {
    console.warn('THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
    return this.manhattanDistanceTo(v);
  },
  lengthManhattan: function () {
    console.warn('THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().');
    return this.manhattanLength();
  }
});
Object.assign(Vector3.prototype, {
  setEulerFromRotationMatrix: function () {
    console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');
  },
  setEulerFromQuaternion: function () {
    console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');
  },
  getPositionFromMatrix: function (m) {
    console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');
    return this.setFromMatrixPosition(m);
  },
  getScaleFromMatrix: function (m) {
    console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');
    return this.setFromMatrixScale(m);
  },
  getColumnFromMatrix: function (index, matrix) {
    console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');
    return this.setFromMatrixColumn(matrix, index);
  },
  applyProjection: function (m) {
    console.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.');
    return this.applyMatrix4(m);
  },
  fromAttribute: function (attribute, index, offset) {
    console.warn('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().');
    return this.fromBufferAttribute(attribute, index, offset);
  },
  distanceToManhattan: function (v) {
    console.warn('THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
    return this.manhattanDistanceTo(v);
  },
  lengthManhattan: function () {
    console.warn('THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().');
    return this.manhattanLength();
  }
});
Object.assign(Vector4.prototype, {
  fromAttribute: function (attribute, index, offset) {
    console.warn('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().');
    return this.fromBufferAttribute(attribute, index, offset);
  },
  lengthManhattan: function () {
    console.warn('THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().');
    return this.manhattanLength();
  }
});

//

Object.assign(Object3D.prototype, {
  getChildByName: function (name) {
    console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');
    return this.getObjectByName(name);
  },
  renderDepth: function () {
    console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');
  },
  translate: function (distance, axis) {
    console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');
    return this.translateOnAxis(axis, distance);
  },
  getWorldRotation: function () {
    console.error('THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.');
  },
  applyMatrix: function (matrix) {
    console.warn('THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().');
    return this.applyMatrix4(matrix);
  }
});
Object.defineProperties(Object3D.prototype, {
  eulerOrder: {
    get: function () {
      console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
      return this.rotation.order;
    },
    set: function (value) {
      console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
      this.rotation.order = value;
    }
  },
  useQuaternion: {
    get: function () {
      console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
    },
    set: function () {
      console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
    }
  }
});
Object.assign(Mesh.prototype, {
  setDrawMode: function () {
    console.error('THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');
  }
});
Object.defineProperties(Mesh.prototype, {
  drawMode: {
    get: function () {
      console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.');
      return TrianglesDrawMode;
    },
    set: function () {
      console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');
    }
  }
});
Object.defineProperties(LOD.prototype, {
  objects: {
    get: function () {
      console.warn('THREE.LOD: .objects has been renamed to .levels.');
      return this.levels;
    }
  }
});
Object.defineProperty(Skeleton.prototype, 'useVertexTexture', {
  get: function () {
    console.warn('THREE.Skeleton: useVertexTexture has been removed.');
  },
  set: function () {
    console.warn('THREE.Skeleton: useVertexTexture has been removed.');
  }
});
SkinnedMesh.prototype.initBones = function () {
  console.error('THREE.SkinnedMesh: initBones() has been removed.');
};
Object.defineProperty(Curve.prototype, '__arcLengthDivisions', {
  get: function () {
    console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');
    return this.arcLengthDivisions;
  },
  set: function (value) {
    console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');
    this.arcLengthDivisions = value;
  }
});

//

PerspectiveCamera.prototype.setLens = function (focalLength, filmGauge) {
  console.warn('THREE.PerspectiveCamera.setLens is deprecated. ' + 'Use .setFocalLength and .filmGauge for a photographic setup.');
  if (filmGauge !== undefined) this.filmGauge = filmGauge;
  this.setFocalLength(focalLength);
};

//

Object.defineProperties(Light.prototype, {
  onlyShadow: {
    set: function () {
      console.warn('THREE.Light: .onlyShadow has been removed.');
    }
  },
  shadowCameraFov: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');
      this.shadow.camera.fov = value;
    }
  },
  shadowCameraLeft: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');
      this.shadow.camera.left = value;
    }
  },
  shadowCameraRight: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');
      this.shadow.camera.right = value;
    }
  },
  shadowCameraTop: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');
      this.shadow.camera.top = value;
    }
  },
  shadowCameraBottom: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');
      this.shadow.camera.bottom = value;
    }
  },
  shadowCameraNear: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');
      this.shadow.camera.near = value;
    }
  },
  shadowCameraFar: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');
      this.shadow.camera.far = value;
    }
  },
  shadowCameraVisible: {
    set: function () {
      console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');
    }
  },
  shadowBias: {
    set: function (value) {
      console.warn('THREE.Light: .shadowBias is now .shadow.bias.');
      this.shadow.bias = value;
    }
  },
  shadowDarkness: {
    set: function () {
      console.warn('THREE.Light: .shadowDarkness has been removed.');
    }
  },
  shadowMapWidth: {
    set: function (value) {
      console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');
      this.shadow.mapSize.width = value;
    }
  },
  shadowMapHeight: {
    set: function (value) {
      console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');
      this.shadow.mapSize.height = value;
    }
  }
});

//

Object.defineProperties(BufferAttribute.prototype, {
  length: {
    get: function () {
      console.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.');
      return this.array.length;
    }
  },
  dynamic: {
    get: function () {
      console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');
      return this.usage === DynamicDrawUsage;
    },
    set: function /* value */
    () {
      console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');
      this.setUsage(DynamicDrawUsage);
    }
  }
});
Object.assign(BufferAttribute.prototype, {
  setDynamic: function (value) {
    console.warn('THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.');
    this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
    return this;
  },
  copyIndicesArray: function /* indices */
  () {
    console.error('THREE.BufferAttribute: .copyIndicesArray() has been removed.');
  },
  setArray: function /* array */
  () {
    console.error('THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');
  }
});
Object.assign(BufferGeometry.prototype, {
  addIndex: function (index) {
    console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');
    this.setIndex(index);
  },
  addAttribute: function (name, attribute) {
    console.warn('THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().');
    if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
      console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');
      return this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
    }
    if (name === 'index') {
      console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');
      this.setIndex(attribute);
      return this;
    }
    return this.setAttribute(name, attribute);
  },
  addDrawCall: function (start, count, indexOffset) {
    if (indexOffset !== undefined) {
      console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');
    }
    console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');
    this.addGroup(start, count);
  },
  clearDrawCalls: function () {
    console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');
    this.clearGroups();
  },
  computeOffsets: function () {
    console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');
  },
  removeAttribute: function (name) {
    console.warn('THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().');
    return this.deleteAttribute(name);
  },
  applyMatrix: function (matrix) {
    console.warn('THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().');
    return this.applyMatrix4(matrix);
  }
});
Object.defineProperties(BufferGeometry.prototype, {
  drawcalls: {
    get: function () {
      console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');
      return this.groups;
    }
  },
  offsets: {
    get: function () {
      console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');
      return this.groups;
    }
  }
});
Object.defineProperties(InstancedBufferGeometry.prototype, {
  maxInstancedCount: {
    get: function () {
      console.warn('THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.');
      return this.instanceCount;
    },
    set: function (value) {
      console.warn('THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.');
      this.instanceCount = value;
    }
  }
});
Object.defineProperties(Raycaster.prototype, {
  linePrecision: {
    get: function () {
      console.warn('THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.');
      return this.params.Line.threshold;
    },
    set: function (value) {
      console.warn('THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.');
      this.params.Line.threshold = value;
    }
  }
});
Object.defineProperties(InterleavedBuffer.prototype, {
  dynamic: {
    get: function () {
      console.warn('THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.');
      return this.usage === DynamicDrawUsage;
    },
    set: function (value) {
      console.warn('THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.');
      this.setUsage(value);
    }
  }
});
Object.assign(InterleavedBuffer.prototype, {
  setDynamic: function (value) {
    console.warn('THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.');
    this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
    return this;
  },
  setArray: function /* array */
  () {
    console.error('THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');
  }
});

//

Object.assign(ExtrudeGeometry.prototype, {
  getArrays: function () {
    console.error('THREE.ExtrudeGeometry: .getArrays() has been removed.');
  },
  addShapeList: function () {
    console.error('THREE.ExtrudeGeometry: .addShapeList() has been removed.');
  },
  addShape: function () {
    console.error('THREE.ExtrudeGeometry: .addShape() has been removed.');
  }
});

//

Object.assign(Scene.prototype, {
  dispose: function () {
    console.error('THREE.Scene: .dispose() has been removed.');
  }
});

//

Object.defineProperties(Uniform.prototype, {
  dynamic: {
    set: function () {
      console.warn('THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.');
    }
  },
  onUpdate: {
    value: function () {
      console.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.');
      return this;
    }
  }
});

//

Object.defineProperties(Material.prototype, {
  wrapAround: {
    get: function () {
      console.warn('THREE.Material: .wrapAround has been removed.');
    },
    set: function () {
      console.warn('THREE.Material: .wrapAround has been removed.');
    }
  },
  overdraw: {
    get: function () {
      console.warn('THREE.Material: .overdraw has been removed.');
    },
    set: function () {
      console.warn('THREE.Material: .overdraw has been removed.');
    }
  },
  wrapRGB: {
    get: function () {
      console.warn('THREE.Material: .wrapRGB has been removed.');
      return new Color();
    }
  },
  shading: {
    get: function () {
      console.error('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
    },
    set: function (value) {
      console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
      this.flatShading = value === FlatShading;
    }
  },
  stencilMask: {
    get: function () {
      console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');
      return this.stencilFuncMask;
    },
    set: function (value) {
      console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');
      this.stencilFuncMask = value;
    }
  }
});
Object.defineProperties(MeshPhongMaterial.prototype, {
  metal: {
    get: function () {
      console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.');
      return false;
    },
    set: function () {
      console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead');
    }
  }
});
Object.defineProperties(MeshPhysicalMaterial.prototype, {
  transparency: {
    get: function () {
      console.warn('THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.');
      return this.transmission;
    },
    set: function (value) {
      console.warn('THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.');
      this.transmission = value;
    }
  }
});
Object.defineProperties(ShaderMaterial.prototype, {
  derivatives: {
    get: function () {
      console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
      return this.extensions.derivatives;
    },
    set: function (value) {
      console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
      this.extensions.derivatives = value;
    }
  }
});

//

Object.assign(WebGLRenderer.prototype, {
  clearTarget: function (renderTarget, color, depth, stencil) {
    console.warn('THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.');
    this.setRenderTarget(renderTarget);
    this.clear(color, depth, stencil);
  },
  animate: function (callback) {
    console.warn('THREE.WebGLRenderer: .animate() is now .setAnimationLoop().');
    this.setAnimationLoop(callback);
  },
  getCurrentRenderTarget: function () {
    console.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().');
    return this.getRenderTarget();
  },
  getMaxAnisotropy: function () {
    console.warn('THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().');
    return this.capabilities.getMaxAnisotropy();
  },
  getPrecision: function () {
    console.warn('THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.');
    return this.capabilities.precision;
  },
  resetGLState: function () {
    console.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().');
    return this.state.reset();
  },
  supportsFloatTextures: function () {
    console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');
    return this.extensions.get('OES_texture_float');
  },
  supportsHalfFloatTextures: function () {
    console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');
    return this.extensions.get('OES_texture_half_float');
  },
  supportsStandardDerivatives: function () {
    console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');
    return this.extensions.get('OES_standard_derivatives');
  },
  supportsCompressedTextureS3TC: function () {
    console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');
    return this.extensions.get('WEBGL_compressed_texture_s3tc');
  },
  supportsCompressedTexturePVRTC: function () {
    console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');
    return this.extensions.get('WEBGL_compressed_texture_pvrtc');
  },
  supportsBlendMinMax: function () {
    console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');
    return this.extensions.get('EXT_blend_minmax');
  },
  supportsVertexTextures: function () {
    console.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.');
    return this.capabilities.vertexTextures;
  },
  supportsInstancedArrays: function () {
    console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');
    return this.extensions.get('ANGLE_instanced_arrays');
  },
  enableScissorTest: function (boolean) {
    console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');
    this.setScissorTest(boolean);
  },
  initMaterial: function () {
    console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');
  },
  addPrePlugin: function () {
    console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');
  },
  addPostPlugin: function () {
    console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');
  },
  updateShadowMap: function () {
    console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');
  },
  setFaceCulling: function () {
    console.warn('THREE.WebGLRenderer: .setFaceCulling() has been removed.');
  },
  allocTextureUnit: function () {
    console.warn('THREE.WebGLRenderer: .allocTextureUnit() has been removed.');
  },
  setTexture: function () {
    console.warn('THREE.WebGLRenderer: .setTexture() has been removed.');
  },
  setTexture2D: function () {
    console.warn('THREE.WebGLRenderer: .setTexture2D() has been removed.');
  },
  setTextureCube: function () {
    console.warn('THREE.WebGLRenderer: .setTextureCube() has been removed.');
  },
  getActiveMipMapLevel: function () {
    console.warn('THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().');
    return this.getActiveMipmapLevel();
  }
});
Object.defineProperties(WebGLRenderer.prototype, {
  shadowMapEnabled: {
    get: function () {
      return this.shadowMap.enabled;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');
      this.shadowMap.enabled = value;
    }
  },
  shadowMapType: {
    get: function () {
      return this.shadowMap.type;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');
      this.shadowMap.type = value;
    }
  },
  shadowMapCullFace: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
      return undefined;
    },
    set: function /* value */
    () {
      console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
    }
  },
  context: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.');
      return this.getContext();
    }
  },
  vr: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .vr has been renamed to .xr');
      return this.xr;
    }
  },
  gammaInput: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');
      return false;
    },
    set: function () {
      console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');
    }
  },
  gammaOutput: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');
      return false;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');
      this.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;
    }
  },
  toneMappingWhitePoint: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');
      return 1.0;
    },
    set: function () {
      console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');
    }
  }
});
Object.defineProperties(WebGLShadowMap.prototype, {
  cullFace: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
      return undefined;
    },
    set: function /* cullFace */
    () {
      console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
    }
  },
  renderReverseSided: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
      return undefined;
    },
    set: function () {
      console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
    }
  },
  renderSingleSided: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
      return undefined;
    },
    set: function () {
      console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
    }
  }
});
function WebGLRenderTargetCube(width, height, options) {
  console.warn('THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).');
  return new WebGLCubeRenderTarget(width, options);
}

//

Object.defineProperties(WebGLRenderTarget.prototype, {
  wrapS: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
      return this.texture.wrapS;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
      this.texture.wrapS = value;
    }
  },
  wrapT: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
      return this.texture.wrapT;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
      this.texture.wrapT = value;
    }
  },
  magFilter: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
      return this.texture.magFilter;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
      this.texture.magFilter = value;
    }
  },
  minFilter: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
      return this.texture.minFilter;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
      this.texture.minFilter = value;
    }
  },
  anisotropy: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
      return this.texture.anisotropy;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
      this.texture.anisotropy = value;
    }
  },
  offset: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
      return this.texture.offset;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
      this.texture.offset = value;
    }
  },
  repeat: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
      return this.texture.repeat;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
      this.texture.repeat = value;
    }
  },
  format: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
      return this.texture.format;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
      this.texture.format = value;
    }
  },
  type: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
      return this.texture.type;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
      this.texture.type = value;
    }
  },
  generateMipmaps: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
      return this.texture.generateMipmaps;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
      this.texture.generateMipmaps = value;
    }
  }
});

//

Object.defineProperties(Audio.prototype, {
  load: {
    value: function (file) {
      console.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');
      const scope = this;
      const audioLoader = new AudioLoader();
      audioLoader.load(file, function (buffer) {
        scope.setBuffer(buffer);
      });
      return this;
    }
  },
  startTime: {
    set: function () {
      console.warn('THREE.Audio: .startTime is now .play( delay ).');
    }
  }
});
AudioAnalyser.prototype.getData = function () {
  console.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().');
  return this.getFrequencyData();
};

//

CubeCamera.prototype.updateCubeMap = function (renderer, scene) {
  console.warn('THREE.CubeCamera: .updateCubeMap() is now .update().');
  return this.update(renderer, scene);
};
CubeCamera.prototype.clear = function (renderer, color, depth, stencil) {
  console.warn('THREE.CubeCamera: .clear() is now .renderTarget.clear().');
  return this.renderTarget.clear(renderer, color, depth, stencil);
};

//

const GeometryUtils = {
  merge: function (geometry1, geometry2, materialIndexOffset) {
    console.warn('THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.');
    let matrix;
    if (geometry2.isMesh) {
      geometry2.matrixAutoUpdate && geometry2.updateMatrix();
      matrix = geometry2.matrix;
      geometry2 = geometry2.geometry;
    }
    geometry1.merge(geometry2, matrix, materialIndexOffset);
  },
  center: function (geometry) {
    console.warn('THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.');
    return geometry.center();
  }
};
exports.GeometryUtils = GeometryUtils;
ImageUtils.crossOrigin = undefined;
ImageUtils.loadTexture = function (url, mapping, onLoad, onError) {
  console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');
  const loader = new TextureLoader();
  loader.setCrossOrigin(this.crossOrigin);
  const texture = loader.load(url, onLoad, undefined, onError);
  if (mapping) texture.mapping = mapping;
  return texture;
};
ImageUtils.loadTextureCube = function (urls, mapping, onLoad, onError) {
  console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');
  const loader = new CubeTextureLoader();
  loader.setCrossOrigin(this.crossOrigin);
  const texture = loader.load(urls, onLoad, undefined, onError);
  if (mapping) texture.mapping = mapping;
  return texture;
};
ImageUtils.loadCompressedTexture = function () {
  console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');
};
ImageUtils.loadCompressedTextureCube = function () {
  console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');
};

//

function CanvasRenderer() {
  console.error('THREE.CanvasRenderer has been removed');
}

//

function JSONLoader() {
  console.error('THREE.JSONLoader has been removed.');
}

//

const SceneUtils = {
  createMultiMaterialObject: function /* geometry, materials */
  () {
    console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
  },
  detach: function /* child, parent, scene */
  () {
    console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
  },
  attach: function /* child, scene, parent */
  () {
    console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
  }
};

//
exports.SceneUtils = SceneUtils;
function LensFlare() {
  console.error('THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js');
}
if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
  /* eslint-disable no-undef */
  __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', {
    detail: {
      revision: REVISION
    }
  }));
  /* eslint-enable no-undef */
}

if (typeof window !== 'undefined') {
  if (window.__THREE__) {
    console.warn('WARNING: Multiple instances of Three.js being imported.');
  } else {
    window.__THREE__ = REVISION;
  }
}
},{}],"result.json":[function(require,module,exports) {
module.exports = {
  "data": [[2409.36434, 3620.519578, 6394.022461, 7829.035156], [2386.9824, 3628.23662, 6394.05127, 7829.086914], [2364.600459, 3635.953662, 6394.088867, 7829.226563], [2342.218518, 3643.670704, 6394.138184, 7829.416992], [2319.836577, 3651.387746, 6394.193848, 7829.65332], [2297.454636, 3659.104789, 6394.265625, 7829.946289], [2275.072695, 3666.821831, 6394.342773, 7830.301758], [2252.690754, 3674.538873, 6394.418945, 7830.719727], [2230.308813, 3682.255915, 6394.499512, 7831.199219], [2207.926873, 3689.972957, 6394.576172, 7831.734375], [2185.544932, 3697.689999, 6394.652344, 7832.327148], [2163.162991, 3705.407042, 6394.714844, 7832.967773], [2140.78105, 3713.124084, 6394.75293, 7833.630859], [2118.399109, 3720.841126, 6394.75293, 7834.291016], [2096.017168, 3728.558168, 6394.699219, 7834.915039], [2073.635227, 3736.27521, 6394.578613, 7835.449219], [2051.253286, 3743.992253, 6394.366211, 7835.876953], [2028.871346, 3751.709295, 6394.068359, 7836.099609], [2006.489405, 3759.426337, 6393.67041, 7836.001953], [1984.107464, 3767.143379, 6393.189941, 7835.480469], [1961.725523, 3774.860421, 6392.59082, 7834.577148], [1939.343582, 3782.577463, 6391.915039, 7833.333984], [1916.961641, 3790.294506, 6391.217773, 7831.722656], [1894.5797, 3798.011548, 6390.52002, 7829.488281], [1872.197759, 3805.72859, 6389.863281, 7826.733398], [1849.815819, 3813.445632, 6389.166016, 7822.657227], [1827.433878, 3821.162674, 6507.722656, 7701.092285], [1804.10832, 3829.109282, 6508.640625, 7696.864746], [1780.782396, 3837.056181, 6509.833984, 7690.290039], [1757.938563, 3844.937795, 6386.26123, 7811.373047], [1735.09473, 3852.81941, 6379.129883, 7816.686523], [1712.250897, 3860.701024, 6371.852539, 7821.737305], [1689.407064, 3868.582638, 6366.567871, 7825.557617], [1666.563231, 3876.464252, 6363.719238, 7827.786133], [1643.719398, 3884.345866, 6362.588867, 7828.563477], [1620.875565, 3892.22748, 6362.321289, 7828.479492], [1598.031732, 3900.109094, 6362.439941, 7827.90332], [1575.187899, 3907.990708, 6362.709473, 7827.012695], [1552.344066, 3915.872322, 6363.000977, 7825.896484], [1529.500233, 3923.753936, 6363.257324, 7824.612305], [1506.6564, 3931.63555, 6363.453613, 7823.206055], [1483.812567, 3939.517165, 6363.59375, 7821.738281], [1460.968734, 3947.398779, 6363.668457, 7820.24707], [1438.124901, 3955.280393, 6363.691895, 7818.759766], [1415.281068, 3963.162007, 6363.669922, 7817.291016], [1392.437235, 3971.043621, 6363.625488, 7815.875977], [1369.593402, 3978.925235, 6363.551758, 7814.52832], [1346.749569, 3986.806849, 6363.458496, 7813.244141], [1323.905736, 3994.688463, 6363.355469, 7812.038086], [1301.061903, 4002.570077, 6363.23877, 7810.90332], [1278.21807, 4010.451691, 6363.115234, 7809.848633], [1255.374237, 4018.333305, 6362.983887, 7808.878906], [1232.530404, 4026.21492, 6362.852539, 7807.982422], [1209.686571, 4034.096534, 6362.727051, 7807.165039], [1186.842738, 4041.978148, 6362.603027, 7806.432617], [1163.998905, 4049.859762, 6362.48877, 7805.774414], [1141.155072, 4057.741376, 6362.379395, 7805.1875], [1118.311238, 4065.62299, 6362.274902, 7804.666992], [1095.467405, 4073.504604, 6362.174316, 7804.220703], [1072.623572, 4081.386218, 6362.085938, 7803.835938], [1049.779739, 4089.267832, 6362.015137, 7803.533203], [1026.935906, 4097.149446, 6361.960938, 7803.305664], [1004.092073, 4105.03106, 6361.922852, 7803.154297], [981.2482403, 4112.912675, 6361.897461, 7803.072266], [2401.293362, 3596.883995, 6394.008789, 7828.964844], [2378.983882, 3604.584083, 6394.033691, 7829.030273], [2356.674401, 3612.284172, 6394.070801, 7829.162109], [2334.36492, 3619.98426, 6394.121094, 7829.349609], [2312.05544, 3627.684349, 6394.180664, 7829.585938], [2289.745959, 3635.384438, 6394.247559, 7829.878906], [2267.436478, 3643.084526, 6394.327148, 7830.237305], [2245.126998, 3650.784615, 6394.415039, 7830.655273], [2222.817517, 3658.484703, 6394.498535, 7831.131836], [2200.508036, 3666.184792, 6394.587402, 7831.671875], [2178.198556, 3673.88488, 6394.664551, 7832.280273], [2155.889075, 3681.584969, 6394.73584, 7832.939453], [2133.579594, 3689.285057, 6394.783691, 7833.625977], [2111.270114, 3696.985146, 6394.793945, 7834.320313], [2088.960633, 3704.685234, 6394.759766, 7834.987305], [2066.651152, 3712.385323, 6394.654785, 7835.581055], [2044.341672, 3720.085412, 6394.453613, 7836.069336], [2022.032191, 3727.7855, 6394.154785, 7836.419922], [1999.72271, 3735.485589, 6393.768066, 7836.430664], [1977.41323, 3743.185677, 6393.287598, 7835.863281], [1955.103749, 3750.885766, 6392.664551, 7834.904297], [1932.794268, 3758.585854, 6391.951172, 7833.695313], [1910.484788, 3766.285943, 6391.216309, 7832.358398], [1888.175307, 3773.986031, 6390.489258, 7830.003906], [1865.865826, 3781.68612, 6509.765137, 7708.213379], [1842.540558, 3789.632348, 6508.545898, 7701.512695], [1819.215176, 3797.578665, 6507.478516, 7698.947266], [1795.889561, 3805.525157, 6507.836914, 7703.712402], [1772.563595, 3813.471919, 6507.537598, 7708.668457], [1749.237164, 3821.419063, 6506.314941, 7690.665039], [1725.91012, 3829.366756, 6499.086426, 7697.146973], [1703.096909, 3837.243489, 6369.864258, 7822.955078], [1680.283699, 3845.120221, 6364.125977, 7827.149414], [1657.470489, 3852.996954, 6361.989746, 7829.241211], [1634.657278, 3860.873686, 6361.726074, 7829.410156], [1611.844068, 3868.750418, 6361.936035, 7828.977539], [1589.030858, 3876.627151, 6362.291992, 7828.228516], [1566.217647, 3884.503883, 6362.682129, 7827.25293], [1543.404437, 3892.380616, 6363.037598, 7826.063477], [1520.591227, 3900.257348, 6363.316406, 7824.719727], [1497.778017, 3908.134081, 6363.519531, 7823.271484], [1474.964806, 3916.010813, 6363.65332, 7821.765625], [1452.151596, 3923.887546, 6363.719727, 7820.243164], [1429.338386, 3931.764278, 6363.732422, 7818.729492], [1406.525175, 3939.64101, 6363.708496, 7817.246094], [1383.711965, 3947.517743, 6363.652344, 7815.816406], [1360.898755, 3955.394475, 6363.570801, 7814.461914], [1338.085544, 3963.271208, 6363.472656, 7813.174805], [1315.272334, 3971.14794, 6363.362305, 7811.960938], [1292.459124, 3979.024673, 6363.241211, 7810.825195], [1269.645913, 3986.901405, 6363.115723, 7809.770508], [1246.832703, 3994.778138, 6362.981934, 7808.792969], [1224.019493, 4002.65487, 6362.851074, 7807.898438], [1201.206282, 4010.531602, 6362.722656, 7807.087891], [1178.393072, 4018.408335, 6362.598145, 7806.351563], [1155.579862, 4026.285067, 6362.479004, 7805.699219], [1132.766651, 4034.1618, 6362.36377, 7805.111328], [1109.953441, 4042.038532, 6362.261719, 7804.592773], [1087.140231, 4049.915265, 6362.162109, 7804.141602], [1064.32702, 4057.791997, 6362.074707, 7803.764648], [1041.51381, 4065.66873, 6362.000488, 7803.46582], [1018.7006, 4073.545462, 6361.947266, 7803.236328], [995.8873895, 4081.422195, 6361.90625, 7803.085938], [973.0741791, 4089.298927, 6361.884766, 7803.003906], [2393.25806, 3573.216869, 6393.976563, 7828.841797], [2371.056715, 3580.86846, 6394, 7828.90625], [2348.85537, 3588.520052, 6394.03418, 7829.035156], [2326.654025, 3596.171643, 6394.085449, 7829.219727], [2304.45268, 3603.823235, 6394.146484, 7829.452148], [2282.251335, 3611.474826, 6394.222656, 7829.746094], [2260.04999, 3619.126418, 6394.311035, 7830.099609], [2237.848646, 3626.778009, 6394.397949, 7830.519531], [2215.647301, 3634.429601, 6394.49707, 7831.001953], [2193.445956, 3642.081192, 6394.59375, 7831.554688], [2171.244611, 3649.732784, 6394.692871, 7832.181641], [2149.043266, 3657.384375, 6394.779785, 7832.875977], [2126.841921, 3665.035967, 6394.841797, 7833.614258], [2104.640577, 3672.687558, 6394.879395, 7834.375977], [2082.439232, 3680.33915, 6394.875, 7835.126953], [2060.237887, 3687.990741, 6394.811035, 7835.797852], [2038.036542, 3695.642333, 6394.638184, 7836.408203], [2015.835197, 3703.293924, 6394.339844, 7837.067383], [1993.633852, 3710.945516, 6393.957031, 7837.441406], [1971.432507, 3718.597107, 6393.535645, 7836.638672], [1949.231163, 3726.248699, 6392.822266, 7835.476563], [1927.029818, 3733.90029, 6392.010742, 7834.176758], [1904.828473, 3741.551882, 6511.439453, 7713.778809], [1881.237827, 3749.827127, 6510.288086, 7710.126465], [1857.647228, 3758.102314, 6509.334961, 7705.862793], [1834.321915, 3766.048405, 6508.425293, 7700.518555], [1810.996487, 3773.994586, 6507.706543, 7696.998047], [1787.670831, 3781.940952, 6507.378906, 7711.942871], [1764.344808, 3789.887609, 6506.119141, 7707.37207], [1741.01831, 3797.834674, 6505.275391, 7697.90625], [1717.691185, 3805.782285, 6498.800781, 7696.037109], [1694.363313, 3813.730584, 6486.007813, 7704.160645], [1671.034507, 3821.679812, 6480.825195, 7708.117676], [1647.704634, 3829.630203, 6481.235352, 7709.765625], [1624.943759, 3837.498811, 6360.399902, 7830.861328], [1602.182885, 3845.367418, 6361.412109, 7829.782227], [1579.422011, 3853.236025, 6362.121582, 7828.810547], [1556.661137, 3861.104633, 6362.697754, 7827.701172], [1533.900262, 3868.97324, 6363.13916, 7826.392578], [1511.139388, 3876.841847, 6363.450684, 7824.938477], [1488.378514, 3884.710455, 6363.658203, 7823.392578], [1465.617639, 3892.579062, 6363.773438, 7821.808594], [1442.856765, 3900.447669, 6363.821289, 7820.225586], [1420.095891, 3908.316276, 6363.817383, 7818.666992], [1397.335016, 3916.184884, 6363.771484, 7817.151367], [1374.574142, 3924.053491, 6363.699707, 7815.700195], [1351.813268, 3931.922098, 6363.61084, 7814.323242], [1329.052394, 3939.790706, 6363.50293, 7813.029297], [1306.291519, 3947.659313, 6363.380371, 7811.808594], [1283.530645, 3955.52792, 6363.25, 7810.667969], [1260.769771, 3963.396528, 6363.116699, 7809.612305], [1238.008896, 3971.265135, 6362.979492, 7808.632813], [1215.248022, 3979.133742, 6362.847656, 7807.741211], [1192.487148, 3987.00235, 6362.710938, 7806.928711], [1169.726273, 3994.870957, 6362.580078, 7806.195313], [1146.965399, 4002.739564, 6362.459473, 7805.541016], [1124.204525, 4010.608172, 6362.345215, 7804.956055], [1101.443651, 4018.476779, 6362.235352, 7804.439453], [1078.682776, 4026.345386, 6362.134277, 7803.992188], [1055.921902, 4034.213994, 6362.047363, 7803.620117], [1033.161028, 4042.082601, 6361.977051, 7803.321289], [1010.400153, 4049.951208, 6361.920898, 7803.097656], [987.639279, 4057.819816, 6361.879883, 7802.944336], [964.8784047, 4065.688423, 6361.859375, 7802.867188], [2385.319321, 3549.506358, 6393.92627, 7828.65918], [2363.322676, 3557.066068, 6393.946289, 7828.722656], [2341.326031, 3564.625778, 6393.984375, 7828.849609], [2319.329386, 3572.185488, 6394.03418, 7829.03125], [2297.332742, 3579.745198, 6394.101563, 7829.253906], [2275.336097, 3587.304908, 6394.179199, 7829.543945], [2253.339452, 3594.864618, 6394.271973, 7829.898438], [2231.342807, 3602.424328, 6394.371094, 7830.30957], [2209.346162, 3609.984038, 6394.48584, 7830.796875], [2187.349517, 3617.543748, 6394.600586, 7831.354492], [2165.352872, 3625.103458, 6394.71582, 7832.007813], [2143.356227, 3632.663168, 6394.82959, 7832.750977], [2121.359582, 3640.222878, 6394.924316, 7833.571289], [2099.362937, 3647.782588, 6394.998535, 7834.457031], [2077.366293, 3655.342298, 6395.056641, 7835.34375], [2055.369648, 3662.902008, 6395.063965, 7836.083008], [2033.373003, 3670.461717, 6394.957031, 7836.686523], [2011.376358, 3678.021427, 6394.606934, 7838.019531], [1989.379713, 3685.581137, 6394.185059, 7839.634766], [1967.383068, 3693.140847, 6514.394531, 7717.458008], [1943.791892, 3701.416725, 6513.318848, 7715.934082], [1920.200908, 3709.692374, 6512.184082, 7713.393555], [1896.610067, 3717.967848, 6510.976563, 7710.718262], [1873.019325, 3726.243207, 6509.942383, 7707.139648], [1849.42863, 3734.518508, 6509.117188, 7704.356934], [1826.103247, 3742.464504, 6508.359375, 7699.288086], [1802.777749, 3750.410588, 6507.691895, 7695.444336], [1779.452018, 3758.356845, 6507.046387, 7702.275391], [1756.125938, 3766.303373, 6505.171387, 7708.472656], [1732.799391, 3774.250284, 6502.967773, 7703.129883], [1709.472232, 3782.19774, 6495.055664, 7696.637695], [1686.144315, 3790.145916, 6484.116211, 7703.825684], [1662.815441, 3798.095065, 6480.699219, 7708.341797], [1639.485465, 3806.045398, 6481.595215, 7709.161133], [1616.154156, 3813.99727, 6482.704102, 7708.994141], [1593.41482, 3821.861974, 6361.185547, 7830.493164], [1570.675485, 3829.726679, 6362.085938, 7829.523438], [1547.936149, 3837.591383, 6362.842773, 7828.349609], [1525.196814, 3845.456087, 6363.365234, 7826.868164], [1502.457478, 3853.320792, 6363.693848, 7825.236328], [1479.718143, 3861.185496, 6363.880859, 7823.548828], [1456.978808, 3869.050201, 6363.965332, 7821.853516], [1434.239472, 3876.914905, 6363.975098, 7820.188477], [1411.500137, 3884.779609, 6363.941895, 7818.563477], [1388.760801, 3892.644314, 6363.868164, 7817.003906], [1366.021466, 3900.509018, 6363.774902, 7815.519531], [1343.28213, 3908.373722, 6363.664551, 7814.120117], [1320.542795, 3916.238427, 6363.539551, 7812.803711], [1297.803459, 3924.103131, 6363.405762, 7811.573242], [1275.064124, 3931.967835, 6363.264648, 7810.425781], [1252.324788, 3939.83254, 6363.117188, 7809.363281], [1229.585453, 3947.697244, 6362.973633, 7808.386719], [1206.846117, 3955.561949, 6362.831543, 7807.49707], [1184.106782, 3963.426653, 6362.692871, 7806.686523], [1161.367447, 3971.291357, 6362.560059, 7805.960938], [1138.628111, 3979.156062, 6362.430664, 7805.308594], [1115.888776, 3987.020766, 6362.310059, 7804.722656], [1093.14944, 3994.88547, 6362.198242, 7804.210938], [1070.410105, 4002.750175, 6362.09668, 7803.770508], [1047.670769, 4010.614879, 6362.009277, 7803.40332], [1024.931434, 4018.479584, 6361.939941, 7803.108398], [1002.192098, 4026.344288, 6361.882813, 7802.887695], [979.4527629, 4034.208992, 6361.84082, 7802.737305], [956.7134274, 4042.073697, 6361.820313, 7802.662109], [2377.255891, 3525.851818, 6393.856934, 7828.415039], [2355.339254, 3533.375618, 6393.876465, 7828.476563], [2333.422617, 3540.899417, 6393.916504, 7828.603516], [2311.50598, 3548.423217, 6393.975098, 7828.772461], [2289.589343, 3555.947016, 6394.039063, 7828.996094], [2267.672706, 3563.470816, 6394.124512, 7829.279297], [2245.756069, 3570.994615, 6394.225098, 7829.625], [2223.839432, 3578.518415, 6394.333984, 7830.033203], [2201.922796, 3586.042215, 6394.460449, 7830.509766], [2180.006159, 3593.566014, 6394.596191, 7831.074219], [2158.089522, 3601.089814, 6394.737793, 7831.736328], [2136.172885, 3608.613613, 6394.879883, 7832.522461], [2114.256248, 3616.137413, 6395.019531, 7833.458008], [2092.339611, 3623.661212, 6395.151367, 7834.548828], [2070.422974, 3631.185012, 6395.289063, 7835.709961], [2048.506337, 3638.708811, 6395.433594, 7836.5], [2026.5897, 3646.232611, 6395.526367, 7836.251953], [2004.673063, 3653.75641, 6394.957031, 7838.672852], [1982.756427, 3661.28021, 6515.010254, 7724.389648], [1959.16491, 3669.556504, 6513.998535, 7715.86084], [1935.573641, 3677.8325, 6512.981445, 7713.346191], [1911.982568, 3686.108258, 6511.785156, 7709.553223], [1888.391643, 3694.383838, 6510.589355, 7706.836914], [1864.800814, 3702.659299, 6509.740234, 7704.536133], [1841.210032, 3710.934702, 6508.916016, 7701.652832], [1817.884585, 3718.880561, 6508.145508, 7697.992676], [1794.559023, 3726.826512, 6507.368164, 7694.638184], [1771.233233, 3734.772649, 6506.939941, 7701.484863], [1747.90708, 3742.719078, 6506.090332, 7708.267578], [1724.580449, 3750.665911, 6501.967773, 7702.885742], [1701.253194, 3758.613289, 6493.144043, 7700.09668], [1677.925191, 3766.561352, 6484.867188, 7705.147461], [1654.596254, 3774.510341, 6482.211426, 7708.742188], [1631.266251, 3782.460496, 6481.356445, 7709.148926], [1607.934899, 3790.41224, 6482.459473, 7708.870117], [1584.602016, 3798.365864, 6483.668457, 7708.564941], [1561.885762, 3806.226344, 6362.19043, 7830.450195], [1539.169508, 3814.086824, 6363.216309, 7829.30957], [1516.453254, 3821.947303, 6363.778809, 7827.481445], [1493.737, 3829.807783, 6364.08252, 7825.586914], [1471.020746, 3837.668262, 6364.208984, 7823.713867], [1448.304492, 3845.528742, 6364.225098, 7821.881836], [1425.588239, 3853.389221, 6364.182617, 7820.102539], [1402.871985, 3861.249701, 6364.100586, 7818.404297], [1380.155731, 3869.110181, 6363.994629, 7816.782227], [1357.439477, 3876.97066, 6363.87207, 7815.259766], [1334.723223, 3884.83114, 6363.731934, 7813.829102], [1312.006969, 3892.691619, 6363.588867, 7812.499023], [1289.290715, 3900.552099, 6363.429688, 7811.250977], [1266.574461, 3908.412578, 6363.273438, 7810.101563], [1243.858208, 3916.273058, 6363.119629, 7809.039063], [1221.141954, 3924.133537, 6362.963867, 7808.05957], [1198.4257, 3931.994017, 6362.813477, 7807.175781], [1175.709446, 3939.854497, 6362.668457, 7806.368164], [1152.993192, 3947.714976, 6362.52832, 7805.641602], [1130.276938, 3955.575456, 6362.392578, 7804.998047], [1107.560684, 3963.435935, 6362.265137, 7804.414063], [1084.844431, 3971.296415, 6362.146484, 7803.907227], [1062.128177, 3979.156894, 6362.047852, 7803.47168], [1039.411923, 3987.017374, 6361.956055, 7803.114258], [1016.695669, 3994.877854, 6361.884277, 7802.823242], [993.9794151, 4002.738333, 6361.829102, 7802.607422], [971.2631612, 4010.598813, 6361.786621, 7802.461914], [948.5469074, 4018.459292, 6361.76709, 7802.384766], [2369.30517, 3502.146591, 6393.765625, 7828.112305], [2347.581251, 3509.583792, 6393.789551, 7828.176758], [2325.857332, 3517.020993, 6393.831543, 7828.294922], [2304.133414, 3524.458195, 6393.885742, 7828.462891], [2282.409495, 3531.895396, 6393.961426, 7828.678711], [2260.685576, 3539.332597, 6394.056641, 7828.954102], [2238.961657, 3546.769798, 6394.168945, 7829.290039], [2217.237738, 3554.207, 6394.294434, 7829.688477], [2195.513819, 3561.644201, 6394.436035, 7830.149414], [2173.7899, 3569.081402, 6394.590332, 7830.6875], [2152.065981, 3576.518604, 6394.752441, 7831.337891], [2130.342063, 3583.955805, 6394.931152, 7832.137695], [2108.618144, 3591.393006, 6395.109375, 7833.173828], [2086.894225, 3598.830207, 6395.301758, 7834.588867], [2065.170306, 3606.267409, 6395.515625, 7836.452148], [2043.446387, 3613.70461, 6395.844238, 7837.967773], [2021.722468, 3621.141811, 6516.458984, 7713.44043], [1998.130208, 3629.41902, 6515.588379, 7715.163574], [1974.538318, 3637.695781, 6514.656738, 7725.579102], [1950.946726, 3645.972175, 6513.798828, 7711.879883], [1927.355379, 3654.248268, 6512.893555, 7709.337402], [1903.764224, 3662.524129, 6511.532715, 7706.891602], [1880.173214, 3670.799815, 6510.226074, 7704.541016], [1856.582301, 3679.075385, 6509.128418, 7701.68457], [1832.991434, 3687.350896, 6508.063477, 7699.137207], [1809.665899, 3695.296661, 6507.415039, 7696.672852], [1786.340249, 3703.242515, 6506.53418, 7693.453125], [1763.014368, 3711.188542, 6507.891602, 7693.312988], [1739.688137, 3719.134839, 6506.69043, 7701.158691], [1716.361441, 3727.081517, 6501.374512, 7703.44043], [1693.034135, 3735.028741, 6494.087402, 7702.161133], [1669.706072, 3742.976684, 6486.135254, 7706.411133], [1646.377053, 3750.925597, 6482.195313, 7709.59668], [1623.046935, 3758.875695, 6481.26709, 7709.507813], [1599.715484, 3766.827329, 6482.288574, 7709.061035], [1576.382525, 3774.780784, 6483.447754, 7708.65332], [1553.047751, 3782.736605, 6484.753418, 7709.44873], [1529.710955, 3790.6951, 6486.30957, 7708.709961], [1507.043409, 3798.547175, 6364.439453, 7828.160156], [1484.375863, 3806.399251, 6364.650879, 7825.915039], [1461.708318, 3814.251327, 6364.644043, 7823.833984], [1439.040772, 3822.103402, 6364.553711, 7821.849609], [1416.373226, 3829.955478, 6364.425781, 7819.952148], [1393.70568, 3837.807554, 6364.283691, 7818.15918], [1371.038134, 3845.659629, 6364.13623, 7816.477539], [1348.370588, 3853.511705, 6363.976074, 7814.902344], [1325.703042, 3861.363781, 6363.812012, 7813.449219], [1303.035496, 3869.215856, 6363.640137, 7812.091797], [1280.36795, 3877.067932, 6363.464844, 7810.841797], [1257.700404, 3884.920008, 6363.29248, 7809.679688], [1235.032858, 3892.772083, 6363.120605, 7808.614258], [1212.365312, 3900.624159, 6362.952148, 7807.647461], [1189.697766, 3908.476235, 6362.788086, 7806.764648], [1167.03022, 3916.32831, 6362.634277, 7805.969727], [1144.362674, 3924.180386, 6362.481445, 7805.248047], [1121.695128, 3932.032462, 6362.342285, 7804.605469], [1099.027583, 3939.884537, 6362.20752, 7804.032227], [1076.360037, 3947.736613, 6362.084961, 7803.529297], [1053.692491, 3955.588689, 6361.980957, 7803.105469], [1031.024945, 3963.440764, 6361.890137, 7802.75], [1008.357399, 3971.29284, 6361.81543, 7802.46875], [985.6898529, 3979.144916, 6361.758301, 7802.25293], [963.0223069, 3986.996991, 6361.716797, 7802.114258], [940.354761, 3994.849067, 6361.700195, 7802.044922], [2361.273874, 3478.477546, 6393.654297, 7827.755859], [2339.662097, 3485.864332, 6393.681152, 7827.81543], [2318.05032, 3493.251118, 6393.721191, 7827.928711], [2296.438544, 3500.637904, 6393.78418, 7828.087891], [2274.826767, 3508.02469, 6393.870117, 7828.302734], [2253.21499, 3515.411476, 6393.97168, 7828.568359], [2231.603213, 3522.798262, 6394.099609, 7828.891602], [2209.991437, 3530.185048, 6394.231445, 7829.269531], [2188.37966, 3537.571834, 6394.395996, 7829.696289], [2166.767883, 3544.95862, 6394.566895, 7830.198242], [2145.156106, 3552.345405, 6394.756836, 7830.785156], [2123.54433, 3559.732191, 6394.969727, 7831.513672], [2101.932553, 3567.118977, 6395.196289, 7832.515625], [2080.320776, 3574.505763, 6395.433594, 7834.166016], [2058.708999, 3581.892549, 6395.640137, 7837.52832], [2037.097223, 3589.279335, 6516.517578, 7724.942383], [2013.50448, 3597.55716, 6516.312988, 7715.342285], [1989.912151, 3605.834467, 6515.38916, 7711.400879], [1966.320178, 3614.11134, 6514.739746, 7718.119141], [1942.728504, 3622.387847, 6514.128418, 7708.701172], [1919.137078, 3630.664056, 6512.975586, 7706.21582], [1895.545846, 3638.940024, 6511.592773, 7703.5625], [1871.954763, 3647.215813, 6510.204102, 7702.788086], [1848.363776, 3655.491481, 6508.769531, 7700.806152], [1824.772836, 3663.76709, 6507.008789, 7698.058594], [1801.44722, 3671.712718, 6506.188477, 7695.40625], [1778.121489, 3679.658436, 6506.652832, 7691.95166], [1754.795532, 3687.604338, 6510.558594, 7688.916992], [1731.469211, 3695.55053, 6508.833496, 7691.394531], [1708.142414, 3703.497127, 6501.782715, 7697.171875], [1684.814995, 3711.44427, 6496.405762, 7700.045898], [1661.486831, 3719.392099, 6488.021973, 7705.951172], [1638.157735, 3727.340853, 6481.725586, 7710.070801], [1614.827575, 3735.290769, 6481.64502, 7709.13916], [1591.496068, 3743.242274, 6482.333496, 7708.22168], [1568.163033, 3751.195657, 6483.222656, 7708.44043], [1544.828125, 3759.151428, 6484.51709, 7708.254395], [1521.491235, 3767.109791, 6485.804688, 7708.008789], [1498.151993, 3775.071314, 6487.184082, 7706.377441], [1475.513215, 3782.917899, 6365.430664, 7826.079102], [1452.874437, 3790.764483, 6365.176758, 7823.866211], [1430.23566, 3798.611068, 6364.915039, 7821.724609], [1407.596882, 3806.457652, 6364.684082, 7819.698242], [1384.958105, 3814.304237, 6364.47998, 7817.814453], [1362.319327, 3822.150822, 6364.282227, 7816.057617], [1339.68055, 3829.997406, 6364.088379, 7814.445313], [1317.041772, 3837.843991, 6363.893555, 7812.953125], [1294.402995, 3845.690575, 6363.694824, 7811.589844], [1271.764217, 3853.53716, 6363.498047, 7810.324219], [1249.12544, 3861.383745, 6363.302246, 7809.171875], [1226.486662, 3869.230329, 6363.116211, 7808.111328], [1203.847885, 3877.076914, 6362.930176, 7807.145508], [1181.209107, 3884.923498, 6362.752441, 7806.273438], [1158.57033, 3892.770083, 6362.585449, 7805.486328], [1135.931552, 3900.616668, 6362.428223, 7804.776367], [1113.292774, 3908.463252, 6362.274902, 7804.141602], [1090.653997, 3916.309837, 6362.13623, 7803.576172], [1068.015219, 3924.156421, 6362.008789, 7803.081055], [1045.376442, 3932.003006, 6361.900391, 7802.666992], [1022.737664, 3939.84959, 6361.813477, 7802.324219], [1000.098887, 3947.696175, 6361.734375, 7802.042969], [977.4601092, 3955.54276, 6361.676758, 7801.838867], [954.8213317, 3963.389344, 6361.633789, 7801.701172], [932.1825541, 3971.235929, 6361.612793, 7801.630859], [2353.125777, 3454.861033, 6393.523926, 7827.341797], [2331.509342, 3462.249935, 6393.544922, 7827.399414], [2309.892907, 3469.638837, 6393.588867, 7827.510742], [2288.276472, 3477.027739, 6393.666016, 7827.665039], [2266.660036, 3484.416641, 6393.754883, 7827.87207], [2245.043601, 3491.805543, 6393.873047, 7828.130859], [2223.427166, 3499.194445, 6394.005371, 7828.439453], [2201.810731, 3506.583347, 6394.160156, 7828.789063], [2180.194296, 3513.972249, 6394.332031, 7829.185547], [2158.57786, 3521.361151, 6394.52832, 7829.621094], [2136.961425, 3528.750053, 6394.744629, 7830.095703], [2115.34499, 3536.138955, 6394.990234, 7830.615234], [2093.728555, 3543.527856, 6395.279785, 7831.207031], [2072.11212, 3550.916758, 6395.610352, 7832.030273], [2050.495684, 3558.30566, 6395.918457, 7833.732422], [2028.879249, 3565.694562, 6516.072754, 7718.816895], [2005.286432, 3573.97251, 6515.852539, 7722.210938], [1981.694029, 3582.249939, 6515.316895, 7709.072754], [1958.101993, 3590.526917, 6514.820313, 7709.371582], [1934.510257, 3598.803524, 6514.447266, 7708.098633], [1910.918766, 3607.079829, 6513.054199, 7704.270996], [1887.327466, 3615.355898, 6511.70752, 7703.09668], [1863.736309, 3623.631792, 6509.09375, 7702.534668], [1840.14525, 3631.907567, 6506.621582, 7702.209961], [1816.554238, 3640.183284, 6505.44873, 7698.283691], [1793.228518, 3648.12881, 6504.724609, 7693.776367], [1769.902682, 3656.074425, 6507.314941, 7691.319824], [1746.576618, 3664.020213, 6511.09375, 7683.432617], [1723.250204, 3671.966269, 6511.629395, 7682.459961], [1699.923327, 3679.912707, 6507.879883, 7692.167969], [1676.595841, 3687.85969, 6499.182129, 7700.769043], [1653.2676, 3695.807392, 6484.479492, 7707.836426], [1629.938407, 3703.756063, 6480.883301, 7709.367676], [1606.608119, 3711.705918, 6481.975098, 7709.126465], [1583.2765, 3719.657308, 6482.366699, 7708.432617], [1559.943377, 3727.610518, 6483.202148, 7708.019043], [1536.608444, 3735.566094, 6484.259277, 7707.63916], [1513.271491, 3743.524342, 6485.424805, 7707.308594], [1489.932173, 3751.485816, 6486.73291, 7706.32959], [1466.59037, 3759.450577, 6488.271484, 7704.601563], [1443.982769, 3767.29111, 6365.714355, 7823.829102], [1421.375167, 3775.131642, 6365.242676, 7821.491211], [1398.767566, 3782.972174, 6364.925781, 7819.322266], [1376.159965, 3790.812706, 6364.665039, 7817.330078], [1353.552364, 3798.653239, 6364.434082, 7815.513672], [1330.944762, 3806.493771, 6364.20459, 7813.854492], [1308.337161, 3814.334303, 6363.974609, 7812.345703], [1285.72956, 3822.174836, 6363.751953, 7810.96582], [1263.121958, 3830.015368, 6363.527832, 7809.708984], [1240.514357, 3837.8559, 6363.30957, 7808.554688], [1217.906756, 3845.696432, 6363.103516, 7807.510742], [1195.299155, 3853.536965, 6362.904297, 7806.554688], [1172.691553, 3861.377497, 6362.705078, 7805.701172], [1150.083952, 3869.218029, 6362.524902, 7804.924805], [1127.476351, 3877.058561, 6362.355957, 7804.22168], [1104.86875, 3884.899094, 6362.20166, 7803.598633], [1082.261148, 3892.739626, 6362.051758, 7803.041992], [1059.653547, 3900.580158, 6361.916992, 7802.563477], [1037.045946, 3908.420691, 6361.807617, 7802.154297], [1014.438345, 3916.261223, 6361.714844, 7801.818359], [991.8307432, 3924.101755, 6361.635742, 7801.553711], [969.223142, 3931.942287, 6361.577637, 7801.348633], [946.6155407, 3939.78282, 6361.536133, 7801.216797], [924.0079394, 3947.623352, 6361.511719, 7801.15332], [2345.109161, 3431.185343, 6393.373535, 7826.875], [2323.619548, 3438.517185, 6393.395508, 7826.93457], [2302.129935, 3445.849027, 6393.448242, 7827.040039], [2280.640322, 3453.180868, 6393.522461, 7827.195313], [2259.150709, 3460.51271, 6393.623047, 7827.394531], [2237.661095, 3467.844551, 6393.748535, 7827.643555], [2216.171482, 3475.176393, 6393.896973, 7827.930664], [2194.681869, 3482.508235, 6394.058105, 7828.263672], [2173.192256, 3489.840076, 6394.253418, 7828.628906], [2151.702643, 3497.171918, 6394.466309, 7829.006836], [2130.21303, 3504.50376, 6394.70166, 7829.361328], [2108.723417, 3511.835601, 6394.979004, 7829.633789], [2087.233804, 3519.167443, 6395.322754, 7829.666992], [2065.744191, 3526.499284, 6395.796875, 7829.009766], [2044.254578, 3533.831126, 6515.773926, 7707.127441], [2020.661217, 3542.109803, 6515.566895, 7709.684082], [1997.068344, 3550.387853, 6515.348633, 7716.398926], [1973.475883, 3558.665381, 6515.100098, 7707.882813], [1949.883779, 3566.942471, 6515.13916, 7704.85791], [1926.291973, 3575.219193, 6514.609375, 7704.083496], [1902.700414, 3583.495614, 6513.733887, 7702.335449], [1879.10905, 3591.77179, 6512.41748, 7702.590332], [1855.517834, 3600.047787, 6509.435547, 7702.672363], [1831.926713, 3608.323663, 6506.105469, 7701.32666], [1808.33564, 3616.599478, 6504.370605, 7698.089844], [1785.009823, 3624.544857, 6503.325195, 7692.76709], [1761.683892, 3632.490326, 6507.804688, 7690.547852], [1738.357735, 3640.435982, 6511.92041, 7684.498535], [1715.031216, 3648.381927, 6512.899414, 7681.161133], [1691.704224, 3656.328278, 6511.643066, 7691.447266], [1668.376611, 3664.275172, 6500.364746, 7699.044922], [1645.048256, 3672.22275, 6483.958496, 7713.258789], [1621.718973, 3680.171252, 6480.01709, 7710.536621], [1598.388628, 3688.120918, 6482.145508, 7709.385254], [1575.056941, 3696.072173, 6482.601563, 7708.321777], [1551.72373, 3704.025307, 6483.294922, 7707.772461], [1528.388653, 3711.980827, 6483.928711, 7707.514648], [1505.051596, 3719.938937, 6485.108398, 7707.106445], [1481.712193, 3727.900206, 6486.368164, 7706.406738], [1458.370381, 3735.864781, 6488.01123, 7705.02832], [1435.765842, 3743.704, 6365.805664, 7823.723633], [1413.161303, 3751.543219, 6365.41748, 7821.102539], [1390.556764, 3759.382438, 6365.108887, 7818.764648], [1367.952224, 3767.221657, 6364.833008, 7816.678711], [1345.347685, 3775.060876, 6364.569824, 7814.803711], [1322.743146, 3782.900095, 6364.308105, 7813.12207], [1300.138607, 3790.739314, 6364.056152, 7811.599609], [1277.534067, 3798.578533, 6363.800293, 7810.229492], [1254.929528, 3806.417752, 6363.551758, 7808.973633], [1232.324989, 3814.256971, 6363.311523, 7807.842773], [1209.720449, 3822.09619, 6363.081055, 7806.80957], [1187.11591, 3829.935409, 6362.858398, 7805.880859], [1164.511371, 3837.774628, 6362.651367, 7805.039063], [1141.906832, 3845.613847, 6362.45459, 7804.279297], [1119.302292, 3853.453065, 6362.27002, 7803.594727], [1096.697753, 3861.292284, 6362.104004, 7802.984375], [1074.093214, 3869.131503, 6361.950195, 7802.442383], [1051.488675, 3876.970722, 6361.808105, 7801.970703], [1028.884135, 3884.809941, 6361.691406, 7801.577148], [1006.279596, 3892.64916, 6361.596191, 7801.248047], [983.6750568, 3900.488379, 6361.519531, 7800.991211], [961.0705175, 3908.327598, 6361.458984, 7800.799805], [938.4659783, 3916.166817, 6361.417969, 7800.673828], [915.861439, 3924.006036, 6361.39502, 7800.611328], [2336.960751, 3407.568962, 6393.198242, 7826.361328], [2315.466166, 3414.903051, 6393.227539, 7826.419922], [2293.971581, 3422.23714, 6393.282715, 7826.525391], [2272.476996, 3429.571229, 6393.363281, 7826.669922], [2250.982412, 3436.905318, 6393.46582, 7826.867188], [2229.487827, 3444.239408, 6393.603516, 7827.110352], [2207.993242, 3451.573497, 6393.760254, 7827.393555], [2186.498658, 3458.907586, 6393.9375, 7827.705078], [2165.004073, 3466.241675, 6394.141602, 7828.055664], [2143.509488, 3473.575764, 6394.373047, 7828.398438], [2122.014903, 3480.909853, 6394.621094, 7828.705078], [2100.520319, 3488.243943, 6394.901367, 7828.896484], [2079.025734, 3495.578032, 6395.225098, 7828.807617], [2057.531149, 3502.912121, 6395.628906, 7828.080078], [2036.036565, 3510.24621, 6515.333008, 7706.92334], [2012.443131, 3518.52501, 6515.05957, 7706.725098], [1988.850195, 3526.803185, 6514.834961, 7708.310547], [1965.257674, 3535.080837, 6514.546875, 7705.979492], [1941.665519, 3543.358035, 6514.426758, 7704.269043], [1918.073664, 3551.634859, 6514.382324, 7703.90918], [1894.482052, 3559.911378, 6514.154297, 7703.039063], [1870.890632, 3568.187659, 6512.875488, 7702.320313], [1847.299355, 3576.463762, 6510.194336, 7702.309082], [1823.708174, 3584.739748, 6507.621094, 7701.469238], [1800.117042, 3593.015672, 6505.866211, 7698.580566], [1776.791106, 3600.960939, 6505.967773, 7693.923828], [1753.465057, 3608.906296, 6509.535645, 7690.140625], [1730.138779, 3616.851824, 6512.226074, 7684.912598], [1706.812153, 3624.797622, 6512.558105, 7685.504395], [1683.485067, 3632.7438, 6511.425781, 7702.143066], [1660.157375, 3640.690525, 6495.19043, 7713.494141], [1636.828931, 3648.637968, 6476.257813, 7717.020508], [1613.499538, 3656.586381, 6479.771973, 7711.433105], [1590.169053, 3664.535977, 6481.858887, 7709.621582], [1566.837244, 3672.487107, 6482.849609, 7708.632324], [1543.503935, 3680.440058, 6483.449707, 7707.612793], [1520.16882, 3688.395374, 6483.898926, 7708.310547], [1496.831693, 3696.35336, 6484.609863, 7707.254883], [1473.492203, 3704.314572, 6486.088379, 7706.231934], [1450.150237, 3712.27907, 6487.730469, 7704.845703], [1427.548766, 3720.116972, 6365.78125, 7823.246094], [1404.947295, 3727.954875, 6365.521484, 7820.422852], [1382.345824, 3735.792777, 6365.255371, 7817.962891], [1359.744352, 3743.630679, 6364.979004, 7815.808594], [1337.142881, 3751.468581, 6364.695801, 7813.908203], [1314.54141, 3759.306483, 6364.415039, 7812.212891], [1291.939939, 3767.144386, 6364.124512, 7810.711914], [1269.338468, 3774.982288, 6363.844727, 7809.353516], [1246.736997, 3782.82019, 6363.571777, 7808.130859], [1224.135526, 3790.658092, 6363.306152, 7807.022461], [1201.534055, 3798.495995, 6363.05127, 7806.016602], [1178.932584, 3806.333897, 6362.807617, 7805.111328], [1156.331113, 3814.171799, 6362.57959, 7804.293945], [1133.729642, 3822.009701, 6362.368652, 7803.558594], [1111.128171, 3829.847603, 6362.170898, 7802.889648], [1088.5267, 3837.685506, 6361.991699, 7802.294922], [1065.925229, 3845.523408, 6361.831543, 7801.773438], [1043.323758, 3853.36131, 6361.686035, 7801.316406], [1020.722287, 3861.199212, 6361.563477, 7800.931641], [998.1208163, 3869.037115, 6361.465332, 7800.619141], [975.5193453, 3876.875017, 6361.381348, 7800.371094], [952.9178743, 3884.712919, 6361.322266, 7800.183594], [930.3164033, 3892.550821, 6361.280762, 7800.066406], [907.7149323, 3900.388724, 6361.258789, 7800.003906], [2328.812334, 3383.952581, 6393.005371, 7825.798828], [2307.312772, 3391.288919, 6393.034668, 7825.854492], [2285.813209, 3398.625256, 6393.096191, 7825.954102], [2264.313647, 3405.961594, 6393.178223, 7826.103516], [2242.814084, 3413.297931, 6393.291992, 7826.301758], [2221.314522, 3420.634269, 6393.434082, 7826.537109], [2199.814959, 3427.970606, 6393.603516, 7826.816406], [2178.315396, 3435.306944, 6393.789551, 7827.125], [2156.815834, 3442.643281, 6394.011719, 7827.467773], [2135.316271, 3449.979619, 6394.25293, 7827.822266], [2113.816709, 3457.315956, 6394.510254, 7828.161133], [2092.317146, 3464.652294, 6394.783691, 7828.445313], [2070.817584, 3471.988632, 6395.064453, 7828.588867], [2049.318021, 3479.324969, 6395.334961, 7828.424805], [2027.818459, 3486.661307, 6514.904785, 7708.379395], [2004.224991, 3494.940218, 6514.479004, 7708.115723], [1980.632011, 3503.218499, 6514.221191, 7708.553223], [1957.039444, 3511.496254, 6513.901367, 7707.442871], [1933.447232, 3519.773567, 6513.708008, 7704.436523], [1909.855318, 3528.05051, 6513.629395, 7703.716309], [1886.263652, 3536.327148, 6513.475586, 7703.717285], [1862.67218, 3544.603541, 6512.307617, 7701.80127], [1839.080856, 3552.879752, 6510.018555, 7701.210938], [1815.489626, 3561.155839, 6508.675781, 7700.504395], [1791.898444, 3569.431866, 6507.371094, 7697.90918], [1768.5724, 3577.376974, 6508.365234, 7694.716797], [1745.246243, 3585.322173, 6510.131348, 7690.451172], [1721.919861, 3593.267555, 6512.181152, 7688.300293], [1698.593118, 3601.213227, 6513.17334, 7690.708984], [1675.265904, 3609.159305, 6510.898926, 7698.895508], [1651.938073, 3617.105928, 6485.591309, 7714.180664], [1628.609503, 3625.053237, 6471.623047, 7716.546875], [1605.280008, 3633.001472, 6478.910156, 7714.202148], [1581.949459, 3640.950868, 6481.946777, 7710.786133], [1558.61757, 3648.901852, 6482.469727, 7709.929199], [1535.284164, 3656.854715, 6483.300293, 7709.71582], [1511.948894, 3664.809964, 6483.756836, 7709.172363], [1488.611654, 3672.767803, 6484.120117, 7707.895508], [1465.272073, 3680.728799, 6485.776855, 7706.176758], [1441.93009, 3688.693104, 6487.48584, 7703.858398], [1419.331687, 3696.5297, 6365.777832, 7822.282227], [1396.733284, 3704.366296, 6365.629883, 7819.374023], [1374.134882, 3712.202891, 6365.407715, 7816.853516], [1351.536479, 3720.039487, 6365.133301, 7814.677734], [1328.938076, 3727.876083, 6364.828613, 7812.791992], [1306.339674, 3735.712678, 6364.515137, 7811.133789], [1283.741271, 3743.549274, 6364.195801, 7809.662109], [1261.142868, 3751.38587, 6363.883789, 7808.351563], [1238.544466, 3759.222465, 6363.577637, 7807.166992], [1215.946063, 3767.059061, 6363.283691, 7806.09668], [1193.34766, 3774.895657, 6363.00293, 7805.131836], [1170.749258, 3782.732253, 6362.738281, 7804.250977], [1148.150855, 3790.568848, 6362.491699, 7803.467773], [1125.552452, 3798.405444, 6362.260742, 7802.753906], [1102.95405, 3806.24204, 6362.051758, 7802.111328], [1080.355647, 3814.078635, 6361.866699, 7801.539063], [1057.757244, 3821.915231, 6361.694824, 7801.03418], [1035.158842, 3829.751827, 6361.544434, 7800.595703], [1012.560439, 3837.588422, 6361.410645, 7800.222656], [989.9620362, 3845.425018, 6361.308594, 7799.922852], [967.3636335, 3853.261614, 6361.227539, 7799.68457], [944.7652309, 3861.098209, 6361.164551, 7799.510742], [922.1668282, 3868.934805, 6361.121094, 7799.392578], [899.5684255, 3876.771401, 6361.103516, 7799.342773], [2320.663917, 3360.336196, 6392.776367, 7825.183594], [2299.159375, 3367.674778, 6392.8125, 7825.234375], [2277.654833, 3375.01336, 6392.873535, 7825.336914], [2256.150291, 3382.351942, 6392.967285, 7825.485352], [2234.64575, 3389.690525, 6393.083984, 7825.679688], [2213.141208, 3397.029107, 6393.23584, 7825.921875], [2191.636666, 3404.367689, 6393.413086, 7826.206055], [2170.132124, 3411.706271, 6393.623535, 7826.526367], [2148.627582, 3419.044853, 6393.86084, 7826.875], [2127.123041, 3426.383435, 6394.111328, 7827.263672], [2105.618499, 3433.722017, 6394.388672, 7827.678711], [2084.113957, 3441.060599, 6394.664551, 7828.139648], [2062.609415, 3448.399181, 6394.92627, 7828.675781], [2041.104873, 3455.737763, 6395.104004, 7829.305664], [2019.600332, 3463.076345, 6514.467285, 7710.375488], [1996.006803, 3471.355383, 6513.978516, 7709.650391], [1972.413771, 3479.633793, 6513.530762, 7709.919922], [1948.821154, 3487.911677, 6513.057617, 7710.317383], [1925.228904, 3496.189102, 6512.726074, 7703.956543], [1901.636951, 3504.466151, 6512.557129, 7703.801758], [1878.045244, 3512.742892, 6512.340332, 7703.373047], [1854.453727, 3521.019394, 6511.280762, 7701.908203], [1830.862353, 3529.295716, 6509.780273, 7700.285645], [1807.271077, 3537.571918, 6508.81543, 7699.992676], [1783.679846, 3545.848061, 6507.676758, 7698.52002], [1760.353674, 3553.793041, 6508.950195, 7695.769531], [1737.027387, 3561.73811, 6509.880859, 7693.271973], [1713.700873, 3569.683353, 6511.984863, 7691.303711], [1690.374014, 3577.628865, 6514.077637, 7691.179688], [1667.046696, 3585.574759, 6509.790527, 7698.803223], [1643.718776, 3593.521199, 6494.354004, 7714.166016], [1620.390107, 3601.468358, 6484.703613, 7720.432129], [1597.060494, 3609.416487, 6485.158691, 7716.808105], [1573.729794, 3617.365799, 6481.567871, 7712.993164], [1550.397774, 3625.316647, 6482.108887, 7711.563477], [1527.064259, 3633.269316, 6482.697266, 7710.96875], [1503.728946, 3641.22435, 6483.069336, 7710.717773], [1480.391626, 3649.182054, 6483.660645, 7707.938965], [1457.051953, 3657.142983, 6485.438965, 7705.831543], [1433.709808, 3665.107199, 6487.249023, 7703.272949], [1411.114479, 3672.942485, 6365.845703, 7821.010742], [1388.519151, 3680.777772, 6365.809082, 7817.930664], [1365.923822, 3688.613059, 6365.609375, 7815.399414], [1343.328493, 3696.448346, 6365.311523, 7813.270508], [1320.733164, 3704.283632, 6364.973633, 7811.447266], [1298.137835, 3712.118919, 6364.616211, 7809.855469], [1275.542506, 3719.954206, 6364.256348, 7808.460938], [1252.947177, 3727.789493, 6363.90625, 7807.207031], [1230.351848, 3735.624779, 6363.566895, 7806.085938], [1207.756519, 3743.460066, 6363.243652, 7805.069336], [1185.16119, 3751.295353, 6362.939453, 7804.149414], [1162.565861, 3759.13064, 6362.649902, 7803.311523], [1139.970532, 3766.965926, 6362.383789, 7802.557617], [1117.375203, 3774.801213, 6362.137695, 7801.875977], [1094.779874, 3782.6365, 6361.916016, 7801.264648], [1072.184545, 3790.471787, 6361.717285, 7800.714844], [1049.589216, 3798.307073, 6361.537598, 7800.231445], [1026.993887, 3806.14236, 6361.381836, 7799.8125], [1004.398558, 3813.977647, 6361.246094, 7799.455078], [981.8032292, 3821.812934, 6361.137207, 7799.165039], [959.2079002, 3829.64822, 6361.049316, 7798.94043], [936.6125713, 3837.483507, 6360.991211, 7798.775391], [914.0172423, 3845.318794, 6360.949219, 7798.671875], [891.4219134, 3853.154081, 6360.927246, 7798.62207], [2312.664393, 3336.652736, 6392.525391, 7824.511719], [2291.303766, 3343.926488, 6392.563477, 7824.566406], [2269.943139, 3351.200239, 6392.621582, 7824.669922], [2248.582512, 3358.473991, 6392.71875, 7824.822266], [2227.221885, 3365.747742, 6392.849121, 7825.021484], [2205.861258, 3373.021494, 6393.010254, 7825.263672], [2184.500631, 3380.295245, 6393.204102, 7825.557617], [2163.140004, 3387.568996, 6393.430176, 7825.887695], [2141.779376, 3394.842748, 6393.682617, 7826.254883], [2120.418749, 3402.116499, 6393.962402, 7826.671875], [2099.058122, 3409.390251, 6394.255859, 7827.155273], [2077.697495, 3416.664002, 6394.560059, 7827.763672], [2056.336868, 3423.937753, 6394.878418, 7828.652344], [2034.976241, 3431.211505, 6514.838379, 7710.599121], [2011.382119, 3439.491388, 6514.107422, 7711.083496], [1987.788566, 3447.770543, 6513.56543, 7710.788574], [1964.195501, 3456.049063, 6513.070801, 7709.117676], [1940.602849, 3464.327054, 6512.40918, 7711.231934], [1917.010552, 3472.6046, 6511.768555, 7706.22168], [1893.418552, 3480.881773, 6511.29834, 7704.1875], [1869.8268, 3489.158639, 6510.693359, 7702.480469], [1846.235242, 3497.435257, 6509.875488, 7702.381348], [1822.643832, 3505.711693, 6509.583496, 7700.270996], [1799.052517, 3513.988004, 6508.771484, 7699.180664], [1775.461248, 3522.264255, 6508.350586, 7698.96582], [1752.134958, 3530.209059, 6508.62793, 7698.304199], [1728.808556, 3538.153954, 6508.997559, 7695.76416], [1705.481929, 3546.099036, 6510.066406, 7694.302246], [1682.154945, 3554.044409, 6512.124023, 7691.26123], [1658.827492, 3561.990189, 6507.611816, 7695.489258], [1635.499424, 3569.936512, 6503.010742, 7710.246094], [1612.170622, 3577.88352, 6492.130371, 7720.418457], [1588.840899, 3585.831454, 6480.969727, 7719.99707], [1565.510125, 3593.780553, 6480.125488, 7715.681641], [1542.178018, 3601.73124, 6481.042969, 7713.308105], [1518.844399, 3609.683808, 6481.645508, 7711.635254], [1495.508926, 3617.638763, 6482.153809, 7710.403809], [1472.171487, 3625.596307, 6483.330566, 7707.610352], [1448.831714, 3633.55701, 6485.1875, 7704.539551], [1425.489548, 3641.521018, 6487.084961, 7701.377441], [1402.897292, 3649.355007, 6366.155273, 7818.958984], [1380.305036, 3657.188996, 6366.158691, 7815.944336], [1357.71278, 3665.022985, 6365.900391, 7813.537109], [1335.120524, 3672.856973, 6365.537109, 7811.552734], [1312.528268, 3680.690962, 6365.129395, 7809.866211], [1289.936012, 3688.524951, 6364.713867, 7808.401367], [1267.343756, 3696.35894, 6364.30957, 7807.103516], [1244.751499, 3704.192929, 6363.914551, 7805.947266], [1222.159243, 3712.026917, 6363.542969, 7804.894531], [1199.566987, 3719.860906, 6363.186035, 7803.947266], [1176.974731, 3727.694895, 6362.850586, 7803.077148], [1154.382475, 3735.528884, 6362.541992, 7802.286133], [1131.790219, 3743.362873, 6362.255371, 7801.572266], [1109.197963, 3751.196861, 6361.993652, 7800.926758], [1086.605707, 3759.03085, 6361.755371, 7800.34668], [1064.013451, 3766.864839, 6361.548828, 7799.826172], [1041.421195, 3774.698828, 6361.363281, 7799.365234], [1018.828939, 3782.532817, 6361.195313, 7798.96582], [996.2366825, 3790.366805, 6361.053711, 7798.628906], [973.6444264, 3798.200794, 6360.941895, 7798.352539], [951.0521703, 3806.034783, 6360.855469, 7798.139648], [928.4599142, 3813.868772, 6360.793457, 7797.985352], [905.8676581, 3821.702761, 6360.754395, 7797.882813], [883.275402, 3829.536749, 6360.73584, 7797.837891], [2304.515614, 3313.0365, 6392.240723, 7823.787109], [2283.149647, 3320.312644, 6392.274414, 7823.838867], [2261.78368, 3327.588788, 6392.339355, 7823.948242], [2240.417712, 3334.864933, 6392.444824, 7824.108398], [2219.051745, 3342.141077, 6392.585449, 7824.313477], [2197.685778, 3349.417221, 6392.757324, 7824.567383], [2176.31981, 3356.693365, 6392.964844, 7824.871094], [2154.953843, 3363.969509, 6393.211914, 7825.211914], [2133.587876, 3371.245653, 6393.483398, 7825.59668], [2112.221908, 3378.521798, 6393.786621, 7826.023438], [2090.855941, 3385.797942, 6394.115723, 7826.504883], [2069.489974, 3393.074086, 6394.462891, 7827.111328], [2048.124006, 3400.35023, 6394.773438, 7828], [2026.758039, 3407.626374, 6514.41748, 7709.964355], [2003.163894, 3415.906368, 6513.776367, 7710.582031], [1979.570289, 3424.185654, 6513.16748, 7710.116211], [1955.977183, 3432.464308, 6512.731445, 7708.447754], [1932.384489, 3440.742433, 6512.095703, 7710.713867], [1908.792164, 3449.020097, 6511.16748, 7706.669922], [1885.200136, 3457.297383, 6510.495605, 7705.308105], [1861.608352, 3465.574357, 6509.625488, 7704.684082], [1838.01676, 3473.851091, 6508.833008, 7702.138672], [1814.42531, 3482.127644, 6508.834961, 7700.469238], [1790.833957, 3490.404077, 6508.495117, 7698.327148], [1767.24265, 3498.680449, 6507.624512, 7699.251465], [1743.916226, 3506.625111, 6507.738281, 7698.59082], [1720.589688, 3514.569862, 6507.973145, 7697.831055], [1697.262925, 3522.514785, 6508.789063, 7696.269531], [1673.935816, 3530.45998, 6507.577637, 7694.552734], [1650.608254, 3538.405557, 6507.236328, 7696.48584], [1627.28009, 3546.351681, 6501.666504, 7705.362793], [1603.951183, 3554.298525, 6487.323242, 7716.944336], [1580.621335, 3562.246341, 6477.458984, 7719.017578], [1557.290405, 3570.195341, 6478.521484, 7715.863281], [1533.958161, 3578.145878, 6479.70459, 7713.554199], [1510.624429, 3586.098235, 6480.382813, 7710.550293], [1487.288905, 3594.05296, 6481.248535, 7708.196777], [1463.951381, 3602.010355, 6483.035645, 7706.158203], [1440.611511, 3609.970977, 6484.967285, 7702.805176], [1417.269179, 3617.934884, 6487.068848, 7699.014648], [1394.68, 3625.767573, 6366.962891, 7816.072266], [1372.090821, 3633.600262, 6366.763184, 7813.345703], [1349.501643, 3641.432951, 6366.30127, 7811.256836], [1326.912464, 3649.26564, 6365.793945, 7809.540039], [1304.323285, 3657.098329, 6365.294434, 7808.069336], [1281.734106, 3664.931018, 6364.80957, 7806.770508], [1259.144927, 3672.763707, 6364.342285, 7805.613281], [1236.555748, 3680.596396, 6363.903809, 7804.564453], [1213.966569, 3688.429085, 6363.48877, 7803.608398], [1191.37739, 3696.261774, 6363.102051, 7802.731445], [1168.788212, 3704.094463, 6362.744141, 7801.929688], [1146.199033, 3711.927152, 6362.40918, 7801.192383], [1123.609854, 3719.759841, 6362.105469, 7800.523438], [1101.020675, 3727.59253, 6361.827637, 7799.914063], [1078.431496, 3735.425219, 6361.578125, 7799.368164], [1055.842317, 3743.257908, 6361.358398, 7798.875], [1033.253138, 3751.090597, 6361.157227, 7798.443359], [1010.66396, 3758.923286, 6360.985352, 7798.060547], [988.0747807, 3766.755975, 6360.839355, 7797.743164], [965.4856018, 3774.588664, 6360.724121, 7797.487305], [942.896423, 3782.421353, 6360.638184, 7797.288086], [920.3072441, 3790.254042, 6360.579102, 7797.137695], [897.7180652, 3798.086731, 6360.535645, 7797.041016], [875.1288864, 3805.91942, 6360.511719, 7796.99707], [2296.537872, 3289.343149, 6391.915527, 7823.00293], [2275.337601, 3296.544572, 6391.95459, 7823.063477], [2254.13733, 3303.745995, 6392.023926, 7823.172852], [2232.937059, 3310.947417, 6392.138184, 7823.345703], [2211.736788, 3318.14884, 6392.285156, 7823.558594], [2190.536517, 3325.350263, 6392.46875, 7823.824219], [2169.336245, 3332.551686, 6392.694336, 7824.144531], [2148.135974, 3339.753108, 6392.95166, 7824.504883], [2126.935703, 3346.954531, 6393.257813, 7824.891602], [2105.735432, 3354.155954, 6393.59375, 7825.306641], [2084.535161, 3361.357377, 6393.967285, 7825.728516], [2063.33489, 3368.558799, 6394.391602, 7826.171875], [2042.134619, 3375.760222, 6514.222168, 7707.404297], [2018.539785, 3384.041212, 6513.865234, 7708.056641], [1994.945594, 3392.32135, 6513.412598, 7708.840332], [1971.351974, 3400.600757, 6512.918945, 7709.337891], [1947.758841, 3408.879527, 6512.41748, 7707.80957], [1924.166122, 3417.157765, 6511.73584, 7705.885742], [1900.573758, 3425.435555, 6510.71875, 7705.796387], [1876.981692, 3433.71297, 6509.885254, 7710.721191], [1853.389872, 3441.990077, 6509.172852, 7705.323242], [1829.798247, 3450.266934, 6508.668945, 7702.888672], [1806.20677, 3458.543607, 6508.483887, 7701.49707], [1782.615387, 3466.820156, 6508.185547, 7700.782715], [1759.024052, 3475.096643, 6507.342773, 7700.358887], [1735.697508, 3483.041113, 6506.921875, 7700.255371], [1712.370849, 3490.985673, 6506.512695, 7699.839844], [1689.043969, 3498.930419, 6507.18457, 7698.249023], [1665.716733, 3506.875455, 6508.062988, 7696.899414], [1642.389029, 3514.8209, 6510.171875, 7700.730469], [1619.060715, 3522.766891, 6500.063965, 7706.265137], [1595.731669, 3530.713571, 6483.20459, 7715.894043], [1572.401708, 3538.661177, 6477.216309, 7717.135742], [1549.070701, 3546.609948, 6477.262207, 7715.427734], [1525.738366, 3554.560307, 6478.437988, 7712.995117], [1502.404525, 3562.512549, 6479.510742, 7710.35791], [1479.068835, 3570.467178, 6480.846191, 7707.439941], [1455.731188, 3578.424399, 6482.884277, 7703.983887], [1432.391216, 3586.38478, 6484.930664, 7700.481934], [1409.048858, 3594.348469, 6487.057617, 7695.792969], [1385.703739, 3602.315895, 6489.286133, 7691.558105], [1363.149261, 3610.141628, 6367.624023, 7810.110352], [1340.594783, 3617.96736, 6366.745605, 7808.608398], [1318.040305, 3625.793093, 6366.05127, 7807.279297], [1295.485827, 3633.618826, 6365.436035, 7806.085938], [1272.931349, 3641.444558, 6364.871094, 7805.004883], [1250.376871, 3649.270291, 6364.348145, 7804.003906], [1227.822394, 3657.096024, 6363.861328, 7803.091797], [1205.267916, 3664.921756, 6363.409668, 7802.236328], [1182.713438, 3672.747489, 6362.990723, 7801.444336], [1160.15896, 3680.573222, 6362.604004, 7800.710938], [1137.604482, 3688.398955, 6362.252441, 7800.030273], [1115.050004, 3696.224687, 6361.931152, 7799.408203], [1092.495526, 3704.05042, 6361.635742, 7798.84668], [1069.941048, 3711.876153, 6361.375, 7798.332031], [1047.38657, 3719.701885, 6361.14209, 7797.873047], [1024.832092, 3727.527618, 6360.936035, 7797.462891], [1002.277614, 3735.353351, 6360.752441, 7797.111328], [979.7231365, 3743.179083, 6360.603516, 7796.8125], [957.1686586, 3751.004816, 6360.487305, 7796.572266], [934.6141807, 3758.830549, 6360.399414, 7796.381836], [912.0597028, 3766.656282, 6360.333496, 7796.242188], [889.5052249, 3774.482014, 6360.289551, 7796.147461], [866.950747, 3782.307747, 6360.265625, 7796.104492], [2288.388679, 3265.727083, 6391.558594, 7822.154297], [2267.182653, 3272.931068, 6391.597656, 7822.219727], [2245.976627, 3280.135053, 6391.674805, 7822.342773], [2224.770601, 3287.339039, 6391.790039, 7822.523438], [2203.564576, 3294.543024, 6391.944824, 7822.756836], [2182.35855, 3301.747009, 6392.140625, 7823.043945], [2161.152524, 3308.950995, 6392.379395, 7823.386719], [2139.946498, 3316.15498, 6392.66748, 7823.767578], [2118.740472, 3323.358965, 6392.992188, 7824.174805], [2097.534446, 3330.562951, 6393.355469, 7824.582031], [2076.328421, 3337.766936, 6393.766602, 7824.933594], [2055.122395, 3344.970921, 6394.231934, 7825.116211], [2033.916369, 3352.174907, 6513.899902, 7705.566895], [2010.321499, 3360.456016, 6513.744141, 7706.12793], [1986.727293, 3368.73627, 6513.237793, 7707.160156], [1963.133627, 3377.015813, 6512.714844, 7707.755371], [1939.540461, 3385.294721, 6512.199707, 7707.805664], [1915.947708, 3393.573098, 6511.60498, 7707.27832], [1892.355322, 3401.851012, 6510.599609, 7719.90918], [1868.763235, 3410.128546, 6509.803711, 7705.374512], [1845.171392, 3418.405767, 6509.15918, 7714.633301], [1821.57974, 3426.682747, 6508.718262, 7704.78125], [1797.988232, 3434.959545, 6508.344727, 7704.687988], [1774.39682, 3443.236221, 6507.695801, 7703.48291], [1750.805454, 3451.512837, 6506.81543, 7702.75], [1727.478772, 3459.457146, 6505.587891, 7702.535156], [1704.151978, 3467.401544, 6505.365723, 7702.313477], [1680.824959, 3475.346117, 6505.37793, 7700.369141], [1657.497597, 3483.290962, 6505.813477, 7700.251953], [1634.169782, 3491.236189, 6507.164063, 7702.572266], [1610.841371, 3499.181964, 6496.51416, 7707.941895], [1587.512218, 3507.12846, 6480.360352, 7714.784668], [1564.182129, 3515.07593, 6477.258789, 7715.916016], [1540.850963, 3523.024585, 6476.174316, 7714.549805], [1517.518488, 3530.974779, 6477.129883, 7712.708496], [1494.184531, 3538.926795, 6478.200195, 7710.5], [1470.848789, 3546.88118, 6480.118164, 7705.825684], [1447.511055, 3554.838238, 6482.439941, 7700.805176], [1424.170982, 3562.798524, 6484.911133, 7695.920898], [1400.828455, 3570.762098, 6487.259766, 7691.825195], [1377.483233, 3578.729291, 6488.997559, 7687.719727], [1354.931966, 3586.553689, 6367.934082, 7806.695313], [1332.380699, 3594.378088, 6367.005859, 7805.782227], [1309.829432, 3602.202486, 6366.21582, 7804.873047], [1287.278166, 3610.026884, 6365.526855, 7803.992188], [1264.726899, 3617.851283, 6364.893066, 7803.139648], [1242.175632, 3625.675681, 6364.314453, 7802.322266], [1219.624365, 3633.500079, 6363.783203, 7801.539063], [1197.073099, 3641.324477, 6363.296387, 7800.797852], [1174.521832, 3649.148876, 6362.850098, 7800.09668], [1151.970565, 3656.973274, 6362.438477, 7799.435547], [1129.419298, 3664.797672, 6362.064453, 7798.817383], [1106.868032, 3672.622071, 6361.724121, 7798.24707], [1084.316765, 3680.446469, 6361.41748, 7797.725586], [1061.765498, 3688.270867, 6361.144043, 7797.251953], [1039.214231, 3696.095266, 6360.902344, 7796.822266], [1016.662965, 3703.919664, 6360.681641, 7796.44043], [994.1116979, 3711.744062, 6360.499512, 7796.107422], [971.5604311, 3719.568461, 6360.348633, 7795.830078], [949.0091644, 3727.392859, 6360.223145, 7795.605469], [926.4578976, 3735.217257, 6360.131348, 7795.426758], [903.9066309, 3743.041656, 6360.063965, 7795.288086], [881.3553641, 3750.866054, 6360.016602, 7795.203125], [858.8040974, 3758.690452, 6359.992188, 7795.163086], [2280.438135, 3242.021376, 6391.162598, 7821.254883], [2259.425003, 3249.138283, 6391.200684, 7821.319336], [2238.411872, 3256.25519, 6391.281738, 7821.448242], [2217.39874, 3263.372098, 6391.405762, 7821.643555], [2196.385609, 3270.489005, 6391.568359, 7821.894531], [2175.372478, 3277.605913, 6391.774414, 7822.209961], [2154.359346, 3284.72282, 6392.035156, 7822.585938], [2133.346215, 3291.839727, 6392.336914, 7823.011719], [2112.333083, 3298.956635, 6392.686523, 7823.458984], [2091.319952, 3306.073542, 6393.07666, 7823.907227], [2070.30682, 3313.19045, 6393.520996, 7824.297852], [2049.293689, 3320.307357, 6513.256836, 7705.402344], [2025.698066, 3328.589537, 6513.544434, 7704.442383], [2002.103175, 3336.870792, 6513.71875, 7703.455566], [1978.508928, 3345.151195, 6513.247559, 7705.64209], [1954.915252, 3353.430864, 6512.75293, 7705.948242], [1931.322067, 3361.709891, 6512.094727, 7705.663574], [1907.729293, 3369.988385, 6511.344238, 7704.747559], [1884.136876, 3378.266431, 6510.588379, 7723.683105], [1860.544757, 3386.544101, 6509.871094, 7725.760254], [1836.952885, 3394.82146, 6509.066895, 7718.616211], [1813.361208, 3403.098569, 6508.108887, 7707.603027], [1789.769679, 3411.375494, 6507.908691, 7707.266113], [1766.178244, 3419.652293, 6507.206543, 7706.587402], [1742.586856, 3427.929031, 6506.208984, 7705.934082], [1719.260054, 3435.87313, 6504.445313, 7705.942383], [1695.93314, 3443.817322, 6503.121582, 7706.396973], [1672.606005, 3451.761701, 6502.505371, 7703.1875], [1649.278515, 3459.706372, 6503.171387, 7702.279785], [1625.950561, 3467.651453, 6500.749023, 7704.51709], [1602.621999, 3475.597079, 6490.308105, 7708.953125], [1579.292708, 3483.543392, 6479.930664, 7713.672852], [1555.962504, 3491.490633, 6477.652832, 7714.373535], [1532.63126, 3499.439043, 6474.52832, 7714.564453], [1509.298693, 3507.389044, 6475.632813, 7712.574219], [1485.964627, 3515.340929, 6476.82666, 7708.839355], [1462.628719, 3523.295205, 6479.307129, 7703.359863], [1439.290861, 3531.252075, 6481.745117, 7696.990723], [1415.950685, 3539.212106, 6484.49707, 7691.36377], [1392.60813, 3547.175448, 6487.052246, 7686.148438], [1369.262824, 3555.142529, 6488.420898, 7683.84668], [1346.714765, 3562.965599, 6367.991699, 7803.305664], [1324.166705, 3570.78867, 6367.114258, 7802.943359], [1301.618645, 3578.61174, 6366.287598, 7802.447266], [1279.070586, 3586.434811, 6365.541504, 7801.865234], [1256.522526, 3594.257881, 6364.856934, 7801.239258], [1233.974466, 3602.080952, 6364.236328, 7800.591797], [1211.426407, 3609.904022, 6363.664063, 7799.949219], [1188.878347, 3617.727093, 6363.145996, 7799.316406], [1166.330287, 3625.550164, 6362.669434, 7798.701172], [1143.782228, 3633.373234, 6362.23584, 7798.114258], [1121.234168, 3641.196305, 6361.842285, 7797.560547], [1098.686108, 3649.019375, 6361.487305, 7797.042969], [1076.138049, 3656.842446, 6361.172363, 7796.563477], [1053.589989, 3664.665516, 6360.885254, 7796.120117], [1031.041929, 3672.488587, 6360.632324, 7795.726563], [1008.49387, 3680.311657, 6360.410645, 7795.370117], [985.9458099, 3688.134728, 6360.217285, 7795.058594], [963.3977503, 3695.957798, 6360.059082, 7794.799805], [940.8496906, 3703.780869, 6359.938477, 7794.589844], [918.3016309, 3711.603939, 6359.836426, 7794.417969], [895.7535712, 3719.42701, 6359.763184, 7794.293945], [873.2055115, 3727.25008, 6359.719238, 7794.211914], [850.6574519, 3735.073151, 6359.694824, 7794.169922], [2272.288456, 3218.405507, 6390.722168, 7820.279297], [2251.269084, 3225.525174, 6390.762207, 7820.34668], [2230.249713, 3232.644842, 6390.847656, 7820.489258], [2209.230341, 3239.764509, 6390.976074, 7820.699219], [2188.210969, 3246.884177, 6391.154297, 7820.978516], [2167.191598, 3254.003844, 6391.372559, 7821.324219], [2146.172226, 3261.123512, 6391.63916, 7821.746094], [2125.152854, 3268.24318, 6391.95752, 7822.223633], [2104.133482, 3275.362847, 6392.327148, 7822.75], [2083.114111, 3282.482515, 6392.741699, 7823.28418], [2062.094739, 3289.602182, 6393.208008, 7823.744141], [2041.075367, 3296.72185, 6512.905762, 7704.764648], [2017.479755, 3305.004163, 6513.272949, 7703.178711], [1993.884833, 3313.285543, 6513.402344, 7703.174316], [1970.290575, 3321.566063, 6513.268555, 7704.137695], [1946.696859, 3329.845869, 6512.895508, 7706.181152], [1923.103643, 3338.125041, 6512.233887, 7704.99707], [1899.510842, 3346.40368, 6511.506836, 7704.120605], [1875.918408, 3354.681854, 6510.611328, 7716.880859], [1852.326273, 3362.959647, 6509.714844, 7719.287109], [1828.734383, 3371.237127, 6508.789551, 7713.986328], [1805.142684, 3379.514364, 6507.647949, 7709.239746], [1781.551128, 3387.791419, 6507.061035, 7709.439941], [1757.95967, 3396.068353, 6506.231934, 7709.165039], [1734.368258, 3404.345225, 6505.860352, 7709.375], [1711.041322, 3412.289151, 6503.332031, 7709.265625], [1687.714276, 3420.233165, 6501.026855, 7708.503906], [1664.387003, 3428.177353, 6499.866699, 7705.59082], [1641.059391, 3436.121815, 6499.449707, 7703.178711], [1617.731327, 3444.066659, 6498.508301, 7705.768555], [1594.402669, 3452.012054, 6488.904297, 7709.174805], [1571.073273, 3459.95817, 6480.445313, 7715.143555], [1547.742944, 3467.905263, 6474.813965, 7715.22168], [1524.411544, 3475.853541, 6472.924316, 7714.969727], [1501.078838, 3483.803361, 6473.960449, 7714.407227], [1477.744657, 3491.755004, 6475.570801, 7708.101563], [1454.408696, 3499.70902, 6478.188965, 7701.133789], [1431.070751, 3507.665712, 6480.733887, 7693.580078], [1407.730475, 3515.625636, 6483.980469, 7687.636719], [1384.387753, 3523.588852, 6486.796875, 7683.327148], [1361.042343, 3531.555689, 6487.657715, 7680.889648], [1338.497493, 3539.377435, 6368.03125, 7800.185547], [1315.952644, 3547.199181, 6367.168945, 7800.239258], [1293.407794, 3555.020927, 6366.291016, 7800.092773], [1270.862945, 3562.842673, 6365.484863, 7799.776367], [1248.318095, 3570.664419, 6364.759277, 7799.355469], [1225.773246, 3578.486165, 6364.100098, 7798.867188], [1203.228396, 3586.307911, 6363.496582, 7798.345703], [1180.683547, 3594.129657, 6362.948242, 7797.816406], [1158.138697, 3601.951403, 6362.451172, 7797.279297], [1135.593847, 3609.773149, 6361.999023, 7796.768555], [1113.048998, 3617.594895, 6361.589355, 7796.268555], [1090.504148, 3625.416641, 6361.22168, 7795.801758], [1067.959299, 3633.238387, 6360.891602, 7795.360352], [1045.414449, 3641.060133, 6360.594727, 7794.956055], [1022.8696, 3648.881879, 6360.334473, 7794.588867], [1000.32475, 3656.703625, 6360.105469, 7794.257813], [977.7799006, 3664.52537, 6359.907715, 7793.96875], [955.235051, 3672.347116, 6359.748047, 7793.726563], [932.6902015, 3680.168862, 6359.61377, 7793.526367], [910.1453519, 3687.990608, 6359.513184, 7793.367188], [887.6005024, 3695.812354, 6359.4375, 7793.244141], [865.0556528, 3703.6341, 6359.390137, 7793.169922], [842.5108033, 3711.455846, 6359.364258, 7793.133789], [2264.13878, 3194.789633, 6390.233398, 7819.226563], [2243.113171, 3201.912057, 6390.280273, 7819.300781], [2222.087562, 3209.03448, 6390.368164, 7819.456055], [2201.061953, 3216.156904, 6390.51123, 7819.682617], [2180.036344, 3223.279327, 6390.689453, 7820], [2159.010735, 3230.401751, 6390.922852, 7820.381836], [2137.985126, 3237.524175, 6391.197266, 7820.851563], [2116.959517, 3244.646598, 6391.533691, 7821.391602], [2095.933908, 3251.769022, 6391.924316, 7822.029297], [2074.908299, 3258.891445, 6392.359375, 7822.738281], [2053.88269, 3266.013869, 6392.845703, 7823.43457], [2032.857081, 3273.136292, 6512.555176, 7704.442383], [2009.261407, 3281.418746, 6512.951172, 7702.819824], [1985.666467, 3289.700273, 6513.18457, 7702.083496], [1962.072172, 3297.980943, 6512.994629, 7703.314941], [1938.478449, 3306.260879, 6512.736328, 7703.988281], [1914.885217, 3314.540174, 6512.273926, 7704.544922], [1891.292398, 3322.818933, 6511.674805, 7704.147461], [1867.699937, 3331.097243, 6510.671387, 7705.87207], [1844.107774, 3339.375176, 6509.653809, 7716.648926], [1820.515858, 3347.652798, 6508.600586, 7720.819824], [1796.924138, 3355.930171, 6507.394043, 7711.329102], [1773.332566, 3364.207358, 6506.324707, 7711.574219], [1749.74109, 3372.48442, 6506.280273, 7712.23584], [1726.14966, 3380.761419, 6505.045898, 7712.788574], [1702.82261, 3388.705122, 6502.287598, 7712.505859], [1679.495447, 3396.648915, 6499.991699, 7710.75], [1656.168065, 3404.592894, 6498.033691, 7707.190918], [1632.840327, 3412.537166, 6496.431152, 7705.677734], [1609.512129, 3420.481848, 6493.82373, 7706.759766], [1586.183323, 3428.427078, 6489.509277, 7709.462891], [1562.853794, 3436.372999, 6481.817871, 7716.967285], [1539.523355, 3444.31985, 6470.980469, 7717.601074], [1516.19188, 3452.267869, 6471.833984, 7715.769043], [1492.859086, 3460.217481, 6472.630371, 7711.478516], [1469.524798, 3468.168979, 6474.064941, 7707.056641], [1446.188673, 3476.12287, 6476.259277, 7698.239746], [1422.850605, 3484.07936, 6479.450195, 7691.558105], [1399.510227, 3492.039017, 6483.257324, 7685.161133], [1376.167478, 3500.001989, 6485.766113, 7681.19873], [1352.821987, 3507.968706, 6486.916992, 7678.619629], [1329.473809, 3515.938899, 6487.673828, 7677.968262], [1306.967231, 3523.752815, 6367.224121, 7797.735352], [1284.460653, 3531.566731, 6366.211914, 7797.90332], [1261.954075, 3539.380646, 6365.353027, 7797.793945], [1239.447497, 3547.194562, 6364.594238, 7797.535156], [1216.940919, 3555.008478, 6363.90332, 7797.168945], [1194.434341, 3562.822394, 6363.277832, 7796.756836], [1171.927763, 3570.63631, 6362.704102, 7796.3125], [1149.421185, 3578.450226, 6362.188477, 7795.854492], [1126.914607, 3586.264141, 6361.719727, 7795.398438], [1104.408029, 3594.078057, 6361.294922, 7794.958008], [1081.901451, 3601.891973, 6360.91748, 7794.533203], [1059.394873, 3609.705889, 6360.577637, 7794.131836], [1036.888295, 3617.519805, 6360.273926, 7793.758789], [1014.381717, 3625.33372, 6360.005371, 7793.421875], [991.8751392, 3633.147636, 6359.767578, 7793.112305], [969.3685612, 3640.961552, 6359.568359, 7792.84082], [946.8619832, 3648.775468, 6359.402344, 7792.608398], [924.3554052, 3656.589384, 6359.266113, 7792.419922], [901.8488272, 3664.4033, 6359.158691, 7792.269531], [879.3422493, 3672.217215, 6359.081543, 7792.15625], [856.8356713, 3680.031131, 6359.031738, 7792.084961], [834.3290933, 3687.845047, 6359.008789, 7792.046875], [2256.222251, 3171.068444, 6389.713379, 7818.094727], [2235.423551, 3178.088307, 6389.756348, 7818.177734], [2214.624851, 3185.10817, 6389.847168, 7818.345703], [2193.826151, 3192.128034, 6389.991211, 7818.602539], [2173.02745, 3199.147897, 6390.174805, 7818.936523], [2152.22875, 3206.16776, 6390.411621, 7819.357422], [2131.43005, 3213.187623, 6390.705566, 7819.862305], [2110.63135, 3220.207487, 6391.060059, 7820.478516], [2089.83265, 3227.22735, 6391.464844, 7821.234375], [2069.03395, 3234.247213, 6391.934082, 7822.196289], [2048.23525, 3241.267076, 6511.706543, 7704.367676], [2024.638728, 3249.550748, 6512.089844, 7703.852051], [2001.043067, 3257.833335, 6512.509766, 7703.090332], [1977.448098, 3266.114986, 6512.811035, 7702.573242], [1953.853793, 3274.395778, 6512.664063, 7702.838379], [1930.260032, 3282.675854, 6512.391602, 7703.646484], [1906.666771, 3290.955294, 6511.923828, 7703.945801], [1883.073927, 3299.2342, 6511.370605, 7705.332031], [1859.481452, 3307.512641, 6510.459473, 7709.695801], [1835.889276, 3315.790701, 6509.567871, 7718.559082], [1812.297345, 3324.068448, 6508.144043, 7718.577148], [1788.705606, 3332.345951, 6506.716309, 7712.128906], [1765.114011, 3340.623274, 6505.436523, 7713.628906], [1741.522513, 3348.900475, 6505.175293, 7714.955566], [1717.931062, 3357.177613, 6503.54541, 7715.856934], [1694.603884, 3365.121126, 6501.216309, 7715.196289], [1671.276595, 3373.06473, 6498.967773, 7715.188477], [1647.949082, 3381.008507, 6496.717285, 7710.185059], [1624.62123, 3388.952558, 6495.02002, 7707.204102], [1601.292928, 3396.896993, 6492.824707, 7708.946289], [1577.964034, 3404.841977, 6488.504395, 7713.884277], [1554.634405, 3412.787686, 6476.364258, 7717.825684], [1531.303846, 3420.73437, 6465.411133, 7719.477539], [1507.972218, 3428.682244, 6469.484863, 7716.138672], [1484.63929, 3436.631662, 6471.739746, 7710.388184], [1461.304891, 3444.582905, 6473.374023, 7705.239258], [1437.968719, 3452.536526, 6475.20459, 7698.372559], [1414.630567, 3460.492826, 6478.555664, 7690.635254], [1391.290093, 3468.452363, 6482.30127, 7684.442383], [1367.947178, 3476.415198, 6484.61377, 7680.049805], [1344.601585, 3484.381661, 6486.204102, 7676.460938], [1321.253352, 3492.351585, 6486.848145, 7676.30957], [1298.750123, 3500.164139, 6366.883301, 7795.788086], [1276.246894, 3507.976693, 6365.960938, 7795.998047], [1253.743664, 3515.789248, 6365.123047, 7795.97168], [1231.240435, 3523.601802, 6364.351563, 7795.800781], [1208.737205, 3531.414356, 6363.645508, 7795.532227], [1186.233976, 3539.22691, 6362.998535, 7795.199219], [1163.730747, 3547.039465, 6362.412598, 7794.827148], [1141.227517, 3554.852019, 6361.875977, 7794.428711], [1118.724288, 3562.664573, 6361.397461, 7794.024414], [1096.221059, 3570.477128, 6360.955078, 7793.631836], [1073.717829, 3578.289682, 6360.569824, 7793.241211], [1051.2146, 3586.102236, 6360.224609, 7792.875], [1028.711371, 3593.914791, 6359.912109, 7792.537109], [1006.208141, 3601.727345, 6359.644043, 7792.219727], [983.7049118, 3609.539899, 6359.40332, 7791.932617], [961.2016824, 3617.352454, 6359.201172, 7791.677734], [938.698453, 3625.165008, 6359.025391, 7791.458008], [916.1952237, 3632.977562, 6358.88623, 7791.272461], [893.6919943, 3640.790116, 6358.775391, 7791.134766], [871.1887649, 3648.602671, 6358.695313, 7791.022461], [848.6855356, 3656.415225, 6358.645508, 7790.954102], [826.1823062, 3664.227779, 6358.620605, 7790.916992], [2248.072005, 3147.452809, 6389.150391, 7816.885742], [2227.266498, 3154.475666, 6389.192383, 7816.977539], [2206.460991, 3161.498523, 6389.287598, 7817.157227], [2185.655484, 3168.52138, 6389.424316, 7817.427734], [2164.849977, 3175.544237, 6389.607422, 7817.780273], [2144.04447, 3182.567095, 6389.844238, 7818.229492], [2123.238963, 3189.589952, 6390.149902, 7818.77832], [2102.433456, 3196.612809, 6390.52002, 7819.433594], [2081.627949, 3203.635666, 6390.957031, 7820.225586], [2060.822442, 3210.658523, 6391.470703, 7821.193359], [2040.016935, 3217.681381, 6511.261719, 7703.152344], [2016.420427, 3225.965165, 6511.618652, 7702.985352], [1992.824704, 3234.247894, 6511.96875, 7704.037598], [1969.229717, 3242.529694, 6512.083496, 7702.269043], [1945.635376, 3250.810636, 6512.019531, 7702.059082], [1922.04161, 3259.090842, 6511.801758, 7703.348145], [1898.448334, 3267.370405, 6511.505371, 7705.067383], [1874.855474, 3275.649433, 6510.916504, 7706.290527], [1851.262972, 3283.928013, 6510.132813, 7708.062012], [1827.670769, 3292.206215, 6509.134277, 7718.59375], [1804.078815, 3300.484107, 6507.633301, 7718.452637], [1780.487056, 3308.761749, 6505.994141, 7715.855469], [1756.895446, 3317.039206, 6504.803711, 7715.860352], [1733.303932, 3325.316537, 6503.742676, 7718.035645], [1709.712464, 3333.593807, 6501.838867, 7718.789551], [1686.385179, 3341.537084, 6500.138672, 7718.249023], [1663.057784, 3349.480454, 6497.932129, 7715.732422], [1639.730167, 3357.424013, 6496.214844, 7711.406738], [1616.4022, 3365.367864, 6493.853516, 7709.25], [1593.073772, 3373.312125, 6491.844727, 7711.449707], [1569.744739, 3381.256934, 6486.077148, 7715.054199], [1546.414983, 3389.202432, 6476.911133, 7720.790527], [1523.08432, 3397.148861, 6470.716309, 7720.574219], [1499.752624, 3405.096463, 6471.991699, 7715.714355], [1476.419614, 3413.04566, 6471.431641, 7709.751953], [1453.085114, 3420.996748, 6472.775391, 7704.113281], [1429.748783, 3428.950234, 6474.856934, 7697.195801], [1406.410515, 3436.906322, 6478.34375, 7689.427734], [1383.069942, 3444.865581, 6481.953125, 7684.137207], [1359.727005, 3452.828163, 6484.029297, 7679.784668], [1336.381333, 3460.794495, 6485.493652, 7676.795898], [1313.032982, 3468.764312, 6486.029785, 7674.956055], [1290.533098, 3476.575503, 6366.453613, 7794.180664], [1268.033213, 3484.386694, 6365.633301, 7794.306641], [1245.533329, 3492.197885, 6364.815918, 7794.292969], [1223.033444, 3500.009076, 6364.039551, 7794.170898], [1200.53356, 3507.820267, 6363.326172, 7793.958984], [1178.033675, 3515.631458, 6362.662598, 7793.685547], [1155.533791, 3523.442649, 6362.061035, 7793.361328], [1133.033906, 3531.25384, 6361.517578, 7793.011719], [1110.534022, 3539.065031, 6361.024902, 7792.65332], [1088.034137, 3546.876222, 6360.581543, 7792.291992], [1065.534253, 3554.687413, 6360.185059, 7791.939453], [1043.034368, 3562.498604, 6359.835449, 7791.603516], [1020.534484, 3570.309795, 6359.521484, 7791.28418], [998.0345991, 3578.120986, 6359.24707, 7790.992188], [975.5347145, 3585.932177, 6359.009277, 7790.719727], [953.03483, 3593.743368, 6358.795898, 7790.480469], [930.5349455, 3601.554559, 6358.619629, 7790.272461], [908.035061, 3609.36575, 6358.477051, 7790.097656], [885.5351765, 3617.176941, 6358.362305, 7789.958984], [863.035292, 3624.988132, 6358.279785, 7789.854492], [840.5354074, 3632.799323, 6358.226563, 7789.786133], [818.0355229, 3640.610514, 6358.200684, 7789.748047], [2239.921762, 3123.837172, 6388.544434, 7815.598633], [2219.109451, 3130.863021, 6388.588867, 7815.689453], [2198.297139, 3137.88887, 6388.67334, 7815.875977], [2177.484828, 3144.91472, 6388.807617, 7816.158203], [2156.672516, 3151.940569, 6388.988281, 7816.53418], [2135.860205, 3158.966419, 6389.222168, 7817.004883], [2115.047893, 3165.992268, 6389.524414, 7817.566406], [2094.235582, 3173.018117, 6389.902344, 7818.248047], [2073.42327, 3180.043967, 6390.367188, 7819.050781], [2052.610959, 3187.069816, 6390.935547, 7820.000977], [2031.798647, 3194.095666, 6510.635254, 7701.895508], [2008.202074, 3202.379612, 6511.017578, 7702.027832], [1984.606364, 3210.662473, 6511.384277, 7702.089844], [1961.011346, 3218.944398, 6511.35498, 7702.115234], [1937.416997, 3227.225459, 6511.290039, 7702.132324], [1913.823191, 3235.505805, 6510.961914, 7704.056641], [1890.229888, 3243.785514, 6510.63916, 7706.216309], [1866.637002, 3252.06469, 6510.164551, 7708.15625], [1843.044485, 3260.343402, 6509.63916, 7710.196777], [1819.45227, 3268.621731, 6508.401367, 7719.221191], [1795.8603, 3276.899749, 6506.661133, 7719.649902], [1772.268523, 3285.177524, 6505.208008, 7715.174316], [1748.67689, 3293.455118, 6503.619629, 7718.230469], [1725.085355, 3301.73259, 6502.289063, 7720.229004], [1701.493866, 3310.010001, 6500.878906, 7720.933105], [1678.166465, 3317.953081, 6499.625, 7720.906738], [1654.838952, 3325.896251, 6498.679199, 7717.38916], [1631.511216, 3333.839596, 6497.294922, 7712.696777], [1608.183142, 3341.783213, 6493.93457, 7711.106934], [1584.854619, 3349.727215, 6491.644043, 7713.043457], [1561.525506, 3357.671768, 6484.605469, 7715.375488], [1538.19566, 3365.617046, 6476.372559, 7719.438965], [1514.864887, 3373.563302, 6473.610352, 7720.048828], [1491.533047, 3381.510748, 6472.025391, 7715.668945], [1468.199911, 3389.45974, 6472.125488, 7709.072754], [1444.865308, 3397.410563, 6473.190918, 7700.65625], [1421.528936, 3405.363766, 6475.185059, 7696.441895], [1398.190589, 3413.319655, 6478.409668, 7690.554199], [1374.849925, 3421.278787, 6481.199707, 7684.737793], [1351.506828, 3429.241224, 6483.503906, 7680.026855], [1328.161059, 3437.207296, 6485.013672, 7676.38623], [1304.812656, 3445.176838, 6485.855469, 7674.193359], [1282.316115, 3452.986674, 6366.157715, 7792.774414], [1259.819573, 3460.796511, 6365.296387, 7792.749023], [1237.323031, 3468.606347, 6364.461914, 7792.723633], [1214.82649, 3476.416183, 6363.67334, 7792.628906], [1192.329948, 3484.22602, 6362.943359, 7792.454102], [1169.833407, 3492.035856, 6362.266113, 7792.21582], [1147.336865, 3499.845693, 6361.654297, 7791.928711], [1124.840324, 3507.655529, 6361.104492, 7791.616211], [1102.343782, 3515.465365, 6360.604004, 7791.285156], [1079.84724, 3523.275202, 6360.153809, 7790.953125], [1057.350699, 3531.085038, 6359.763184, 7790.626953], [1034.854157, 3538.894875, 6359.405762, 7790.3125], [1012.357616, 3546.704711, 6359.089355, 7790.017578], [989.8610741, 3554.514548, 6358.814453, 7789.737305], [967.3645326, 3562.324384, 6358.573242, 7789.480469], [944.867991, 3570.13422, 6358.364258, 7789.250977], [922.3714494, 3577.944057, 6358.181152, 7789.045898], [899.8749078, 3585.753893, 6358.035156, 7788.880859], [877.3783663, 3593.56373, 6357.917969, 7788.746094], [854.8818247, 3601.373566, 6357.837891, 7788.645508], [832.3852831, 3609.183402, 6357.780762, 7788.577148], [809.8887415, 3616.993239, 6357.751953, 7788.541016], [2232.049352, 3100.095904, 6387.897461, 7814.211914], [2211.508068, 3106.999115, 6387.9375, 7814.311523], [2190.966784, 3113.902326, 6388.017578, 7814.504883], [2170.4255, 3120.805537, 6388.141602, 7814.795898], [2149.884216, 3127.708748, 6388.306152, 7815.189453], [2129.342932, 3134.611959, 6388.536133, 7815.672852], [2108.801649, 3141.51517, 6388.825195, 7816.254883], [2088.260365, 3148.418381, 6389.200684, 7816.932617], [2067.719081, 3155.321592, 6389.687012, 7817.733398], [2047.177797, 3162.224803, 6509.40332, 7699.705078], [2023.580347, 3170.509978, 6509.967285, 7700.402832], [1999.983787, 3178.794038, 6510.325684, 7700.628906], [1976.388014, 3187.077038, 6510.547363, 7701.083496], [1952.792977, 3195.359108, 6510.504883, 7701.601074], [1929.19859, 3203.640319, 6510.384766, 7702.665527], [1905.604777, 3211.920793, 6510.078125, 7704.333496], [1882.011458, 3220.200626, 6509.755371, 7706.29541], [1858.418554, 3228.479924, 6509.303223, 7708.510254], [1834.82601, 3236.758773, 6508.850586, 7711.571777], [1811.233767, 3245.037245, 6507.189941, 7717.432617], [1787.641772, 3253.315408, 6505.615723, 7722.254883], [1764.049975, 3261.593321, 6503.709961, 7721.264648], [1740.458327, 3269.871049, 6501.771484, 7719.144531], [1716.866774, 3278.148653, 6500.757324, 7721.869629], [1693.275268, 3286.426195, 6499.743164, 7723.645996], [1669.947771, 3294.369033, 6498.92627, 7722.851074], [1646.620163, 3302.311961, 6498.824707, 7719.371582], [1623.292335, 3310.255076, 6496.707031, 7714.158203], [1599.964157, 3318.198484, 6494.376465, 7710.852539], [1576.635517, 3326.142304, 6490.260254, 7713.000977], [1553.306276, 3334.086672, 6483.884277, 7717.27002], [1529.976314, 3342.031733, 6477.111816, 7718.787109], [1506.645448, 3349.977726, 6474.935547, 7719.428711], [1483.313549, 3357.924892, 6472.439941, 7713.994629], [1459.98034, 3365.873655, 6472.904785, 7708.061523], [1436.645644, 3373.824313, 6473.683105, 7701.01123], [1413.309122, 3381.777373, 6476.130859, 7696.125], [1389.970664, 3389.733042, 6479.018066, 7692.083984], [1366.629909, 3397.69189, 6481.20459, 7684.678223], [1343.286796, 3405.654067, 6483.219238, 7679.237793], [1319.940954, 3413.620005, 6484.587402, 7675.101074], [1296.592439, 3421.589436, 6485.468262, 7672.571289], [1274.099235, 3429.397914, 6365.858887, 7791.124023], [1251.606032, 3437.206393, 6364.930176, 7791.197266], [1229.112829, 3445.014872, 6364.056152, 7791.224609], [1206.619625, 3452.823351, 6363.239746, 7791.162109], [1184.126422, 3460.631829, 6362.495117, 7791.015625], [1161.633219, 3468.440308, 6361.813477, 7790.796875], [1139.140015, 3476.248787, 6361.194824, 7790.533203], [1116.646812, 3484.057265, 6360.638184, 7790.236328], [1094.153609, 3491.865744, 6360.136719, 7789.927734], [1071.660405, 3499.674223, 6359.688477, 7789.616211], [1049.167202, 3507.482702, 6359.292969, 7789.306641], [1026.673998, 3515.29118, 6358.937988, 7789.009766], [1004.180795, 3523.099659, 6358.620117, 7788.725586], [981.6875918, 3530.908138, 6358.348633, 7788.458008], [959.1943884, 3538.716616, 6358.102539, 7788.212891], [936.701185, 3546.525095, 6357.895508, 7787.993164], [914.2079817, 3554.333574, 6357.713379, 7787.795898], [891.7147783, 3562.142053, 6357.5625, 7787.628906], [869.221575, 3569.950531, 6357.447266, 7787.495117], [846.7283716, 3577.75901, 6357.362793, 7787.400391], [824.2351682, 3585.567489, 6357.303223, 7787.335938], [801.7419649, 3593.375967, 6357.268066, 7787.296875], [2223.898432, 3076.480555, 6387.216797, 7812.733398], [2203.349666, 3083.387046, 6387.249023, 7812.833008], [2182.800901, 3090.293537, 6387.319336, 7813.03125], [2162.252135, 3097.200028, 6387.430176, 7813.337891], [2141.70337, 3104.106519, 6387.581543, 7813.742188], [2121.154604, 3111.01301, 6387.780273, 7814.245117], [2100.605839, 3117.919501, 6388.039063, 7814.839844], [2080.057073, 3124.825991, 6388.375977, 7815.500977], [2059.508308, 3131.732482, 6388.81543, 7816.212891], [2038.959542, 3138.638973, 6508.34668, 7698.091309], [2015.362087, 3146.924291, 6508.876465, 7698.636719], [1991.76546, 3155.208508, 6509.331055, 7698.776855], [1968.169697, 3163.491638, 6509.532715, 7699.763672], [1944.574629, 3171.77383, 6509.597168, 7700.703125], [1920.98023, 3180.055158, 6509.389648, 7702.341309], [1897.386376, 3188.335771, 6509.070313, 7704.051758], [1873.793027, 3196.615747, 6508.729492, 7705.887695], [1850.200096, 3204.89519, 6508.36377, 7707.817383], [1826.607535, 3213.174169, 6507.629883, 7709.08252], [1803.015278, 3221.452768, 6506.186523, 7717.178711], [1779.423266, 3229.731055, 6504.539063, 7723.61377], [1755.831448, 3238.009099, 6501.925781, 7720.084473], [1732.239774, 3246.286964, 6499.324219, 7718.506836], [1708.648199, 3254.564707, 6499.228027, 7722.827637], [1685.05667, 3262.842389, 6498.433105, 7723.048828], [1661.729068, 3270.785021, 6499.325684, 7721.96582], [1638.401355, 3278.727743, 6499.74707, 7718.916504], [1615.07342, 3286.67064, 6495.431641, 7714.371582], [1591.745147, 3294.61381, 6491.907227, 7710.447266], [1568.416426, 3302.557365, 6487.272461, 7711.971191], [1545.087116, 3310.501471, 6481.645508, 7714.839844], [1521.757074, 3318.446302, 6478.181152, 7717.33252], [1498.426108, 3326.392113, 6475.460449, 7717.461426], [1475.094076, 3334.339116, 6473.851074, 7712.544922], [1451.760752, 3342.28767, 6474.001953, 7706.658203], [1428.425962, 3350.238056, 6475.113281, 7700.602539], [1405.089406, 3358.190829, 6477.420898, 7694.943848], [1381.750881, 3366.146293, 6479.541992, 7689.480957], [1358.410042, 3374.105009, 6481.333008, 7683.604492], [1335.066775, 3382.067036, 6483.273926, 7677.543457], [1311.720841, 3390.032709, 6484.388184, 7673.411133], [1288.372281, 3398.001861, 6485.285645, 7669.844727], [1265.882413, 3405.80899, 6365.586914, 7789.260742], [1243.392545, 3413.616118, 6364.515137, 7789.674805], [1220.902677, 3421.423247, 6363.575684, 7789.80957], [1198.41281, 3429.230375, 6362.735352, 7789.780273], [1175.922942, 3437.037504, 6361.978027, 7789.641602], [1153.433074, 3444.844632, 6361.299316, 7789.426758], [1130.943207, 3452.651761, 6360.675293, 7789.167969], [1108.453339, 3460.458889, 6360.121582, 7788.881836], [1085.963471, 3468.266018, 6359.624512, 7788.577148], [1063.473603, 3476.073146, 6359.174805, 7788.275391], [1040.983736, 3483.880275, 6358.778809, 7787.976563], [1018.493868, 3491.687403, 6358.428223, 7787.6875], [996.0040002, 3499.494532, 6358.115723, 7787.414063], [973.5141325, 3507.30166, 6357.841309, 7787.15625], [951.0242648, 3515.108789, 6357.603516, 7786.916992], [928.5343971, 3522.915917, 6357.395996, 7786.707031], [906.0445294, 3530.723046, 6357.210938, 7786.513672], [883.5546617, 3538.530174, 6357.062012, 7786.348633], [861.0647939, 3546.337303, 6356.938965, 7786.217773], [838.5749262, 3554.144431, 6356.851563, 7786.120117], [816.0850585, 3561.95156, 6356.792969, 7786.053711], [793.5951908, 3569.758688, 6356.760254, 7786.019531], [2215.747516, 3052.865211, 6386.492188, 7811.152344], [2195.191274, 3059.774988, 6386.525879, 7811.251953], [2174.635032, 3066.684765, 6386.581055, 7811.458984], [2154.078789, 3073.594542, 6386.675781, 7811.771484], [2133.522547, 3080.504319, 6386.79834, 7812.199219], [2112.966305, 3087.414096, 6386.961914, 7812.731445], [2092.410062, 3094.323873, 6387.174805, 7813.349609], [2071.85382, 3101.23365, 6387.446289, 7814.004883], [2051.297578, 3108.143427, 6387.816406, 7814.558594], [2030.741335, 3115.053204, 6507.212402, 7695.837891], [2007.143827, 3123.338648, 6507.606934, 7695.85791], [1983.54721, 3131.622974, 6507.992188, 7696.0625], [1959.951381, 3139.906239, 6508.099609, 7697.671387], [1936.356291, 3148.188573, 6508.179688, 7699.544434], [1912.761852, 3156.470048, 6508.068848, 7701.758301], [1889.167988, 3164.750786, 6507.943848, 7703.287109], [1865.57462, 3173.030881, 6507.675293, 7704.98584], [1841.981669, 3181.310443, 6507.291016, 7706.694336], [1818.389079, 3189.589556, 6506.200684, 7708.95459], [1794.796789, 3197.868294, 6504.780762, 7720.380371], [1771.20475, 3206.146723, 6502.902832, 7723.091309], [1747.612909, 3214.424903, 6499.200195, 7727.211914], [1724.021217, 3222.702901, 6497.273926, 7717.728027], [1700.429621, 3230.980773, 6497.562988, 7722.304688], [1676.838072, 3239.258583, 6497.0625, 7720.879883], [1653.510388, 3247.200966, 6497.260254, 7721.518555], [1630.182592, 3255.143442, 6497.65918, 7718.352539], [1606.854578, 3263.086106, 6493.530273, 7714.638672], [1583.526213, 3271.029065, 6489.268555, 7710.951172], [1560.197389, 3278.972433, 6484.650879, 7711.172363], [1536.867963, 3286.916349, 6480.067383, 7713.351074], [1513.537817, 3294.860958, 6477.481934, 7714.21875], [1490.206769, 3302.8065, 6475.496582, 7712.870605], [1466.87469, 3310.753217, 6475.033691, 7710.244629], [1443.541302, 3318.701538, 6475.275391, 7705.04541], [1420.20643, 3326.651757, 6476.609863, 7699.196777], [1396.869735, 3334.604383, 6478.536621, 7693.36377], [1373.531109, 3342.559623, 6480.333984, 7688.356934], [1350.190187, 3350.518051, 6481.924805, 7682.301758], [1326.846912, 3358.479816, 6483.157227, 7676.597168], [1303.500911, 3366.445351, 6484.15332, 7672.122559], [1280.152244, 3374.41439, 6485.143555, 7668.115234], [1257.665707, 3382.220164, 6365.143066, 7787.931641], [1235.17917, 3390.025938, 6363.958984, 7788.4375], [1212.692632, 3397.831712, 6362.994141, 7788.560547], [1190.206095, 3405.637486, 6362.145996, 7788.507813], [1167.719557, 3413.443259, 6361.387695, 7788.336914], [1145.23302, 3421.249033, 6360.709473, 7788.108398], [1122.746483, 3429.054807, 6360.097656, 7787.833008], [1100.259945, 3436.860581, 6359.547363, 7787.541992], [1077.773408, 3444.666354, 6359.056641, 7787.237305], [1055.286871, 3452.472128, 6358.617188, 7786.93457], [1032.800333, 3460.277902, 6358.225098, 7786.636719], [1010.313796, 3468.083676, 6357.878906, 7786.350586], [987.8272584, 3475.88945, 6357.575195, 7786.080078], [965.3407211, 3483.695223, 6357.302246, 7785.827148], [942.8541837, 3491.500997, 6357.066406, 7785.595703], [920.3676463, 3499.306771, 6356.858398, 7785.384766], [897.8811089, 3507.112545, 6356.683594, 7785.198242], [875.3945715, 3514.918319, 6356.531738, 7785.037109], [852.9080342, 3522.724092, 6356.406738, 7784.90918], [830.4214968, 3530.529866, 6356.318359, 7784.8125], [807.9349594, 3538.33564, 6356.259766, 7784.742188], [785.448422, 3546.141414, 6356.226074, 7784.708984], [2207.596601, 3029.249869, 6385.739258, 7809.469727], [2187.032882, 3036.162932, 6385.762207, 7809.567383], [2166.469164, 3043.075996, 6385.819336, 7809.779297], [2145.905445, 3049.989059, 6385.88916, 7810.098633], [2125.341726, 3056.902123, 6385.984863, 7810.541992], [2104.778007, 3063.815186, 6386.101563, 7811.115234], [2084.214288, 3070.72825, 6386.24707, 7811.816406], [2063.650569, 3077.641313, 6386.413086, 7812.610352], [2043.08685, 3084.554377, 6386.63916, 7813.298828], [2022.523131, 3091.46744, 6505.915039, 7694.308594], [1998.925615, 3099.753021, 6506.277344, 7692.72998], [1975.328927, 3108.037501, 6506.501465, 7693.341797], [1951.733105, 3116.320891, 6506.594238, 7695.092773], [1928.137981, 3124.603342, 6506.621094, 7697.724121], [1904.543527, 3132.88493, 6506.483887, 7700.512207], [1880.94962, 3141.165801, 6506.337891, 7702.28418], [1857.356218, 3149.446036, 6506.144043, 7703.856445], [1833.763235, 3157.725739, 6505.760742, 7707.251465], [1810.170625, 3166.004978, 6504.549316, 7713.618164], [1786.578317, 3174.283838, 6503.305664, 7717.109375], [1762.986258, 3182.562387, 6501.178711, 7722.300293], [1739.394392, 3190.840695, 6498.190918, 7731.179199], [1715.802671, 3199.118823, 6495.501465, 7722.525391], [1692.211049, 3207.39683, 6495.613281, 7716.731934], [1668.619474, 3215.674777, 6495.640625, 7716.082031], [1645.291698, 3223.616954, 6495.365234, 7723.814453], [1621.963812, 3231.559221, 6493.456055, 7711.722168], [1598.635703, 3239.501662, 6490.476563, 7717.330078], [1575.307256, 3247.444377, 6486.96582, 7712.528809], [1551.978363, 3255.387476, 6482.67041, 7712.074219], [1528.648882, 3263.331128, 6479.270996, 7710.559082], [1505.31867, 3271.275506, 6477.771973, 7709.084473], [1481.987533, 3279.220866, 6476.131348, 7708.010742], [1458.655333, 3287.16742, 6475.907715, 7706.617676], [1435.321842, 3295.115527, 6476.058594, 7702.634766], [1411.986887, 3303.065472, 6477.798828, 7697.764648], [1388.650169, 3311.017807, 6479.422363, 7692.663086], [1365.311483, 3318.972841, 6480.736816, 7687.140625], [1341.970487, 3326.931135, 6482.088379, 7680.991699], [1318.627065, 3334.892751, 6483.188477, 7675.666504], [1295.280982, 3342.858022, 6483.980469, 7671.308594], [1272.76171, 3350.669294, 6365.110352, 7787.887695], [1250.242438, 3358.480566, 6364.178223, 7787.609375], [1227.723165, 3366.291839, 6363.192871, 7787.576172], [1205.203893, 3374.103111, 6362.286133, 7787.494141], [1182.684621, 3381.914384, 6361.463867, 7787.331055], [1160.165348, 3389.725656, 6360.728027, 7787.101563], [1137.646076, 3397.536928, 6360.061523, 7786.831055], [1115.126804, 3405.348201, 6359.459961, 7786.529297], [1092.607531, 3413.159473, 6358.921875, 7786.209961], [1070.088259, 3420.970745, 6358.44043, 7785.894531], [1047.568987, 3428.782018, 6358.009766, 7785.583984], [1025.049714, 3436.59329, 6357.625977, 7785.283203], [1002.530442, 3444.404562, 6357.287598, 7784.996094], [980.0111696, 3452.215835, 6356.987305, 7784.723633], [957.4918973, 3460.027107, 6356.723633, 7784.478516], [934.972625, 3467.83838, 6356.490234, 7784.246094], [912.4533526, 3475.649652, 6356.290527, 7784.036133], [889.9340803, 3483.460924, 6356.114746, 7783.856445], [867.4148079, 3491.272197, 6355.966797, 7783.699219], [844.8955356, 3499.083469, 6355.849609, 7783.571289], [822.3762632, 3506.894741, 6355.760254, 7783.469727], [799.8569909, 3514.706014, 6355.702148, 7783.402344], [777.3377185, 3522.517286, 6355.669922, 7783.370117], [2199.782059, 3005.48225, 6384.955566, 7807.676758], [2179.547236, 3012.246324, 6384.975098, 7807.77832], [2159.312413, 3019.010398, 6385.020996, 7807.984375], [2139.07759, 3025.774472, 6385.075684, 7808.302734], [2118.842768, 3032.538546, 6385.149414, 7808.758789], [2098.607945, 3039.302619, 6385.225098, 7809.369141], [2078.373122, 3046.066693, 6385.293945, 7810.196289], [2058.138299, 3052.830767, 6385.316406, 7811.319336], [2037.903476, 3059.594841, 6504.210938, 7693.914063], [2014.30498, 3067.881755, 6504.52002, 7693.251465], [1990.707408, 3076.167457, 6504.817871, 7690.84375], [1967.110727, 3084.452038, 6504.952148, 7691.939941], [1943.514837, 3092.735559, 6504.960449, 7693.216309], [1919.919687, 3101.018147, 6504.910156, 7696.096191], [1896.325189, 3109.299874, 6504.825195, 7698.503418], [1872.731268, 3117.580866, 6504.581055, 7700.69873], [1849.137844, 3125.861216, 6504.216309, 7701.787109], [1825.544837, 3134.141031, 6503.339355, 7704.390137], [1801.952192, 3142.4204, 6501.780273, 7707.70459], [1778.359851, 3150.699393, 6500.603516, 7716.532227], [1754.767759, 3158.97808, 6498.871094, 7717.062988], [1731.175865, 3167.256518, 6497.182617, 7729.526367], [1707.584122, 3175.534771, 6494.932129, 7732.133301], [1683.992475, 3183.812902, 6493.758301, 7715.317871], [1660.400876, 3192.090971, 6493.876465, 7718.068848], [1637.073031, 3200.0329, 6493.696777, 7725.508789], [1613.745076, 3207.97492, 6491.374023, 7713.476563], [1590.416902, 3215.917126, 6488.544434, 7719.364746], [1567.088377, 3223.859626, 6484.861328, 7713.975098], [1543.759393, 3231.802536, 6480.831543, 7702.870605], [1520.429809, 3239.745999, 6478.418457, 7697.60498], [1497.099505, 3247.690155, 6477.265625, 7699.327148], [1473.7683, 3255.635247, 6476.662109, 7701.511719], [1450.436065, 3263.581516, 6476.708984, 7702.026367], [1427.102523, 3271.529389, 6477.151367, 7699.523926], [1403.767498, 3279.479164, 6478.383789, 7695.486328], [1380.430649, 3287.431354, 6479.634766, 7691.046387], [1357.091872, 3295.386164, 6480.930664, 7686.057617], [1333.750803, 3303.344171, 6481.91748, 7680.1875], [1310.407382, 3311.305525, 6482.756836, 7674.563965], [1287.06124, 3319.270661, 6483.59668, 7669.695313], [1264.545147, 3327.08063, 6364.171875, 7787.476563], [1242.029054, 3334.8906, 6363.261719, 7787.044922], [1219.512961, 3342.700569, 6362.344238, 7786.763672], [1196.996868, 3350.510539, 6361.485352, 7786.50293], [1174.480775, 3358.320508, 6360.699219, 7786.22168], [1151.964682, 3366.130478, 6359.98584, 7785.908203], [1129.448589, 3373.940447, 6359.34375, 7785.579102], [1106.932496, 3381.750417, 6358.764648, 7785.230469], [1084.416403, 3389.560386, 6358.23877, 7784.886719], [1061.90031, 3397.370356, 6357.771973, 7784.550781], [1039.384217, 3405.180325, 6357.356445, 7784.223633], [1016.868124, 3412.990295, 6356.988281, 7783.916992], [994.3520309, 3420.800265, 6356.656738, 7783.623047], [971.8359379, 3428.610234, 6356.371582, 7783.352539], [949.3198448, 3436.420204, 6356.112793, 7783.099609], [926.8037518, 3444.230173, 6355.885254, 7782.87207], [904.2876588, 3452.040143, 6355.68457, 7782.664063], [881.7715658, 3459.850112, 6355.521484, 7782.486328], [859.2554728, 3467.660082, 6355.378906, 7782.328125], [836.7393798, 3475.470051, 6355.261719, 7782.204102], [814.2232868, 3483.280021, 6355.174316, 7782.102539], [791.7071938, 3491.08999, 6355.115723, 7782.035156], [769.1911008, 3498.89996, 6355.086426, 7782.000977], [2191.630329, 2981.867271, 6384.140137, 7805.782227], [2171.387214, 2988.634994, 6384.168457, 7805.873047], [2151.1441, 2995.402718, 6384.202148, 7806.070313], [2130.900986, 3002.170441, 6384.253906, 7806.376953], [2110.657871, 3008.938165, 6384.313965, 7806.8125], [2090.414757, 3015.705889, 6384.364258, 7807.420898], [2070.171642, 3022.473612, 6384.378906, 7808.27832], [2049.928528, 3029.241336, 6384.312012, 7809.575195], [2029.685413, 3036.009059, 6503.061523, 7692.876465], [2006.086837, 3044.296091, 6503.294434, 7692.288086], [1982.489253, 3052.581923, 6503.500488, 7691.115723], [1958.892499, 3060.866652, 6503.376465, 7691.206543], [1935.296613, 3069.150291, 6503.252441, 7692.793457], [1911.701425, 3077.432989, 6503.158203, 7694.591797], [1888.106908, 3085.714823, 6503.063965, 7696.77002], [1864.51294, 3093.995943, 6502.716309, 7699.087891], [1840.919477, 3102.276425, 6502.087891, 7701.682617], [1817.326435, 3110.556376, 6500.759766, 7703.239258], [1793.733766, 3118.835864, 6499.217285, 7706.126953], [1770.141401, 3127.114973, 6497.64502, 7720.93457], [1746.549285, 3135.393772, 6496.08252, 7712.22168], [1722.957363, 3143.672329, 6494.459473, 7732.276855], [1699.365586, 3151.950709, 6492.731445, 7734.186523], [1675.773908, 3160.228967, 6492.069824, 7734.096191], [1652.182278, 3168.507165, 6492.007813, 7731.816895], [1628.854355, 3176.448886, 6491.404297, 7726.603027], [1605.526322, 3184.390697, 6488.984863, 7726.021484], [1582.198067, 3192.332683, 6486.132324, 7716.086914], [1558.869475, 3200.274943, 6482.389648, 7715.60498], [1535.540436, 3208.217588, 6478.492188, 7703.80957], [1512.210808, 3216.160785, 6478.102539, 7688.190918], [1488.88045, 3224.104711, 6477.234375, 7686.664551], [1465.549169, 3232.049619, 6476.92334, 7686.462402], [1442.216826, 3239.995725, 6476.857422, 7689.839355], [1418.88319, 3247.943387, 6477.641113, 7692.597168], [1395.548093, 3255.892892, 6478.693848, 7692.835938], [1372.211234, 3263.844793, 6479.517578, 7689.955566], [1348.872408, 3271.799401, 6480.460449, 7685.243164], [1325.531274, 3279.757275, 6481.393066, 7679.030762], [1302.187716, 3287.718482, 6482.128906, 7672.086426], [1278.841499, 3295.683353, 6482.957031, 7668.31543], [1256.328585, 3303.492018, 6363.33252, 7786.675781], [1233.815671, 3311.300682, 6362.352051, 7786.318359], [1211.302757, 3319.109346, 6361.437012, 7785.932617], [1188.789844, 3326.918011, 6360.610352, 7785.537109], [1166.27693, 3334.726675, 6359.858887, 7785.135742], [1143.764016, 3342.53534, 6359.176758, 7784.734375], [1121.251103, 3350.344004, 6358.561523, 7784.335938], [1098.738189, 3358.152669, 6358.006348, 7783.943359], [1076.225275, 3365.961333, 6357.499023, 7783.556641], [1053.712361, 3373.769998, 6357.053711, 7783.188477], [1031.199448, 3381.578662, 6356.657715, 7782.848633], [1008.686534, 3389.387327, 6356.306641, 7782.525391], [986.1736202, 3397.195991, 6355.991211, 7782.229492], [963.6607065, 3405.004655, 6355.711426, 7781.952148], [941.1477928, 3412.81332, 6355.462891, 7781.694336], [918.634879, 3420.621984, 6355.243652, 7781.466797], [896.1219653, 3428.430649, 6355.055664, 7781.260742], [873.6090516, 3436.239313, 6354.896973, 7781.082031], [851.0961379, 3444.047978, 6354.757324, 7780.927734], [828.5832242, 3451.856642, 6354.647461, 7780.799805], [806.0703105, 3459.665307, 6354.564453, 7780.706055], [783.5573967, 3467.473971, 6354.506836, 7780.640625], [761.044483, 3475.282636, 6354.480469, 7780.605469], [2183.478595, 2958.2523, 6383.311035, 7803.78418], [2163.227185, 2965.023682, 6383.337402, 7803.876953], [2142.975775, 2971.795064, 6383.37793, 7804.051758], [2122.724365, 2978.566447, 6383.427246, 7804.326172], [2102.472955, 2985.337829, 6383.480957, 7804.703125], [2082.221545, 2992.109211, 6383.527832, 7805.214844], [2061.970135, 2998.880593, 6383.53418, 7805.902344], [2041.718725, 3005.651975, 6383.464355, 7806.842773], [2021.467315, 3012.423358, 6501.978516, 7689.438965], [1997.868747, 3020.710519, 6502.087402, 7690.07666], [1974.271104, 3028.996464, 6502.165039, 7689.921875], [1950.674355, 3037.281288, 6502.012695, 7690.450684], [1927.078397, 3045.565049, 6501.839355, 7691.473145], [1903.483179, 3053.847878, 6501.623535, 7693.244629], [1879.888615, 3062.129846, 6501.250488, 7695.145508], [1856.294629, 3070.411078, 6500.251953, 7697.865723], [1832.70114, 3078.691667, 6499.455566, 7700.754883], [1809.10807, 3086.971723, 6497.912598, 7702.783203], [1785.515363, 3095.251333, 6496.368652, 7706.06543], [1761.922958, 3103.530568, 6494.859375, 7717.35498], [1738.330805, 3111.809496, 6493.322266, 7720.182129], [1714.73885, 3120.088177, 6491.428711, 7728.627441], [1691.147047, 3128.366673, 6489.500488, 7738.6875], [1667.555339, 3136.645047, 6490.000977, 7724.195801], [1643.96368, 3144.92336, 6490.651367, 7730.127441], [1620.635702, 3152.864833, 6489.03418, 7727.45752], [1597.307613, 3160.806398, 6486.539551, 7731.588867], [1573.979305, 3168.748154, 6483.379883, 7724.989258], [1550.650648, 3176.690203, 6479.351563, 7719.987305], [1527.32153, 3184.632663, 6476.79248, 7697.342773], [1503.991813, 3192.575674, 6477.128418, 7683.749512], [1480.661376, 3200.519379, 6476.596191, 7678.174316], [1457.330038, 3208.464021, 6476.750977, 7678.407715], [1433.997671, 3216.409843, 6476.954102, 7681.978027], [1410.663996, 3224.357276, 6477.65332, 7686.176758], [1387.328839, 3232.306616, 6478.365723, 7688.92041], [1363.991861, 3240.258375, 6479.262695, 7687.887695], [1340.652956, 3248.212763, 6479.831543, 7683.862305], [1317.311757, 3256.170354, 6480.556641, 7678.652344], [1293.968209, 3264.131302, 6481.336914, 7672.473633], [1270.62194, 3272.096041, 6482.199219, 7667.572754], [1248.112198, 3279.9034, 6362.39502, 7786.054688], [1225.602456, 3287.71076, 6361.358398, 7785.624023], [1203.092714, 3295.518119, 6360.463379, 7785.101563], [1180.582972, 3303.325479, 6359.660156, 7784.569336], [1158.07323, 3311.132839, 6358.943359, 7784.050781], [1135.563488, 3318.940198, 6358.29541, 7783.557617], [1113.053746, 3326.747558, 6357.715332, 7783.084961], [1090.544004, 3334.554917, 6357.192871, 7782.635742], [1068.034262, 3342.362277, 6356.717285, 7782.212891], [1045.52452, 3350.169637, 6356.29248, 7781.816406], [1023.014778, 3357.976996, 6355.91748, 7781.452148], [1000.505035, 3365.784356, 6355.582031, 7781.116211], [977.9952934, 3373.591715, 6355.285156, 7780.805664], [955.4855514, 3381.399075, 6355.020508, 7780.523438], [932.9758093, 3389.206435, 6354.783691, 7780.264648], [910.4660673, 3397.013794, 6354.575684, 7780.03418], [887.9563252, 3404.821154, 6354.398926, 7779.829102], [865.4465832, 3412.628513, 6354.241211, 7779.65332], [842.9368411, 3420.435873, 6354.111816, 7779.5], [820.4270991, 3428.243232, 6354.008301, 7779.376953], [797.917357, 3436.050592, 6353.929199, 7779.283203], [775.407615, 3443.857952, 6353.877441, 7779.220703], [752.8978729, 3451.665311, 6353.848633, 7779.186523], [2175.326872, 2934.637335, 6382.469727, 7801.709961], [2155.067177, 2941.412382, 6382.498535, 7801.785156], [2134.807482, 2948.187428, 6382.539063, 7801.94043], [2114.547788, 2954.962475, 6382.590332, 7802.166016], [2094.288093, 2961.737522, 6382.656738, 7802.459961], [2074.028398, 2968.512568, 6382.72168, 7802.827148], [2053.768703, 2975.287615, 6382.768555, 7803.255859], [2033.509009, 2982.062662, 6382.778809, 7803.705078], [2013.249314, 2988.837708, 6501.177734, 7685.641113], [1989.650663, 2997.124978, 6501.303223, 7686.931641], [1966.053006, 3005.411046, 6501.045898, 7688.184082], [1942.45618, 3013.696011, 6500.72998, 7689.184082], [1918.860223, 3021.979883, 6500.440918, 7690.210938], [1895.264964, 3030.262815, 6500.244629, 7691.645508], [1871.670377, 3038.544882, 6499.582031, 7693.063965], [1848.07634, 3046.826233, 6498.560547, 7695.065918], [1824.482809, 3055.106948, 6497.175781, 7699.896484], [1800.889699, 3063.387131, 6495.300293, 7703.658691], [1777.296964, 3071.666851, 6493.491699, 7707.328125], [1753.704532, 3079.946193, 6491.869629, 7715.293945], [1730.11235, 3088.225226, 6490.524902, 7720.769043], [1706.520362, 3096.504017, 6489.92334, 7726.61377], [1682.92852, 3104.782629, 6487.624023, 7735.089355], [1659.336777, 3113.061122, 6488.40625, 7733.66748], [1635.745082, 3121.339554, 6489.294922, 7729.136719], [1612.417039, 3129.280825, 6486.78125, 7728.605469], [1589.088885, 3137.222186, 6484.217285, 7730.726563], [1565.760508, 3145.163722, 6482.021973, 7732.415039], [1542.431795, 3153.105533, 6477.740723, 7722.003418], [1519.102634, 3161.047729, 6476.016113, 7731.342285], [1495.772886, 3168.99048, 6475.763672, 7712.808594], [1472.442407, 3176.93396, 6475.963867, 7691.331055], [1449.111005, 3184.878426, 6476.276855, 7674.618164], [1425.778542, 3192.824092, 6476.729492, 7681.145996], [1402.444786, 3200.771318, 6477.390625, 7687.001953], [1379.109567, 3208.720391, 6477.804199, 7687.743652], [1355.772588, 3216.671867, 6478.299316, 7687.063477], [1332.433641, 3224.626056, 6478.861816, 7683.729492], [1309.092388, 3232.583521, 6479.505859, 7679.780762], [1285.748712, 3240.544326, 6480.116699, 7674.578125], [1262.402376, 3248.508806, 6481.078613, 7667.883301], [1239.895806, 3256.314858, 6361.22168, 7785.811523], [1217.389236, 3264.120909, 6360.231445, 7785.021484], [1194.882666, 3271.926961, 6359.376465, 7784.27832], [1172.376095, 3279.733012, 6358.62207, 7783.583984], [1149.869525, 3287.539064, 6357.951172, 7782.945313], [1127.362955, 3295.345115, 6357.352539, 7782.360352], [1104.856385, 3303.151167, 6356.80957, 7781.814453], [1082.349815, 3310.957218, 6356.322754, 7781.308594], [1059.843245, 3318.76327, 6355.880859, 7780.84668], [1037.336675, 3326.569321, 6355.486328, 7780.414063], [1014.830104, 3334.375373, 6355.13623, 7780.03125], [992.3235342, 3342.181424, 6354.820313, 7779.675781], [969.8169641, 3349.987476, 6354.540039, 7779.357422], [947.3103939, 3357.793527, 6354.291504, 7779.06543], [924.8038238, 3365.599578, 6354.071289, 7778.805664], [902.2972536, 3373.40563, 6353.87793, 7778.574219], [879.7906835, 3381.211681, 6353.709473, 7778.369141], [857.2841133, 3389.017733, 6353.566895, 7778.191406], [834.7775432, 3396.823784, 6353.443848, 7778.045898], [812.270973, 3404.629836, 6353.347168, 7777.923828], [789.7644029, 3412.435887, 6353.276855, 7777.836914], [767.2578327, 3420.241939, 6353.222656, 7777.777344], [744.7512626, 3428.04799, 6353.19873, 7777.735352], [2167.175144, 2911.02238, 6381.612305, 7799.56543], [2146.90716, 2917.801101, 6381.635254, 7799.630859], [2126.639176, 2924.579822, 6381.682617, 7799.753906], [2106.371192, 2931.358544, 6381.745117, 7799.927734], [2086.103208, 2938.137265, 6381.831543, 7800.147461], [2065.835224, 2944.915986, 6381.931152, 7800.379883], [2045.567241, 2951.694707, 6382.040039, 7800.581055], [2025.299257, 2958.473428, 6382.14209, 7800.626953], [2005.031273, 2965.252149, 6500.375977, 7682.106445], [1981.43263, 2973.539539, 6500.484863, 7683.770996], [1957.834911, 2981.825713, 6500.130371, 7685.514648], [1934.238086, 2990.110765, 6499.800781, 7687.036621], [1910.642054, 2998.394752, 6499.452148, 7688.104004], [1887.046763, 3006.677805, 6499.016602, 7689.433105], [1863.452125, 3014.959998, 6498, 7691.325195], [1839.858067, 3023.241454, 6496.956055, 7694.072266], [1816.264506, 3031.522268, 6495.133301, 7699.256348], [1792.671365, 3039.802548, 6492.925781, 7704.783203], [1769.078587, 3048.08238, 6490.964844, 7708.770996], [1745.486112, 3056.361839, 6489.180664, 7716.00293], [1721.893888, 3064.640991, 6488.07666, 7720.498047], [1698.301864, 3072.919894, 6487.739258, 7727.162109], [1674.70999, 3081.198615, 6487.337891, 7732.470215], [1651.118213, 3089.477211, 6487.009277, 7735.12207], [1627.526484, 3097.755748, 6486.00293, 7731.066895], [1604.198397, 3105.696778, 6483.80127, 7730.166504], [1580.870198, 3113.637899, 6482.052246, 7734.230957], [1557.541782, 3121.579208, 6479.825195, 7732.983398], [1534.213014, 3129.520811, 6476.910645, 7728.213379], [1510.883788, 3137.462827, 6475.921387, 7726.22998], [1487.55396, 3145.405397, 6473.683105, 7701.230469], [1464.223415, 3153.348664, 6475.008301, 7709.576172], [1440.891967, 3161.292871, 6475.620605, 7714.237305], [1417.559489, 3169.238261, 6476.177734, 7695.736328], [1394.225704, 3177.185263, 6476.567383, 7691.478516], [1370.890437, 3185.134177, 6477.018555, 7689.158691], [1347.553347, 3193.085516, 6477.255371, 7686.296875], [1324.21433, 3201.039491, 6477.638184, 7683.156738], [1300.87302, 3208.996679, 6478.245605, 7678.879883], [1277.529362, 3216.957232, 6478.873535, 7674.228027], [1254.182983, 3224.921586, 6479.78418, 7668.532715], [1231.679577, 3232.726328, 6359.865723, 7785.599609], [1209.176172, 3240.531071, 6358.964844, 7784.37207], [1186.672767, 3248.335814, 6358.185547, 7783.387695], [1164.169361, 3256.140557, 6357.5, 7782.541992], [1141.665956, 3263.9453, 6356.891602, 7781.788086], [1119.16255, 3271.750042, 6356.344238, 7781.114258], [1096.659145, 3279.554785, 6355.853027, 7780.501953], [1074.15574, 3287.359528, 6355.408203, 7779.945313], [1051.652334, 3295.164271, 6355.006348, 7779.438477], [1029.148929, 3302.969013, 6354.641602, 7778.984375], [1006.645524, 3310.773756, 6354.315918, 7778.571289], [984.1421183, 3318.578499, 6354.025391, 7778.208984], [961.6387129, 3326.383242, 6353.770508, 7777.873047], [939.1353076, 3334.187985, 6353.539551, 7777.573242], [916.6319022, 3341.992727, 6353.330566, 7777.310547], [894.1284968, 3349.79747, 6353.152832, 7777.082031], [871.6250915, 3357.602213, 6352.995605, 7776.876953], [849.1216861, 3365.406956, 6352.869629, 7776.708008], [826.6182808, 3373.211698, 6352.754395, 7776.561523], [804.1148754, 3381.016441, 6352.665039, 7776.448242], [781.61147, 3388.821184, 6352.59668, 7776.360352], [759.1080647, 3396.625927, 6352.550781, 7776.300781], [736.6046593, 3404.43067, 6352.526855, 7776.264648], [2159.023426, 2887.407432, 6380.728027, 7797.355469], [2138.747163, 2894.189833, 6380.755859, 7797.416016], [2118.4709, 2900.972235, 6380.806641, 7797.512695], [2098.194637, 2907.754637, 6380.880371, 7797.649414], [2077.918374, 2914.537038, 6380.992188, 7797.8125], [2057.642111, 2921.31944, 6381.133301, 7797.970703], [2037.365848, 2928.101841, 6381.30957, 7798.054688], [2017.089584, 2934.884243, 6381.531738, 7797.949219], [1996.813321, 2941.666645, 6499.791992, 7679.462402], [1973.214594, 2949.954137, 6499.718262, 7681.211426], [1949.616859, 2958.240427, 6499.302246, 7682.686523], [1926.019957, 2966.525611, 6498.816406, 7684.20166], [1902.423922, 2974.809702, 6498.286621, 7685.779297], [1878.828588, 2983.092849, 6497.659668, 7687.223145], [1855.233925, 2991.375132, 6496.557129, 7689.488281], [1831.639812, 2999.656699, 6495.29541, 7693.72998], [1808.046207, 3007.937628, 6492.976074, 7698.637207], [1784.453022, 3016.218026, 6490.45752, 7704.113281], [1760.860212, 3024.49796, 6488.935547, 7709.960938], [1737.267706, 3032.777515, 6487.458496, 7715.507324], [1713.67545, 3041.056761, 6486.312988, 7720.359375], [1690.083387, 3049.335766, 6485.723633, 7725.580078], [1666.491472, 3057.614591, 6484.786133, 7729.540039], [1642.899655, 3065.893297, 6484.158203, 7732.119629], [1619.307886, 3074.171942, 6483.066406, 7732.07373], [1595.979744, 3082.112774, 6481.699219, 7731.056152], [1572.651491, 3090.053696, 6480.12793, 7730.14209], [1549.323017, 3097.994795, 6478.118652, 7733.214844], [1525.994204, 3105.936167, 6475.619141, 7739.518555], [1502.664945, 3113.877929, 6472.83252, 7718.716797], [1479.335098, 3121.820245, 6471.212891, 7693.895508], [1456.004519, 3129.763292, 6473.26709, 7684.663086], [1432.673017, 3137.707328, 6474.372559, 7682.990723], [1409.340452, 3145.652567, 6474.910156, 7687.745605], [1386.006595, 3153.59937, 6475.215332, 7688.804688], [1362.671275, 3161.548025, 6475.536621, 7684.074707], [1339.334194, 3169.499089, 6475.857422, 7682.816895], [1315.995145, 3177.452873, 6476.222168, 7680.94873], [1292.653789, 3185.409941, 6476.594727, 7678.336914], [1269.310009, 3193.370356, 6477.277832, 7674.103516], [1245.96357, 3201.334457, 6478.213379, 7667.511719], [1223.46333, 3209.137888, 6358.370605, 7784.814453], [1200.963091, 3216.941318, 6357.583008, 7783.479492], [1178.462851, 3224.744748, 6356.898438, 7782.363281], [1155.962611, 3232.548178, 6356.30127, 7781.394531], [1133.462371, 3240.351608, 6355.76123, 7780.550781], [1110.962131, 3248.155039, 6355.282715, 7779.800781], [1088.461892, 3255.958469, 6354.847168, 7779.126953], [1065.961652, 3263.761899, 6354.447754, 7778.526367], [1043.461412, 3271.565329, 6354.089844, 7777.987305], [1020.961172, 3279.36876, 6353.756836, 7777.503906], [998.4609326, 3287.17219, 6353.463867, 7777.075195], [975.9606928, 3294.97562, 6353.202148, 7776.692383], [953.4604531, 3302.77905, 6352.966309, 7776.353516], [930.9602133, 3310.582481, 6352.755371, 7776.049805], [908.4599735, 3318.385911, 6352.565918, 7775.789063], [885.9597337, 3326.189341, 6352.404785, 7775.555664], [863.459494, 3333.992771, 6352.262207, 7775.353516], [840.9592542, 3341.796202, 6352.146973, 7775.191406], [818.4590144, 3349.599632, 6352.046875, 7775.055664], [795.9587746, 3357.403062, 6351.963379, 7774.944336], [773.4585349, 3365.206492, 6351.902344, 7774.858398], [750.9582951, 3373.009923, 6351.857422, 7774.798828], [728.4580553, 3380.813353, 6351.835449, 7774.765625], [2150.871703, 2863.792493, 6379.810547, 7795.099609], [2130.587156, 2870.578586, 6379.84082, 7795.147461], [2110.302608, 2877.364679, 6379.900879, 7795.232422], [2090.01806, 2884.150771, 6379.993164, 7795.351563], [2069.733512, 2890.936864, 6380.122559, 7795.491211], [2049.448964, 2897.722956, 6380.294434, 7795.621094], [2029.164417, 2904.509049, 6380.521484, 7795.700195], [2008.879869, 2911.295141, 6380.862305, 7795.686523], [1988.595321, 2918.081234, 6499.270996, 7677.765625], [1964.996599, 2926.368839, 6499.003906, 7678.948242], [1941.398802, 2934.655227, 6498.613281, 7680.03418], [1917.801899, 2942.94049, 6498.049805, 7681.866211], [1894.205789, 2951.224687, 6497.265137, 7683.018066], [1870.61042, 2959.507949, 6496.202637, 7684.709473], [1847.015705, 2967.79035, 6495.032227, 7688.060059], [1823.421569, 2976.072011, 6493.416016, 7692.391113], [1799.82793, 2984.35303, 6491.288086, 7698.312012], [1776.234711, 2992.633514, 6489.029297, 7703.601563], [1752.641855, 3000.913551, 6487.349609, 7708.854004], [1729.049303, 3009.193214, 6485.900879, 7714.269043], [1705.457002, 3017.472569, 6484.733887, 7719.484863], [1681.8649, 3025.751675, 6483.710938, 7724.073242], [1658.272949, 3034.030599, 6482.462402, 7727.641602], [1634.681095, 3042.309398, 6481.661621, 7729.648926], [1611.089288, 3050.588136, 6480.594727, 7730.890625], [1587.761112, 3058.528731, 6479.499023, 7730.417969], [1564.432825, 3066.46942, 6478.265137, 7730.849609], [1541.104319, 3074.4103, 6476.440918, 7735.768066], [1517.775462, 3082.351475, 6473.787109, 7738.774902], [1494.446146, 3090.293064, 6470.984375, 7731.775391], [1471.116228, 3098.235207, 6470.158691, 7712.60498], [1447.785591, 3106.178046, 6471.687012, 7702.923828], [1424.454051, 3114.121829, 6472.789063, 7696.157227], [1401.121482, 3122.066799, 6473.145508, 7691.44873], [1377.787604, 3130.013388, 6473.445313, 7688.732422], [1354.452243, 3137.961892, 6473.644531, 7683.878418], [1331.11506, 3145.91283, 6473.850586, 7680.054199], [1307.775948, 3153.866408, 6474.310547, 7675.984375], [1284.434543, 3161.823204, 6474.726074, 7674.266602], [1261.090787, 3169.783374, 6475.703125, 7671.592285], [1237.744311, 3177.747353, 6476.570313, 7666.149414], [1215.247231, 3185.549469, 6356.755371, 7783.731445], [1192.75015, 3193.351586, 6356.087402, 7782.375], [1170.253069, 3201.153703, 6355.523926, 7781.176758], [1147.755989, 3208.95582, 6355.029785, 7780.132813], [1125.258908, 3216.757936, 6354.583496, 7779.212891], [1102.761828, 3224.560053, 6354.17041, 7778.40332], [1080.264747, 3232.36217, 6353.794434, 7777.68457], [1057.767666, 3240.164286, 6353.449219, 7777.043945], [1035.270586, 3247.966403, 6353.135254, 7776.478516], [1012.773505, 3255.76852, 6352.842773, 7775.978516], [990.2764247, 3263.570637, 6352.581543, 7775.53125], [967.7793441, 3271.372753, 6352.348633, 7775.142578], [945.2822635, 3279.17487, 6352.141113, 7774.797852], [922.785183, 3286.976987, 6351.952148, 7774.494141], [900.2881024, 3294.779104, 6351.780762, 7774.229492], [877.7910218, 3302.58122, 6351.633301, 7774.001953], [855.2939412, 3310.383337, 6351.508301, 7773.805664], [832.7968606, 3318.185454, 6351.404785, 7773.640625], [810.29978, 3325.98757, 6351.316895, 7773.513672], [787.8026994, 3333.789687, 6351.243164, 7773.413086], [765.3056188, 3341.591804, 6351.186035, 7773.334961], [742.8085383, 3349.393921, 6351.148438, 7773.275391], [720.3114577, 3357.196037, 6351.126953, 7773.246094], [2142.719989, 2840.177561, 6378.861816, 7792.796875], [2122.427165, 2846.967351, 6378.897461, 7792.841797], [2102.134341, 2853.757141, 6378.972168, 7792.925781], [2081.841517, 2860.54693, 6379.068359, 7793.041016], [2061.548693, 2867.33672, 6379.209961, 7793.179688], [2041.255869, 2874.126509, 6379.388672, 7793.3125], [2020.963045, 2880.916299, 6379.628906, 7793.419922], [2000.670221, 2887.706089, 6379.964844, 7793.485352], [1980.377397, 2894.495878, 6498.202637, 7675.751953], [1956.778593, 2902.783579, 6497.982422, 7676.830566], [1933.180779, 2911.070073, 6497.649902, 7678.172852], [1909.583797, 2919.35546, 6496.839844, 7679.580078], [1885.987685, 2927.639754, 6495.9375, 7680.428223], [1862.39227, 2935.923102, 6494.77002, 7682.313477], [1838.797529, 2944.205584, 6493.569336, 7685.311523], [1815.203337, 2952.487348, 6491.743164, 7690.312012], [1791.609651, 2960.768474, 6489.513672, 7696.205078], [1768.016388, 2969.049066, 6487.601563, 7701.71582], [1744.423498, 2977.329194, 6485.814941, 7706.771973], [1720.830912, 2985.608944, 6484.482422, 7712.207031], [1697.238575, 2993.888382, 6483.330566, 7717.247559], [1673.646432, 3002.16758, 6482.207031, 7721.582031], [1650.054437, 3010.446597, 6480.677246, 7725.672852], [1626.462539, 3018.725494, 6479.01709, 7727.342285], [1602.87069, 3027.00433, 6477.885742, 7728.854492], [1579.542468, 3034.944738, 6477.01123, 7726.990234], [1556.214134, 3042.885235, 6476.852539, 7728.805176], [1532.885578, 3050.82591, 6474.921875, 7728.157227], [1509.556685, 3058.76686, 6472.43457, 7727.025879], [1486.227343, 3066.708199, 6469.260254, 7731.592285], [1462.897414, 3074.650096, 6469.491699, 7722.13916], [1439.566752, 3082.592728, 6470.401367, 7718.455566], [1416.235165, 3090.53635, 6470.821777, 7711.028809], [1392.902516, 3098.481179, 6471.101074, 7699.416992], [1369.568573, 3106.427576, 6471.351563, 7688.899414], [1346.233167, 3114.375829, 6471.527344, 7674.540527], [1322.895998, 3122.326497, 6471.791016, 7673.568848], [1299.55686, 3130.279891, 6472.149414, 7670.550293], [1276.215414, 3138.236577, 6472.687988, 7669.811035], [1252.871543, 3146.196617, 6473.588379, 7668.518066], [1229.525013, 3154.160349, 6474.665527, 7665.548828], [1207.031093, 3161.961148, 6354.945313, 7782.62207], [1184.537174, 3169.761947, 6354.480469, 7781.107422], [1162.043254, 3177.562746, 6354.079102, 7779.839844], [1139.549334, 3185.363545, 6353.707031, 7778.733398], [1117.055414, 3193.164344, 6353.354004, 7777.762695], [1094.561495, 3200.965143, 6353.024902, 7776.917969], [1072.067575, 3208.765942, 6352.716309, 7776.15918], [1049.573655, 3216.566741, 6352.427246, 7775.493164], [1027.079735, 3224.36754, 6352.155273, 7774.908203], [1004.585815, 3232.168339, 6351.90625, 7774.392578], [982.0918957, 3239.969138, 6351.678223, 7773.94043], [959.5979759, 3247.769937, 6351.478027, 7773.546875], [937.1040561, 3255.570736, 6351.291504, 7773.199219], [914.6101363, 3263.371535, 6351.128906, 7772.897461], [892.1162166, 3271.172334, 6350.977539, 7772.636719], [869.6222968, 3278.973133, 6350.849121, 7772.416992], [847.128377, 3286.773932, 6350.738281, 7772.230469], [824.6344573, 3294.574731, 6350.646484, 7772.068359], [802.1405375, 3302.37553, 6350.573242, 7771.941406], [779.6466177, 3310.176329, 6350.507324, 7771.850586], [757.152698, 3317.977128, 6350.456055, 7771.780273], [734.6587782, 3325.777927, 6350.424316, 7771.727539], [712.1648584, 3333.578726, 6350.407227, 7771.701172], [2134.568268, 2816.562639, 6377.875977, 7790.452148], [2114.267161, 2823.356135, 6377.922852, 7790.498047], [2093.966054, 2830.149632, 6377.999023, 7790.586914], [2073.664947, 2836.943128, 6378.106445, 7790.702148], [2053.36384, 2843.736625, 6378.245117, 7790.851563], [2033.062734, 2850.530121, 6378.427734, 7791.023438], [2012.761627, 2857.323618, 6378.646973, 7791.191406], [1992.46052, 2864.117114, 6378.928223, 7791.319336], [1972.159413, 2870.910611, 6496.945801, 7673.654297], [1948.560613, 2879.198416, 6496.598633, 7674.782715], [1924.962738, 2887.485002, 6496.05957, 7676.64209], [1901.365757, 2895.770462, 6495.216309, 7678.263184], [1877.769567, 2904.054853, 6494.272461, 7678.559082], [1854.174118, 2912.338308, 6493.187988, 7679.622559], [1830.579324, 2920.620899, 6491.95752, 7681.13916], [1806.985107, 2928.90275, 6490.031738, 7686.645996], [1783.391388, 2937.183956, 6487.953613, 7693.093262], [1759.798089, 2945.464627, 6486.256836, 7697.93457], [1736.205152, 2953.744848, 6484.441895, 7704.254395], [1712.612518, 2962.024694, 6483.171875, 7709.351074], [1689.020135, 2970.304232, 6481.948242, 7713.391602], [1665.427951, 2978.583521, 6480.843262, 7716.901855], [1641.835918, 2986.862625, 6479.572754, 7721.821289], [1618.243982, 2995.141605, 6477.503906, 7723.112793], [1594.652092, 3003.420524, 6475.847656, 7725.621094], [1571.323843, 3011.360705, 6475.019531, 7722.07959], [1547.995481, 3019.300978, 6474.632813, 7722.341797], [1524.6669, 3027.241439, 6473.526855, 7723.275391], [1501.337968, 3035.182198, 6471.642578, 7726.530273], [1478.008577, 3043.123373, 6469.471191, 7724.687988], [1454.678583, 3051.065104, 6469.672852, 7721.647461], [1431.347869, 3059.007539, 6469.119141, 7719.762207], [1408.016252, 3066.950918, 6468.969238, 7713.056641], [1384.683604, 3074.895487, 6469.020996, 7703.167969], [1361.349647, 3082.841676, 6469.143066, 7691.071289], [1338.014205, 3090.789788, 6469.23584, 7676.37793], [1314.676939, 3098.740336, 6469.483887, 7669.183105], [1291.337742, 3106.693531, 6469.87793, 7666.08252], [1267.996253, 3114.649953, 6470.643555, 7665.103027], [1244.652411, 3122.609753, 6471.500977, 7664.691895], [1222.127415, 3130.415799, 6352.926758, 7782.53418], [1199.602418, 3138.221845, 6352.975098, 7781.009766], [1177.077422, 3146.02789, 6352.821289, 7779.602539], [1154.552426, 3153.833936, 6352.601563, 7778.327148], [1132.027429, 3161.639982, 6352.356445, 7777.196289], [1109.502433, 3169.446028, 6352.104004, 7776.196289], [1086.977436, 3177.252073, 6351.859375, 7775.318359], [1064.45244, 3185.058119, 6351.61377, 7774.545898], [1041.927443, 3192.864165, 6351.379395, 7773.865234], [1019.402447, 3200.67021, 6351.15332, 7773.270508], [996.8774504, 3208.476256, 6350.945801, 7772.745117], [974.352454, 3216.282302, 6350.755371, 7772.291016], [951.8274575, 3224.088347, 6350.586914, 7771.897461], [929.3024611, 3231.894393, 6350.430664, 7771.55957], [906.7774646, 3239.700439, 6350.286621, 7771.266602], [884.2524682, 3247.506484, 6350.161133, 7771.008789], [861.7274718, 3255.31253, 6350.048828, 7770.794922], [839.2024753, 3263.118576, 6349.95166, 7770.618164], [816.6774789, 3270.924621, 6349.872559, 7770.473633], [794.1524824, 3278.730667, 6349.804688, 7770.349609], [771.627486, 3286.536713, 6349.750977, 7770.256836], [749.1024895, 3294.342759, 6349.713867, 7770.200195], [726.5774931, 3302.148804, 6349.680664, 7770.158203], [704.0524966, 3309.95485, 6349.66748, 7770.130859], [2126.416553, 2792.947722, 6376.862793, 7788.063477], [2106.107171, 2799.744931, 6376.911133, 7788.119141], [2085.797788, 2806.542139, 6376.993164, 7788.208984], [2065.488405, 2813.339348, 6377.104004, 7788.339844], [2045.179023, 2820.136557, 6377.246582, 7788.513672], [2024.86964, 2826.933765, 6377.419922, 7788.736328], [2004.560258, 2833.730974, 6377.617188, 7789.00293], [1984.250875, 2840.528183, 6377.830566, 7789.307617], [1963.941493, 2847.325392, 6495.693359, 7671.958008], [1940.34261, 2855.613286, 6495.243164, 7673.791992], [1916.744719, 2863.899972, 6494.401367, 7675.347168], [1893.14766, 2872.185549, 6493.471191, 7676.742188], [1869.551469, 2880.470028, 6492.463379, 7676.625977], [1845.955975, 2888.753561, 6491.400391, 7675.588867], [1822.361154, 2897.036225, 6489.939453, 7677.193848], [1798.766882, 2905.318169, 6488.118164, 7680.866211], [1775.173116, 2913.599475, 6486.42334, 7686.326172], [1751.579771, 2921.880245, 6484.856934, 7693.396973], [1727.986798, 2930.160549, 6483.263184, 7700.561523], [1704.394131, 2938.440473, 6481.749512, 7706.20752], [1680.801712, 2946.720084, 6480.362305, 7709.328125], [1657.209487, 2954.999454, 6479.710938, 7711.840332], [1633.617408, 2963.278644, 6478.466309, 7716.120605], [1610.025427, 2971.557712, 6476.181641, 7717.799316], [1586.433494, 2979.836718, 6474.143066, 7718.983398], [1563.105203, 2987.776716, 6473.712402, 7717.125488], [1539.7768, 2995.716806, 6473.337402, 7716.469727], [1516.448175, 3003.657074, 6471.87793, 7720.578613], [1493.119211, 3011.597618, 6470.12207, 7717.901855], [1469.789799, 3019.538553, 6468.995605, 7722.221191], [1446.459798, 3027.480048, 6468.252441, 7720.828613], [1423.129064, 3035.422278, 6467.804199, 7717.399902], [1399.797405, 3043.365503, 6467.432129, 7712.105469], [1376.464681, 3051.309938, 6467.018555, 7701.354004], [1353.130663, 3059.255946, 6466.92334, 7688.641602], [1329.79518, 3067.203815, 6466.957031, 7677.152832], [1306.457933, 3075.154102, 6467.220703, 7669.439453], [1283.118716, 3083.107122, 6467.594238, 7664.647949], [1259.777189, 3091.063438, 6468.562988, 7662.680664], [1236.433236, 3099.023115, 6469.436035, 7661.697266], [1213.911269, 3106.827881, 6350.973145, 7780.476563], [1191.389302, 3114.632647, 6351.204102, 7779.288086], [1168.867335, 3122.437413, 6351.228027, 7777.951172], [1146.345368, 3130.242179, 6351.145508, 7776.676758], [1123.823401, 3138.046945, 6351.014648, 7775.525391], [1101.301434, 3145.851711, 6350.848633, 7774.509766], [1078.779467, 3153.656478, 6350.679199, 7773.615234], [1056.2575, 3161.461244, 6350.496094, 7772.84082], [1033.735533, 3169.26601, 6350.315918, 7772.154297], [1011.213566, 3177.070776, 6350.141113, 7771.557617], [988.6915995, 3184.875542, 6349.975586, 7771.037109], [966.1696325, 3192.680308, 6349.820801, 7770.59375], [943.6476655, 3200.485074, 6349.680664, 7770.204102], [921.1256986, 3208.28984, 6349.55127, 7769.871094], [898.6037316, 3216.094606, 6349.435059, 7769.585938], [876.0817646, 3223.899372, 6349.32959, 7769.345703], [853.5597976, 3231.704138, 6349.233887, 7769.138672], [831.0378306, 3239.508904, 6349.155273, 7768.979492], [808.5158636, 3247.31367, 6349.083008, 7768.84082], [785.9938967, 3255.118436, 6349.025879, 7768.725586], [763.4719297, 3262.923202, 6348.98291, 7768.644531], [740.9499627, 3270.727968, 6348.952148, 7768.592773], [718.4279957, 3278.532734, 6348.934082, 7768.560547], [695.9060287, 3286.3375, 6348.922363, 7768.541016], [2118.26483, 2769.332814, 6375.818359, 7785.643555], [2097.947163, 2776.133743, 6375.865234, 7785.697266], [2077.629496, 2782.934673, 6375.950684, 7785.792969], [2057.311829, 2789.735602, 6376.068359, 7785.929688], [2036.994162, 2796.536532, 6376.21875, 7786.12793], [2016.676495, 2803.337461, 6376.392578, 7786.400391], [1996.358828, 2810.138391, 6376.570313, 7786.777344], [1976.041161, 2816.93932, 6376.715332, 7787.319336], [1955.723494, 2823.74025, 6494.34375, 7670.529297], [1932.124621, 2832.028244, 6493.809082, 7672.276367], [1908.52667, 2840.315015, 6492.862305, 7673.658691], [1884.929612, 2848.600657, 6491.930176, 7674.413086], [1861.333346, 2856.885227, 6490.75, 7673.816895], [1837.73782, 2865.16886, 6489.649414, 7672.433594], [1814.142946, 2873.451626, 6487.905762, 7672.685547], [1790.54865, 2881.733649, 6486.084473, 7672.019043], [1766.954852, 2890.015026, 6484.498047, 7680.737305], [1743.361471, 2898.295866, 6483.094727, 7687.21582], [1719.768452, 2906.576256, 6481.741211, 7695.633789], [1696.175737, 2914.856268, 6479.92334, 7701.530273], [1672.583272, 2923.13597, 6478.904297, 7705.65918], [1648.991005, 2931.415422, 6478.659668, 7706.82373], [1625.398889, 2939.694689, 6477.359375, 7710.654297], [1601.806868, 2947.973831, 6475.449219, 7712.008789], [1578.214896, 2956.252912, 6473.43457, 7714.960449], [1554.886581, 2964.192691, 6472.668457, 7713.943359], [1531.558153, 2972.132563, 6471.864746, 7712.469727], [1508.229507, 2980.072627, 6470.458984, 7712.957031], [1484.900509, 2988.01299, 6469.053223, 7716.137695], [1461.57105, 2995.95377, 6467.333984, 7718.999023], [1438.240988, 3003.895108, 6466.632813, 7715.8125], [1414.910205, 3011.837147, 6466.038574, 7713.770508], [1391.578518, 3019.780136, 6465.468262, 7708.183594], [1368.245798, 3027.724318, 6465.104004, 7699.350098], [1344.911767, 3035.670127, 6464.84668, 7685.984375], [1321.576252, 3043.617861, 6464.87793, 7677.825195], [1298.238911, 3051.568038, 6465.039063, 7670.166504], [1274.899639, 3059.520865, 6465.599121, 7665.01709], [1251.558072, 3067.476924, 6466.465332, 7662.4375], [1228.214151, 3075.436366, 6467.464844, 7661.119629], [1204.867506, 3083.399632, 6468.688965, 7660.030762], [1182.383053, 3091.196465, 6349.642578, 7777.712891], [1159.898599, 3098.993299, 6349.729492, 7776.242188], [1137.414146, 3106.790133, 6349.745605, 7774.893555], [1114.929692, 3114.586966, 6349.697266, 7773.714844], [1092.445239, 3122.3838, 6349.611328, 7772.69043], [1069.960785, 3130.180633, 6349.505371, 7771.803711], [1047.476332, 3137.977467, 6349.37793, 7771.029297], [1024.991879, 3145.7743, 6349.251953, 7770.358398], [1002.507425, 3153.571134, 6349.123047, 7769.772461], [980.0229717, 3161.367967, 6348.995117, 7769.262695], [957.5385182, 3169.164801, 6348.877441, 7768.826172], [935.0540648, 3176.961635, 6348.768066, 7768.452148], [912.5696113, 3184.758468, 6348.66748, 7768.134766], [890.0851579, 3192.555302, 6348.572266, 7767.868164], [867.6007044, 3200.352135, 6348.480469, 7767.635742], [845.1162509, 3208.148969, 6348.408203, 7767.451172], [822.6317975, 3215.945802, 6348.346191, 7767.302734], [800.147344, 3223.742636, 6348.290527, 7767.1875], [777.6628906, 3231.539469, 6348.238281, 7767.083984], [755.1784371, 3239.336303, 6348.205566, 7767.004883], [732.6939837, 3247.133136, 6348.186523, 7766.961914], [710.2095302, 3254.92997, 6348.171875, 7766.939453], [687.7250768, 3262.726804, 6348.16748, 7766.927734], [2110.113113, 2745.717909, 6374.73291, 7783.191406], [2089.787167, 2752.522564, 6374.783691, 7783.239258], [2069.461221, 2759.327218, 6374.870117, 7783.329102], [2049.135275, 2766.131872, 6374.995117, 7783.466797], [2028.809329, 2772.936527, 6375.165039, 7783.664063], [2008.483383, 2779.741181, 6375.353516, 7783.952148], [1988.157437, 2786.545835, 6375.54834, 7784.378906], [1967.831491, 2793.35049, 6375.717773, 7785.064453], [1947.505545, 2800.155144, 6493.335938, 7668.700195], [1923.906591, 2808.443221, 6492.525879, 7670.48291], [1900.308629, 2816.730087, 6491.416992, 7671.293945], [1876.711495, 2825.01584, 6490.330078, 7671.305664], [1853.115228, 2833.300493, 6489.10498, 7671.24707], [1829.51966, 2841.584197, 6487.819336, 7669.10498], [1805.924763, 2849.86703, 6485.960449, 7668.05957], [1782.330413, 2858.14914, 6484.210938, 7670.924316], [1758.736568, 2866.430608, 6482.82373, 7675.73584], [1735.143144, 2874.711541, 6481.442383, 7682.53125], [1711.550093, 2882.992005, 6480.159668, 7690.382813], [1687.957345, 2891.272087, 6478.563477, 7697.089355], [1664.364844, 2899.551855, 6477.744629, 7700.175293], [1640.772537, 2907.83138, 6477.375, 7702.052246], [1617.180377, 2916.110723, 6476.201172, 7703.604492], [1593.588313, 2924.389946, 6474.67041, 7705.826172], [1569.996298, 2932.669106, 6473.331543, 7708.012695], [1546.667943, 2940.608713, 6472.258789, 7711.313477], [1523.339477, 2948.54841, 6470.989746, 7708.779785], [1500.010787, 2956.488286, 6469.515625, 7710.166504], [1476.681758, 2964.42844, 6467.730957, 7715.995605], [1453.352282, 2972.368987, 6466.168945, 7713.882324], [1430.022214, 2980.310094, 6464.986328, 7711.973145], [1406.691412, 2988.251941, 6464.365234, 7709.748047], [1383.359684, 2996.194785, 6463.706543, 7704.307129], [1360.026891, 3004.138842, 6463.081543, 7697.618164], [1336.692801, 3012.084475, 6462.815918, 7688.07666], [1313.357246, 3020.031973, 6462.81543, 7679.119141], [1290.019925, 3027.981893, 6462.884277, 7671.303223], [1266.680633, 3035.934551, 6463.714355, 7666.113281], [1243.339029, 3043.890509, 6464.648438, 7662.719727], [1219.995, 3051.849835, 6465.685547, 7660.402344], [1196.648304, 3059.812864, 6466.846191, 7658.937012], [1174.167008, 3067.60837, 6348.075195, 7776.161133], [1151.685711, 3075.403876, 6348.301758, 7774.397461], [1129.204415, 3083.199382, 6348.38916, 7772.948242], [1106.723118, 3090.994888, 6348.413086, 7771.741211], [1084.241821, 3098.790394, 6348.390625, 7770.730469], [1061.760525, 3106.5859, 6348.339844, 7769.866211], [1039.279228, 3114.381406, 6348.265137, 7769.119141], [1016.797931, 3122.176912, 6348.186035, 7768.472656], [994.3166346, 3129.972418, 6348.100098, 7767.90625], [971.835338, 3137.767924, 6348.010254, 7767.419922], [949.3540413, 3145.56343, 6347.924805, 7767.003906], [926.8727447, 3153.358936, 6347.842773, 7766.648438], [904.391448, 3161.154442, 6347.769043, 7766.345703], [881.9101514, 3168.949948, 6347.701172, 7766.097656], [859.4288547, 3176.745454, 6347.633789, 7765.896484], [836.9475581, 3184.54096, 6347.572266, 7765.731445], [814.4662614, 3192.336466, 6347.524414, 7765.600586], [791.9849648, 3200.131972, 6347.481934, 7765.500977], [769.5036681, 3207.927478, 6347.448242, 7765.416992], [747.0223715, 3215.722984, 6347.419434, 7765.353516], [724.5410748, 3223.51849, 6347.402832, 7765.31543], [702.0597782, 3231.313996, 6347.399414, 7765.295898], [679.5784815, 3239.109502, 6347.397461, 7765.293945], [2101.961385, 2722.103012, 6373.610352, 7780.700195], [2081.62715, 2728.911399, 6373.657715, 7780.741211], [2061.292915, 2735.719785, 6373.755371, 7780.820313], [2040.95868, 2742.528172, 6373.895996, 7780.935547], [2020.624445, 2749.336558, 6374.085449, 7781.111328], [2000.290209, 2756.144945, 6374.310547, 7781.362305], [1979.955974, 2762.953331, 6374.555176, 7781.727539], [1959.621739, 2769.761718, 6374.812988, 7782.314453], [1939.287504, 2776.570104, 6492.415039, 7666.009766], [1915.688562, 2784.858275, 6491.479004, 7667.349121], [1892.090542, 2793.14522, 6490.419922, 7668.695313], [1868.493413, 2801.431032, 6489.109375, 7667.862305], [1844.897076, 2809.715771, 6487.70752, 7666.787109], [1821.301477, 2817.999569, 6486.001465, 7665.326172], [1797.70653, 2826.282497, 6484.187012, 7664.693359], [1774.11216, 2834.564681, 6482.583496, 7667.111816], [1750.518286, 2842.846215, 6481.299805, 7672.772949], [1726.924828, 2851.12721, 6480.01709, 7677.477539], [1703.331733, 2859.407753, 6478.647461, 7683.786133], [1679.738939, 2867.687916, 6477.455566, 7689.500977], [1656.146395, 2875.967768, 6476.780273, 7693.666504], [1632.554049, 2884.247369, 6476.17334, 7695.85498], [1608.961853, 2892.526784, 6474.787109, 7695.44873], [1585.369752, 2900.806073, 6473.722168, 7698.598633], [1561.7777, 2909.0853, 6472.632813, 7699.195801], [1538.449321, 2917.024696, 6471.551758, 7702.988281], [1515.12083, 2924.964184, 6469.563965, 7706.532715], [1491.79212, 2932.903863, 6467.455566, 7707.962402], [1468.463056, 2940.843841, 6465.797363, 7710.880371], [1445.133532, 2948.784238, 6463.560547, 7709.158691], [1421.803404, 2956.725197, 6463.064453, 7708.080566], [1398.472553, 2964.666861, 6462.519531, 7704.855957], [1375.140798, 2972.609478, 6461.877441, 7700.994141], [1351.808008, 2980.553288, 6461.096191, 7695.510254], [1328.473907, 2988.498729, 6460.763672, 7687.106445], [1305.13832, 2996.446096, 6460.660645, 7678.94043], [1281.800905, 3004.395911, 6460.833008, 7672.128906], [1258.461558, 3012.34838, 6461.791016, 7666.625], [1235.119914, 3020.304088, 6462.831543, 7662.832031], [1211.775915, 3028.263183, 6463.964355, 7660.122559], [1188.429191, 3036.226107, 6465.112793, 7658.55127], [1165.951048, 3044.020285, 6346.727051, 7774.384766], [1143.472904, 3051.814463, 6347.005371, 7772.250977], [1120.994761, 3059.608641, 6347.120117, 7770.742188], [1098.516617, 3067.402819, 6347.17334, 7769.581055], [1076.038474, 3075.196997, 6347.193359, 7768.625], [1053.56033, 3082.991175, 6347.184082, 7767.811523], [1031.082187, 3090.785353, 6347.162109, 7767.110352], [1008.604043, 3098.579531, 6347.124512, 7766.496094], [986.1258996, 3106.373709, 6347.074707, 7765.967773], [963.647756, 3114.167887, 6347.027344, 7765.508789], [941.1696125, 3121.962065, 6346.975586, 7765.117188], [918.6914689, 3129.756243, 6346.921387, 7764.789063], [896.2133254, 3137.550421, 6346.871094, 7764.513672], [873.7351819, 3145.344599, 6346.827148, 7764.290039], [851.2570383, 3153.138777, 6346.778809, 7764.113281], [828.7788948, 3160.932955, 6346.734863, 7763.970703], [806.3007512, 3168.727133, 6346.699219, 7763.866211], [783.8226077, 3176.521311, 6346.668457, 7763.786133], [761.3444641, 3184.315489, 6346.647461, 7763.725586], [738.8663206, 3192.109667, 6346.631836, 7763.680664], [716.3881771, 3199.903845, 6346.621094, 7763.655273], [693.9100335, 3207.698023, 6346.620605, 7763.649414], [671.43189, 3215.492201, 6346.62207, 7763.640625], [2093.809661, 2698.488117, 6372.424316, 7778.168945], [2073.467141, 2705.300238, 6372.485352, 7778.210938], [2053.12462, 2712.112359, 6372.596191, 7778.273438], [2032.782099, 2718.92448, 6372.760254, 7778.364258], [2012.439579, 2725.7366, 6372.979004, 7778.490234], [1992.097058, 2732.548721, 6373.248535, 7778.65332], [1971.754537, 2739.360842, 6373.556152, 7778.858398], [1951.412017, 2746.172963, 6373.914063, 7779.111328], [1931.069496, 2752.985084, 6491.40625, 7662.338379], [1907.470479, 2761.273334, 6490.435059, 7663.152344], [1883.87245, 2769.560368, 6489.412109, 7663.569824], [1860.27525, 2777.846288, 6488.007324, 7663.427246], [1836.678917, 2786.131104, 6486.602051, 7661.833984], [1813.08328, 2794.414968, 6484.812988, 7661.913574], [1789.488313, 2802.697957, 6482.84082, 7662.263672], [1765.893892, 2810.980222, 6481.347656, 7664.022949], [1742.299976, 2819.261842, 6479.97998, 7668.291992], [1718.706478, 2827.542924, 6478.739746, 7672.530273], [1695.113352, 2835.823535, 6477.544434, 7676.071777], [1671.520529, 2844.103763, 6476.620605, 7682.844238], [1647.927954, 2852.383676, 6475.866211, 7685.724609], [1624.335571, 2860.663344, 6474.980469, 7686.371582], [1600.743334, 2868.942829, 6474.101563, 7687.330566], [1577.151194, 2877.222193, 6473.037598, 7690.556641], [1553.559102, 2885.501494, 6471.015137, 7692.139648], [1530.230682, 2893.440723, 6468.994629, 7700.962402], [1506.90215, 2901.380043, 6467.04541, 7706.578613], [1483.573395, 2909.319542, 6464.81543, 7705.660645], [1460.2443, 2917.25932, 6461.94043, 7707.165527], [1436.914757, 2925.199494, 6459.199707, 7706.108887], [1413.584621, 2933.140228, 6460.095703, 7704.401855], [1390.253751, 2941.081704, 6460.419922, 7700.956543], [1366.921953, 2949.024179, 6459.546875, 7697.216797], [1343.589088, 2956.96787, 6458.942383, 7691.556152], [1320.254927, 2964.913139, 6458.640137, 7684.742188], [1296.919298, 2972.860276, 6458.567871, 7676.916016], [1273.581902, 2980.809841, 6458.933594, 7669.347168], [1250.242535, 2988.762145, 6459.776855, 7664.299805], [1226.900854, 2996.717756, 6460.863281, 7660.101074], [1203.556746, 3004.676736, 6462.063477, 7657.102539], [1180.209972, 3012.639424, 6463.341797, 7654.776855], [1156.860571, 3020.605653, 6464.82959, 7652.471191], [1134.423603, 3028.390962, 6345.869629, 7769.46582], [1111.986635, 3036.17627, 6345.898926, 7768.202148], [1089.549667, 3043.961579, 6345.961914, 7767.204102], [1067.112699, 3051.746887, 6346.016602, 7766.373047], [1044.675731, 3059.532196, 6346.052734, 7765.646484], [1022.238763, 3067.317504, 6346.067871, 7765.007813], [999.8017951, 3075.102813, 6346.067383, 7764.446289], [977.3648272, 3082.888121, 6346.063965, 7763.958008], [954.9278593, 3090.67343, 6346.047852, 7763.530273], [932.4908913, 3098.458738, 6346.023926, 7763.173828], [910.0539234, 3106.244047, 6345.998535, 7762.874023], [887.6169554, 3114.029356, 6345.975098, 7762.631836], [865.1799875, 3121.814664, 6345.950195, 7762.441406], [842.7430195, 3129.599973, 6345.922852, 7762.291016], [820.3060516, 3137.385281, 6345.891602, 7762.18457], [797.8690836, 3145.17059, 6345.869141, 7762.106445], [775.4321157, 3152.955898, 6345.855469, 7762.052734], [752.9951477, 3160.741207, 6345.842773, 7762.013672], [730.5581798, 3168.526515, 6345.839355, 7761.995117], [708.1212118, 3176.311824, 6345.833008, 7761.988281], [685.6842439, 3184.097132, 6345.833496, 7761.979492], [663.2472759, 3191.882441, 6345.840332, 7761.983398], [2085.657926, 2674.873228, 6371.192871, 7775.610352], [2065.307108, 2681.689088, 6371.259766, 7775.643555], [2044.95629, 2688.504949, 6371.382324, 7775.699219], [2024.605472, 2695.32081, 6371.575195, 7775.761719], [2004.254654, 2702.13667, 6371.825195, 7775.84082], [1983.903836, 2708.952531, 6372.146484, 7775.918945], [1963.553018, 2715.768391, 6372.523926, 7775.946289], [1943.2022, 2722.584252, 6372.973633, 7775.84375], [1922.851382, 2729.400112, 6490.322754, 7658.630371], [1899.252381, 2737.688453, 6489.397461, 7659.04248], [1875.654301, 2745.975563, 6488.244629, 7659.355957], [1852.057112, 2754.261538, 6486.861328, 7659.027344], [1828.460711, 2762.546436, 6485.357422, 7658.421387], [1804.865048, 2770.830389, 6483.561523, 7657.969238], [1781.270036, 2779.11347, 6481.760254, 7658.913574], [1757.675599, 2787.395803, 6480.396484, 7660.253418], [1734.081657, 2795.677485, 6479.039063, 7663.815918], [1710.488132, 2803.958624, 6477.806152, 7667.742188], [1686.894966, 2812.23931, 6476.560547, 7671.42334], [1663.302102, 2820.519615, 6475.546875, 7675.671875], [1639.709487, 2828.799607, 6474.655762, 7677.711426], [1616.117069, 2837.079345, 6473.746582, 7678.071289], [1592.524801, 2845.358898, 6472.368164, 7679.020996], [1568.932629, 2853.638324, 6470.506348, 7685.552246], [1545.340504, 2861.917688, 6468.405762, 7690.038086], [1522.012057, 2869.856711, 6466.066406, 7697.663574], [1498.683498, 2877.795827, 6463.740723, 7703.425293], [1475.354718, 2885.735137, 6461.354004, 7705.663574], [1452.025587, 2893.674749, 6458.751953, 7704.940918], [1428.695993, 2901.614778, 6456.286133, 7703.787598], [1405.365794, 2909.55537, 6456.879395, 7701.117188], [1382.034872, 2917.496666, 6458.12207, 7697.770996], [1358.703043, 2925.438918, 6457.296387, 7693.213867], [1335.370179, 2933.382366, 6456.493652, 7687.541016], [1312.036004, 2941.327447, 6456.211426, 7681.237305], [1288.70034, 2949.274459, 6456.158203, 7673.559082], [1265.36285, 2957.223922, 6456.863281, 7665.818848], [1242.023425, 2965.176042, 6457.789551, 7659.804199], [1218.681703, 2973.131403, 6458.88916, 7654.891602], [1195.337623, 2981.090155, 6460.053711, 7653.070313], [1171.990819, 2989.05274, 6461.410156, 7650.460938], [1148.641344, 2997.018884, 6462.888672, 7648.54834], [1126.207671, 3004.802808, 6344.505371, 7766.178711], [1103.773999, 3012.586731, 6344.643066, 7765.384766], [1081.340326, 3020.370654, 6344.756836, 7764.670898], [1058.906653, 3028.154577, 6344.853027, 7764.006836], [1036.47298, 3035.938501, 6344.927734, 7763.391602], [1014.039307, 3043.722424, 6344.987305, 7762.828125], [991.6056346, 3051.506347, 6345.024902, 7762.316406], [969.1719618, 3059.290271, 6345.054688, 7761.875], [946.7382889, 3067.074194, 6345.070801, 7761.486328], [924.3046161, 3074.858117, 6345.075684, 7761.166992], [901.8709433, 3082.642041, 6345.078125, 7760.90625], [879.4372705, 3090.425964, 6345.080566, 7760.704102], [857.0035977, 3098.209887, 6345.072754, 7760.556641], [834.5699249, 3105.993811, 6345.062988, 7760.44043], [812.1362521, 3113.777734, 6345.053711, 7760.366211], [789.7025792, 3121.561657, 6345.044434, 7760.327148], [767.2689064, 3129.34558, 6345.037109, 7760.306641], [744.8352336, 3137.129504, 6345.033691, 7760.295898], [722.4015608, 3144.913427, 6345.037598, 7760.298828], [699.967888, 3152.69735, 6345.039551, 7760.304688], [677.5342152, 3160.481274, 6345.04248, 7760.3125], [655.1005423, 3168.265197, 6345.048828, 7760.316406], [2077.506192, 2651.258339, 6369.902832, 7773.026367], [2057.14708, 2658.07794, 6369.975586, 7773.056641], [2036.787967, 2664.897541, 6370.116699, 7773.099609], [2016.428854, 2671.717142, 6370.328125, 7773.155273], [1996.069741, 2678.536743, 6370.612305, 7773.206055], [1975.710628, 2685.356344, 6370.971191, 7773.229492], [1955.351515, 2692.175945, 6371.415527, 7773.160156], [1934.992403, 2698.995546, 6371.964844, 7772.847656], [1914.63329, 2705.815147, 6489.237793, 7655.358398], [1891.034218, 2714.103562, 6488.324707, 7655.284668], [1867.436135, 2722.390759, 6487.159668, 7655.356445], [1843.838879, 2730.676838, 6485.866211, 7655.222656], [1820.242488, 2738.961809, 6484.117188, 7654.589355], [1796.646792, 2747.245824, 6482.207031, 7654.777344], [1773.051765, 2755.528963, 6480.674316, 7655.787109], [1749.457283, 2763.811374, 6479.398438, 7657.952148], [1725.863304, 2772.093138, 6478.126953, 7660.953125], [1702.269743, 2780.374362, 6476.855957, 7664.241699], [1678.676554, 2788.655113, 6475.652832, 7667.505859], [1655.083666, 2796.935478, 6474.673828, 7669.906738], [1631.491025, 2805.215527, 6473.725098, 7670.509277], [1607.898575, 2813.495331, 6471.851563, 7671.416016], [1584.306271, 2821.77495, 6470.111328, 7673.303711], [1560.714065, 2830.054447, 6467.579102, 7679.171387], [1537.121906, 2838.333882, 6464.981445, 7690.265137], [1513.793414, 2846.272745, 6462.635742, 7693.303223], [1490.464809, 2854.2117, 6460.246094, 7699.584961], [1467.135981, 2862.150834, 6457.92627, 7704.077148], [1443.806813, 2870.090248, 6455.415527, 7703.887207], [1420.477194, 2878.030056, 6453.870605, 7703.255371], [1397.146984, 2885.970429, 6453.340332, 7699.866211], [1373.816038, 2893.911545, 6453.956543, 7695.429688], [1350.484164, 2901.853659, 6453.685059, 7690.319824], [1327.151222, 2909.796993, 6453.816895, 7684.098633], [1303.816982, 2917.741906, 6453.813477, 7676.931152], [1280.481275, 2925.68869, 6453.834961, 7669.117676], [1257.143799, 2933.637904, 6454.656738, 7660.024902], [1233.804351, 2941.589861, 6455.563965, 7654.069824], [1210.462589, 2949.545127, 6456.702637, 7650.679688], [1187.118398, 2957.503767, 6457.950195, 7647.944824], [1163.77154, 2965.466118, 6459.432617, 7645.981445], [1140.422054, 2973.432013, 6460.935547, 7644.787109], [1117.991679, 2981.214556, 6343.194824, 7762.743164], [1095.561304, 2988.997098, 6343.409668, 7762.488281], [1073.130929, 2996.779641, 6343.568848, 7762.081055], [1050.700554, 3004.562183, 6343.703125, 7761.589844], [1028.270179, 3012.344726, 6343.825684, 7761.081055], [1005.839804, 3020.127268, 6343.916504, 7760.589844], [983.4094295, 3027.909811, 6343.994141, 7760.130859], [960.9790546, 3035.692353, 6344.055176, 7759.723633], [938.5486797, 3043.474896, 6344.104492, 7759.382813], [916.1183048, 3051.257438, 6344.138672, 7759.099609], [893.6879299, 3059.039981, 6344.166016, 7758.882813], [871.257555, 3066.822524, 6344.186523, 7758.720703], [848.8271801, 3074.605066, 6344.200195, 7758.621094], [826.3968052, 3082.387609, 6344.209961, 7758.552734], [803.9664303, 3090.170151, 6344.216309, 7758.523438], [781.5360554, 3097.952694, 6344.21582, 7758.524414], [759.1056805, 3105.735236, 6344.223145, 7758.537109], [736.6753056, 3113.517779, 6344.230469, 7758.566406], [714.2449307, 3121.300321, 6344.236816, 7758.591797], [691.8145558, 3129.082864, 6344.243652, 7758.621094], [669.3841809, 3136.865406, 6344.253418, 7758.643555], [646.953806, 3144.647949, 6344.257813, 7758.652344], [2069.354446, 2627.643454, 6368.553223, 7770.419922], [2048.987025, 2634.466799, 6368.630371, 7770.452148], [2028.619604, 2641.290145, 6368.78418, 7770.491211], [2008.252183, 2648.11349, 6369.006348, 7770.541016], [1987.884762, 2654.936835, 6369.315918, 7770.594727], [1967.517342, 2661.76018, 6369.709473, 7770.633789], [1947.149921, 2668.583525, 6370.209473, 7770.609375], [1926.7825, 2675.406871, 6370.818359, 7770.416016], [1906.415079, 2682.230216, 6488.097168, 7653.33252], [1882.81603, 2690.518719, 6487.111328, 7652.847168], [1859.2179, 2698.805988, 6485.921387, 7652.317871], [1835.620661, 2707.092119, 6484.689453, 7651.617676], [1812.024209, 2715.37717, 6482.8125, 7651.343262], [1788.428494, 2723.661272, 6480.845703, 7652.07373], [1764.833427, 2731.944499, 6479.414063, 7653.493652], [1741.238935, 2740.226975, 6477.979004, 7656.166016], [1717.644937, 2748.508799, 6476.771973, 7657.98877], [1694.051354, 2756.790078, 6475.621582, 7660.553223], [1670.458131, 2765.0709, 6474.804688, 7663.447754], [1646.865208, 2773.35134, 6474.213379, 7665.244629], [1623.272533, 2781.631467, 6472.891113, 7665.63916], [1599.680055, 2789.911338, 6470.616211, 7664.145996], [1576.087727, 2798.191023, 6468.012207, 7668.823242], [1552.495494, 2806.470581, 6464.880371, 7674.197754], [1528.903308, 2814.750076, 6461.485352, 7682.375488], [1505.574783, 2822.68874, 6459.007324, 7690.510742], [1482.246145, 2830.627496, 6456.607422, 7698.794434], [1458.917287, 2838.566444, 6454.508301, 7706.608887], [1435.588076, 2846.505693, 6452.05957, 7703.066895], [1412.258403, 2854.445361, 6450.706543, 7701.203125], [1388.928123, 2862.385594, 6450.266602, 7697.78125], [1365.59712, 2870.326535, 6450.410645, 7692.869629], [1342.265211, 2878.268432, 6450.606934, 7687.41748], [1318.932266, 2886.211525, 6450.667969, 7679.947754], [1295.598007, 2894.156253, 6450.689941, 7672.216309], [1272.26226, 2902.102913, 6451.268555, 7664.432129], [1248.924685, 2910.052026, 6452.273438, 7657.628418], [1225.585176, 2918.003799, 6453.374512, 7651.134277], [1202.243368, 2925.958817, 6454.519531, 7646.255859], [1178.899203, 2933.91723, 6455.771973, 7643.688477], [1155.55231, 2941.879479, 6457.223145, 7642.768066], [1132.202748, 2949.845291, 6458.788574, 7641.686035], [1108.850397, 2957.814611, 6460.377441, 7641.069336], [1086.465379, 2965.587213, 6342.234375, 7759.741211], [1064.08036, 2973.359815, 6342.398438, 7759.571289], [1041.695342, 2981.132418, 6342.580566, 7759.198242], [1019.310324, 2988.90502, 6342.73584, 7758.759766], [996.9253052, 2996.677622, 6342.868652, 7758.30957], [974.5402868, 3004.450225, 6342.976563, 7757.890625], [952.1552685, 3012.222827, 6343.070801, 7757.516602], [929.7702501, 3019.995429, 6343.145996, 7757.207031], [907.3852317, 3027.768032, 6343.209473, 7756.96875], [885.0002133, 3035.540634, 6343.258301, 7756.800781], [862.6151949, 3043.313236, 6343.301758, 7756.693359], [840.2301765, 3051.085839, 6343.340332, 7756.640625], [817.8451581, 3058.858441, 6343.360352, 7756.637695], [795.4601397, 3066.631043, 6343.376465, 7756.657227], [773.0751214, 3074.403646, 6343.395996, 7756.701172], [750.690103, 3082.176248, 6343.40918, 7756.767578], [728.3050846, 3089.94885, 6343.425293, 7756.827148], [705.9200662, 3097.721453, 6343.441406, 7756.887695], [683.5350478, 3105.494055, 6343.452148, 7756.944336], [661.1500294, 3113.266657, 6343.460449, 7756.977539], [638.765011, 3121.03926, 6343.462402, 7757.000977], [2061.202701, 2604.028568, 6367.137695, 7767.791016], [2040.826973, 2610.855657, 6367.213379, 7767.81543], [2020.451245, 2617.682745, 6367.365723, 7767.857422], [2000.075518, 2624.509834, 6367.608887, 7767.915039], [1979.69979, 2631.336922, 6367.925781, 7767.989258], [1959.324062, 2638.164011, 6368.345215, 7768.092773], [1938.948335, 2644.991099, 6368.875977, 7768.216797], [1918.572607, 2651.818188, 6369.540527, 7768.331055], [1898.19688, 2658.645276, 6486.861328, 7651.861816], [1874.597767, 2666.933851, 6485.780762, 7651.178711], [1850.999641, 2675.221206, 6484.541992, 7649.744141], [1827.402341, 2683.507438, 6483.092285, 7648.996582], [1803.805905, 2691.792559, 6481.138672, 7648.652832], [1780.210163, 2700.076722, 6479.257324, 7649.61084], [1756.615089, 2708.360005, 6477.855469, 7650.967285], [1733.020558, 2716.642558, 6476.436035, 7653.003418], [1709.426529, 2724.924462, 6475.183594, 7655.17627], [1685.832918, 2733.205822, 6473.921387, 7657.218262], [1662.239677, 2741.486709, 6473.223633, 7659.289551], [1638.646737, 2749.767208, 6472.784668, 7661.105469], [1615.054043, 2758.04739, 6470.952637, 7661.925781], [1591.461541, 2766.327326, 6468.833984, 7662.678223], [1567.869183, 2774.607077, 6465.277832, 7665.739746], [1544.276923, 2782.886705, 6461.18457, 7669.740723], [1520.68471, 2791.16627, 6458.03125, 7678.847656], [1497.356132, 2799.104776, 6454.661621, 7686.992188], [1474.027442, 2807.043373, 6453.036133, 7688.294922], [1450.698529, 2814.98215, 6451.012695, 7702.577637], [1427.369275, 2822.921208, 6448.995117, 7700.060547], [1404.039571, 2830.860661, 6447.394043, 7698.314453], [1380.709274, 2838.800678, 6446.798828, 7694.623047], [1357.378241, 2846.741436, 6447.126465, 7688.677734], [1334.04628, 2854.683197, 6447.390625, 7682.084473], [1310.71325, 2862.626176, 6447.5, 7674.724609], [1287.378923, 2870.570738, 6447.596191, 7666.761719], [1264.043126, 2878.517171, 6448.540527, 7659.146973], [1240.705562, 2886.466037, 6449.579102, 7654.59375], [1217.366025, 2894.417648, 6450.775879, 7646.86377], [1194.024172, 2902.372571, 6452.077637, 7643.777832], [1170.679891, 2910.330872, 6453.526367, 7641.138184], [1147.332942, 2918.292886, 6455.049316, 7640.538574], [1123.983365, 2926.258449, 6456.626465, 7640.328125], [1100.63103, 2934.227618, 6458.313965, 7640.543945], [1078.249463, 2941.998782, 6340.812988, 7757.765625], [1055.867896, 2949.769946, 6341.206543, 7757.258789], [1033.486329, 2957.541111, 6341.476563, 7756.866211], [1011.104762, 2965.312275, 6341.674316, 7756.443359], [988.7231946, 2973.083439, 6341.835449, 7756.008789], [966.3416275, 2980.854604, 6341.969727, 7755.594727], [943.9600604, 2988.625768, 6342.089844, 7755.240234], [921.5784933, 2996.396932, 6342.20459, 7754.960938], [899.1969263, 3004.168097, 6342.294434, 7754.771484], [876.8153592, 3011.939261, 6342.374023, 7754.658203], [854.4337921, 3019.710425, 6342.431152, 7754.615234], [832.052225, 3027.48159, 6342.48291, 7754.631836], [809.6706579, 3035.252754, 6342.522461, 7754.685547], [787.2890908, 3043.023918, 6342.552734, 7754.771484], [764.9075238, 3050.795082, 6342.576172, 7754.875977], [742.5259567, 3058.566247, 6342.60498, 7754.987305], [720.1443896, 3066.337411, 6342.623047, 7755.097656], [697.7628225, 3074.108575, 6342.64209, 7755.191406], [675.3812554, 3081.87974, 6342.657715, 7755.270508], [652.9996884, 3089.650904, 6342.668945, 7755.331055], [630.6181213, 3097.422068, 6342.669434, 7755.360352], [2053.050942, 2580.413685, 6365.641602, 7765.138672], [2032.666893, 2587.244519, 6365.715332, 7765.155273], [2012.282845, 2594.075353, 6365.871094, 7765.191406], [1991.898797, 2600.906187, 6366.11377, 7765.253906], [1971.514749, 2607.737021, 6366.445313, 7765.360352], [1951.130701, 2614.567855, 6366.874023, 7765.533203], [1930.746653, 2621.398689, 6367.409668, 7765.828125], [1910.362604, 2628.229523, 6368.091797, 7766.325195], [1889.978556, 2635.060358, 6485.476563, 7650.663086], [1866.379472, 2643.34902, 6484.307617, 7649.90332], [1842.781306, 2651.636445, 6483.008789, 7649.314941], [1819.184029, 2659.922727, 6481.265625, 7647.589844], [1795.587539, 2668.207926, 6479.316895, 7646.819336], [1771.991784, 2676.492175, 6477.597656, 7647.108398], [1748.396678, 2684.775546, 6476.056641, 7648.101563], [1724.802144, 2693.058162, 6474.645996, 7649.966797], [1701.208103, 2701.340124, 6473.397949, 7651.590332], [1677.614477, 2709.62154, 6472.135254, 7653.078613], [1654.021209, 2717.902497, 6471.68457, 7655.202637], [1630.428242, 2726.183071, 6470.841797, 7657.069336], [1606.835521, 2734.46333, 6468.664551, 7659.586914], [1583.242998, 2742.743333, 6466.336426, 7660.915527], [1559.650623, 2751.02315, 6461.940918, 7663.789063], [1536.058343, 2759.302838, 6457.803223, 7669.007813], [1512.466113, 2767.582464, 6452.166992, 7675.347168], [1489.137493, 2775.520772, 6447.604004, 7680.883301], [1465.808763, 2783.459173, 6447.998047, 7685.993164], [1442.479812, 2791.397768, 6447.786621, 7691.37207], [1419.150508, 2799.336664, 6446.033691, 7694.095215], [1395.820741, 2807.275981, 6444.414063, 7693.470215], [1372.490368, 2815.215859, 6443.533691, 7689.839355], [1349.159272, 2823.156444, 6443.80957, 7683.411621], [1325.827268, 2831.097985, 6444.041016, 7675.588379], [1302.494229, 2839.040725, 6444.329102, 7668.030762], [1279.159876, 2846.985102, 6444.827148, 7659.910156], [1255.824035, 2854.931412, 6445.862305, 7652.866699], [1232.486366, 2862.880178, 6446.937988, 7647.303223], [1209.146762, 2870.831606, 6448.287598, 7642.96875], [1185.80486, 2878.78628, 6449.624512, 7640.548828], [1162.460599, 2886.744352, 6451.152832, 7638.890137], [1139.113612, 2894.706264, 6452.722656, 7638.666016], [1115.763954, 2902.671742, 6454.474121, 7638.785645], [1092.411506, 2910.640733, 6456.156738, 7638.291992], [1069.056524, 2918.612789, 6457.679199, 7637.32373], [1046.724933, 2926.372875, 6340.146484, 7754.847656], [1024.393342, 2934.132962, 6340.442383, 7754.55957], [1002.061752, 2941.893048, 6340.645508, 7754.139648], [979.7301607, 2949.653135, 6340.814453, 7753.675781], [957.3985698, 2957.413221, 6340.975098, 7753.240234], [935.0669789, 2965.173307, 6341.132813, 7752.884766], [912.735388, 2972.933394, 6341.274902, 7752.633789], [890.4037972, 2980.69348, 6341.396484, 7752.487305], [868.0722063, 2988.453567, 6341.495117, 7752.44043], [845.7406154, 2996.213653, 6341.576172, 7752.473633], [823.4090245, 3003.973739, 6341.63916, 7752.571289], [801.0774337, 3011.733826, 6341.692383, 7752.710938], [778.7458428, 3019.493912, 6341.732422, 7752.871094], [756.4142519, 3027.253999, 6341.77002, 7753.043945], [734.082661, 3035.014085, 6341.797852, 7753.214844], [711.7510701, 3042.774171, 6341.82373, 7753.374023], [689.4194793, 3050.534258, 6341.846191, 7753.506836], [667.0878884, 3058.294344, 6341.860352, 7753.62207], [644.7562975, 3066.054431, 6341.875977, 7753.702148], [622.4247066, 3073.814517, 6341.880859, 7753.75], [2044.899183, 2556.798799, 6364.0625, 7762.461914], [2024.506815, 2563.633376, 6364.135254, 7762.467773], [2004.114447, 2570.467954, 6364.293457, 7762.494141], [1983.722079, 2577.302531, 6364.538086, 7762.545898], [1963.32971, 2584.137109, 6364.870117, 7762.661133], [1942.937342, 2590.971686, 6365.29248, 7762.857422], [1922.544974, 2597.806264, 6365.802734, 7763.236328], [1902.152606, 2604.640841, 6366.466309, 7763.958008], [1881.760238, 2611.475419, 6483.961426, 7648.946777], [1858.161096, 2619.764152, 6482.617188, 7648.494629], [1834.562941, 2628.05166, 6481.266602, 7647.925781], [1810.96561, 2636.338043, 6479.294922, 7646.085938], [1787.369143, 2644.623313, 6477.294434, 7644.77832], [1763.773369, 2652.907621, 6475.701172, 7644.630371], [1740.178261, 2661.191047, 6474.136719, 7645.385742], [1716.583696, 2669.47374, 6472.651367, 7646.680176], [1692.989633, 2677.755783, 6471.246582, 7647.875977], [1669.395986, 2686.03728, 6470.147949, 7648.673828], [1645.802708, 2694.318302, 6469.443848, 7649.540527], [1622.209731, 2702.598936, 6468.171387, 7653.185547], [1598.616999, 2710.879251, 6466.133789, 7655.727051], [1575.024459, 2719.159319, 6463.477051, 7658.331543], [1551.432064, 2727.439202, 6459.541992, 7661.669922], [1527.839765, 2735.718962, 6455.061035, 7667.571289], [1504.247515, 2743.998659, 6449.286133, 7670.730469], [1480.918835, 2751.936811, 6444.5625, 7678.379395], [1457.590044, 2759.875056, 6444.633789, 7682.489258], [1434.261029, 2767.81348, 6444.512207, 7684.467285], [1410.931673, 2775.752184, 6443.049316, 7687.554199], [1387.601868, 2783.691283, 6441.483887, 7688.311035], [1364.27147, 2791.630946, 6440.754883, 7683.115723], [1340.940336, 2799.571353, 6440.782227, 7676.296875], [1317.608274, 2807.512761, 6441.089355, 7667.650391], [1294.275144, 2815.455388, 6441.428711, 7658.862305], [1270.940716, 2823.399598, 6442.192871, 7650.182617], [1247.604819, 2831.34568, 6443.248535, 7642.535645], [1224.267154, 2839.294197, 6444.4375, 7639.860352], [1200.927516, 2847.245462, 6445.792969, 7637.521484], [1177.585564, 2855.200041, 6447.228027, 7637.171387], [1154.241182, 2863.158001, 6448.833496, 7636.723145], [1130.894133, 2871.119679, 6450.469238, 7636.927734], [1107.544455, 2879.084906, 6452.273926, 7637.092285], [1084.19202, 2887.053743, 6454.004883, 7636.864258], [1060.836961, 2895.02575, 6455.579102, 7635.411621], [1037.47949, 2903.000429, 6456.973145, 7634.523926], [1015.202999, 2910.748207, 6339.492188, 7752.382813], [992.9265085, 2918.495984, 6339.652344, 7751.884766], [970.6500178, 2926.243761, 6339.79834, 7751.30957], [948.3735272, 2933.991538, 6339.982422, 7750.802734], [926.0970366, 2941.739316, 6340.187012, 7750.425781], [903.820546, 2949.487093, 6340.368164, 7750.200195], [881.5440554, 2957.23487, 6340.518066, 7750.107422], [859.2675648, 2964.982647, 6340.63623, 7750.149414], [836.9910741, 2972.730425, 6340.733887, 7750.272461], [814.7145835, 2980.478202, 6340.8125, 7750.47168], [792.4380929, 2988.225979, 6340.873535, 7750.708984], [770.1616023, 2995.973756, 6340.92627, 7750.963867], [747.8851117, 3003.721534, 6340.964355, 7751.220703], [725.608621, 3011.469311, 6341, 7751.457031], [703.3321304, 3019.217088, 6341.028809, 7751.674805], [681.0556398, 3026.964865, 6341.054199, 7751.859375], [658.7791492, 3034.712643, 6341.070313, 7752.00293], [636.5026586, 3042.46042, 6341.084473, 7752.107422], [614.2261679, 3050.208197, 6341.089844, 7752.163086], [2036.42757, 2533.328964, 6362.400879, 7759.774414], [2015.707028, 2540.312336, 6362.470215, 7759.770508], [1994.986485, 2547.295708, 6362.633789, 7759.774414], [1974.265942, 2554.27908, 6362.879395, 7759.803711], [1953.545399, 2561.262451, 6363.203125, 7759.870117], [1932.824857, 2568.245823, 6363.609375, 7760.016602], [1912.104314, 2575.229195, 6364.057617, 7760.304688], [1891.383771, 2582.212567, 6364.508301, 7760.835938], [1870.663229, 2589.195939, 6364.792969, 7761.731445], [1849.942686, 2596.179311, 6480.845215, 7646.330078], [1826.344497, 2604.46689, 6479.23291, 7645.544434], [1802.747196, 2612.753323, 6477.236328, 7643.72168], [1779.150681, 2621.03867, 6475.31543, 7642.291016], [1755.554902, 2629.323063, 6473.645508, 7642.088379], [1731.959769, 2637.606576, 6472.003906, 7642.395508], [1708.365209, 2645.889335, 6470.573242, 7642.749023], [1684.771142, 2654.171435, 6468.973145, 7643.306152], [1661.177488, 2662.452988, 6468.105469, 7644.277832], [1637.584192, 2670.734082, 6467.227539, 7646.036621], [1613.991195, 2679.014792, 6465.651367, 7648.503906], [1590.398445, 2687.295184, 6464.013184, 7652.503418], [1566.805892, 2695.575322, 6460.400879, 7654.60791], [1543.213487, 2703.855272, 6456.688965, 7658.319336], [1519.621178, 2712.135094, 6451.913086, 7663.734375], [1496.028917, 2720.414853, 6446.428223, 7663.342773], [1472.700187, 2728.352809, 6443.400391, 7675.600586], [1449.371347, 2736.290859, 6441.93457, 7678.356934], [1426.042286, 2744.2291, 6440.567383, 7676.260742], [1402.712871, 2752.167641, 6439.365723, 7677.543457], [1379.382995, 2760.106603, 6438.378418, 7679.907715], [1356.052514, 2768.046129, 6438.130859, 7674.531738], [1332.721308, 2775.986363, 6437.82373, 7667.109375], [1309.389197, 2783.927553, 6438.252441, 7657.659668], [1286.056049, 2791.86994, 6438.720215, 7648.454102], [1262.72159, 2799.813964, 6439.699219, 7642.35791], [1239.385641, 2807.759922, 6440.722656, 7637.468262], [1216.047865, 2815.708337, 6441.973145, 7634.075195], [1192.708154, 2823.659417, 6443.307617, 7633.107422], [1169.366145, 2831.613746, 6444.836426, 7634.005371], [1146.02178, 2839.571476, 6446.478516, 7634.905273], [1122.674688, 2847.533051, 6448.250977, 7634.753906], [1099.324925, 2855.498194, 6450.078125, 7634.674805], [1075.972371, 2863.46685, 6451.820313, 7634.132324], [1052.617284, 2871.438574, 6453.391602, 7633.497559], [1029.259812, 2879.413086, 6454.889648, 7632.674316], [1005.900305, 2887.390051, 6456.341797, 7633.117188], [983.684828, 2895.124119, 6338.677246, 7749.708984], [961.4693508, 2902.858187, 6338.737793, 7748.874023], [939.2538737, 2910.592256, 6338.976563, 7748.236328], [917.0383965, 2918.326324, 6339.251465, 7747.817383], [894.8229193, 2926.060392, 6339.490234, 7747.62207], [872.6074421, 2933.79446, 6339.672852, 7747.614258], [850.391965, 2941.528528, 6339.814941, 7747.754883], [828.1764878, 2949.262596, 6339.919434, 7748.013672], [805.9610106, 2956.996664, 6340.001953, 7748.335938], [783.7455334, 2964.730732, 6340.069336, 7748.694336], [761.5300563, 2972.4648, 6340.121582, 7749.058594], [739.3145791, 2980.198868, 6340.175293, 7749.407227], [717.0991019, 2987.932937, 6340.208496, 7749.728516], [694.8836247, 2995.667005, 6340.240723, 7750.012695], [672.6681476, 3003.401073, 6340.261719, 7750.245117], [650.4526704, 3011.135141, 6340.285645, 7750.431641], [628.2371932, 3018.869209, 6340.298828, 7750.557617], [606.0217161, 3026.603277, 6340.304688, 7750.619141], [2028.276626, 2509.713709, 6360.650391, 7757.092773], [2007.548578, 2516.700456, 6360.725098, 7757.074219], [1986.82053, 2523.687202, 6360.889648, 7757.042969], [1966.092482, 2530.673949, 6361.139648, 7757.021484], [1945.364434, 2537.660696, 6361.473145, 7757.010742], [1924.636386, 2544.647442, 6361.87207, 7757.036133], [1903.908338, 2551.634189, 6362.3125, 7757.138672], [1883.18029, 2558.620935, 6362.714355, 7757.360352], [1862.452242, 2565.607682, 6362.914063, 7757.771484], [1841.724194, 2572.594428, 6478.98584, 7642.221191], [1818.126022, 2580.88209, 6477.117188, 7640.77832], [1794.528676, 2589.168623, 6474.97168, 7639.794434], [1770.932191, 2597.45404, 6472.987793, 7638.072266], [1747.336399, 2605.738494, 6471.335449, 7638.083008], [1723.741272, 2614.022063, 6469.744629, 7638.418945], [1700.14669, 2622.304898, 6468.141113, 7638.796387], [1676.552606, 2630.58708, 6466.793945, 7638.998047], [1652.95894, 2638.868716, 6465.700684, 7639.621094], [1629.365642, 2647.149875, 6464.507324, 7641.534668], [1605.772644, 2655.430646, 6463.168945, 7644.039063], [1582.17989, 2663.711097, 6461.522949, 7647.125], [1558.587329, 2671.991301, 6457.51709, 7650.429199], [1534.994912, 2680.27132, 6453.495117, 7654.465332], [1511.402591, 2688.551215, 6447.724121, 7661.166016], [1487.810319, 2696.831047, 6440.967285, 7666.293945], [1464.48152, 2704.768847, 6439.010742, 7675.179199], [1441.152609, 2712.706739, 6437.736816, 7678.541504], [1417.823476, 2720.64481, 6436.617188, 7676.845703], [1394.494002, 2728.583162, 6435.409668, 7670.504883], [1371.164079, 2736.521907, 6434.760742, 7675.272461], [1347.833564, 2744.461218, 6434.625977, 7665.836426], [1324.502314, 2752.40127, 6434.834473, 7657.404297], [1301.170136, 2760.342323, 6435.4375, 7649.183105], [1277.836889, 2768.284595, 6436.226563, 7641.395996], [1254.502347, 2776.228451, 6437.271484, 7633.872559], [1231.166337, 2784.174182, 6438.350098, 7631.760254], [1207.828558, 2792.122348, 6439.653809, 7631.87207], [1184.488809, 2800.073263, 6440.95752, 7631.359375], [1161.146744, 2808.027496, 6442.472168, 7631.569824], [1137.802251, 2815.985112, 6444.143066, 7631.905273], [1114.455091, 2823.946448, 6446.016602, 7632.208496], [1091.105304, 2831.911339, 6447.89209, 7632.361816], [1067.752759, 2839.879842, 6449.601563, 7631.86377], [1044.39759, 2847.851519, 6451.214355, 7631.849121], [1021.040009, 2855.825868, 6452.776367, 7631.401855], [997.6804187, 2863.802563, 6454.25, 7630.283691], [974.3191232, 2871.781183, 6455.120117, 7629.823242], [952.1715497, 2879.499935, 6337.499023, 7746.220703], [930.0239762, 2887.218687, 6337.926758, 7745.449219], [907.8764027, 2894.937438, 6338.353516, 7744.987305], [885.7288292, 2902.65619, 6338.666504, 7744.848633], [863.5812558, 2910.374942, 6338.872559, 7744.967773], [841.4336823, 2918.093694, 6339.018555, 7745.263672], [819.2861088, 2925.812446, 6339.125, 7745.681641], [797.1385353, 2933.531198, 6339.20752, 7746.163086], [774.9909618, 2941.249949, 6339.27832, 7746.670898], [752.8433883, 2948.968701, 6339.336426, 7747.166992], [730.6958148, 2956.687453, 6339.38623, 7747.631836], [708.5482413, 2964.406205, 6339.420898, 7748.043945], [686.4006679, 2972.124957, 6339.45459, 7748.399414], [664.2530944, 2979.843709, 6339.482422, 7748.689453], [642.1055209, 2987.56246, 6339.502441, 7748.912109], [619.9579474, 2995.281212, 6339.516602, 7749.056641], [597.8103739, 3002.999964, 6339.517578, 7749.134766], [2020.125679, 2486.098457, 6358.810547, 7754.427734], [1999.390123, 2493.08858, 6358.89209, 7754.387695], [1978.654566, 2500.078704, 6359.060547, 7754.319336], [1957.91901, 2507.068827, 6359.325684, 7754.229492], [1937.183453, 2514.05895, 6359.674316, 7754.116211], [1916.447896, 2521.049074, 6360.098633, 7753.995117], [1895.71234, 2528.039197, 6360.600586, 7753.855469], [1874.976783, 2535.02932, 6361.116211, 7753.688477], [1854.241227, 2542.019444, 6361.489746, 7753.446289], [1833.50567, 2549.009567, 6477.024902, 7637.075195], [1809.907472, 2557.297299, 6474.705078, 7635.66748], [1786.310161, 2565.583882, 6472.584473, 7634.14502], [1762.713636, 2573.869377, 6470.708008, 7633.328125], [1739.117846, 2582.153916, 6468.915527, 7633.488281], [1715.522702, 2590.437574, 6467.315918, 7633.87207], [1691.928131, 2598.720474, 6465.613281, 7634.527832], [1668.334051, 2607.002716, 6464.223633, 7634.600098], [1644.740385, 2615.284409, 6462.978516, 7635.789551], [1621.147076, 2623.565642, 6461.628418, 7637.12207], [1597.554066, 2631.846491, 6460.216309, 7640.020996], [1573.961304, 2640.127022, 6457.67041, 7643.518066], [1550.368737, 2648.407298, 6453.879883, 7646.558105], [1526.776319, 2656.687384, 6449.379883, 7651.796387], [1503.183996, 2664.967344, 6441.739746, 7658.956543], [1479.591721, 2673.247241, 6435.606445, 7664.702637], [1456.262863, 2681.184842, 6434.386719, 7672.028809], [1432.933895, 2689.122538, 6433.172363, 7679.607422], [1409.604707, 2697.060426, 6432.419922, 7678.676758], [1386.275167, 2704.998615, 6431.298828, 7669.907227], [1362.945165, 2712.937224, 6431.282715, 7666.852539], [1339.614558, 2720.876394, 6431.313965, 7656.201172], [1316.283228, 2728.816271, 6431.737793, 7648.67627], [1292.950992, 2736.757103, 6432.285645, 7639.069336], [1269.617722, 2744.699135, 6433.509766, 7634.532227], [1246.28314, 2752.642803, 6434.751953, 7632.050293], [1222.947072, 2760.588408, 6435.974121, 7629.879883], [1199.609176, 2768.536471, 6437.32666, 7629.524414], [1176.269346, 2776.4872, 6438.674805, 7628.973633], [1152.927221, 2784.441181, 6440.089355, 7628.964844], [1129.582738, 2792.398566, 6441.769043, 7628.90918], [1106.23553, 2800.359797, 6443.635742, 7629.344727], [1082.885651, 2808.324601, 6445.57666, 7629.479492], [1059.532984, 2816.292923, 6447.339844, 7629.487305], [1036.177784, 2824.264317, 6449.038086, 7629.551758], [1012.820198, 2832.238499, 6450.595703, 7629.069336], [989.460578, 2840.215136, 6452.109863, 7628.352051], [966.0991542, 2848.19363, 6452.951172, 7627.234863], [942.7360686, 2856.17404, 6452.983887, 7625.980469], [920.6644977, 2863.875572, 6336.869629, 7742.341797], [898.5929267, 2871.577104, 6337.57959, 7741.841797], [876.5213557, 2879.278636, 6337.942871, 7741.829102], [854.4497847, 2886.980169, 6338.139648, 7742.138672], [832.3782137, 2894.681701, 6338.265625, 7742.652344], [810.3066428, 2902.383233, 6338.355469, 7743.288086], [788.2350718, 2910.084765, 6338.432617, 7743.97168], [766.1635008, 2917.786297, 6338.502441, 7744.660156], [744.0919298, 2925.487829, 6338.555664, 7745.314453], [722.0203588, 2933.189362, 6338.608887, 7745.905273], [699.9487879, 2940.890894, 6338.64502, 7746.418945], [677.8772169, 2948.592426, 6338.679199, 7746.857422], [655.8056459, 2956.293958, 6338.70459, 7747.200195], [633.7340749, 2963.99549, 6338.724121, 7747.462891], [611.6625039, 2971.697022, 6338.73877, 7747.629883], [589.590933, 2979.398555, 6338.744141, 7747.712891], [2012.292068, 2462.33925, 6356.884277, 7751.793945], [1991.866338, 2469.188796, 6356.970215, 7751.733398], [1971.440608, 2476.038342, 6357.146484, 7751.626953], [1951.014879, 2482.887887, 6357.418457, 7751.461914], [1930.589149, 2489.737433, 6357.790039, 7751.24707], [1910.163419, 2496.586979, 6358.260742, 7750.967773], [1889.737689, 2503.436525, 6358.867676, 7750.608398], [1869.311959, 2510.286071, 6359.668457, 7750.097656], [1848.88623, 2517.135616, 6476.599121, 7633.548828], [1825.287068, 2525.424662, 6474.738281, 7632.245117], [1801.688894, 2533.712476, 6472.284668, 7629.542969], [1778.091543, 2541.99916, 6470.179688, 7628.819824], [1754.495055, 2550.284725, 6468.269043, 7628.422852], [1730.899258, 2558.569326, 6466.47168, 7628.656738], [1707.304128, 2566.85304, 6464.6875, 7629.246094], [1683.70954, 2575.136019, 6462.970703, 7629.891113], [1660.115453, 2583.418344, 6461.550781, 7630.197754], [1636.521781, 2591.700121, 6460.052246, 7631.175293], [1612.928478, 2599.981423, 6458.16748, 7633.51123], [1589.335475, 2608.262334, 6456.958008, 7636.71875], [1565.742717, 2616.542926, 6454.093262, 7640.505371], [1542.15015, 2624.82327, 6450.665039, 7644.096191], [1518.557727, 2633.103428, 6445.224121, 7650.053223], [1494.965401, 2641.383463, 6438.34668, 7657.803711], [1471.373123, 2649.663435, 6431.751953, 7664.375977], [1448.044188, 2657.60088, 6429.689941, 7674.568359], [1424.715142, 2665.538417, 6428.570801, 7679.803223], [1401.385874, 2673.476132, 6428.045898, 7674.674316], [1378.056265, 2681.414127, 6427.425781, 7660.713867], [1354.726208, 2689.352515, 6428.285645, 7652.223633], [1331.39556, 2697.291468, 6429.177734, 7645.946777], [1308.064178, 2705.231163, 6428.503418, 7639.956543], [1284.731869, 2713.171859, 6429.083008, 7633.977051], [1261.398494, 2721.113775, 6430.69873, 7629.995117], [1238.063822, 2729.057273, 6432.187988, 7628.143066], [1214.727684, 2737.002647, 6433.500977, 7626.694824], [1191.38978, 2744.950458, 6434.841797, 7626.505371], [1168.049904, 2752.90102, 6436.187988, 7626.044922], [1144.707717, 2760.854903, 6437.701172, 7625.375488], [1121.363102, 2768.812173, 6439.410156, 7624.986816], [1098.015821, 2776.773167, 6441.242676, 7625.817871], [1074.665915, 2784.737717, 6443.091797, 7626.103516], [1051.313251, 2792.705883, 6444.899414, 7626.750977], [1027.957964, 2800.677226, 6446.666504, 7626.713379], [1004.600267, 2808.651245, 6448.297363, 7626.206543], [981.2405609, 2816.627611, 6449.86084, 7625.405762], [957.8791495, 2824.605902, 6450.531738, 7624.350098], [934.5160472, 2832.586267, 6450.930176, 7622.488281], [911.1519465, 2840.568247, 6453.170898, 7621.918945], [889.165945, 2848.250323, 6337.152344, 7738.205078], [867.1799436, 2855.932398, 6337.378906, 7738.46875], [845.1939422, 2863.614474, 6337.476563, 7739.099609], [823.2079407, 2871.29655, 6337.544434, 7739.924805], [801.2219393, 2878.978625, 6337.608887, 7740.84082], [779.2359379, 2886.660701, 6337.670898, 7741.77832], [757.2499364, 2894.342777, 6337.731934, 7742.686523], [735.263935, 2902.024852, 6337.785645, 7743.520508], [713.2779336, 2909.706928, 6337.833008, 7744.257813], [691.2919321, 2917.389004, 6337.873535, 7744.889648], [669.3059307, 2925.071079, 6337.90918, 7745.40332], [647.3199293, 2932.753155, 6337.936523, 7745.799805], [625.3339278, 2940.435231, 6337.956055, 7746.094727], [603.3479264, 2948.117306, 6337.969727, 7746.285156], [581.361925, 2955.799382, 6337.972656, 7746.370117], [2004.14027, 2438.724361, 6354.871582, 7749.213867], [1983.70618, 2445.577647, 6354.957031, 7749.142578], [1963.272091, 2452.430932, 6355.141602, 7748.988281], [1942.838002, 2459.284218, 6355.416016, 7748.757813], [1922.403912, 2466.137504, 6355.796875, 7748.443359], [1901.969823, 2472.99079, 6356.295898, 7748.03418], [1881.535733, 2479.844076, 6356.9375, 7747.511719], [1861.101644, 2486.697361, 6357.771484, 7746.845703], [1840.667554, 2493.550647, 6474.444824, 7630.391602], [1817.068441, 2501.839775, 6472.232422, 7628.11084], [1793.470245, 2510.12766, 6469.882813, 7625.504883], [1769.872937, 2518.414396, 6467.775391, 7623.916504], [1746.276414, 2526.700039, 6465.814941, 7623.122559], [1722.680626, 2534.984726, 6464.000488, 7623.689453], [1699.085485, 2543.26853, 6462.149902, 7624.58252], [1675.490915, 2551.551576, 6460.362793, 7625.633789], [1651.896838, 2559.833962, 6458.706543, 7626.759766], [1628.303175, 2568.115799, 6456.897461, 7628.002441], [1604.709869, 2576.397175, 6454.915039, 7629.563965], [1581.11686, 2584.678167, 6453.037109, 7633.084961], [1557.5241, 2592.958841, 6449.513672, 7638.324219], [1533.931536, 2601.239259, 6446.342773, 7642.763672], [1510.33912, 2609.519489, 6440.875488, 7649.170898], [1486.746798, 2617.79959, 6434.747559, 7656.955078], [1463.154525, 2626.079629, 6429.14502, 7663.060059], [1439.825524, 2634.016874, 6424.930176, 7668.175781], [1416.496413, 2641.954212, 6423.368164, 7677.312988], [1393.167082, 2649.89174, 6422.65625, 7661.224121], [1369.837399, 2657.829568, 6423.445801, 7651.714844], [1346.507256, 2665.767817, 6426.322754, 7646.14209], [1323.176509, 2673.706627, 6426.935547, 7635.666504], [1299.84504, 2681.646147, 6425.418945, 7631.755859], [1276.512667, 2689.58662, 6426.178223, 7627.706543], [1253.179261, 2697.528293, 6427.813477, 7624.717773], [1229.844544, 2705.471602, 6429.432129, 7623.879395], [1206.508341, 2713.416848, 6430.893555, 7623.474121], [1183.170314, 2721.364553, 6432.34668, 7623.418945], [1159.830354, 2729.314928, 6433.692871, 7622.437988], [1136.488099, 2737.268557, 6435.125488, 7621.652832], [1113.143488, 2745.225594, 6436.835449, 7621.688965], [1089.796154, 2753.186481, 6438.727539, 7622.019043], [1066.446152, 2761.150944, 6440.638672, 7622.706055], [1043.093362, 2769.118928, 6442.552734, 7623.618652], [1019.73804, 2777.089985, 6444.243652, 7623.898926], [996.3803354, 2785.063834, 6445.856934, 7623.580566], [973.0205967, 2793.040141, 6447.275391, 7623.13916], [949.6590561, 2801.018307, 6448.178711, 7622.035645], [926.2958537, 2808.99839, 6449.190918, 7620.452637], [902.9317558, 2816.980161, 6451.688477, 7618.693848], [879.566832, 2824.963847, 6453.716309, 7617.35498], [857.6778755, 2832.623779, 6336.937988, 7734.746094], [835.7889191, 2840.283711, 6336.842285, 7735.875], [813.8999626, 2847.943643, 6336.833008, 7737.108398], [792.0110062, 2855.603575, 6336.861328, 7738.374023], [770.1220497, 2863.263507, 6336.91748, 7739.617188], [748.2330932, 2870.923439, 6336.970215, 7740.782227], [726.3441368, 2878.583372, 6337.023438, 7741.825195], [704.4551803, 2886.243304, 6337.067871, 7742.727539], [682.5662239, 2893.903236, 6337.109375, 7743.46875], [660.6772674, 2901.563168, 6337.14209, 7744.05957], [638.7883109, 2909.2231, 6337.17041, 7744.505859], [616.8993545, 2916.883032, 6337.193359, 7744.827148], [595.010398, 2924.542964, 6337.203613, 7745.02832], [573.1214416, 2932.202896, 6337.210938, 7745.124023], [1995.988474, 2415.109468, 6352.768066, 7746.714844], [1975.546027, 2421.966491, 6352.853516, 7746.626953], [1955.10358, 2428.823513, 6353.03125, 7746.439453], [1934.661133, 2435.680535, 6353.311523, 7746.146484], [1914.218686, 2442.537558, 6353.687988, 7745.751953], [1893.776239, 2449.39458, 6354.18457, 7745.227539], [1873.333792, 2456.251603, 6354.817383, 7744.567383], [1852.891345, 2463.108625, 6355.625977, 7743.78125], [1832.448898, 2469.965647, 6472.179688, 7627.409668], [1808.849744, 2478.254847, 6469.708008, 7624.952148], [1785.251577, 2486.542815, 6467.300293, 7622.07959], [1761.654234, 2494.829651, 6465.139648, 7620.234375], [1738.057754, 2503.115366, 6463.246094, 7619.331543], [1714.461966, 2511.400116, 6461.37207, 7619.168457], [1690.866844, 2519.683976, 6459.499023, 7620.273438], [1667.272265, 2527.967102, 6457.631348, 7621.86377], [1643.678186, 2536.249572, 6455.705566, 7624.062012], [1620.084523, 2544.531496, 6453.738281, 7625.152344], [1596.49123, 2552.812942, 6451.556641, 7626.326172], [1572.898236, 2561.093999, 6448.954102, 7631.1875], [1549.305486, 2569.374735, 6445.127441, 7637.125], [1525.712927, 2577.655224, 6441.13623, 7641.413086], [1502.120513, 2585.935527, 6436.226074, 7647.739746], [1478.528196, 2594.215706, 6430.019531, 7654.205566], [1454.935927, 2602.495823, 6424.301758, 7655.583496], [1431.606842, 2610.432907, 6420.037598, 7655.101074], [1408.277647, 2618.370083, 6418.401367, 7651.570801], [1384.948228, 2626.307437, 6417.057617, 7642.140137], [1361.618471, 2634.24507, 6418.161133, 7642.136719], [1338.288267, 2642.183098, 6420.36377, 7643.695313], [1314.957472, 2650.121688, 6420.860352, 7629.86084], [1291.625944, 2658.06102, 6421.483398, 7623.307617], [1268.293491, 2666.001353, 6423.33252, 7621.297363], [1244.959973, 2673.942905, 6425.024902, 7618.466797], [1221.62516, 2681.886043, 6426.540527, 7618.470215], [1198.288883, 2689.831056, 6427.95166, 7620.569336], [1174.950841, 2697.778509, 6429.444824, 7619.802734], [1151.610831, 2705.728715, 6430.941895, 7619.402344], [1128.268509, 2713.682245, 6432.560059, 7618.984863], [1104.923761, 2721.639164, 6434.334473, 7619.113281], [1081.57635, 2729.599811, 6436.138672, 7619.102051], [1058.226315, 2737.564019, 6438.048828, 7620.460449], [1034.873525, 2745.531846, 6439.962891, 7621.248535], [1011.518114, 2753.502854, 6441.639648, 7621.436035], [988.1602945, 2761.476539, 6443.339355, 7621.226563], [964.8004676, 2769.452573, 6444.675781, 7620.908691], [941.4389374, 2777.430534, 6445.845215, 7620.39209], [918.0757179, 2785.410571, 6447.208496, 7618.461914], [894.7115007, 2793.392224, 6449.264648, 7616.703613], [871.3464573, 2801.37562, 6451.104004, 7615.033203], [847.9802145, 2809.36066, 6452.411133, 7614.695801], [826.202274, 2816.995198, 6336.116699, 7732.536133], [804.4243334, 2824.629737, 6336.084961, 7734.253906], [782.6463928, 2832.264275, 6336.100098, 7735.938477], [760.8684523, 2839.898814, 6336.147461, 7737.53418], [739.0905117, 2847.533352, 6336.206055, 7738.995117], [717.3125712, 2855.167891, 6336.26416, 7740.276367], [695.5346306, 2862.802429, 6336.311523, 7741.348633], [673.75669, 2870.436968, 6336.349609, 7742.206055], [651.9787495, 2878.071506, 6336.385254, 7742.859375], [630.2008089, 2885.706045, 6336.411133, 7743.34082], [608.4228683, 2893.340583, 6336.432617, 7743.671875], [586.6449278, 2900.975122, 6336.444824, 7743.881836], [564.8669872, 2908.609661, 6336.45459, 7743.981445], [1987.836666, 2391.494577, 6350.581055, 7744.325195], [1967.385849, 2398.355337, 6350.665039, 7744.214844], [1946.935032, 2405.216097, 6350.833008, 7743.99707], [1926.484216, 2412.076856, 6351.097168, 7743.665039], [1906.033399, 2418.937616, 6351.461426, 7743.194336], [1885.582582, 2425.798376, 6351.93457, 7742.557617], [1865.131766, 2432.659136, 6352.526855, 7741.75], [1844.680949, 2439.519896, 6353.258789, 7740.765625], [1824.230132, 2446.380656, 6469.56543, 7624.205566], [1800.631031, 2454.669941, 6467.126465, 7622.429688], [1777.032847, 2462.957979, 6464.719238, 7619.905762], [1753.435552, 2471.244865, 6462.624023, 7617.860352], [1729.839043, 2479.53066, 6460.600098, 7616.226074], [1706.243268, 2487.815496, 6458.67334, 7615.532715], [1682.64814, 2496.099449, 6456.711914, 7617.04248], [1659.053585, 2504.382643, 6454.682129, 7618.699219], [1635.459523, 2512.665175, 6452.588867, 7620.758301], [1611.865873, 2520.94716, 6449.733887, 7623.203125], [1588.272581, 2529.228683, 6447.132324, 7624.235352], [1564.679589, 2537.509821, 6444.831055, 7629.574707], [1541.086844, 2545.790642, 6441.585938, 7634.992676], [1517.494294, 2554.071206, 6436.672852, 7641.920898], [1493.901893, 2562.351583, 6431.359375, 7647.251465], [1470.309587, 2570.631831, 6425.256348, 7652.770508], [1446.717329, 2578.912017, 6418.715332, 7654.65332], [1423.388173, 2586.848896, 6414.929199, 7645.435059], [1400.058906, 2594.785869, 6412.64502, 7639.131836], [1376.729421, 2602.723035, 6411.816895, 7634.109863], [1353.399583, 2610.660501, 6412.844238, 7631.484375], [1330.069287, 2618.598385, 6414.509277, 7642.723633], [1306.738388, 2626.53683, 6416.550293, 7629.720703], [1283.406768, 2634.475982, 6418.563965, 7619.988281], [1260.074245, 2642.416087, 6420.438477, 7616.212402], [1236.74069, 2650.357394, 6422.160645, 7614.240723], [1213.405827, 2658.30034, 6423.56543, 7613.493164], [1190.069479, 2666.245224, 6425.01416, 7614.813965], [1166.731309, 2674.19257, 6426.394531, 7616.295898], [1143.391208, 2682.142587, 6427.76123, 7616.645508], [1120.048814, 2690.095861, 6429.660645, 7617.278809], [1096.704068, 2698.052545, 6431.650391, 7617.855957], [1073.356599, 2706.013084, 6433.512207, 7617.917969], [1050.006465, 2713.977203, 6435.445313, 7618.674316], [1026.653546, 2721.944846, 6437.287109, 7619.670898], [1003.298097, 2729.915568, 6438.955078, 7619.466797], [979.9402673, 2737.889083, 6440.560059, 7619.184082], [956.5804061, 2745.865056, 6441.855469, 7618.705078], [933.2187448, 2753.842892, 6443.343262, 7617.680176], [909.8554247, 2761.822644, 6445.11377, 7616.630859], [886.4912104, 2769.804088, 6446.877441, 7615.005859], [863.1261726, 2777.787447, 6448.405762, 7613.699219], [839.7598036, 2785.772366, 6449.904785, 7613.136719], [816.3920822, 2793.758357, 6451.500488, 7612.958496], [794.7423534, 2801.363528, 6335.279785, 7731.428711], [773.0926246, 2808.968698, 6335.305664, 7733.584961], [751.4428959, 2816.573868, 6335.372559, 7735.581055], [729.7931671, 2824.179038, 6335.454102, 7737.393555], [708.1434383, 2831.784208, 6335.513184, 7738.9375], [686.4937096, 2839.389378, 6335.55957, 7740.183594], [664.8439808, 2846.994549, 6335.59668, 7741.138672], [643.194252, 2854.599719, 6335.628906, 7741.835938], [621.5445233, 2862.204889, 6335.658203, 7742.319336], [599.8947945, 2869.810059, 6335.680664, 7742.647461], [578.2450657, 2877.415229, 6335.698242, 7742.842773], [556.595337, 2885.0204, 6335.708008, 7742.939453], [1979.684861, 2367.879682, 6348.311523, 7742.054688], [1959.225678, 2374.744177, 6348.388672, 7741.927734], [1938.766495, 2381.608671, 6348.546875, 7741.696289], [1918.307312, 2388.473166, 6348.788086, 7741.324219], [1897.848129, 2395.337661, 6349.124023, 7740.796875], [1877.388946, 2402.202155, 6349.556152, 7740.066406], [1856.929763, 2409.06665, 6350.103516, 7739.09668], [1836.47058, 2415.931145, 6350.765137, 7737.838867], [1816.011397, 2422.795639, 6466.920898, 7620.824219], [1792.412259, 2431.084994, 6464.453125, 7620.04834], [1768.814108, 2439.373115, 6462.083984, 7617.77002], [1745.216782, 2447.660103, 6459.899902, 7616.082031], [1721.62032, 2455.94597, 6457.816406, 7614.272949], [1698.024549, 2464.23087, 6455.858887, 7613.962402], [1674.429446, 2472.51488, 6453.793945, 7614.879883], [1650.834886, 2480.798154, 6451.598633, 7616.48291], [1627.240826, 2489.080774, 6449.166016, 7619.26416], [1603.647184, 2497.362846, 6446.100098, 7621.891113], [1580.05391, 2505.64444, 6443.22998, 7624.44043], [1556.460936, 2513.925644, 6441.032715, 7628.523926], [1532.868207, 2522.206529, 6437.929199, 7635.032227], [1509.275669, 2530.487166, 6431.636719, 7641.465332], [1485.683276, 2538.767618, 6425.273926, 7646.763184], [1462.09098, 2547.047946, 6420.265625, 7650.119629], [1438.498731, 2555.328211, 6413.809082, 7644.821777], [1415.169486, 2563.264927, 6409.504395, 7628.458496], [1391.840131, 2571.201735, 6407.109375, 7629.14209], [1368.510554, 2579.138721, 6406.640625, 7632.976563], [1345.180638, 2587.075985, 6407.143555, 7634.201172], [1321.850275, 2595.013643, 6410.178223, 7634.722168], [1298.519324, 2602.951865, 6413.210938, 7629.494141], [1275.18764, 2610.890829, 6415.096191, 7615.755859], [1251.855033, 2618.830794, 6417.445313, 7612.325684], [1228.521362, 2626.77198, 6419.178223, 7610.305664], [1205.186398, 2634.71475, 6420.513672, 7609.276367], [1181.849971, 2642.659399, 6421.958008, 7610.445313], [1158.511782, 2650.606488, 6423.445801, 7612.734375], [1135.171626, 2658.556334, 6424.702148, 7614.990234], [1111.829161, 2666.509508, 6426.789551, 7616.459961], [1088.484274, 2674.466074, 6428.946777, 7617.467773], [1065.136725, 2682.426371, 6430.90625, 7617.522949], [1041.786555, 2690.390233, 6432.955566, 7617.253906], [1018.433633, 2698.357719, 6434.711914, 7618.441895], [995.078093, 2706.328388, 6436.362305, 7618.374512], [971.7201467, 2714.301737, 6437.950684, 7617.530273], [948.3601964, 2722.277438, 6439.412598, 7616.205078], [924.9985451, 2730.255068, 6441.006836, 7615.041016], [901.6352068, 2738.234775, 6442.614746, 7614.536133], [878.2708738, 2746.216099, 6444.205078, 7612.591797], [854.9057168, 2754.199167, 6445.785645, 7611.945313], [831.5393635, 2762.18388, 6447.543457, 7611.442383], [808.1716373, 2770.169869, 6449.078125, 7611.594727], [784.803791, 2778.156376, 6450.583496, 7612.573242], [763.3036559, 2785.727257, 6334.47168, 7731.385742], [741.8035208, 2793.298137, 6334.579102, 7733.838867], [720.3033857, 2800.869017, 6334.716309, 7736.041016], [698.8032506, 2808.439898, 6334.776367, 7737.902344], [677.3031155, 2816.010778, 6334.817871, 7739.317383], [655.8029804, 2823.581659, 6334.848633, 7740.324219], [634.3028453, 2831.152539, 6334.883789, 7741.011719], [612.8027102, 2838.723419, 6334.912109, 7741.46582], [591.3025751, 2846.2943, 6334.9375, 7741.75], [569.80244, 2853.86518, 6334.958496, 7741.915039], [548.3023049, 2861.43606, 6334.971191, 7741.990234], [1971.533045, 2344.264789, 6345.975586, 7739.905273], [1951.065485, 2351.13302, 6346.044434, 7739.782227], [1930.597925, 2358.001251, 6346.181152, 7739.539063], [1910.130365, 2364.869482, 6346.385742, 7739.15332], [1889.662805, 2371.737712, 6346.678223, 7738.584961], [1869.195245, 2378.605943, 6347.061035, 7737.802734], [1848.727685, 2385.474174, 6347.555176, 7736.736328], [1828.260125, 2392.342405, 6348.174316, 7735.276367], [1807.792565, 2399.210636, 6464.319824, 7617.934082], [1784.193483, 2407.500075, 6461.764648, 7617.074219], [1760.595319, 2415.788266, 6459.433594, 7616.021484], [1736.998044, 2424.075306, 6457.156738, 7614.794434], [1713.401555, 2432.361251, 6455.069336, 7613.263672], [1689.805803, 2440.646239, 6453.047852, 7612.591797], [1666.210698, 2448.93034, 6450.833008, 7613.557617], [1642.616166, 2457.213685, 6448.555176, 7615.419922], [1619.022126, 2465.496367, 6445.171875, 7618.141602], [1595.428501, 2473.778501, 6441.394043, 7621.87793], [1571.835234, 2482.060174, 6439.722168, 7623.874512], [1548.242267, 2490.341461, 6438.92627, 7629.580078], [1524.649547, 2498.622431, 6435.161133, 7633.333008], [1501.057022, 2506.903145, 6428.12207, 7640.504883], [1477.464647, 2515.183672, 6419.948242, 7646.911133], [1453.872366, 2523.46407, 6414.543945, 7647.364746], [1430.280133, 2531.744405, 6408.959961, 7628.808594], [1406.950814, 2539.680914, 6403.36377, 7626.875977], [1383.621384, 2547.617515, 6401.043457, 7624.519531], [1360.291735, 2555.554307, 6401.952148, 7626.8125], [1336.961736, 2563.491399, 6401.925293, 7629.095703], [1313.631278, 2571.428909, 6405.571289, 7631.644043], [1290.300218, 2579.366982, 6409.683105, 7641.929199], [1266.968439, 2587.305764, 6411.202148, 7613.766602], [1243.635758, 2595.2455, 6413.071289, 7610.190918], [1220.302047, 2603.186438, 6415.619141, 7607.382813], [1196.96703, 2611.129014, 6417.25293, 7605.793945], [1173.630529, 2619.07353, 6418.92627, 7606.14502], [1150.292207, 2627.02051, 6420.488281, 7608.788574], [1126.951958, 2634.970164, 6422.103027, 7611.655762], [1103.609418, 2642.923079, 6424.370117, 7615.29541], [1080.264528, 2650.879411, 6426.711426, 7616.560547], [1056.916919, 2658.839599, 6428.644531, 7617.210449], [1033.566647, 2666.803372, 6430.588379, 7617.322754], [1010.213594, 2674.770672, 6432.30127, 7616.870605], [986.8580144, 2682.741052, 6434.052734, 7617.442871], [963.5000572, 2690.714229, 6435.537598, 7615.233887], [940.140072, 2698.68987, 6436.954102, 7613.391113], [916.7782891, 2706.667374, 6438.445801, 7611.966309], [893.4148507, 2714.646796, 6439.960449, 7610.746582], [870.050521, 2722.62791, 6441.754395, 7609.632813], [846.6853707, 2730.610942, 6443.679688, 7608.959473], [823.3188919, 2738.595533, 6445.409668, 7609.21875], [799.9510652, 2746.5812, 6446.979004, 7609.796875], [776.5832179, 2754.567564, 6448.554688, 7611.304199], [753.2155442, 2762.553737, 6449.924316, 7613.035156], [731.8921976, 2770.084153, 6333.758301, 7732.337891], [710.5688509, 2777.614569, 6334.045898, 7735.045898], [689.2455043, 2785.144985, 6334.072754, 7737.306641], [667.9221577, 2792.6754, 6334.078613, 7738.850586], [646.5988111, 2800.205816, 6334.100098, 7739.830078], [625.2754644, 2807.736232, 6334.135742, 7740.425781], [603.9521178, 2815.266648, 6334.172852, 7740.77832], [582.6287712, 2822.797064, 6334.20752, 7740.974609], [561.3054246, 2830.32748, 6334.228516, 7741.075195], [539.982078, 2837.857896, 6334.243164, 7741.117188], [1963.381235, 2320.649894, 6343.57959, 7737.899414], [1942.905302, 2327.521859, 6343.630859, 7737.77832], [1922.42937, 2334.393823, 6343.737305, 7737.530273], [1901.953437, 2341.265788, 6343.901367, 7737.148438], [1881.477505, 2348.137753, 6344.137695, 7736.59375], [1861.001573, 2355.009718, 6344.45166, 7735.823242], [1840.52564, 2361.881683, 6344.865234, 7734.762695], [1820.049708, 2368.753647, 6345.428223, 7733.248047], [1799.573775, 2375.625612, 6461.593262, 7615.535156], [1775.97466, 2383.915121, 6459.062988, 7615.005859], [1752.376531, 2392.203395, 6456.63623, 7614.626953], [1728.779229, 2400.490536, 6454.388184, 7613.493164], [1705.182791, 2408.776554, 6452.273438, 7612.634766], [1681.587045, 2417.061604, 6450.220215, 7612.132324], [1657.991967, 2425.345765, 6447.945801, 7612.965332], [1634.397434, 2433.629189, 6445.666504, 7614.899902], [1610.803402, 2441.91196, 6441.835449, 7617.22168], [1587.209787, 2450.19418, 6437.817871, 7620.905273], [1563.61654, 2458.475925, 6435.643066, 7622.818848], [1540.023594, 2466.75728, 6435.967285, 7626.974609], [1516.430894, 2475.038316, 6432.446289, 7630.904297], [1492.838385, 2483.319103, 6427.05127, 7636.964844], [1469.246022, 2491.599705, 6418.178711, 7642.099121], [1445.653754, 2499.880183, 6411.012695, 7648.483398], [1422.061535, 2508.160599, 6404.849609, 7631.118652], [1398.732125, 2516.096939, 6398.822266, 7624.952148], [1375.402604, 2524.03337, 6396.004883, 7623.241211], [1352.072862, 2531.96998, 6397.397461, 7625.041016], [1328.742782, 2539.906869, 6398.16748, 7624.770996], [1305.412256, 2547.844152, 6400.960938, 7622.408203], [1282.08114, 2555.781998, 6405.095703, 7640.543945], [1258.749295, 2563.720586, 6406.950684, 7624.70459], [1235.416527, 2571.660176, 6408.696777, 7609.549316], [1212.082697, 2579.600988, 6411.357422, 7606.34375], [1188.747575, 2587.543387, 6413.530273, 7604.134277], [1165.410993, 2595.487666, 6415.705566, 7603.773438], [1142.07265, 2603.434389, 6417.398438, 7605.074219], [1118.732342, 2611.383871, 6419.760742, 7608.80127], [1095.38973, 2619.336684, 6422.477539, 7613.451172], [1072.044697, 2627.292894, 6424.619629, 7615.191406], [1048.697006, 2635.252839, 6426.483398, 7616.346191], [1025.346696, 2643.216354, 6428.563965, 7615.999023], [1001.993639, 2651.183496, 6430.549805, 7615.081543], [978.6379672, 2659.153824, 6432.07666, 7613.882324], [955.2798927, 2667.126836, 6433.152832, 7612.246094], [931.9198174, 2675.102202, 6434.466309, 7610.81543], [908.558045, 2683.079497, 6436.134766, 7608.748047], [885.1945889, 2691.058873, 6437.840332, 7607.240723], [861.8301415, 2699.039868, 6439.979004, 7607.212891], [838.4648734, 2707.022607, 6441.818848, 7607.311523], [815.0984123, 2715.006994, 6443.438965, 7607.690918], [791.7305817, 2722.992657, 6445.034668, 7608.363281], [768.3626343, 2730.978839, 6446.569336, 7610.024414], [744.9948504, 2738.96471, 6448.02002, 7611.909668], [721.6264195, 2746.950812, 6449.316895, 7614.588867], [698.2577482, 2754.936971, 6450.390137, 7617.766602], [677.3974754, 2762.362828, 6333.389648, 7737.433594], [656.5372026, 2769.788685, 6333.326172, 7738.947266], [635.6769298, 2777.214541, 6333.34082, 7739.71875], [614.816657, 2784.640398, 6333.38623, 7740.091797], [593.9563842, 2792.066255, 6333.436035, 7740.25], [573.0961113, 2799.492112, 6333.483398, 7740.294922], [552.2358385, 2806.917969, 6333.51123, 7740.298828], [531.3755657, 2814.343825, 6333.528809, 7740.290039], [1955.229414, 2297.035001, 6341.132813, 7736.024414], [1934.7451, 2303.910702, 6341.171387, 7735.907227], [1914.260786, 2310.786402, 6341.241211, 7735.672852], [1893.776472, 2317.662103, 6341.350098, 7735.307617], [1873.292158, 2324.537804, 6341.506836, 7734.813477], [1852.807844, 2331.413505, 6341.730957, 7734.143555], [1832.32353, 2338.289206, 6342.039551, 7733.256836], [1811.839216, 2345.164907, 6342.476563, 7732.033203], [1791.354902, 2352.040608, 6458.702148, 7614.585938], [1767.755843, 2360.3302, 6456.169922, 7613.641113], [1744.157704, 2368.618545, 6453.887207, 7613.284668], [1720.560456, 2376.905736, 6451.608887, 7612.50293], [1696.963993, 2385.191833, 6449.416504, 7611.489258], [1673.368268, 2393.476971, 6447.387695, 7611.506836], [1649.773191, 2401.761224, 6445.210938, 7612.325195], [1626.178688, 2410.044718, 6442.472168, 7613.712891], [1602.584679, 2418.32755, 6438.446289, 7616.02002], [1578.991084, 2426.609834, 6434.699707, 7619.151855], [1555.397847, 2434.891657, 6431.463867, 7621.522461], [1531.804911, 2443.173095, 6430.980957, 7623.896484], [1508.212222, 2451.454216, 6428.666016, 7627.472168], [1484.619729, 2459.735081, 6424.386719, 7633.267578], [1461.027386, 2468.015758, 6416.637695, 7637.0625], [1437.435137, 2476.296307, 6407.950195, 7641.493652], [1413.842937, 2484.576793, 6401.571289, 7628.249512], [1390.513451, 2492.51292, 6395.38623, 7628.46582], [1367.183855, 2500.449141, 6391.708008, 7624.084961], [1343.85404, 2508.385554, 6392.687988, 7620.475098], [1320.523876, 2516.322267, 6394.485352, 7619.768066], [1297.193253, 2524.2594, 6396.875488, 7617.703125], [1273.862029, 2532.197094, 6399.579102, 7630.00293], [1250.530086, 2540.135496, 6401.873047, 7639.155762], [1227.197242, 2548.074852, 6404.342773, 7609.872559], [1203.86337, 2556.015414, 6407.043945, 7606.003418], [1180.528192, 2563.957615, 6409.891602, 7602.990723], [1157.191535, 2571.90176, 6412.23877, 7603.145508], [1133.853058, 2579.848372, 6414.322754, 7603.486816], [1110.512656, 2587.79766, 6416.861328, 7608.174805], [1087.169966, 2595.750214, 6419.102051, 7611.964844], [1063.824929, 2603.706186, 6421.443359, 7614.518555], [1040.477177, 2611.66602, 6423.77002, 7614.661133], [1017.126765, 2619.629444, 6426.539551, 7614.429688], [993.7735756, 2627.596399, 6428.944336, 7612.658691], [970.4178638, 2635.56644, 6430.520508, 7610.672852], [947.0597778, 2643.539279, 6431.883301, 7608.70166], [923.6996682, 2651.514583, 6432.887695, 7608.701172], [900.3377647, 2659.491751, 6434.29541, 7607.021484], [876.9742094, 2667.470842, 6435.969727, 7605.641602], [853.6097663, 2675.451624, 6438.102051, 7604.900879], [830.2445063, 2683.434329, 6440.028809, 7604.993652], [806.8779217, 2691.418594, 6441.631836, 7606.513184], [783.5099924, 2699.403934, 6443.266113, 7607.556152], [760.1420455, 2707.389974, 6444.692871, 7609.209961], [736.7742754, 2715.375822, 6446.135742, 7611.794922], [713.4057362, 2723.3617, 6447.388672, 7614.886719], [690.0369677, 2731.347577, 6448.59668, 7618.553223], [666.6685463, 2739.332375, 6449.715332, 7621.760742], [646.1314598, 2746.68471, 6332.499512, 7739.789063], [625.5943734, 2754.037045, 6332.551758, 7740.00293], [605.0572869, 2761.389379, 6332.630371, 7739.967773], [584.5202004, 2768.741714, 6332.70459, 7739.823242], [563.9831139, 2776.094049, 6332.766602, 7739.661133], [543.4460274, 2783.446384, 6332.813965, 7739.53125], [522.9089409, 2790.798718, 6332.837402, 7739.457031], [1947.0776, 2273.420106, 6338.661621, 7734.268555], [1926.584911, 2280.299542, 6338.678223, 7734.15918], [1906.092221, 2287.178977, 6338.704102, 7733.941406], [1885.599531, 2294.058412, 6338.74707, 7733.619141], [1865.106841, 2300.937848, 6338.815918, 7733.202148], [1844.614152, 2307.817283, 6338.923828, 7732.688477], [1824.121462, 2314.696719, 6339.078125, 7732.086914], [1803.628772, 2321.576154, 6339.311523, 7731.433594], [1783.136083, 2328.45559, 6455.587402, 7614.84668], [1759.536993, 2336.745252, 6453.030273, 7613.383789], [1735.938891, 2345.033679, 6450.683594, 7612.396973], [1712.341616, 2353.32097, 6448.538574, 7611.753418], [1688.745205, 2361.607139, 6446.478516, 7610.839844], [1665.14949, 2369.892339, 6444.546387, 7610.55127], [1641.554441, 2378.176651, 6442.520508, 7611.15625], [1617.959939, 2386.460225, 6439.378906, 7612.145996], [1594.365937, 2394.743145, 6435.623535, 7614.291504], [1570.772354, 2403.025516, 6431.550781, 7617.232422], [1547.179141, 2411.307412, 6428.338867, 7620.041504], [1523.586229, 2419.588916, 6425.56543, 7621.5], [1499.993562, 2427.870102, 6423.979004, 7624.17334], [1476.401087, 2436.15104, 6419.757813, 7625.439453], [1452.808757, 2444.431792, 6413.392578, 7632.312012], [1429.216524, 2452.712421, 6404.913086, 7636.155273], [1405.624339, 2460.992987, 6398.062012, 7633.124023], [1382.294763, 2468.928943, 6392.24707, 7630.794922], [1358.965076, 2476.86499, 6389.373047, 7624.986816], [1335.635168, 2484.801216, 6388.358887, 7621.395508], [1312.304921, 2492.73772, 6389.963379, 7620.016113], [1288.97423, 2500.674618, 6392.453125, 7617.617676], [1265.642951, 2508.612082, 6394.928223, 7617.575684], [1242.310942, 2516.55029, 6397.370117, 7627.061035], [1218.97801, 2524.489501, 6400.30957, 7609.920898], [1195.644019, 2532.429934, 6403.476074, 7605.947266], [1172.308737, 2540.371957, 6406.218262, 7603.593262], [1148.971996, 2548.31586, 6408.560059, 7603.845215], [1125.633497, 2556.262211, 6410.854492, 7605.876953], [1102.293036, 2564.211325, 6413.131836, 7610.35498], [1078.950272, 2572.163775, 6415.382813, 7614.160156], [1055.605091, 2580.119625, 6417.519043, 7615.384766], [1032.257256, 2588.079217, 6419.748047, 7615.226074], [1008.906807, 2596.042379, 6422.754395, 7613.007324], [985.5536133, 2604.009176, 6424.443848, 7609.668945], [962.1978095, 2611.979161, 6428.755371, 7608.276855], [938.8396077, 2619.951833, 6430.54834, 7607.595703], [915.4794084, 2627.926862, 6431.621094, 7607.503906], [892.1175163, 2635.903825, 6432.779297, 7608.338379], [868.7539448, 2643.882868, 6434.618652, 7604.283203], [845.3893853, 2651.863532, 6436.540527, 7602.554688], [822.024009, 2659.845943, 6438.279297, 7603.437012], [798.657443, 2667.830004, 6439.936523, 7605.176758], [775.2895118, 2675.815341, 6441.520996, 7606.47168], [751.9214666, 2683.8012, 6443.07666, 7607.283203], [728.5535874, 2691.786746, 6444.520508, 7610.810547], [705.1850635, 2699.772524, 6445.669434, 7614.756836], [681.8163026, 2707.75836, 6446.846191, 7618.702637], [658.447772, 2715.742871, 6447.986328, 7621.632324], [635.0800849, 2723.726918, 6449.077148, 7623.763672], [614.9584179, 2730.984847, 6331.733398, 7740.541016], [594.8367509, 2738.242777, 6331.879883, 7739.954102], [574.715084, 2745.500706, 6331.983398, 7739.422852], [554.593417, 2752.758636, 6332.070801, 7738.993164], [534.47175, 2760.016565, 6332.134766, 7738.703125], [514.350083, 2767.274494, 6332.166504, 7738.549805], [1938.925778, 2249.805215, 6336.179688, 7732.615234], [1918.424705, 2256.688388, 6336.169922, 7732.516602], [1897.923631, 2263.571561, 6336.150879, 7732.314453], [1877.422557, 2270.454734, 6336.121582, 7732.037109], [1856.921484, 2277.337907, 6336.092285, 7731.691406], [1836.42041, 2284.22108, 6336.061035, 7731.316406], [1815.919337, 2291.104253, 6336.042969, 7730.980469], [1795.418263, 2297.987426, 6336.031738, 7730.833984], [1774.91719, 2304.8706, 6452.291992, 7614.918945], [1751.318159, 2313.160345, 6449.844238, 7613.510742], [1727.720048, 2321.44884, 6447.51709, 7612.321289], [1704.122827, 2329.736181, 6445.358398, 7611.257813], [1680.526395, 2338.022428, 6443.324219, 7610.211914], [1656.930699, 2346.307715, 6441.536621, 7609.146484], [1633.335654, 2354.592117, 6439.526367, 7609.393555], [1609.741182, 2362.875761, 6436.253906, 7610.300781], [1586.147205, 2371.158743, 6432.80127, 7612.231934], [1562.553643, 2379.441176, 6428.708496, 7615.524414], [1538.960441, 2387.723148, 6425.036621, 7619.460938], [1515.367538, 2396.004736, 6422.185547, 7620.651855], [1491.774884, 2404.286006, 6419.836426, 7622.616699], [1468.182426, 2412.567021, 6415.544434, 7625.129883], [1444.590118, 2420.847847, 6409.395996, 7629.963867], [1420.997906, 2429.128546, 6401.853516, 7636.496582], [1397.405741, 2437.409181, 6394.099609, 7621.687012], [1374.07609, 2445.344921, 6388.914063, 7627.543457], [1350.746329, 2453.280754, 6385.859375, 7626.903809], [1327.416349, 2461.216778, 6385.209961, 7621.266113], [1304.08602, 2469.153102, 6385.82373, 7620.795898], [1280.755232, 2477.089846, 6387.76709, 7619.575684], [1257.423844, 2485.027155, 6390.255371, 7623.845703], [1234.091738, 2492.965174, 6392.764648, 7627.316895], [1210.758733, 2500.90415, 6395.63623, 7610.466309], [1187.4247, 2508.844329, 6399.35498, 7606.539063], [1164.089363, 2516.786152, 6402.282227, 7605.007813], [1140.752547, 2524.729919, 6404.753906, 7605.738281], [1117.413914, 2532.676156, 6406.846191, 7609.212402], [1094.073357, 2540.625074, 6408.37793, 7617.845215], [1070.730516, 2548.577263, 6410.458008, 7617.649902], [1047.385332, 2556.532874, 6412.891113, 7618.35791], [1024.037436, 2564.492353, 6414.279297, 7617.386719], [1000.686885, 2572.455425, 6416.136719, 7613.271973], [977.3335599, 2580.422032, 6419.462891, 7608.888672], [953.977717, 2588.391728, 6426.498047, 7606.09082], [930.6195047, 2596.364227, 6428.371582, 7606.167969], [907.2592721, 2604.339194, 6430.038086, 7606.061523], [883.8972508, 2612.316029, 6431.237305, 7604.913574], [860.5335811, 2620.294787, 6433.038574, 7602.785156], [837.1690273, 2628.27524, 6434.875488, 7600.463379], [813.8036605, 2636.257615, 6436.540527, 7601.405762], [790.4369724, 2644.241555, 6438.157227, 7603.570313], [767.0689439, 2652.226571, 6439.803223, 7605.263184], [743.7009007, 2660.212288, 6441.460938, 7607.296387], [720.3330362, 2668.197814, 6442.867676, 7609.652832], [696.964406, 2676.183369, 6444.001465, 7614.569336], [673.5955483, 2684.168924, 6445.155762, 7617.566406], [650.2270396, 2692.1534, 6446.226563, 7620.476074], [626.8593592, 2700.137336, 6447.293457, 7622.228027], [603.4929077, 2708.121921, 6448.395508, 7623.463379], [583.9249193, 2715.2539, 6331.162598, 7739.881836], [564.356931, 2722.385879, 6331.284668, 7738.911133], [544.7889426, 2729.517858, 6331.397949, 7738.195313], [525.2209543, 2736.649837, 6331.483398, 7737.728516], [505.6529659, 2743.781816, 6331.527344, 7737.498047], [1930.773963, 2226.190323, 6333.702637, 7731.056641], [1910.264513, 2233.077233, 6333.669922, 7730.963867], [1889.755063, 2239.964143, 6333.603027, 7730.779297], [1869.245613, 2246.851053, 6333.5, 7730.530273], [1848.736162, 2253.737964, 6333.368652, 7730.223633], [1828.226712, 2260.624874, 6333.200684, 7729.908203], [1807.717262, 2267.511784, 6332.986328, 7729.678711], [1787.207812, 2274.398694, 6332.73584, 7729.739258], [1766.698362, 2281.285605, 6448.928223, 7614.018066], [1743.0993, 2289.575417, 6446.335938, 7613.310547], [1719.501226, 2297.863993, 6444.143555, 7610.929688], [1695.903982, 2306.151434, 6442.064941, 7610.309082], [1672.3076, 2314.437751, 6440.190918, 7609.485352], [1648.711915, 2322.7231, 6438.460449, 7608.288574], [1625.116899, 2331.007559, 6436.129883, 7607.796387], [1601.522428, 2339.291281, 6433.047363, 7607.679688], [1577.92846, 2347.574349, 6429.53418, 7610.533203], [1554.33491, 2355.856868, 6425.683105, 7613.841309], [1530.741731, 2364.13891, 6421.530273, 7617.527832], [1507.148853, 2372.420564, 6419.006348, 7620.578125], [1483.556222, 2380.701898, 6416.316406, 7621.877441], [1459.963783, 2388.982983, 6412.024414, 7625.318359], [1436.371488, 2397.263884, 6406.124023, 7630.596191], [1412.779292, 2405.544661, 6398.59668, 7634.215332], [1389.187143, 2413.825375, 6390.643555, 7613.112793], [1365.857404, 2421.760939, 6385.692871, 7621.628906], [1342.527553, 2429.696593, 6381.79248, 7631.665527], [1319.197482, 2437.632428, 6383.021484, 7621.107422], [1295.867074, 2445.568543, 6384.845215, 7621.689453], [1272.536219, 2453.505052, 6385.740234, 7620.196289], [1249.204778, 2461.442126, 6386.950195, 7617.918945], [1225.872607, 2469.379945, 6388.238281, 7628.01123], [1202.539515, 2477.31877, 6390.927734, 7619.717285], [1179.205363, 2485.258819, 6394.111328, 7609.763184], [1155.869923, 2493.20046, 6396.867676, 7608.070313], [1132.533024, 2501.143985, 6399.405273, 7609.180176], [1109.194371, 2509.089961, 6401.177734, 7611.87793], [1085.853757, 2517.038703, 6402.975586, 7616.244141], [1062.510844, 2524.990786, 6403.709961, 7620.262695], [1039.165516, 2532.946272, 6404.564941, 7624.371582], [1015.817539, 2540.905505, 6406.361816, 7620.746094], [992.466951, 2548.868316, 6411.844238, 7614.173828], [969.1136234, 2556.834764, 6417.429688, 7608.431152], [945.7576899, 2564.804406, 6422.707031, 7603.756348], [922.3993622, 2572.776738, 6426.208496, 7603.619141], [899.0390423, 2580.75143, 6428.198242, 7605.202148], [875.6770329, 2588.728056, 6429.69043, 7602.475586], [852.3133489, 2596.706767, 6431.374512, 7600.440918], [828.9486807, 2604.687101, 6432.895996, 7598.763672], [805.5831985, 2612.669185, 6434.629883, 7599.311523], [782.2165309, 2620.652921, 6436.366699, 7601.314453], [758.848502, 2628.637936, 6438.250977, 7603.518555], [735.480361, 2636.623473, 6440.135254, 7606.083496], [712.1123883, 2644.608698, 6441.207031, 7608.027832], [688.7437742, 2652.594156, 6442.339355, 7611.439453], [665.3749246, 2660.579673, 6443.388184, 7615.40625], [642.0063063, 2668.563863, 6444.354492, 7618.306641], [618.6385329, 2676.54759, 6445.498535, 7620.227051], [595.2721328, 2684.532173, 6446.716797, 7621.068359], [571.9060756, 2692.51621, 6448.024414, 7622.275391], [553.1131683, 2699.472001, 6330.600098, 7738.145508], [534.320261, 2706.427792, 6330.751465, 7737.146484], [515.5273537, 2713.383583, 6330.871582, 7736.517578], [496.7344464, 2720.339374, 6330.936523, 7736.208984], [1922.622141, 2202.575434, 6331.260742, 7729.592773], [1902.104307, 2209.466086, 6331.207031, 7729.501953], [1881.586473, 2216.356737, 6331.092773, 7729.322266], [1861.068639, 2223.247388, 6330.918945, 7729.074219], [1840.550805, 2230.13804, 6330.679688, 7728.766602], [1820.032971, 2237.028691, 6330.366211, 7728.407227], [1799.515137, 2243.919342, 6329.980957, 7728.073242], [1778.997303, 2250.809994, 6329.506836, 7727.913086], [1758.479469, 2257.700645, 6445.541504, 7611.712891], [1734.880466, 2265.990539, 6442.853516, 7609.932129], [1711.282384, 2274.279182, 6440.729492, 7608.837891], [1687.685193, 2282.566671, 6438.637207, 7609.100098], [1664.08879, 2290.853064, 6436.930664, 7608.383789], [1640.493126, 2299.138498, 6435.235352, 7607.794922], [1616.898112, 2307.423047, 6432.558594, 7606.822754], [1593.303672, 2315.706835, 6429.63623, 7607.103516], [1569.709728, 2323.989962, 6426.234863, 7609.150879], [1546.116199, 2332.272541, 6422.519531, 7611.979492], [1522.523031, 2340.55466, 6418.017578, 7618.147461], [1498.930163, 2348.836394, 6414.369629, 7621.362793], [1475.337544, 2357.11781, 6411.42334, 7623.959961], [1451.745123, 2365.398971, 6407.647461, 7627.49707], [1428.15285, 2373.679943, 6402.595215, 7632.952148], [1404.560674, 2381.960787, 6395.097168, 7638.184082], [1380.968545, 2390.241569, 6387.833496, 7616.188965], [1357.638733, 2398.176912, 6383.562012, 7614.384277], [1334.308811, 2406.112349, 6379.155762, 7622.836914], [1310.978672, 2414.04798, 6380.463379, 7618.833008], [1287.648182, 2421.983913, 6383.846191, 7619.843262], [1264.317235, 2429.920266, 6384.80957, 7620.246582], [1240.985688, 2437.857182, 6385.729492, 7620.050293], [1217.653423, 2445.794809, 6386.538574, 7623.160645], [1194.320258, 2453.733394, 6388.131836, 7625.084473], [1170.986066, 2461.673187, 6389.680176, 7611.023438], [1147.650572, 2469.614625, 6391.091797, 7610.182129], [1124.313601, 2477.558013, 6393.37793, 7611.349609], [1100.974815, 2485.503872, 6395.477539, 7614.116211], [1077.634109, 2493.452418, 6396.971191, 7616.313965], [1054.29112, 2501.404236, 6397.075195, 7621.650391], [1030.945792, 2509.359483, 6399.891602, 7622.32373], [1007.597755, 2517.318602, 6406.321777, 7619.130859], [984.2470665, 2525.28132, 6412.566895, 7612.758301], [960.8936096, 2533.247579, 6417.552246, 7605.024414], [937.5376385, 2541.216932, 6422.37793, 7600.079102], [914.1793026, 2549.18909, 6424.537598, 7600.862793], [890.8189508, 2557.16372, 6426.299805, 7600.112793], [867.4568136, 2565.140218, 6427.672852, 7599.141113], [844.0930333, 2573.118644, 6429.115723, 7597.40332], [820.7283717, 2581.098768, 6430.714355, 7595.681152], [797.3629005, 2589.080818, 6432.296387, 7595.088867], [773.9961123, 2597.064434, 6434.029785, 7599.189941], [750.6279866, 2605.049129, 6436.186035, 7601.265137], [727.2598484, 2613.034526, 6438.21582, 7603.323242], [703.8918915, 2621.019732, 6439.586426, 7605.79248], [680.5231706, 2629.004969, 6440.661133, 7609.229004], [657.1542242, 2636.990208, 6441.736328, 7613.650879], [633.7856273, 2644.974366, 6442.728027, 7616.294434], [610.4178597, 2652.957984, 6443.92334, 7617.939941], [587.0513199, 2660.942253, 6445.138184, 7619.784668], [563.6852126, 2668.926188, 6446.461914, 7620.555176], [544.9077902, 2675.876258, 6329.768066, 7736.820313], [526.1303678, 2682.826327, 6330.125977, 7735.733398], [507.3529454, 2689.776397, 6330.317383, 7734.985352], [488.5755231, 2696.726467, 6330.405273, 7734.610352], [1914.470326, 2178.960547, 6328.87793, 7728.210938], [1893.944116, 2185.85494, 6328.800781, 7728.12207], [1873.417907, 2192.749333, 6328.643066, 7727.947266], [1852.891697, 2199.643725, 6328.39502, 7727.686523], [1832.365487, 2206.538118, 6328.056152, 7727.335938], [1811.839277, 2213.432511, 6327.614258, 7726.882813], [1791.313067, 2220.326904, 6327.06543, 7726.301758], [1770.786857, 2227.221297, 6326.38916, 7725.506836], [1750.260647, 2234.11569, 6442.133789, 7607.651855], [1726.661614, 2242.405649, 6439.637695, 7606.46875], [1703.06357, 2250.694371, 6437.493164, 7606.147949], [1679.466354, 2258.981956, 6435.452148, 7606.836914], [1655.870004, 2267.268418, 6433.692383, 7607.182617], [1632.274349, 2275.553911, 6431.854004, 7607.430664], [1608.679363, 2283.838513, 6428.842285, 7606.024414], [1585.084924, 2292.122379, 6425.894043, 7606.487793], [1561.490988, 2300.40559, 6422.424805, 7609.370605], [1537.897472, 2308.688253, 6418.904297, 7613.565918], [1514.304325, 2316.97044, 6414.406738, 7619.018066], [1490.711482, 2325.252236, 6409.518555, 7623.686035], [1467.118884, 2333.533712, 6405.912598, 7627.53125], [1443.526481, 2341.814942, 6401.977051, 7631.45459], [1419.934222, 2350.095985, 6396.537109, 7636.666992], [1396.34206, 2358.376906, 6390.090332, 7642.291016], [1372.749947, 2366.657763, 6385.662598, 7609.071777], [1349.42005, 2374.592929, 6381.489746, 7609.662109], [1326.090043, 2382.528187, 6378.029297, 7624.780762], [1302.759814, 2390.463623, 6376.620605, 7618.508789], [1279.429248, 2398.39934, 6379.939941, 7617.218262], [1256.098237, 2406.335454, 6382.0625, 7616.874023], [1232.76664, 2414.272134, 6383.82666, 7617.180176], [1209.434312, 2422.20956, 6385.140625, 7621.47998], [1186.101064, 2430.147994, 6386.223145, 7624.944824], [1162.766758, 2438.087655, 6387.774414, 7612.547363], [1139.431164, 2446.02891, 6389.904785, 7610.806152], [1116.094114, 2453.972051, 6390.83252, 7610.85498], [1092.75531, 2461.917647, 6391.456543, 7612.236328], [1069.414548, 2469.866013, 6393.084961, 7613.84668], [1046.071489, 2477.817725, 6395.496094, 7620.584961], [1022.72602, 2485.772847, 6399.972656, 7619.101074], [999.3779045, 2493.73172, 6408.091309, 7617.078125], [976.0271819, 2501.694176, 6414.951172, 7608.810059], [952.6737241, 2509.660273, 6418.536621, 7604.297852], [929.3176647, 2517.62957, 6421.248047, 7601.313477], [905.9592159, 2525.601561, 6422.828613, 7599.408203], [882.5987787, 2533.575915, 6424.477539, 7598.470703], [859.2366558, 2541.552208, 6425.498047, 7596.702148], [835.8728621, 2549.530588, 6426.901855, 7595.232422], [812.5080876, 2557.510593, 6428.493652, 7594.239258], [789.1425024, 2565.492352, 6429.904297, 7595.20752], [765.7757347, 2573.475766, 6431.671875, 7597.285645], [742.407609, 2581.460462, 6433.63916, 7601.111328], [719.0393735, 2589.445682, 6435.373535, 7602.351074], [695.6713079, 2597.43059, 6436.981934, 7603.720703], [672.3026027, 2605.415731, 6438.484375, 7607.666016], [648.9336635, 2613.400934, 6439.839355, 7610.935059], [625.564957, 2621.384809, 6441.196289, 7613.997559], [602.1970949, 2629.368222, 6442.441406, 7615.466309], [578.8306056, 2637.352492, 6443.708984, 7617.250488], [555.4644597, 2645.336217, 6445.067871, 7619.599609], [532.0980492, 2653.318043, 6446.474609, 7618.268555], [514.4872024, 2660.003009, 6329.677246, 7733.981445], [496.8763557, 2666.687975, 6329.872559, 7733.077148], [479.265509, 2673.372941, 6329.969727, 7732.644531], [1906.318505, 2155.345664, 6326.572754, 7726.923828], [1885.783913, 2162.243804, 6326.473633, 7726.833984], [1865.24932, 2169.141943, 6326.269043, 7726.65918], [1844.714728, 2176.040082, 6325.960449, 7726.388672], [1824.180136, 2182.938222, 6325.541504, 7726.010742], [1803.645543, 2189.836361, 6324.98291, 7725.493164], [1783.110951, 2196.734501, 6324.288086, 7724.751953], [1762.576358, 2203.63264, 6323.419922, 7723.612305], [1742.041766, 2210.53078, 6438.970703, 7605.112793], [1718.442791, 2218.820818, 6436.437012, 7603.652832], [1694.844739, 2227.109604, 6434.304199, 7601.956543], [1671.247576, 2235.397235, 6432.479492, 7604.495605], [1647.651203, 2243.68377, 6430.830566, 7607.316895], [1624.05557, 2251.969345, 6428.42627, 7606.270508], [1600.460586, 2260.254034, 6425.285156, 7606.555664], [1576.866178, 2268.537963, 6421.945313, 7607.046875], [1553.272264, 2276.821232, 6418.352051, 7610.273926], [1529.678768, 2285.103951, 6414.556152, 7614.475586], [1506.085633, 2293.38621, 6409.824707, 7620.262695], [1482.492798, 2301.668082, 6405.040039, 7624.869141], [1458.900212, 2309.949638, 6401.046875, 7630.752441], [1435.307824, 2318.23094, 6396.399414, 7635.36377], [1411.715586, 2326.512052, 6391.175781, 7639.620605], [1388.123443, 2334.793037, 6385.937988, 7637.678711], [1364.531349, 2343.073957, 6382.798828, 7611.655762], [1341.201384, 2351.008902, 6378.986328, 7605.610352], [1317.871309, 2358.943939, 6374.619629, 7627.065918], [1294.541015, 2366.879169, 6374.407227, 7616.947266], [1271.210372, 2374.8147, 6375.709473, 7616.569824], [1247.879271, 2382.750653, 6378.171387, 7616.955078], [1224.54757, 2390.687174, 6379.882324, 7617.041992], [1201.215153, 2398.624408, 6381.398926, 7619.085938], [1177.881837, 2406.562602, 6382.966309, 7623.116211], [1154.547494, 2414.502004, 6386.369141, 7611.998535], [1131.21185, 2422.443053, 6389.224609, 7607.988281], [1107.87473, 2430.386055, 6391.131348, 7610.423828], [1084.535797, 2438.331533, 6393.040527, 7612.336914], [1061.194945, 2446.2797, 6395.300293, 7612.027344], [1037.851815, 2454.231147, 6396.486816, 7610.922852], [1014.506347, 2462.186028, 6404.271973, 7609.05957], [991.1581754, 2470.144786, 6413.077148, 7607.850586], [967.8073555, 2478.107149, 6417.625977, 7601.880371], [944.4537714, 2486.073056, 6420.316406, 7602.179688], [921.0976772, 2494.042062, 6421.606445, 7600.31543], [897.7392217, 2502.01388, 6422.40332, 7599.509766], [874.3787544, 2509.988173, 6422.989746, 7598.100098], [851.0165062, 2517.964339, 6423.570801, 7596.345703], [827.6526171, 2525.942436, 6424.777832, 7594.77832], [804.2878507, 2533.922232, 6426.479492, 7593.322754], [780.9222769, 2541.903958, 6427.84082, 7594.290527], [757.5553891, 2549.887254, 6428.967285, 7596.561035], [734.187167, 2557.871631, 6431.011719, 7599.653809], [710.8189339, 2565.856713, 6432.806641, 7602.375977], [687.450883, 2573.841605, 6434.576172, 7604.226074], [664.0820702, 2581.826529, 6436.166016, 7607.185547], [640.7130337, 2589.811455, 6437.895508, 7610.742188], [617.3443467, 2597.795301, 6439.847168, 7612.282715], [593.9764889, 2605.778608, 6441.126465, 7613.608887], [570.609859, 2613.762567, 6442.456055, 7614.986328], [547.2436601, 2621.746194, 6443.906738, 7616.78418], [523.8772968, 2629.727989, 6445.155762, 7616.206055], [500.5103779, 2637.70849, 6446.265137, 7614.812988], [484.8439932, 2643.952086, 6329.518555, 7730.691406], [469.1776085, 2650.195682, 6329.627441, 7730.249023], [1898.166693, 2131.730783, 6324.364746, 7725.71875], [1877.623726, 2138.63267, 6324.248535, 7725.632813], [1857.080759, 2145.534558, 6324.010254, 7725.458008], [1836.537792, 2152.436445, 6323.646973, 7725.198242], [1815.994825, 2159.338333, 6323.147461, 7724.829102], [1795.451858, 2166.240221, 6322.499512, 7724.328125], [1774.908892, 2173.142108, 6321.675781, 7723.607422], [1754.365925, 2180.043996, 6320.650879, 7722.470703], [1733.822958, 2186.945883, 6436.161133, 7603.677246], [1710.223953, 2195.235983, 6433.775879, 7602.947754], [1686.625938, 2203.524845, 6431.460938, 7602.422363], [1663.028751, 2211.812571, 6429.694336, 7602.958008], [1639.43243, 2220.099171, 6427.940918, 7604.667969], [1615.836805, 2228.384801, 6425.209961, 7605.063477], [1592.241849, 2236.669541, 6422.246582, 7604.702637], [1568.64744, 2244.953544, 6418.670898, 7607.005371], [1545.053535, 2253.236891, 6414.608887, 7609.599121], [1521.460049, 2261.51969, 6409.8125, 7613.504395], [1497.866934, 2269.802013, 6404.712402, 7620.57959], [1474.274122, 2278.083945, 6400.500977, 7625.061035], [1450.681558, 2286.365558, 6397.159668, 7630.547852], [1427.089186, 2294.646922, 6392.588379, 7634.776367], [1403.49696, 2302.928102, 6387.65625, 7640.348145], [1379.904831, 2311.209158, 6382.626465, 7631.875977], [1356.312751, 2319.490152, 6379.552734, 7611.055664], [1332.982703, 2327.424915, 6376.211426, 7605.182617], [1309.652547, 2335.35977, 6370.011719, 7619.671875], [1286.322169, 2343.294806, 6368.096191, 7623.416992], [1262.991453, 2351.230123, 6371.209473, 7617.289551], [1239.660293, 2359.165838, 6373.795898, 7616.358398], [1216.328546, 2367.102119, 6375.46875, 7615.149902], [1192.99607, 2375.039149, 6376.635254, 7614.474609], [1169.662674, 2382.977187, 6378.609375, 7620.786133], [1146.32822, 2390.916455, 6381.394043, 7615.925293], [1122.992481, 2398.857319, 6384.410645, 7605.169434], [1099.655285, 2406.800074, 6388.433105, 7606.323242], [1076.316338, 2414.745287, 6393.54541, 7606.889648], [1052.975436, 2422.693275, 6397.07959, 7606.526367], [1029.632238, 2430.644614, 6400.447266, 7605.052246], [1006.286634, 2438.599367, 6407.42627, 7601.666992], [982.9383862, 2446.557878, 6413.019531, 7598.178711], [959.5875358, 2454.519976, 6416.833496, 7597.239258], [936.2339531, 2462.485724, 6421.177246, 7598.37207], [912.8777731, 2470.454676, 6422.060059, 7598.73584], [889.5192074, 2478.426326, 6422.461426, 7599.456543], [866.1586567, 2486.400344, 6422.602051, 7598.234863], [842.7964237, 2494.376304, 6422.868164, 7597.783691], [819.4325232, 2502.354355, 6423.826172, 7595.00293], [796.0676443, 2510.334035, 6424.98291, 7594.036133], [772.701957, 2518.315473, 6425.641113, 7594.326172], [749.3350901, 2526.298569, 6426.488281, 7596.318848], [725.9668676, 2534.28295, 6428.072266, 7600.392578], [702.5985368, 2542.267856, 6429.719238, 7604.751465], [679.2303767, 2550.252453, 6431.679199, 7605.63916], [655.8615781, 2558.237284, 6433.833496, 7607.090332], [632.4925469, 2566.222178, 6436.231934, 7608.947266], [609.1237478, 2574.205743, 6438.210449, 7610.81543], [585.7557937, 2582.188847, 6439.912598, 7611.687012], [562.3892115, 2590.172811, 6441.330078, 7613.101074], [539.0229726, 2598.156231, 6442.773438, 7613.665039], [515.6564685, 2606.137748, 6443.981934, 7614.196289], [492.2895349, 2614.118264, 6445.13623, 7612.351074], [476.6489517, 2620.352392, 6329.17627, 7727.766602], [461.0083685, 2626.58652, 6329.397461, 7727.408203], [1890.014873, 2108.115908, 6322.272949, 7724.595703], [1869.463525, 2115.021549, 6322.138672, 7724.510742], [1848.912178, 2121.927191, 6321.878418, 7724.34668], [1828.36083, 2128.832832, 6321.466309, 7724.110352], [1807.809482, 2135.738474, 6320.916504, 7723.790039], [1787.258134, 2142.644115, 6320.192871, 7723.380859], [1766.706786, 2149.549757, 6319.268555, 7722.864258], [1746.155439, 2156.455398, 6318.086914, 7722.226563], [1725.604091, 2163.36104, 6433.654297, 7604.456055], [1702.005146, 2171.651216, 6431.147461, 7603.086914], [1678.407121, 2179.940139, 6428.972656, 7602.586914], [1654.809989, 2188.227907, 6427.305664, 7602.273438], [1631.213645, 2196.514577, 6425.32959, 7603.324707], [1607.618039, 2204.800285, 6422.245605, 7604.004395], [1584.023085, 2213.085107, 6419.248535, 7605.067871], [1560.428706, 2221.369169, 6414.621582, 7606.690918], [1536.834823, 2229.652569, 6410.227539, 7608.90625], [1513.241356, 2237.935421, 6405.257813, 7611.879883], [1489.648251, 2246.21781, 6400.553223, 7617.236816], [1466.055446, 2254.499815, 6396.287598, 7623.290039], [1442.462892, 2262.781502, 6392.810059, 7629.16748], [1418.870534, 2271.062935, 6388.783203, 7631.950195], [1395.278327, 2279.344178, 6384.371582, 7638.502441], [1371.686216, 2287.625293, 6380.214355, 7623.074707], [1348.094153, 2295.906346, 6376.695313, 7605.226074], [1324.764042, 2303.840885, 6373.714844, 7605.130859], [1301.43382, 2311.775519, 6367.51123, 7610.144043], [1278.103381, 2319.710348, 6362.82959, 7621.079102], [1254.772593, 2327.64548, 6366.297363, 7617.011719], [1231.441346, 2335.581034, 6369.163574, 7615.464355], [1208.109501, 2343.517154, 6371.359863, 7612.933105], [1184.776939, 2351.453988, 6372.368164, 7611.081055], [1161.443479, 2359.391783, 6374.28125, 7610.228027], [1138.108993, 2367.33079, 6376.641602, 7611.899414], [1114.773206, 2375.271449, 6378.997559, 7605.77002], [1091.435946, 2383.214063, 6381.913086, 7607.649414], [1068.096874, 2391.159159, 6388.012695, 7607.364746], [1044.755887, 2399.106947, 6393.291992, 7606.269043], [1021.412623, 2407.058019, 6398.980469, 7599.262207], [998.0670232, 2415.012529, 6405.597168, 7594.876953], [974.7187229, 2422.970924, 6411.619141, 7591.770508], [951.3677781, 2430.93293, 6416.958984, 7590.45752], [928.0140724, 2438.898488, 6420.549316, 7593.276855], [904.6578599, 2446.86715, 6420.249023, 7597.000977], [881.2992895, 2454.838628, 6421.49707, 7597.178711], [857.9387107, 2462.812585, 6422.207031, 7597.492188], [834.5763537, 2470.788419, 6422.168945, 7596.794922], [811.2123592, 2478.766188, 6422.5625, 7596.561035], [787.8474893, 2486.74566, 6422.885254, 7595.35791], [764.4818136, 2494.727067, 6423.019531, 7596.720703], [741.1148265, 2502.710049, 6423.909668, 7599.148438], [717.7465067, 2510.694114, 6425.175781, 7602.78418], [694.3781773, 2518.678885, 6426.734375, 7606.609863], [671.0100301, 2526.663468, 6428.880371, 7607.702148], [647.6411228, 2534.648085, 6431.513672, 7605.369141], [624.2719919, 2542.632706, 6434.509277, 7608.917969], [600.9032105, 2550.616245, 6437.151367, 7610.38623], [577.5352573, 2558.599245, 6438.985352, 7611.046875], [554.1685316, 2566.582901, 6440.282715, 7611.64502], [530.8022373, 2574.566224, 6441.59375, 7612.207031], [507.4357781, 2582.547714, 6442.918457, 7612.496582], [484.0687644, 2590.52791, 6444.257813, 7610.567383], [460.7013219, 2598.508213, 6445.575684, 7607.68457], [448.9628344, 2603.855116, 6329.384766, 7724.201172], [1881.863062, 2084.501035, 6320.30127, 7723.541016], [1861.303341, 2091.410433, 6320.163086, 7723.462891], [1840.743621, 2098.319831, 6319.879883, 7723.319336], [1820.1839, 2105.229229, 6319.449707, 7723.110352], [1799.62418, 2112.138627, 6318.858398, 7722.84375], [1779.064459, 2119.048025, 6318.092773, 7722.537109], [1758.504739, 2125.957423, 6317.11377, 7722.236328], [1737.945018, 2132.866821, 6315.852539, 7722.02832], [1717.385297, 2139.776219, 6431.55957, 7604.706543], [1693.786322, 2148.066455, 6428.948242, 7604.675781], [1670.188335, 2156.35545, 6426.725586, 7603.257813], [1646.591178, 2164.643307, 6424.937988, 7602.92334], [1622.994885, 2172.930037, 6422.460449, 7603.177734], [1599.399288, 2181.215797, 6419.297363, 7603.120117], [1575.804361, 2189.500666, 6415.875488, 7604.945801], [1552.20998, 2197.784797, 6411.48877, 7606.688477], [1528.616104, 2206.068271, 6406.59082, 7607.513672], [1505.022647, 2214.351197, 6401.625, 7610.512695], [1481.429562, 2222.633646, 6396.824219, 7613.96582], [1457.836779, 2230.915705, 6392.553223, 7620.90918], [1434.244243, 2239.197443, 6388.773438, 7625.759766], [1410.651902, 2247.478934, 6384.530762, 7628.694824], [1387.059705, 2255.76024, 6381.260254, 7627.88623], [1363.467605, 2264.041421, 6376.708496, 7613.099121], [1339.875555, 2272.32254, 6372.893066, 7601.568848], [1316.545366, 2280.2569, 6370.53125, 7603.719727], [1293.215067, 2288.191352, 6366.853027, 7610.368164], [1269.884547, 2296.125984, 6359.883301, 7630.210449], [1246.553691, 2304.060899, 6360.774902, 7615.999512], [1223.222389, 2311.99621, 6364.671387, 7612.831055], [1199.8905, 2319.932092, 6366.683105, 7610.670898], [1176.557884, 2327.868722, 6368.460449, 7609.104492], [1153.224349, 2335.806364, 6370.043457, 7606.472656], [1129.889756, 2343.745236, 6372.290527, 7606.388184], [1106.553879, 2351.685708, 6374.345703, 7607.649902], [1083.216548, 2359.628074, 6375.828125, 7607.479492], [1059.877466, 2367.572902, 6382.169434, 7607.85791], [1036.53643, 2375.520509, 6388.580566, 7605.468262], [1013.193103, 2383.471472, 6395.317383, 7598.28418], [989.8473723, 2391.425857, 6402.53418, 7590.192383], [966.4990005, 2399.384005, 6408.416992, 7589.700195], [943.148028, 2407.345747, 6415.430664, 7589.174316], [919.7943271, 2415.311144, 6419.162109, 7592.111816], [896.4380316, 2423.279751, 6418.780762, 7594.600586], [873.0793535, 2431.251063, 6419.940918, 7595.299316], [849.7186931, 2439.224746, 6421.73584, 7595.469727], [826.3563528, 2447.200376, 6421.033203, 7598.325684], [802.9923474, 2455.178102, 6420.391602, 7598.631836], [779.6273654, 2463.157461, 6420.636719, 7598.930664], [756.2615762, 2471.138581, 6420.718262, 7600.350586], [732.8946091, 2479.121365, 6421.179688, 7602.577637], [709.5262879, 2487.105436, 6422.424805, 7606.368652], [686.1578588, 2495.090036, 6423.913086, 7608.853516], [662.7896015, 2503.074326, 6426.604492, 7609.877441], [639.4207061, 2511.058853, 6429.391113, 7609.381348], [616.051578, 2519.043443, 6432.793457, 7609.244629], [592.6826827, 2527.026706, 6436.229004, 7610.686523], [569.3146308, 2535.009506, 6438.136719, 7610.031738], [545.9479499, 2542.993169, 6439.79541, 7610.63623], [522.5816123, 2550.976288, 6440.994629, 7609.947266], [499.2150095, 2558.957503, 6442.214844, 7608.502441], [475.8479772, 2566.937716, 6443.516602, 7606.569824], [452.4805681, 2574.917823, 6444.966309, 7604.903809], [440.7807383, 2580.250606, 6329.399902, 7721.295898], [1873.711244, 2060.886169, 6318.467773, 7722.560547], [1853.143144, 2067.799331, 6318.325195, 7722.490234], [1832.575044, 2074.712492, 6318.032227, 7722.358398], [1812.006944, 2081.625654, 6317.586914, 7722.167969], [1791.438843, 2088.538816, 6316.981445, 7721.936523], [1770.870743, 2095.451977, 6316.205078, 7721.695313], [1750.302643, 2102.365139, 6315.236816, 7721.529297], [1729.734543, 2109.2783, 6313.973633, 7721.624023], [1709.166443, 2116.191462, 6429.485352, 7604.841309], [1685.567527, 2124.481768, 6426.79541, 7604.704102], [1661.969532, 2132.77082, 6424.740234, 7604.087402], [1638.372428, 2141.058714, 6422.844727, 7603.782715], [1614.776112, 2149.34551, 6420.131348, 7603.564453], [1591.180536, 2157.631344, 6416.744629, 7604.333984], [1567.585608, 2165.916289, 6412.686035, 7605.339355], [1543.991258, 2174.200474, 6408.371582, 7606.769531], [1520.397402, 2182.483996, 6403.537598, 7607.060059], [1496.803964, 2190.766968, 6398.483398, 7607.346191], [1473.210886, 2199.049479, 6393.70752, 7612.5], [1449.618109, 2207.331604, 6389.223633, 7616.976563], [1426.025583, 2215.613412, 6385.171387, 7621.3125], [1402.433254, 2223.894964, 6382.640625, 7625.408203], [1378.841074, 2232.176327, 6378.995605, 7618.335938], [1355.248991, 2240.457562, 6373.203125, 7605.352539], [1331.656957, 2248.738734, 6369.581055, 7600.571777], [1308.326707, 2256.672871, 6367.507324, 7602.597168], [1284.996348, 2264.607103, 6365.382324, 7606.394043], [1261.665771, 2272.541526, 6359.303711, 7612.347168], [1238.334845, 2280.476253, 6354.976074, 7613.947266], [1215.003462, 2288.411404, 6359.641113, 7613.478516], [1191.671479, 2296.347124, 6362.652344, 7610.935547], [1168.338781, 2304.28356, 6364.410645, 7607.915527], [1145.005185, 2312.22096, 6366.069336, 7605.933105], [1121.670565, 2320.159571, 6366.989258, 7609.824219], [1098.334647, 2328.099837, 6367.904297, 7606.046875], [1074.997253, 2336.04206, 6370.473633, 7607.643555], [1051.658052, 2343.986769, 6375.845215, 7610.684082], [1028.316936, 2351.934176, 6383.266602, 7607.130859], [1004.973545, 2359.884873, 6391.616699, 7601.685059], [981.6278225, 2367.839014, 6399.435547, 7596.200195], [958.2794011, 2375.797048, 6405.104004, 7592.255859], [934.928339, 2383.758698, 6411.335938, 7591.581543], [911.5745174, 2391.723906, 6415.411621, 7593.313477], [888.2181924, 2399.692222, 6415.969238, 7594.006348], [864.8595118, 2407.663362, 6418.041504, 7594.433105], [841.4988252, 2415.636986, 6420.416992, 7595.699219], [818.1363619, 2423.612493, 6419.940918, 7598.666992], [794.772263, 2431.589939, 6418.256836, 7601.756348], [771.4072897, 2439.569092, 6418.425293, 7601.506836], [748.0415118, 2447.550185, 6418.555176, 7603.52002], [724.6744237, 2455.532856, 6419.140625, 7606.526855], [701.3060042, 2463.516613, 6420.035645, 7609.674316], [677.9375752, 2471.501081, 6421.470215, 7611.845215], [654.5693283, 2479.485361, 6424.32666, 7612.492188], [631.2003218, 2487.469676, 6427.402344, 7611.003906], [607.8310912, 2495.453996, 6431.609863, 7609.723633], [584.4622111, 2503.437235, 6434.868652, 7608.526367], [561.0941583, 2511.419935, 6437.368164, 7608.277344], [537.7273315, 2519.403293, 6439.239746, 7607.871582], [514.3609347, 2527.386318, 6440.498047, 7607.163574], [490.9943735, 2535.367508, 6441.696777, 7605.75], [467.6272577, 2543.347401, 6443.067383, 7603.705566], [444.2597141, 2551.327404, 6444.491699, 7602.009766], [420.8927376, 2559.308636, 6445.581055, 7603.047363], [1865.937356, 2037.099479, 6316.788086, 7721.642578], [1845.738805, 2043.844579, 6316.641602, 7721.583008], [1825.540255, 2050.58968, 6316.338867, 7721.455078], [1805.341705, 2057.33478, 6315.888184, 7721.266602], [1785.143155, 2064.079881, 6315.27832, 7721.033203], [1764.944605, 2070.824981, 6314.516113, 7720.777344], [1744.746055, 2077.570082, 6313.65625, 7720.560547], [1724.547505, 2084.315182, 6430.163574, 7603.253906], [1700.947659, 2092.606733, 6427.462891, 7603.835938], [1677.348713, 2100.897094, 6424.894531, 7603.963379], [1653.750757, 2109.186213, 6422.768066, 7604.283691], [1630.153628, 2117.474192, 6420.560059, 7603.849121], [1606.557363, 2125.761044, 6417.657227, 7604.286133], [1582.961794, 2134.046923, 6414.473633, 7604.339844], [1559.366895, 2142.331909, 6410.548828, 7604.800293], [1535.772542, 2150.616157, 6406.005371, 7605.163574], [1512.178693, 2158.899747, 6400.617188, 7606.379883], [1488.585264, 2167.182788, 6395.317383, 7608.228516], [1464.992205, 2175.465353, 6389.283203, 7611.997559], [1441.399449, 2183.747525, 6383.230957, 7616.950684], [1417.80694, 2192.029378, 6380.819824, 7620.876465], [1394.214624, 2200.310982, 6379.117188, 7622.76709], [1370.622454, 2208.592401, 6375.322266, 7610.975586], [1347.030382, 2216.873696, 6370.356445, 7599.442871], [1323.438359, 2225.154928, 6366.631348, 7601.569824], [1300.108035, 2233.088884, 6364.379883, 7602.631836], [1276.777602, 2241.022934, 6360.865234, 7606.549316], [1253.446948, 2248.957163, 6355.078613, 7612.645996], [1230.115957, 2256.891676, 6350.523438, 7616.28125], [1206.784521, 2264.826586, 6354.104492, 7613.856445], [1183.4525, 2272.762067, 6358.621094, 7611.271484], [1160.119753, 2280.698297, 6360.101074, 7608.780762], [1136.786085, 2288.635541, 6361.551758, 7606.430664], [1113.451362, 2296.574017, 6362.896484, 7611.17041], [1090.115356, 2304.514097, 6362.925781, 7612.618652], [1066.777896, 2312.456073, 6365.625, 7611.557129], [1043.438689, 2320.400515, 6370.00293, 7613.344238], [1020.09753, 2328.347742, 6377.663086, 7611.068359], [996.7540811, 2336.298331, 6386.43457, 7605.614746], [973.4082298, 2344.252347, 6393.62207, 7600.853027], [950.0597407, 2352.210132, 6399.945801, 7598.074707], [926.7086528, 2360.171519, 6405.671875, 7596.277832], [903.3548398, 2368.136568, 6410.174805, 7596.340332], [879.9984337, 2376.104833, 6413.301758, 7596.32959], [856.6396473, 2384.075808, 6415.77002, 7595.962402], [833.2788801, 2392.04916, 6418.125488, 7597.146973], [809.9164344, 2400.024463, 6419.18457, 7599.387207], [786.5523251, 2408.001868, 6417.211426, 7600.757324], [763.1872396, 2415.98091, 6416.744141, 7602.42334], [739.8213479, 2423.961718, 6416.552246, 7604.67334], [716.4542788, 2431.944194, 6417.472656, 7607.84668], [693.0858564, 2439.92796, 6418.497559, 7613.635254], [669.7173258, 2447.912259, 6420.129883, 7613.554199], [646.3489664, 2455.896249, 6422.597168, 7612.981445], [622.97997, 2463.880477, 6425.882813, 7611.325195], [599.6107399, 2471.864771, 6430.013672, 7609.310547], [576.2417425, 2479.847734, 6433.640625, 7607.739746], [552.8735876, 2487.830237, 6436.759277, 7605.404785], [529.5068027, 2495.813604, 6438.560547, 7605.70459], [506.1403602, 2503.796427, 6439.970703, 7604.361816], [482.773653, 2511.777344, 6441.200195, 7602.611816], [459.4065162, 2519.757257, 6442.622559, 7601.662598], [436.0390032, 2527.737064, 6444.04834, 7600.45752], [412.6718812, 2535.718045, 6444.944824, 7603.028809], [1857.784494, 2013.485085, 6315.263672, 7720.797852], [1837.57652, 2020.23442, 6315.106934, 7720.739258], [1817.368546, 2026.983755, 6314.805664, 7720.614258], [1797.160573, 2033.733091, 6314.34375, 7720.419922], [1776.952599, 2040.482426, 6313.717285, 7720.15625], [1756.744625, 2047.231762, 6312.933105, 7719.817383], [1736.536652, 2053.981097, 6312.005371, 7719.376953], [1716.328678, 2060.730432, 6428.256836, 7601.431641], [1692.728808, 2069.022074, 6425.47998, 7601.820313], [1669.129923, 2077.312501, 6423.046875, 7602.245117], [1645.531959, 2085.601672, 6420.796387, 7603.63623], [1621.934885, 2093.889683, 6418.305664, 7602.739258], [1598.338598, 2102.176594, 6415.37207, 7602.643066], [1574.743049, 2110.46254, 6412.175293, 7602.485352], [1551.14815, 2118.747598, 6408.138184, 7602.678223], [1527.553827, 2127.031894, 6403.617676, 7603.375], [1503.959998, 2135.315525, 6398.10791, 7603.974121], [1480.366586, 2143.598607, 6392.307617, 7607.330566], [1456.773534, 2151.881225, 6384.74707, 7612.325195], [1433.180784, 2160.163459, 6378.125977, 7616.939941], [1409.588284, 2168.445373, 6376.348633, 7620.779297], [1385.995981, 2176.727033, 6375.116699, 7617.569336], [1362.403827, 2185.008502, 6370.775391, 7606.313965], [1338.811769, 2193.289843, 6366.888184, 7599.134277], [1315.219761, 2201.571122, 6364.081055, 7602.321777], [1291.889379, 2209.504855, 6361.469727, 7602.469238], [1268.558889, 2217.438683, 6356.442871, 7605.226563], [1245.228181, 2225.372707, 6350.348145, 7611.067383], [1221.897124, 2233.307035, 6347.352051, 7616.428223], [1198.565611, 2241.241787, 6348.03125, 7616.457031], [1175.233499, 2249.177107, 6352.801758, 7611.807129], [1151.900672, 2257.113141, 6355.331055, 7610.215332], [1128.566949, 2265.050141, 6356.887207, 7608.716309], [1105.232201, 2272.988358, 6358.294922, 7610.265625], [1081.896156, 2280.928231, 6359.348145, 7616.431152], [1058.558641, 2288.870067, 6362.203613, 7618.343262], [1035.219317, 2296.814392, 6366.304688, 7615.438477], [1011.878081, 2304.76142, 6373.039063, 7614.294922], [988.5345723, 2312.711742, 6381.411621, 7609.516113], [965.1887334, 2320.665516, 6387.8125, 7604.149902], [941.8401975, 2328.623188, 6394.09082, 7603.714355], [918.4890229, 2336.584484, 6399.160156, 7601.978027], [895.1350916, 2344.549345, 6403.272461, 7600.935059], [871.7786579, 2352.517323, 6407.479004, 7601.751465], [848.419871, 2360.488128, 6411.630859, 7601.892578], [825.0590785, 2368.461423, 6415.508789, 7602.090332], [801.6965103, 2376.436605, 6417.344727, 7601.621582], [778.3323075, 2384.41373, 6417.144531, 7601.387207], [754.9672306, 2392.392569, 6417.332031, 7601.002441], [731.6013493, 2400.373352, 6416.577148, 7603.472656], [708.2341582, 2408.355717, 6416.374023, 7606.943359], [684.8656357, 2416.339173, 6417.088379, 7610.236816], [661.4971032, 2424.323341, 6419.012695, 7612.469238], [638.1287529, 2432.307324, 6421.229492, 7612.71582], [614.7596424, 2440.291343, 6424.981445, 7610.484863], [591.3903079, 2448.275368, 6429.002441, 7608.444824], [568.0213224, 2456.258312, 6432.772461, 7606.652344], [544.6531638, 2464.240716, 6435.686035, 7604.977051], [521.2862301, 2472.223779, 6437.841797, 7604.251953], [497.9197261, 2480.20651, 6439.401367, 7603.730469], [474.553058, 2488.187403, 6440.776367, 7601.682129], [451.1858349, 2496.166998, 6442.268555, 7600.015625], [427.8181845, 2504.146702, 6443.546875, 7600.676758], [404.4511002, 2512.127636, 6444.383301, 7602.322266], [1849.63163, 1989.870703, 6313.889648, 7720.029297], [1829.41423, 1996.624285, 6313.73584, 7719.969727], [1809.196831, 2003.377868, 6313.431641, 7719.835938], [1788.979432, 2010.13145, 6312.958984, 7719.633789], [1768.762033, 2016.885033, 6312.320801, 7719.34375], [1748.544633, 2023.638616, 6311.505371, 7718.947266], [1728.327234, 2030.392198, 6310.487793, 7718.375], [1708.109835, 2037.145781, 6426.592285, 7600.208496], [1684.510022, 2045.437449, 6423.959473, 7600.333008], [1660.911109, 2053.727924, 6421.503418, 7600.499023], [1637.313184, 2062.017157, 6419.063477, 7600.649902], [1613.716085, 2070.305247, 6416.042969, 7600.963867], [1590.119851, 2078.592208, 6413.157715, 7601.130859], [1566.524311, 2086.878195, 6409.814453, 7600.824219], [1542.92944, 2095.163287, 6406.038574, 7599.242676], [1519.335115, 2103.447639, 6401.636719, 7601.522949], [1495.741292, 2111.731333, 6395.901855, 7603.824707], [1472.147889, 2120.014477, 6388.874023, 7608.27832], [1448.554857, 2128.297141, 6380.980469, 7613.406738], [1424.962127, 2136.579415, 6375.605957, 7619.049316], [1401.369643, 2144.861367, 6373.139648, 7621.918457], [1377.777354, 2153.143072, 6371.45166, 7613.588379], [1354.185209, 2161.42459, 6368.015625, 7602.44873], [1330.593162, 2169.705984, 6364.278809, 7600.275391], [1307.001163, 2177.987316, 6361.438965, 7602.185059], [1283.670711, 2185.920872, 6358.514648, 7603.129883], [1260.340149, 2193.85452, 6353.541504, 7605.020996], [1237.009367, 2201.788348, 6347.062012, 7609.221191], [1213.678248, 2209.722461, 6343.086426, 7614.967773], [1190.346685, 2217.656971, 6343.144531, 7616.181152], [1167.014537, 2225.592053, 6346.478516, 7612.800293], [1143.681664, 2233.527887, 6350.365723, 7608.897949], [1120.347873, 2241.464734, 6351.880859, 7609.199707], [1097.013026, 2249.402817, 6354.290527, 7611.057617], [1073.676898, 2257.342506, 6358.15332, 7615.790039], [1050.339318, 2265.284093, 6359.899902, 7614.760742], [1026.999992, 2273.228153, 6363.314453, 7613.35498], [1003.658716, 2281.175001, 6369.513672, 7613.049316], [980.3151521, 2289.125218, 6376.710938, 7608.741699], [956.9691874, 2297.078868, 6381.75, 7604.728516], [933.6205867, 2305.036295, 6387.99707, 7604.267578], [910.2693901, 2312.997329, 6391.930664, 7605.10498], [886.9154679, 2320.962033, 6395.895996, 7606.553223], [863.5589555, 2328.92996, 6400.179199, 7608.350586], [840.2000632, 2336.900602, 6404.416504, 7610.711426], [816.8391911, 2344.873626, 6409.071777, 7607.377441], [793.4766415, 2352.848607, 6412.37793, 7604.207031], [770.1124277, 2360.825695, 6415.998535, 7601.08252], [746.7472383, 2368.804425, 6417.451172, 7600.008301], [723.3812421, 2376.784926, 6417.023926, 7601.743652], [700.0140686, 2384.767097, 6415.930664, 7605.608887], [676.6455418, 2392.750565, 6416.990234, 7609.104492], [653.2769063, 2400.734565, 6418.700195, 7610.49707], [629.9084411, 2408.71826, 6420.182617, 7610.649414], [606.5393378, 2416.702194, 6424.208008, 7609.73584], [583.1700018, 2424.686195, 6428.057617, 7608.365723], [559.8008967, 2432.668864, 6431.86084, 7606.997559], [536.432634, 2440.651073, 6435.106934, 7605.566895], [513.0657395, 2448.634148, 6437.223145, 7603.858887], [489.6991868, 2456.616678, 6438.744141, 7602.501953], [466.33237, 2464.597298, 6440.37207, 7601.467285], [442.9651235, 2472.576913, 6441.892578, 7600.046875], [419.5975003, 2480.556422, 6443.055664, 7600.836914], [396.2302687, 2488.537106, 6444.001465, 7602.009277], [1841.478766, 1966.256323, 6312.678711, 7719.317383], [1821.251943, 1973.014155, 6312.523438, 7719.261719], [1801.025119, 1979.771986, 6312.216797, 7719.143555], [1780.798295, 1986.529818, 6311.748047, 7718.946289], [1760.571471, 1993.28765, 6311.108887, 7718.663086], [1740.344647, 2000.045482, 6310.276367, 7718.255859], [1720.117823, 2006.803313, 6309.225098, 7717.619141], [1699.890999, 2013.561145, 6425.248535, 7599.085938], [1676.291165, 2021.852897, 6422.591309, 7599.291016], [1652.692314, 2030.143434, 6420.187988, 7598.28418], [1629.094382, 2038.432711, 6417.591797, 7599.032227], [1605.49734, 2046.720827, 6414.402344, 7599.689941], [1581.901084, 2055.007842, 6411.208008, 7600.186035], [1558.305565, 2063.293889, 6407.522949, 7600.023438], [1534.710695, 2071.579047, 6403.938477, 7600.001953], [1511.1164, 2079.86344, 6399.342285, 7601.126953], [1487.522598, 2088.147169, 6394.165039, 7603.513184], [1463.929213, 2096.430345, 6387.776855, 7608.955566], [1440.336188, 2104.713058, 6379.13623, 7614.79248], [1416.743463, 2112.995385, 6373.055176, 7620.383789], [1393.150989, 2121.277393, 6370.221191, 7622.227539], [1369.55871, 2129.559144, 6367.944336, 7610.883789], [1345.966582, 2137.840706, 6365.285156, 7599.100098], [1322.374549, 2146.122139, 6361.857422, 7601.262207], [1298.782565, 2154.40351, 6358.875, 7602.143555], [1275.452058, 2162.336846, 6355.141602, 7602.598633], [1252.121442, 2170.270276, 6349.927734, 7604.234863], [1228.790607, 2178.203898, 6344.28418, 7609.75293], [1205.459426, 2186.137825, 6338.022949, 7615.141113], [1182.127787, 2194.072177, 6337.843262, 7615.058105], [1158.795551, 2202.0071, 6342.412598, 7612.456055], [1135.462601, 2209.942741, 6345.729004, 7609.904785], [1112.128757, 2217.879349, 6349.713379, 7607.328125], [1088.79389, 2225.817174, 6353.193848, 7607.79541], [1065.457726, 2233.756658, 6357.428223, 7607.970215], [1042.120093, 2241.698107, 6360.527832, 7610.103027], [1018.780653, 2249.64205, 6364.225586, 7608.590332], [995.4393021, 2257.588701, 6368.734375, 7608.351074], [972.0956805, 2265.538654, 6371.814453, 7606.364258], [948.7497301, 2273.492064, 6376.177246, 7604.525391], [925.4010855, 2281.449381, 6381.063965, 7605.646973], [902.0498031, 2289.410327, 6385.380859, 7609.213379], [878.695765, 2297.374844, 6389.657227, 7611.054199], [855.3392259, 2305.342484, 6393.568359, 7612.623535], [831.9803341, 2313.312958, 6397.682617, 7612.825195], [808.6194372, 2321.285929, 6402.098633, 7611.158691], [785.256765, 2329.260791, 6406.341797, 7607.28125], [761.8924583, 2337.237603, 6411.512207, 7603.181641], [738.5272765, 2345.216132, 6414.078613, 7601.979004], [715.1612899, 2353.196608, 6414.586914, 7602.581543], [691.7939924, 2361.178673, 6414.907715, 7605.172363], [668.4253645, 2369.16183, 6415.479004, 7608.086426], [645.0567252, 2377.145703, 6415.815918, 7609.49707], [621.6882666, 2385.129391, 6419.208496, 7608.822754], [598.3190479, 2393.113117, 6424.296387, 7608.050781], [574.9496047, 2401.096851, 6427.713867, 7607.722168], [551.58051, 2409.079501, 6431.158203, 7607.043945], [528.2122407, 2417.061613, 6434.340332, 7605.751465], [504.8451955, 2425.044385, 6436.365723, 7603.710938], [481.4785789, 2433.026823, 6438.18457, 7602.186523], [458.1117983, 2441.007421, 6440.026855, 7602.070313], [434.7444631, 2448.986718, 6441.552246, 7601.555176], [411.3767007, 2456.966123, 6442.682617, 7601.847656], [388.0095043, 2464.94676, 6443.606934, 7603.470703], [1833.325901, 1942.641955, 6311.614258, 7718.665039], [1813.089649, 1949.404049, 6311.46582, 7718.615234], [1792.853398, 1956.166142, 6311.163574, 7718.516602], [1772.617146, 1962.928236, 6310.709961, 7718.348633], [1752.380895, 1969.690329, 6310.085938, 7718.112305], [1732.144644, 1976.452423, 6309.276855, 7717.797852], [1711.908392, 1983.214516, 6308.27002, 7717.37207], [1691.672141, 1989.97661, 6424.518066, 7599.327148], [1668.072364, 1998.268383, 6421.896484, 7599.243652], [1644.473488, 2006.558962, 6419.28418, 7599.199707], [1620.875598, 2014.848295, 6416.183594, 7599.309082], [1597.278533, 2023.136484, 6412.818848, 7599.62207], [1573.68233, 2031.423541, 6409.32373, 7600.685059], [1550.086822, 2039.709622, 6405.493652, 7601.726074], [1526.491981, 2047.994807, 6401.915039, 7600.038086], [1502.897684, 2056.27925, 6397.547852, 7601.053223], [1479.303891, 2064.563034, 6392.271973, 7603.665527], [1455.710515, 2072.846266, 6385.789063, 7609.394043], [1432.117509, 2081.129018, 6378.415039, 7615.328613], [1408.524805, 2089.411378, 6370.960938, 7619.691895], [1384.932348, 2097.693416, 6367.59668, 7622.383789], [1361.340083, 2105.975206, 6364.783203, 7611.018555], [1337.747964, 2114.256809, 6362.276855, 7599.718262], [1314.155942, 2122.538288, 6359.714355, 7601.87207], [1290.563967, 2130.819704, 6356.95752, 7603.240723], [1267.233391, 2138.752862, 6352.339355, 7604.932129], [1243.902705, 2146.686113, 6349.49707, 7605.533203], [1220.571799, 2154.619545, 6341.762207, 7609.211914], [1197.240558, 2162.553261, 6335.338379, 7612.974609], [1173.908872, 2170.487375, 6333.743652, 7613.127441], [1150.576603, 2178.422062, 6338.788574, 7609.588867], [1127.243608, 2186.357501, 6342.699707, 7606.38916], [1103.909697, 2194.293957, 6347.243164, 7603.925293], [1080.574733, 2202.23165, 6352.469727, 7602.318359], [1057.238488, 2210.170952, 6356.802246, 7603.708008], [1033.900793, 2218.112157, 6360.971191, 7604.95752], [1010.561353, 2226.055838, 6363.67041, 7603.759277], [987.219965, 2234.002313, 6366.341309, 7605.981934], [963.87629, 2241.952162, 6369.197266, 7605.387695], [940.5302165, 2249.905451, 6372.907715, 7605.57373], [917.1815071, 2257.862523, 6376.437012, 7607.091309], [893.8302037, 2265.823211, 6379.852051, 7611.035156], [870.4761766, 2273.787574, 6383.741699, 7614.076172], [847.1195593, 2281.755167, 6388.002441, 7615.855957], [823.7605626, 2289.725481, 6392.274902, 7614.70752], [800.3995865, 2297.698183, 6396.481445, 7612.483398], [777.0369325, 2305.672847, 6400.868652, 7608.94873], [753.6726138, 2313.649622, 6406.178711, 7606.464355], [730.307319, 2321.628043, 6410.485352, 7604.794922], [706.9412165, 2329.608239, 6410.75293, 7605.113281], [683.5739362, 2337.590111, 6411.261719, 7606.424316], [660.2053021, 2345.573282, 6416.271484, 7606.933594], [636.8365584, 2353.556989, 6415.390137, 7606.019531], [613.4679834, 2361.54039, 6419.448242, 7605.406738], [590.09877, 2369.524032, 6424.026855, 7605.033691], [566.7293229, 2377.507742, 6427.628418, 7605.253906], [543.3601066, 2385.49012, 6430.861816, 7607.481445], [519.9917315, 2393.472035, 6433.744629, 7604.435059], [496.624723, 2401.454819, 6435.85791, 7603.704102], [473.2580563, 2409.437057, 6437.8125, 7602.073242], [449.8911251, 2417.417381, 6439.558594, 7601.986816], [426.5237646, 2425.396699, 6441.131836, 7601.904785], [403.156028, 2433.375908, 6442.372559, 7602.59082], [379.7886823, 2441.356294, 6443.331543, 7604.328613], [1825.173035, 1919.02759, 6310.703613, 7718.070313], [1804.927356, 1925.793947, 6310.563965, 7718.03125], [1784.681677, 1932.560304, 6310.279785, 7717.951172], [1764.435999, 1939.326662, 6309.839844, 7717.822266], [1744.19032, 1946.093019, 6309.248535, 7717.649414], [1723.944641, 1952.859376, 6308.48291, 7717.450195], [1703.698962, 1959.625734, 6307.536621, 7717.260742], [1683.453284, 1966.392091, 6423.941406, 7599.655762], [1659.853488, 1974.683942, 6421.40625, 7599.979004], [1636.254675, 1982.974575, 6418.878906, 7600.035645], [1612.656781, 1991.263947, 6415.430176, 7600.037598], [1589.059773, 1999.552156, 6411.932129, 7601.050293], [1565.463552, 2007.839259, 6407.81543, 7601.827637], [1541.868065, 2016.125396, 6403.666504, 7601.868652], [1518.273228, 2024.410639, 6399.882813, 7600.607422], [1494.678962, 2032.695116, 6396.157227, 7600.496094], [1471.085191, 2040.978927, 6390.332031, 7602.521484], [1447.491834, 2049.262185, 6384.21875, 7608.665527], [1423.898837, 2057.544978, 6376.46582, 7614.736328], [1400.306139, 2065.827384, 6370.064453, 7620.011719], [1376.713691, 2074.10947, 6364.917969, 7622.214355], [1353.121439, 2082.3913, 6361.961426, 7616.690918], [1329.529335, 2090.672939, 6359.602539, 7608.181152], [1305.937328, 2098.954451, 6357.774414, 7603.265137], [1282.345369, 2107.235898, 6355.195801, 7603.529297], [1259.014739, 2115.168837, 6354.122559, 7603.572754], [1235.684001, 2123.101871, 6352.371582, 7604.895996], [1212.353045, 2131.0351, 6341.59668, 7607.254395], [1189.021741, 2138.968636, 6332.818359, 7608.356934], [1165.689982, 2146.902596, 6331.878418, 7610.538086], [1142.357627, 2154.837126, 6335.843262, 7606.303711], [1119.024557, 2162.772373, 6341.294434, 7602.499023], [1095.690595, 2170.708591, 6347.156738, 7600.032715], [1072.355611, 2178.646028, 6351.773438, 7599.217773], [1049.019331, 2186.585128, 6354.963379, 7598.648926], [1025.681584, 2194.526199, 6358.023926, 7600.729492], [1002.342032, 2202.469767, 6360.880859, 7601.624023], [979.0005706, 2210.416047, 6363.893066, 7602.00293], [955.6568403, 2218.365636, 6366.865723, 7603.26709], [932.3107821, 2226.318688, 6370.015625, 7606.453613], [908.9620298, 2234.275652, 6373.405762, 7609.599609], [885.6106415, 2242.236253, 6376.813965, 7612.60498], [862.2564985, 2250.200434, 6380.264648, 7615.521973], [838.899855, 2258.167744, 6383.524902, 7615.693359], [815.5408587, 2266.137893, 6386.845703, 7614.932129], [792.1798574, 2274.110544, 6390.647949, 7612.35498], [768.8170808, 2282.08509, 6395.362305, 7609.098145], [745.4526687, 2290.06159, 6400.492188, 7607.486816], [722.0873806, 2298.039811, 6403.695313, 7604.962891], [698.7212866, 2306.019986, 6405.050781, 7603.633789], [675.3538818, 2314.001751, 6409.785645, 7601.660645], [651.9851453, 2321.984614, 6414.251953, 7601.978516], [628.6163963, 2329.968193, 6417.603027, 7601.896973], [605.2478261, 2337.951589, 6421.538574, 7600.925293], [581.8784959, 2345.935023, 6425.12207, 7600.876953], [558.5089406, 2353.918466, 6428.010254, 7601.661133], [535.1397324, 2361.900824, 6430.825195, 7602.282715], [511.7713487, 2369.882642, 6433.070801, 7601.844727], [488.404188, 2377.865122, 6435.467773, 7601.628906], [465.0374561, 2385.847268, 6437.47998, 7599.944336], [441.6705601, 2393.82757, 6439.351563, 7600.146484], [418.3031095, 2401.806568, 6440.836426, 7602.088379], [394.9352317, 2409.785673, 6442.023438, 7604.024414], [371.5679194, 2417.766009, 6443.130371, 7605.643555], [1817.020165, 1895.413237, 6309.939941, 7717.520508], [1796.765056, 1902.183871, 6309.808105, 7717.49707], [1776.509946, 1908.954504, 6309.54248, 7717.430664], [1756.254837, 1915.725138, 6309.129883, 7717.336914], [1735.999727, 1922.495772, 6308.576172, 7717.21875], [1715.744618, 1929.266405, 6307.875, 7717.087891], [1695.489508, 1936.037039, 6307.019531, 7717.011719], [1675.234398, 1942.807673, 6423.59668, 7599.515625], [1651.634664, 1951.099538, 6421.051758, 7600.130371], [1628.035828, 1959.390208, 6418.217773, 7600.086914], [1604.437976, 1967.679629, 6414.683105, 7600.333008], [1580.840948, 1975.967903, 6411.041992, 7600.73291], [1557.244782, 1984.255043, 6406.739258, 7601.790039], [1533.649308, 1992.541206, 6402.573242, 7600.943359], [1510.054501, 2000.82647, 6398.79834, 7600.310059], [1486.460237, 2009.11099, 6394.791016, 7600.452148], [1462.866474, 2017.394849, 6389.539063, 7601.708008], [1439.273128, 2025.678155, 6383.921387, 7607.04541], [1415.680151, 2033.960981, 6374.609863, 7614.034668], [1392.087475, 2042.243413, 6366.333496, 7620.607422], [1368.495045, 2050.525524, 6362, 7624.021973], [1344.902808, 2058.807384, 6359.120605, 7621.511719], [1321.310715, 2067.089057, 6357.054199, 7614.009766], [1297.718719, 2075.370607, 6355.559082, 7607.020508], [1274.126771, 2083.652092, 6353.835449, 7604.062012], [1250.796074, 2091.584857, 6352.727539, 7601.683594], [1227.465267, 2099.517716, 6348.798828, 7602.637695], [1204.134239, 2107.450756, 6339.025391, 7604.541992], [1180.802878, 2115.384078, 6330.761719, 7607.399414], [1157.471072, 2123.317802, 6331.689453, 7608.305664], [1134.138685, 2131.252099, 6333.661621, 7603.323242], [1110.805572, 2139.187151, 6339.731445, 7599.902344], [1087.471545, 2147.123221, 6346.123047, 7598.503418], [1064.136465, 2155.060531, 6348.828125, 7598.453613], [1040.800106, 2162.999452, 6352.08252, 7598.523438], [1017.462298, 2170.94028, 6355.259766, 7600.368164], [994.1227465, 2178.883588, 6358.296387, 7603.646973], [970.7812468, 2186.829697, 6361.294434, 7603.388672], [947.4374631, 2194.779185, 6364.194336, 7604.890137], [924.0912819, 2202.732118, 6367.249512, 7607.923828], [900.7424666, 2210.688843, 6370.514648, 7611.040039], [877.3910564, 2218.64919, 6373.563477, 7614.575195], [854.0369244, 2226.613219, 6376.594238, 7616.776855], [830.6802026, 2234.580483, 6379.685059, 7616.64209], [807.3211015, 2242.550474, 6383.297852, 7613.917969], [783.9600205, 2250.522859, 6387.513184, 7610.92627], [760.5972611, 2258.497209, 6391.393066, 7608.902832], [737.2328371, 2266.473675, 6395.302246, 7606.639648], [713.8674355, 2274.45179, 6400.778809, 7603.417969], [690.5012247, 2282.431686, 6406.228027, 7599.58252], [667.1338356, 2290.413259, 6410.677734, 7596.972656], [643.7650919, 2298.396136, 6415.421875, 7596.080566], [620.3962371, 2306.379549, 6418.393066, 7596.982422], [597.0275501, 2314.362657, 6422.303223, 7596.470215], [573.6582236, 2322.346007, 6425.667969, 7596.518555], [550.2886631, 2330.329425, 6428.396973, 7596.867188], [526.9193324, 2338.311509, 6430.894043, 7597.53125], [503.5508418, 2346.293131, 6432.993164, 7597.622559], [480.183717, 2354.275621, 6435.221191, 7597.483398], [456.816933, 2362.257565, 6437.197754, 7598.425781], [433.4498849, 2370.237592, 6439.124512, 7599.8125], [410.0824077, 2378.216609, 6440.498535, 7602.286133], [386.7145542, 2386.195517, 6441.780762, 7605.35498], [363.3470912, 2394.175601, 6442.990723, 7606.696777], [1808.867296, 1871.798886, 6309.310547, 7717.011719], [1788.602755, 1878.573798, 6309.191406, 7716.992188], [1768.338214, 1885.348709, 6308.940918, 7716.944336], [1748.073673, 1892.123621, 6308.5625, 7716.875], [1727.809132, 1898.898533, 6308.055664, 7716.78418], [1707.544591, 1905.673445, 6307.42041, 7716.675781], [1687.28005, 1912.448356, 6306.656738, 7716.585938], [1667.015509, 1919.223268, 6423.304688, 7598.983887], [1643.415758, 1927.515205, 6420.79834, 7600.008789], [1619.816987, 1935.805922, 6417.560547, 7598.71875], [1596.219134, 1944.095376, 6413.956055, 7598.27832], [1572.622166, 1952.383663, 6410.328613, 7599.086914], [1549.025983, 1960.670844, 6405.927734, 7598.918457], [1525.430533, 1968.957054, 6401.621582, 7598.085449], [1501.835731, 1977.242369, 6397.890625, 7597.589355], [1478.2415, 1985.526917, 6393.597168, 7597.84082], [1454.647761, 1993.810797, 6388.655273, 7599.852051], [1431.054436, 2002.094124, 6383.45752, 7605.945313], [1407.46147, 2010.376983, 6373.028809, 7613.163086], [1383.868802, 2018.659454, 6362.742188, 7621.382813], [1360.276382, 2026.941605, 6359.257813, 7626.539063], [1336.684159, 2035.223499, 6356.07959, 7626.127441], [1313.092084, 2043.505202, 6354.480469, 7619.094727], [1289.500105, 2051.786775, 6353.563477, 7609.067383], [1265.908173, 2060.068286, 6351.772461, 7600.748535], [1242.577423, 2068.000836, 6351.18457, 7598.696289], [1219.246565, 2075.933481, 6344.164551, 7601.820313], [1195.915489, 2083.866319, 6334.083984, 7605.414063], [1172.584064, 2091.799463, 6328.457031, 7608.113281], [1149.252186, 2099.733034, 6328.261719, 7607.726074], [1125.919712, 2107.667178, 6330.749023, 7604.191406], [1102.586527, 2115.602043, 6338.260742, 7600.130859], [1079.252448, 2123.53788, 6344.293457, 7599.455078], [1055.917349, 2131.474937, 6346.198242, 7600.139648], [1032.580956, 2139.41366, 6349.056152, 7600.289063], [1009.243096, 2147.354356, 6352.249512, 7603.970215], [985.9034322, 2155.297555, 6354.759277, 7605.657715], [962.5618601, 2163.243472, 6358.116211, 7606.008301], [939.2180201, 2171.192703, 6361.401855, 7609.327637], [915.8718532, 2179.145404, 6364.157227, 7613.021973], [892.522995, 2187.102025, 6366.681152, 7617.461914], [869.1714999, 2195.062289, 6369.562988, 7618.100098], [845.8172511, 2203.026137, 6372.77002, 7617.613281], [822.4605022, 2210.99312, 6376.775879, 7615.469727], [799.101401, 2218.962949, 6381.249023, 7611.739746], [775.7402943, 2226.935284, 6385.46875, 7607.824219], [752.3774119, 2234.909519, 6390.631348, 7604.820801], [729.0128929, 2242.885712, 6395.920898, 7603.645508], [705.6474975, 2250.863629, 6401.601563, 7602.384766], [682.2812948, 2258.843504, 6405.481445, 7597.958984], [658.9137799, 2266.824971, 6412.541016, 7594.742676], [635.5449332, 2274.807538, 6417.977051, 7592.772949], [612.1760726, 2282.790824, 6419.664551, 7594.156738], [588.8073894, 2290.773925, 6422.530762, 7593.837891], [565.4379452, 2298.757066, 6425.587402, 7592.574219], [542.0682755, 2306.740215, 6428.46582, 7591.938965], [518.6989529, 2314.722279, 6430.866699, 7592.42627], [495.3304533, 2322.703802, 6432.98584, 7593.370117], [471.9631748, 2330.685987, 6435.063965, 7594.407715], [448.5963246, 2338.667837, 6437.066895, 7595.265137], [425.2293104, 2346.647839, 6438.770508, 7599.050293], [401.8617416, 2354.626534, 6440.134277, 7602.058594], [378.4937465, 2362.605335, 6441.491211, 7605.390137], [355.1263164, 2370.585368, 6442.759277, 7607.426758], [1800.714422, 1848.184547, 6308.807129, 7716.52832], [1780.440445, 1854.963748, 6308.695313, 7716.514648], [1760.166469, 1861.74295, 6308.465332, 7716.482422], [1739.892492, 1868.522151, 6308.12207, 7716.427734], [1719.618516, 1875.301353, 6307.661133, 7716.356445], [1699.344539, 1882.080555, 6307.095215, 7716.254883], [1679.070563, 1888.859756, 6306.445313, 7716.112305], [1658.796586, 1895.638958, 6423.256348, 7598.395508], [1635.196898, 1903.930903, 6420.679199, 7597.494141], [1611.598107, 1912.22165, 6417.076172, 7596.799805], [1588.000299, 1920.511146, 6413.238281, 7596.317871], [1564.403314, 1928.799494, 6409.52832, 7596.456055], [1540.807189, 1937.086704, 6405.508789, 7597.266113], [1517.211753, 1945.372935, 6401.391602, 7595.162598], [1493.616983, 1953.658265, 6397.304688, 7595.333984], [1470.022756, 1961.942849, 6393.169434, 7596.72168], [1446.429029, 1970.226771, 6389.682617, 7598.262207], [1422.835716, 1978.510139, 6381.739258, 7604.799316], [1399.242773, 1986.793024, 6367.992188, 7613.936035], [1375.650129, 1995.075516, 6359.477539, 7622.629395], [1352.05773, 2003.357684, 6357.368652, 7627.608398], [1328.465523, 2011.639602, 6354.243652, 7629.183594], [1304.87346, 2019.921332, 6353.214844, 7624.150391], [1281.281493, 2028.202938, 6352.100586, 7608.000488], [1257.689575, 2036.48448, 6349.17041, 7598.435547], [1234.358757, 2044.416858, 6348.009277, 7598.163574], [1211.027831, 2052.349329, 6338.393066, 7600.082031], [1187.696684, 2060.281982, 6328.579102, 7604.380859], [1164.365203, 2068.214921, 6326.080078, 7609.709961], [1141.033279, 2076.14826, 6324.174316, 7610.035156], [1117.700774, 2084.082174, 6327.499023, 7607.422363], [1094.367544, 2092.016844, 6333.094238, 7604.360352], [1071.033401, 2099.952534, 6338.32959, 7601.945313], [1047.698206, 2107.889467, 6341.711426, 7601.779297], [1024.361732, 2115.828014, 6345.228027, 7602.84668], [1001.02381, 2123.768474, 6347.650391, 7603.744629], [977.6841466, 2131.711417, 6350.336914, 7619.906738], [954.3425363, 2139.657166, 6352.98291, 7618.001953], [930.9986429, 2147.6063, 6355.38916, 7615.733887], [907.652352, 2155.558886, 6358.665039, 7618.728027], [884.303429, 2163.515269, 6362.585938, 7620.115723], [860.9519119, 2171.475281, 6366.164551, 7620.642578], [837.5976726, 2179.438981, 6369.654297, 7618.249512], [814.2408446, 2187.405923, 6374.294434, 7613.575684], [790.8816376, 2195.375596, 6380.606934, 7609.008789], [767.5204503, 2203.347667, 6386.041992, 7605.754883], [744.157584, 2211.321707, 6391.164063, 7603.619141], [720.7930522, 2219.297866, 6394.009766, 7603.106934], [697.4275424, 2227.275679, 6396.831055, 7602.213379], [674.0612224, 2235.255273, 6402.262695, 7598.712891], [650.6937227, 2243.236549, 6410.293945, 7595.151367], [627.3248684, 2251.219129, 6415.782227, 7592.04834], [603.9559015, 2259.202248, 6418.977539, 7591.061523], [580.5871005, 2267.185061, 6422.487305, 7590.21875], [557.2176601, 2275.168115, 6425.458008, 7589.19043], [533.8479851, 2283.151239, 6428.3125, 7588.063965], [510.4785385, 2291.133026, 6430.495117, 7588.960449], [487.1099317, 2299.11435, 6432.686035, 7590.011719], [463.7426885, 2307.096544, 6434.880371, 7592.388672], [440.3757863, 2315.078189, 6436.910156, 7595.191895], [417.0086195, 2323.057914, 6438.418945, 7598.354492], [393.641024, 2331.036626, 6439.754395, 7602.768555], [370.2730523, 2339.015227, 6441.070313, 7605.097656], [346.9054706, 2346.995004, 6442.344727, 7607.735352], [1792.561546, 1824.570208, 6308.417969, 7716.057617], [1772.278133, 1831.353701, 6308.311523, 7716.053711], [1751.99472, 1838.137193, 6308.106445, 7716.033203], [1731.711307, 1844.920685, 6307.79248, 7716.000977], [1711.427893, 1851.704178, 6307.375488, 7715.954102], [1691.14448, 1858.48767, 6306.861816, 7715.875977], [1670.861067, 1865.271163, 6306.279297, 7715.699219], [1650.577654, 1872.054655, 6423.10791, 7597.687988], [1626.977952, 1880.346667, 6420.371094, 7596.804199], [1603.37923, 1888.637455, 6416.992188, 7595.160156], [1579.781423, 1896.926977, 6413.104492, 7595.12207], [1556.1845, 1905.215331, 6409.135254, 7594.258301], [1532.588361, 1913.502576, 6405.092285, 7593.397949], [1508.992953, 1921.788848, 6400.783203, 7593.510742], [1485.398191, 1930.074225, 6396.557129, 7593.321289], [1461.803999, 1938.358831, 6392.085449, 7596.604004], [1438.210298, 1946.642767, 6388.416016, 7599.075195], [1414.617009, 1954.926149, 6381.154785, 7604.589355], [1391.024077, 1963.209063, 6363.129395, 7614.155762], [1367.431444, 1971.491587, 6356.190918, 7624.077148], [1343.839058, 1979.773791, 6355.886719, 7627.82666], [1320.246867, 1988.055735, 6353.76709, 7629.20459], [1296.654825, 1996.337488, 6352.741699, 7629.484863], [1273.062877, 2004.619113, 6350.901855, 7606.468262], [1249.470977, 2012.900674, 6347.610352, 7589.158203], [1226.140107, 2020.832838, 6341.56543, 7593.927734], [1202.809128, 2028.765099, 6331.447754, 7603.587891], [1179.477932, 2036.697556, 6323.366699, 7608.995605], [1156.14639, 2044.630319, 6322.244629, 7611.960938], [1132.814393, 2052.56351, 6321.09375, 7613.072266], [1109.481802, 2060.497274, 6324.491211, 7610.875], [1086.148498, 2068.431758, 6328.241211, 7607.893066], [1062.814303, 2076.367217, 6332.711426, 7605.480957], [1039.479088, 2084.303901, 6337.262207, 7604.126953], [1016.14258, 2092.242255, 6340.166504, 7604.318359], [992.8046049, 2100.182585, 6343.883301, 7608.208008], [969.4648285, 2108.125424, 6345.900391, 7628.976074], [946.1231438, 2116.070985, 6346.762695, 7631.319336], [922.7791923, 2124.019865, 6349.744629, 7621.699707], [899.4329157, 2131.972221, 6354.666992, 7625.035645], [876.0839478, 2139.928503, 6359.10498, 7624.189941], [852.732344, 2147.888435, 6363.234863, 7619.951172], [829.3779869, 2155.85196, 6369.226074, 7614.599121], [806.0211307, 2163.818623, 6375.412598, 7610.808105], [782.6619218, 2171.788136, 6381.533203, 7607.766113], [759.3007074, 2179.760159, 6385.879395, 7604.779785], [735.9377171, 2187.734085, 6390.205566, 7603.226074], [712.5730899, 2195.70997, 6392.728516, 7603.827148], [689.2075854, 2203.687584, 6394.250488, 7602.580566], [665.8412725, 2211.667158, 6399.763672, 7599.854004], [642.4736475, 2219.648327, 6407.577637, 7596.293457], [619.1046891, 2227.630597, 6413.536621, 7592.331543], [595.7357161, 2235.613586, 6419.21582, 7590.34082], [572.3669194, 2243.596391, 6422.364746, 7589.130859], [548.9973612, 2251.579236, 6424.590332, 7586.883301], [525.6275765, 2259.562088, 6427.537598, 7586.100586], [502.2581381, 2267.543852, 6430.067383, 7586.818359], [478.8895212, 2275.525074, 6432.353516, 7588.924805], [455.5221254, 2283.506959, 6434.62207, 7591.858398], [432.1551565, 2291.488508, 6436.625977, 7595.057129], [408.788024, 2299.468205, 6437.966797, 7598.197754], [385.4203369, 2307.446592, 6439.337891, 7601.325684], [362.0522236, 2315.425084, 6440.636719, 7604.283203], [338.6846738, 2323.404808, 6441.92041, 7606.655762], [1784.408667, 1800.955881, 6308.128906, 7715.603516], [1764.115812, 1807.743675, 6308.034668, 7715.602539], [1743.822957, 1814.531469, 6307.847168, 7715.599609], [1723.530103, 1821.319263, 6307.55957, 7715.584961], [1703.237248, 1828.107057, 6307.176758, 7715.576172], [1682.944394, 1834.894851, 6306.703613, 7715.59082], [1662.651539, 1841.682645, 6306.157715, 7715.663086], [1642.358685, 1848.470439, 6423.093262, 7598.416016], [1618.75905, 1856.762453, 6420.095215, 7596.536133], [1595.160309, 1865.053265, 6416.695313, 7594.927246], [1571.562551, 1873.342824, 6412.99707, 7594.277344], [1547.965613, 1881.631232, 6409.049316, 7592.590332], [1524.369534, 1889.918501, 6404.689941, 7592.574707], [1500.774144, 1898.204789, 6400.06543, 7592.977051], [1477.179417, 1906.490174, 6395.622559, 7594.662598], [1453.585231, 1914.774811, 6391.181641, 7596.563965], [1429.991544, 1923.058785, 6386.6875, 7599.075195], [1406.398271, 1931.342203, 6381.44043, 7605.57666], [1382.805365, 1939.625137, 6368.394531, 7616.010254], [1359.212758, 1947.907675, 6363.96875, 7623.380859], [1335.620395, 1956.18989, 6355.864258, 7626.646973], [1312.028223, 1964.471855, 6353.336426, 7627.555664], [1288.436195, 1972.75363, 6352.285645, 7621.568848], [1264.844264, 1981.035281, 6349.888184, 7598.187012], [1241.252379, 1989.316868, 6346.938965, 7585.812988], [1217.921441, 1997.248865, 6341.34668, 7591.621582], [1194.590395, 2005.180956, 6329.413086, 7602.375488], [1171.259128, 2013.113228, 6319.618652, 7608.055176], [1147.927527, 2021.045787, 6318.241211, 7612.917969], [1124.595484, 2028.978747, 6318.854492, 7614.811523], [1101.26286, 2036.912285, 6321.887695, 7613.723145], [1077.929513, 2044.84658, 6325.694824, 7608.582031], [1054.595252, 2052.781898, 6329.640137, 7605.929688], [1031.25994, 2060.718462, 6334.834961, 7604.327148], [1007.923349, 2068.656643, 6338.23291, 7605.834961], [984.5853125, 2076.596739, 6342.343262, 7609.433105], [961.2455343, 2084.539324, 6343.579102, 7618.366699], [937.9038105, 2092.48472, 6345.136719, 7629.748535], [914.5598037, 2100.433507, 6348.834473, 7623.983398], [891.2134002, 2108.385752, 6353.618652, 7623.618652], [867.8643656, 2116.341801, 6359.001953, 7621.283203], [844.5127379, 2124.301483, 6364.549316, 7617.706543], [821.1583894, 2132.26486, 6370.57959, 7615.214844], [797.8014522, 2140.231483, 6375.564453, 7610.899414], [774.442136, 2148.200842, 6380.566895, 7608.074707], [751.08084, 2156.172602, 6385.053223, 7606.584961], [727.7178645, 2164.146334, 6389.233398, 7605.28418], [704.353224, 2172.122188, 6391.027832, 7604.101563], [680.987604, 2180.099697, 6393.645508, 7602.968262], [657.6211734, 2188.07899, 6399.071777, 7599.210449], [634.2535626, 2196.059966, 6406.549805, 7597.075195], [610.8845967, 2204.042249, 6414.120605, 7594.569824], [587.5155173, 2212.025069, 6420.38623, 7592.396973], [564.1466028, 2220.007583, 6422.389648, 7590.247559], [540.7770485, 2227.990338, 6423.478516, 7586.452148], [517.407259, 2235.973162, 6426.195313, 7586.625], [494.0376975, 2243.954646, 6428.952148, 7586.594727], [470.6689738, 2251.935667, 6431.795898, 7588.617676], [447.3016134, 2259.917557, 6434.203125, 7591.416016], [423.9345924, 2267.898899, 6436.154785, 7595.029785], [400.5673069, 2275.878314, 6437.507324, 7598.166016], [377.1995931, 2283.856716, 6438.843262, 7601.441406], [353.8315026, 2291.835004, 6440.113281, 7603.419434], [342.5955749, 2296.997422, 6324.119629, 7720.803711], [1776.255785, 1777.341553, 6307.935547, 7715.150391], [1755.953488, 1784.133648, 6307.851074, 7715.157227], [1735.65119, 1790.925743, 6307.686035, 7715.161133], [1715.348893, 1797.717839, 6307.428223, 7715.166016], [1695.046595, 1804.509934, 6307.068848, 7715.182617], [1674.744298, 1811.302029, 6306.619141, 7715.248047], [1654.442001, 1818.094124, 6306.088867, 7715.420898], [1634.139703, 1824.88622, 6423.076172, 7598.33252], [1610.540057, 1833.178293, 6419.810547, 7597.125488], [1586.941389, 1841.469142, 6416.460938, 7595.86377], [1563.343634, 1849.758722, 6412.652832, 7593.966309], [1539.746761, 1858.047131, 6408.818359, 7593.226563], [1516.150671, 1866.334431, 6404.246582, 7593.187012], [1492.555311, 1874.620754, 6399.402832, 7594.143066], [1468.960594, 1882.90618, 6394.685059, 7596.125488], [1445.366447, 1891.190835, 6389.991211, 7598.076172], [1421.772789, 1899.474819, 6385.501953, 7599.990723], [1398.179543, 1907.758245, 6380.050781, 7604.208984], [1374.586652, 1916.041203, 6373.383789, 7613.089355], [1350.994059, 1924.32377, 6364.230469, 7620.016602], [1327.401711, 1932.606016, 6356.788574, 7624.369141], [1303.809559, 1940.888002, 6353.08252, 7625.416504], [1280.217554, 1949.169797, 6351.487793, 7610.674316], [1256.625644, 1957.451462, 6348.445313, 7588.197266], [1233.033781, 1965.733062, 6346.129883, 7581.285156], [1209.702791, 1973.66485, 6339.562988, 7589.196777], [1186.371691, 1981.596733, 6330.855957, 7600.870605], [1163.040374, 1989.52881, 6319.325684, 7607.406738], [1139.708712, 1997.461196, 6315.279297, 7613.905762], [1116.376595, 2005.39401, 6315.601074, 7616.263672], [1093.043884, 2013.3274, 6319.187012, 7613.696777], [1069.710461, 2021.261516, 6324.938477, 7609.067871], [1046.376146, 2029.196607, 6330.977051, 7606.197266], [1023.040814, 2037.132924, 6335.692871, 7605.372559], [999.7041887, 2045.070915, 6336.758301, 7606.581543], [976.3660965, 2053.010885, 6337.570313, 7610.426758], [953.0262028, 2060.953368, 6340.681641, 7615.915039], [929.6844028, 2068.89858, 6345.316406, 7625.990723], [906.3403359, 2076.847116, 6351.956055, 7624.383301], [882.9939448, 2084.799133, 6358.45166, 7623.863281], [859.6448635, 2092.755084, 6363.272949, 7620.785645], [836.2931471, 2100.714689, 6367.394043, 7618.452148], [812.9386789, 2108.677891, 6369.418945, 7614.432129], [789.5817112, 2116.644236, 6374.463867, 7611.166992], [766.2223921, 2124.613435, 6379.5, 7607.660156], [742.861068, 2132.585149, 6384.389648, 7608.094727], [719.4979671, 2140.558767, 6388.96582, 7604.437012], [696.1332302, 2148.534349, 6391.855469, 7603.788574], [672.7676146, 2156.511659, 6394.969727, 7600.79248], [649.4011906, 2164.49093, 6399.666504, 7599.466797], [626.033454, 2172.471798, 6405.643555, 7597.52002], [602.6643841, 2180.453768, 6413.70459, 7597.493652], [579.2952989, 2188.436458, 6419.248535, 7594.925781], [555.9263888, 2196.418961, 6420.772949, 7592.004883], [532.5567171, 2204.401503, 6422.710938, 7589.135254], [509.1868185, 2212.384052, 6425.384766, 7588.183105], [485.8172651, 2220.365512, 6428.069336, 7587.835938], [462.4485328, 2228.346427, 6430.964355, 7589.606934], [439.0810198, 2236.328005, 6433.643066, 7591.041504], [415.7139326, 2244.309246, 6435.368164, 7595.572754], [392.3466813, 2252.288631, 6436.833008, 7599.191895], [368.978876, 2260.266703, 6438.189941, 7601.760254], [345.6106444, 2268.244879, 6439.507324, 7602.930664], [334.4134265, 2273.393045, 6323.135254, 7719.536133], [1768.102899, 1753.727234, 6307.82666, 7714.706055], [1747.791154, 1760.52364, 6307.75293, 7714.710938], [1727.479408, 1767.320046, 6307.611816, 7714.71875], [1707.167663, 1774.116452, 6307.383789, 7714.728516], [1686.855918, 1780.912858, 6307.057617, 7714.743164], [1666.544172, 1787.709264, 6306.61377, 7714.791016], [1646.232427, 1794.50567, 6306.031738, 7714.923828], [1625.920682, 1801.302075, 6422.794922, 7597.806152], [1602.321104, 1809.594146, 6419.549805, 7596.680176], [1578.722421, 1817.885014, 6416.111328, 7595.396484], [1555.124717, 1826.174626, 6412.260254, 7594.45459], [1531.527833, 1834.463085, 6408.291504, 7594.109375], [1507.931806, 1842.750404, 6403.583008, 7594.946289], [1484.336466, 1851.036739, 6399.093262, 7596.575195], [1460.741788, 1859.322169, 6394.177246, 7598.299805], [1437.147651, 1867.606852, 6388.943359, 7600.293945], [1413.55401, 1875.890867, 6384.225586, 7602.379395], [1389.960782, 1884.174326, 6379.297363, 7604.935547], [1366.36792, 1892.4573, 6372.90918, 7610.711914], [1342.775357, 1900.739879, 6364.297852, 7618.124023], [1319.183036, 1909.022132, 6358.308105, 7623.353027], [1295.590905, 1917.304133, 6354.058105, 7624.680664], [1271.998918, 1925.585946, 6350.30127, 7602.40625], [1248.407027, 1933.867633, 6346.578613, 7577.47998], [1224.815183, 1942.149256, 6344.428711, 7578.980469], [1201.484124, 1950.080878, 6340.076172, 7584.045898], [1178.152955, 1958.012593, 6331.975098, 7594.083496], [1154.821568, 1965.944492, 6321.160156, 7604.23877], [1131.489846, 1973.876677, 6312.633789, 7613.697754], [1108.157682, 1981.809265, 6312.832031, 7620.617676], [1084.824937, 1989.742432, 6315.231445, 7620.76416], [1061.491468, 1997.676358, 6319.125488, 7611.363281], [1038.157087, 2005.611309, 6327.949707, 7608.579102], [1014.821654, 2013.547509, 6329.519043, 7610.091309], [991.484945, 2021.485331, 6329.623535, 7610.857422], [968.1467889, 2029.42507, 6333.79834, 7612.149902], [944.8068915, 2037.367304, 6341.900391, 7614.765137], [921.4650504, 2045.312352, 6349.34082, 7621.331055], [898.1209262, 2053.260798, 6355.896484, 7622.67627], [874.7744065, 2061.212706, 6360.816895, 7623.446777], [851.4252564, 2069.168424, 6365.984863, 7620.875977], [828.0735143, 2077.12778, 6368.930664, 7619.273926], [804.7190519, 2085.090837, 6368.853027, 7615.412109], [781.3620016, 2093.057145, 6373.702148, 7609.351563], [758.0025734, 2101.026191, 6380.963867, 7605.391113], [734.6411658, 2108.997641, 6384.880371, 7602.472168], [711.2780792, 2116.971065, 6388.634766, 7600.837402], [687.9133271, 2124.946613, 6393.023438, 7600.25293], [664.547596, 2132.923817, 6397.274414, 7598.70166], [641.1810534, 2140.902807, 6401.962891, 7597.371094], [617.813331, 2148.88348, 6408.132813, 7596.679688], [594.444254, 2156.865462, 6414.625488, 7596.082031], [571.0750625, 2164.84798, 6418.186035, 7594.87793], [547.706035, 2172.830189, 6419.850098, 7593.020508], [524.3363676, 2180.812641, 6422.073242, 7589.453125], [500.9664647, 2188.795159, 6424.867188, 7588.710449], [477.5967888, 2196.776335, 6427.644531, 7588.791992], [454.2279501, 2204.757045, 6430.385254, 7590.399414], [430.8604729, 2212.738626, 6432.953613, 7592.990723], [407.4933347, 2220.719655, 6434.538086, 7595.683105], [384.1259318, 2228.698756, 6436.071289, 7599.430664], [360.7581002, 2236.676839, 6437.374512, 7601.65625], [337.3898925, 2244.654809, 6438.658691, 7602.729492], [326.2313314, 2249.788695, 6322.119141, 7718.524414], [1759.950011, 1730.112913, 6307.79541, 7714.261719], [1739.628816, 1736.913628, 6307.736816, 7714.262695], [1719.307621, 1743.714342, 6307.621582, 7714.270508], [1698.986425, 1750.515057, 6307.436035, 7714.270508], [1678.66523, 1757.315771, 6307.161133, 7714.268555], [1658.344035, 1764.116486, 6306.75293, 7714.254883], [1638.02284, 1770.9172, 6306.115234, 7714.176758], [1617.701645, 1777.717915, 6422.5, 7596.516602], [1594.102059, 1786.010042, 6419.343262, 7594.852539], [1570.503451, 1794.300942, 6415.712891, 7594.980469], [1546.905754, 1802.590572, 6411.864746, 7594.881348], [1523.308938, 1810.879028, 6407.781738, 7594.989746], [1499.712902, 1819.166372, 6403.445313, 7595.852051], [1476.117596, 1827.45274, 6398.89502, 7597.152832], [1452.522932, 1835.738208, 6394.227051, 7600.189941], [1428.928835, 1844.022904, 6388.810059, 7601.898926], [1405.335227, 1852.306926, 6383.248535, 7604.638672], [1381.742029, 1860.590391, 6378.286133, 7607.822754], [1358.149185, 1868.873387, 6371.833984, 7612.523438], [1334.556639, 1877.155989, 6364.597168, 7617.461914], [1310.964338, 1885.43827, 6359.573242, 7620.406738], [1287.37223, 1893.72029, 6353.775879, 7620.495605], [1263.78027, 1902.002119, 6350.153809, 7601.306152], [1240.188404, 1910.283816, 6345.896484, 7572.001953], [1216.596585, 1918.565451, 6342.748535, 7577.181152], [1193.265471, 1926.496864, 6340.863281, 7580.19873], [1169.93425, 1934.428374, 6332.158203, 7589.254883], [1146.602811, 1942.360081, 6321.914063, 7599.857422], [1123.271026, 1950.292098, 6313.718262, 7611.965332], [1099.938787, 1958.224544, 6311.866699, 7617.757324], [1076.605954, 1966.157567, 6311.441406, 7621.652344], [1053.272408, 1974.091313, 6314.922852, 7614.611816], [1029.937971, 1982.026039, 6319.712891, 7611.446289], [1006.602516, 1989.961994, 6321.820313, 7612.51123], [983.2657681, 1997.899627, 6326.165527, 7614.311035], [959.9275548, 2005.839244, 6335.736328, 7617.626465], [936.587541, 2013.781379, 6345.34375, 7622.204102], [913.2456207, 2021.726245, 6350.63623, 7624.627441], [889.9014346, 2029.674441, 6355.372559, 7624.092285], [866.5549244, 2037.626123, 6360.444336, 7626.891113], [843.2057257, 2045.581743, 6365.100586, 7621.335449], [819.853893, 2053.541023, 6367.578125, 7620.594727], [796.4993085, 2061.503906, 6368.81543, 7614.140625], [773.1422262, 2069.469937, 6373.65625, 7608.21582], [749.7827932, 2077.438824, 6382.145508, 7601.272461], [726.4213556, 2085.410227, 6386.594727, 7597.90332], [703.0581427, 2093.383536, 6389.477051, 7595.975586], [679.6932933, 2101.35881, 6393.975098, 7596.986328], [656.327566, 2109.335814, 6399.063965, 7596.739258], [632.9610296, 2117.314781, 6404.183594, 7596.70166], [609.5931813, 2125.295346, 6409.450195, 7595.753418], [586.2240003, 2133.277012, 6414.825684, 7595.831055], [562.8548031, 2141.259396, 6418.005859, 7593.245117], [539.4857804, 2149.241594, 6419.815918, 7590.041016], [516.1159967, 2157.223829, 6422.127441, 7588], [492.7459851, 2165.20607, 6424.644531, 7587.377441], [469.3763182, 2173.187218, 6427.244141, 7587.605957], [446.007471, 2181.167819, 6429.962402, 7591.943848], [422.6398421, 2189.149084, 6432.116211, 7592.47998], [399.272639, 2197.13001, 6433.793457, 7594.841309], [375.9052709, 2205.109077, 6435.352539, 7598.087402], [352.5373493, 2213.086829, 6436.5625, 7600.041992], [337.3346768, 2219.159203, 6320.835449, 7716.886719], [322.1320043, 2225.231578, 6320.962402, 7716.90625], [1751.797117, 1706.498601, 6307.822266, 7713.821289], [1731.466467, 1713.303632, 6307.782715, 7713.823242], [1711.135817, 1720.108663, 6307.704102, 7713.825195], [1690.805166, 1726.913694, 6307.580566, 7713.817383], [1670.474516, 1733.718725, 6307.398438, 7713.813477], [1650.143866, 1740.523755, 6307.119629, 7713.771484], [1629.813215, 1747.328786, 6306.584961, 7713.604492], [1609.482565, 1754.133817, 6422.437988, 7595.53418], [1585.883052, 1762.425938, 6419.195801, 7594.553711], [1562.284431, 1770.716854, 6415.318848, 7594.149902], [1538.686788, 1779.006512, 6411.473145, 7594.35498], [1515.089964, 1787.295016, 6407.313477, 7593.958008], [1491.493994, 1795.582377, 6403.844727, 7594.808105], [1467.898712, 1803.868752, 6399.29248, 7596.406738], [1444.30409, 1812.154222, 6394.305176, 7598.967773], [1420.710005, 1820.438943, 6388.590332, 7602.211426], [1397.116417, 1828.722995, 6382.511719, 7605.865723], [1373.523242, 1837.00649, 6376.830078, 7609.184082], [1349.930431, 1845.289498, 6371.39502, 7612.416504], [1326.337918, 1853.57211, 6366.325195, 7615.497559], [1302.745646, 1861.854396, 6359.552734, 7616.564453], [1279.153565, 1870.136429, 6353.210449, 7616.859375], [1255.561626, 1878.418273, 6349.99707, 7605.398438], [1231.969783, 1886.699991, 6346.09082, 7586.463379], [1208.377987, 1894.981645, 6341.70166, 7576.897461], [1185.046804, 1902.912896, 6339.617676, 7577.518555], [1161.715511, 1910.844241, 6333.54834, 7584.268066], [1138.384, 1918.77577, 6322.590332, 7595.25293], [1115.052154, 1926.707587, 6316.478516, 7607.65332], [1091.719866, 1934.639808, 6312.391602, 7613.813965], [1068.386997, 1942.572608, 6310.49707, 7618.557129], [1045.053404, 1950.506171, 6311.874023, 7610.140137], [1021.718899, 1958.440761, 6315.737305, 7613.34668], [998.3833424, 1966.376602, 6319.874023, 7610.851074], [975.0465091, 1974.314067, 6326.280273, 7614.425781], [951.70823, 1982.253454, 6336.000488, 7617.11377], [928.3682086, 1990.195339, 6344.035645, 7624.330566], [905.0262445, 1998.140043, 6348.102051, 7628.756836], [881.6819983, 2006.088149, 6353.491211, 7627.940918], [858.3353583, 2014.039723, 6358.589844, 7628.251465], [834.9860872, 2021.995112, 6363.662109, 7627.227539], [811.6342268, 2029.954145, 6364.526367, 7622.929688], [788.2796466, 2037.916882, 6365.256836, 7615.089844], [764.92248, 2045.882874, 6371.82666, 7609.804199], [741.5629368, 2053.851606, 6380.804199, 7601.560059], [718.2014143, 2061.822745, 6386.586914, 7596.630371], [694.8382138, 2069.79586, 6390.866699, 7594.745117], [671.4733491, 2077.7711, 6395.102539, 7595.681641], [648.107505, 2085.747997, 6400.257324, 7597.944824], [624.7408503, 2093.726681, 6405.491699, 7597.351074], [601.3730159, 2101.707048, 6410.62793, 7595.841797], [578.0038273, 2109.688724, 6414.885742, 7593.248535], [554.6345238, 2117.670935, 6417.473145, 7590.627441], [531.2653847, 2125.652836, 6420.085449, 7588.030273], [507.8956053, 2133.634978, 6422.532227, 7585.07373], [484.5255903, 2141.617185, 6424.962891, 7584.856934], [461.1558018, 2149.598046, 6427.439941, 7586.950195], [437.7868492, 2157.57844, 6429.749023, 7589.503906], [414.4192571, 2165.559704, 6431.607422, 7591.736816], [391.0520034, 2173.540416, 6433.340332, 7593.652344], [367.6844847, 2181.519195, 6434.729004, 7596.401367], [344.3165373, 2189.496955, 6436.025879, 7598.585938], [329.139656, 2195.559744, 6319.910156, 7715.107422], [313.9627747, 2201.622533, 6319.938477, 7715.305664], [1744.109988, 1682.672281, 6307.891602, 7713.380859], [1724.235647, 1689.269621, 6307.866699, 7713.376953], [1704.361306, 1695.866961, 6307.830566, 7713.373047], [1684.486965, 1702.464301, 6307.780762, 7713.368164], [1664.612623, 1709.061641, 6307.731445, 7713.371094], [1644.738282, 1715.658982, 6307.728027, 7713.428711], [1624.863941, 1722.256322, 6425.128906, 7596.486328], [1601.263467, 1730.549691, 6422.416016, 7593.391602], [1577.663949, 1738.841866, 6419.058105, 7592.863281], [1554.065406, 1747.132811, 6415.253906, 7593.143555], [1530.467773, 1755.422483, 6411.943359, 7592.532227], [1506.87102, 1763.710981, 6408.520996, 7592.19043], [1483.275045, 1771.998366, 6404.990234, 7592.784668], [1459.679798, 1780.284773, 6400.268066, 7594.318848], [1436.085193, 1788.570278, 6395.568848, 7597.536133], [1412.491155, 1796.855009, 6389.151855, 7601.778809], [1388.897603, 1805.139068, 6382.784668, 7605.976563], [1365.304461, 1813.422566, 6377.661621, 7609.599121], [1341.711673, 1821.705594, 6373.599121, 7611.500977], [1318.119179, 1829.988229, 6368.157227, 7612.970703], [1294.526932, 1838.27054, 6362.020996, 7612.510742], [1270.934877, 1846.55259, 6356.45459, 7612.273926], [1247.34297, 1854.834448, 6351.922363, 7605.445313], [1223.751155, 1863.116176, 6346.895508, 7593.104004], [1200.159389, 1871.397839, 6341.677246, 7578.816406], [1176.82815, 1879.328885, 6338.660645, 7576.512695], [1153.496803, 1887.260028, 6336.841309, 7580.03125], [1130.165238, 1895.191367, 6326.949219, 7590.085938], [1106.833327, 1903.123015, 6320.503418, 7599.371094], [1083.500962, 1911.055094, 6314.248535, 7610.213867], [1060.168002, 1918.987752, 6310.401855, 7618.350098], [1036.834331, 1926.921139, 6309.050293, 7613.590332], [1013.499769, 1934.855506, 6313.32373, 7612.92041], [990.1641875, 1942.791105, 6317.561035, 7609.629883], [966.8273141, 1950.728383, 6326.146973, 7615.91748], [943.4889749, 1958.667648, 6336.217773, 7617.754883], [920.1488352, 1966.609433, 6342.424316, 7625.13916], [896.8067891, 1974.553955, 6345.768555, 7633.366699], [873.462479, 1982.501812, 6350.45752, 7630.523438], [850.1158457, 1990.453161, 6355.279297, 7632.65625], [826.766525, 1998.408453, 6359.13623, 7630.711426], [803.4145712, 2006.367409, 6360.23584, 7627.000977], [780.0598679, 2014.329971, 6363.234863, 7621.692871], [756.7026674, 2022.295682, 6370.561523, 7614.50293], [733.3431176, 2030.264255, 6378.501465, 7604.915039], [709.9815641, 2038.235346, 6383.370605, 7600.093262], [686.6182363, 2046.208346, 6389.029297, 7598.079102], [663.2532729, 2054.18331, 6395.381348, 7596.540527], [639.8874321, 2062.160006, 6401.043457, 7596.946777], [616.5207827, 2070.138665, 6406.799805, 7597.326172], [593.1528219, 2078.118922, 6412.136719, 7595.753418], [569.7835298, 2086.100279, 6415.569336, 7592.742188], [546.414221, 2094.082356, 6418.052734, 7589.345703], [523.0450868, 2102.064243, 6420.296875, 7586.264648], [499.675191, 2110.046165, 6422.726074, 7584.73291], [476.3050682, 2118.028092, 6425.099121, 7584.92041], [452.9352893, 2126.008922, 6427.268555, 7585.511719], [429.56633, 2133.989205, 6429.408203, 7589.117188], [406.1985867, 2141.970151, 6431.391113, 7592.060059], [382.8312687, 2149.950757, 6433.080078, 7593.668945], [359.4637862, 2157.9295, 6434.508789, 7594.722656], [336.0957491, 2165.906924, 6435.629395, 7596.070313], [320.9446511, 2171.960181, 6319.098145, 7713.412109], [305.793553, 2178.013437, 6318.936523, 7713.898438], [1735.955728, 1659.058582, 6307.976563, 7712.944336], [1716.070566, 1665.660853, 6307.968262, 7712.938477], [1696.185403, 1672.263124, 6307.973633, 7712.918945], [1676.300241, 1678.865395, 6307.985352, 7712.901367], [1656.415079, 1685.467665, 6308.013672, 7712.886719], [1636.529916, 1692.069936, 6308.081055, 7712.931641], [1616.644754, 1698.672207, 6425.313477, 7596.005859], [1593.044324, 1706.965616, 6422.476074, 7593.585449], [1569.444881, 1715.257781, 6419.541016, 7591.835938], [1545.846329, 1723.54874, 6416.407715, 7591.904297], [1522.248754, 1731.83844, 6413.049805, 7590.683594], [1498.651994, 1740.126983, 6409.368652, 7589.002441], [1475.05609, 1748.414383, 6405.214844, 7591.156738], [1451.46087, 1756.700796, 6400.798828, 7593.611816], [1427.86631, 1764.986302, 6396.192383, 7597.168945], [1404.272288, 1773.271057, 6389.826172, 7601.59082], [1380.67876, 1781.555143, 6383.452148, 7606.177246], [1357.085643, 1789.83867, 6377.485352, 7609.728027], [1333.492892, 1798.12171, 6373.502441, 7610.258301], [1309.900436, 1806.404353, 6368.70459, 7610.82373], [1286.308223, 1814.686669, 6363.770508, 7610.657715], [1262.716199, 1822.96873, 6359.441406, 7609.706543], [1239.124317, 1831.250604, 6354.629883, 7608.691406], [1215.53253, 1839.532351, 6349.507324, 7602.811035], [1191.940791, 1847.814033, 6344.146973, 7583.242188], [1168.60948, 1855.744917, 6339.847168, 7576.618164], [1145.278061, 1863.675897, 6336.77832, 7579.40918], [1121.946421, 1871.607061, 6331.965332, 7586.024414], [1098.614447, 1879.538513, 6325.203613, 7593.645508], [1075.282032, 1887.470371, 6316.580078, 7607.992676], [1051.949034, 1895.402809, 6307.33252, 7620.309082], [1028.615314, 1903.336009, 6307.470703, 7628.864746], [1005.280679, 1911.27024, 6311.464355, 7626.121094], [981.9449943, 1919.205724, 6316.138672, 7620.799805], [958.6080332, 1927.142835, 6327.154785, 7615.791992], [935.2696254, 1935.081871, 6338.167969, 7612.342773], [911.9294771, 1943.023408, 6342.172852, 7620.477051], [888.5873862, 1950.967768, 6345.249023, 7627.604004], [865.243014, 1958.915535, 6348.801758, 7632.515625], [841.8962482, 1966.866774, 6352.467773, 7632.327637], [818.5468541, 1974.821833, 6355.469238, 7631.462891], [795.1948707, 1982.780539, 6358.177734, 7632.882813], [771.8401693, 1990.742955, 6363.339355, 7625.477051], [748.482883, 1998.708627, 6369.227051, 7617.703613], [725.1232211, 2006.677045, 6375.895996, 7610.678223], [701.7615818, 2014.647871, 6382.173828, 7605.303223], [678.3982654, 2022.620672, 6388.220215, 7600.969238], [655.0332858, 2030.595601, 6394.845215, 7599.734375], [631.6673273, 2038.572187, 6400.787109, 7598.703613], [608.3005591, 2046.550561, 6406.491699, 7597.274414], [584.9326122, 2054.530619, 6412.399414, 7594.270996], [561.5633124, 2062.511984, 6415.50293, 7591.932129], [538.1938978, 2070.493886, 6418.492188, 7589.297852], [514.8246472, 2078.475474, 6420.577637, 7587.111816], [491.4547566, 2086.457301, 6422.762207, 7586.033203], [468.0846305, 2094.439193, 6424.993164, 7586.785645], [444.7147305, 2102.419735, 6427.027344, 7588.71582], [421.3456658, 2110.399807, 6429.012207, 7591.459961], [397.9779606, 2118.38075, 6431.033691, 7593.138672], [374.6105935, 2126.36114, 6432.85791, 7594.352051], [351.2429608, 2134.339593, 6434.531738, 7593.709473], [334.0569747, 2140.866711, 6318.338867, 7711.456055], [316.8709887, 2147.393829, 6317.966309, 7712.514648], [299.6850026, 2153.920947, 6317.773438, 7712.980469], [1727.801467, 1635.444883, 6308.060059, 7712.517578], [1707.905483, 1642.052083, 6308.074219, 7712.503906], [1688.009498, 1648.659284, 6308.110352, 7712.46875], [1668.113514, 1655.266484, 6308.166504, 7712.422852], [1648.217529, 1661.873685, 6308.244629, 7712.356445], [1628.321544, 1668.480885, 6308.338867, 7712.325195], [1608.42556, 1675.088086, 6425.346191, 7595.469727], [1584.82516, 1683.3815, 6422.762695, 7593.246094], [1561.225716, 1691.673718, 6419.810059, 7590.914551], [1537.627245, 1699.964704, 6416.837402, 7589.904785], [1514.029682, 1708.254418, 6413.391113, 7589.383301], [1490.432998, 1716.542955, 6409.878906, 7589.260742], [1466.837091, 1724.830376, 6405.381348, 7590.558105], [1443.241911, 1733.116819, 6400.654785, 7593.389648], [1419.647371, 1741.40236, 6395.689941, 7596.839844], [1396.053398, 1749.687125, 6389.796387, 7601.666016], [1372.459911, 1757.971216, 6384.019531, 7606.208984], [1348.866832, 1766.254746, 6378.177246, 7608.258789], [1325.274107, 1774.537806, 6372.885254, 7609.04248], [1301.681676, 1782.820471, 6368.168945, 7609.220703], [1278.08949, 1791.102812, 6363.476563, 7609.875], [1254.497497, 1799.384892, 6359.467773, 7609.486328], [1230.90565, 1807.666779, 6355.70752, 7608.244629], [1207.313898, 1815.948536, 6351.627441, 7601.061035], [1183.722193, 1824.230227, 6346.902344, 7590.672852], [1160.390824, 1832.160908, 6342.964844, 7582.446777], [1137.059346, 1840.091685, 6339.540039, 7579.295898], [1113.727652, 1848.022661, 6334.109863, 7583.002441], [1090.395611, 1855.953948, 6329.12207, 7592.887695], [1067.063117, 1863.885666, 6319.992676, 7608.454102], [1043.730027, 1871.817962, 6306.553223, 7625.3125], [1020.396225, 1879.750987, 6306.429199, 7638.805176], [997.061532, 1887.684994, 6310.705566, 7635.716309], [973.7258193, 1895.620234, 6317.689941, 7628.600098], [950.3888162, 1903.557158, 6328.647461, 7621.763184], [927.0503464, 1911.496073, 6337.045898, 7620.160156], [903.710078, 1919.43751, 6341.596191, 7621.288086], [880.3679031, 1927.381688, 6345.222656, 7624.335938], [857.0234652, 1935.329204, 6348.597168, 7625.59375], [833.6767051, 1943.280215, 6351.769531, 7628.271973], [810.3272575, 1951.235175, 6353.043457, 7630.957031], [786.9751797, 1959.193803, 6356.177246, 7629.819336], [763.6203539, 1967.156041, 6359.667969, 7626.789063], [740.2630323, 1975.121434, 6363.463867, 7620.193848], [716.9033628, 1983.089689, 6372.146973, 7614.274414], [693.541691, 1991.060465, 6380.469238, 7609.587891], [670.1782459, 1999.033149, 6386.943848, 7604.880371], [646.8131671, 2007.007799, 6393.79541, 7601.815918], [623.4472115, 2014.984182, 6400.491699, 7600.283203], [600.080448, 2022.962529, 6406.211914, 7598.443359], [576.7123747, 2030.942475, 6411.063477, 7595.175293], [553.3429706, 2038.923522, 6414.481445, 7591.750488], [529.9735507, 2046.905286, 6417.773926, 7589.625488], [506.6043048, 2054.886858, 6420.17041, 7589.436523], [483.2342989, 2062.868465, 6422.550781, 7589.744141], [459.8640656, 2070.850075, 6424.615723, 7590.380371], [436.4941755, 2078.830585, 6426.55127, 7591.879883], [413.1251042, 2086.810544, 6428.587891, 7594.384766], [389.7572488, 2094.791167, 6430.688477, 7595.870605], [366.3898187, 2102.771449, 6432.80957, 7595.124512], [343.0222237, 2110.749865, 6434.399414, 7594.623047], [325.8555623, 2117.269757, 6317.188477, 7711.572266], [308.6889009, 2123.78965, 6316.649414, 7712.205078], [291.5222394, 2130.309543, 6316.420898, 7712.526367], [1719.647197, 1611.831184, 6308.133789, 7712.100586], [1699.740381, 1618.443315, 6308.160156, 7712.085938], [1679.833565, 1625.055447, 6308.220215, 7712.040039], [1659.926749, 1631.667578, 6308.319336, 7711.946289], [1640.019932, 1638.279709, 6308.479492, 7711.782227], [1620.113116, 1644.891841, 6308.689941, 7711.544922], [1600.2063, 1651.503972, 6425.785645, 7594.475098], [1576.605948, 1659.797425, 6422.922852, 7592.34375], [1553.006583, 1668.089633, 6420.054688, 7590.617676], [1529.408105, 1676.380632, 6416.98877, 7589.92627], [1505.810603, 1684.670372, 6411.912598, 7590.856934], [1482.213917, 1692.958953, 6406.804199, 7591.754395], [1458.618083, 1701.24639, 6403.094727, 7591.264648], [1435.022935, 1709.532839, 6399.324219, 7593.353027], [1411.428443, 1717.818379, 6395.08252, 7596.377441], [1387.83449, 1726.103168, 6389.625977, 7600.724609], [1364.24103, 1734.387288, 6384.172852, 7603.875], [1340.647982, 1742.670848, 6378.560059, 7606.248047], [1317.055298, 1750.953919, 6373.442383, 7607.751465], [1293.462909, 1759.236593, 6368.201172, 7609.538574], [1269.870762, 1767.518939, 6363.339355, 7610.865234], [1246.278805, 1775.801031, 6359.078125, 7610.356445], [1222.686989, 1784.082933, 6355.111816, 7609.154785], [1199.095269, 1792.36471, 6351.713379, 7605.464844], [1175.503595, 1800.646421, 6348.841309, 7594.222168], [1152.172152, 1808.576942, 6345.668945, 7586.41748], [1128.8406, 1816.507559, 6342.239258, 7581.929688], [1105.508828, 1824.438358, 6338.150879, 7584.708008], [1082.176722, 1832.369448, 6333.546387, 7589.63916], [1058.844174, 1840.300943, 6326.331543, 7609.856445], [1035.511044, 1848.233019, 6313.07373, 7631.481934], [1012.17719, 1856.16586, 6312.62793, 7644.337891], [988.8424238, 1864.099733, 6311.796875, 7639.37207], [965.5066071, 1872.03486, 6319.300781, 7631.126953], [942.1695134, 1879.971615, 6329.914063, 7624.078125], [918.830974, 1887.910298, 6335.266113, 7622.10791], [895.4906941, 1895.851485, 6338.855469, 7623.210449], [872.1484716, 1903.795499, 6343.138184, 7626.231934], [848.8039697, 1911.742923, 6347.174316, 7627.458008], [825.4570752, 1919.693824, 6350.192383, 7629.583984], [802.1075542, 1927.648549, 6350.997559, 7629.910645], [778.7554449, 1935.606926, 6354.135254, 7627.639648], [755.4006191, 1943.569015, 6359.536621, 7625.145508], [732.0432107, 1951.534365, 6362.606934, 7620.643555], [708.6834282, 1959.502462, 6370.743652, 7616.48291], [685.3216696, 1967.472969, 6378.776855, 7613.025391], [661.958235, 1975.445455, 6386.45166, 7608.449707], [638.5931391, 1983.420068, 6394.097656, 7606.766113], [615.2270651, 1991.396341, 6400.04541, 7601.87793], [591.8601825, 1999.374399, 6405.762695, 7598.041992], [568.4921225, 2007.354145, 6410.156738, 7595.296875], [545.1227108, 2015.335198, 6413.91748, 7593.093262], [521.7531845, 2023.316785, 6416.933105, 7592.125977], [498.3838223, 2031.298058, 6419.327637, 7592.377441], [475.0138217, 2039.279568, 6421.600586, 7593.291504], [451.643585, 2047.261141, 6423.781738, 7594.500977], [428.2735747, 2055.241361, 6426.147949, 7594.617676], [404.9043995, 2063.221109, 6428.314453, 7595.48291], [381.5365827, 2071.201729, 6430.415527, 7596.008301], [358.169104, 2079.181793, 6432.583984, 7595.97998], [339.7777111, 2085.987596, 6315.91748, 7711.811523], [321.3863182, 2092.793398, 6315.385742, 7711.974609], [302.9949254, 2099.599201, 6315.018555, 7712.230469], [284.6035325, 2106.405003, 6314.839355, 7712.386719], [1711.492926, 1588.217484, 6308.178711, 7711.703125], [1691.575277, 1594.834543, 6308.212891, 7711.693359], [1671.657627, 1601.451603, 6308.287598, 7711.655273], [1651.739978, 1608.068663, 6308.423828, 7711.542969], [1631.822329, 1614.685723, 6308.651367, 7711.28418], [1611.90468, 1621.302783, 6309.036133, 7710.727539], [1591.98703, 1627.919843, 6426.357422, 7592.963379], [1568.386713, 1636.213301, 6423.169922, 7591.234375], [1544.787348, 1644.50556, 6419.996094, 7590.602051], [1521.188956, 1652.796587, 6416.72998, 7590.399414], [1497.591471, 1661.086339, 6410.050293, 7591.124023], [1473.994862, 1669.374914, 6403.702637, 7593.353027], [1450.39903, 1677.662374, 6399.894043, 7593.844238], [1426.803925, 1685.948853, 6396.64209, 7596.328125], [1403.209459, 1694.234429, 6393.879883, 7596.420898], [1379.615558, 1702.519228, 6389.220215, 7598.590332], [1356.022143, 1710.803354, 6384.627441, 7601.361816], [1332.429136, 1719.086917, 6379.04248, 7603.96875], [1308.836483, 1727.370009, 6374.162598, 7606.230469], [1285.244124, 1735.652705, 6369.101563, 7608.653809], [1261.65201, 1743.935079, 6364.45459, 7610.84375], [1238.060088, 1752.217189, 6359.29541, 7612.400391], [1214.468313, 1760.499107, 6355.910645, 7609.956543], [1190.876631, 1768.780893, 6352.827637, 7605.368652], [1167.284997, 1777.062615, 6350.305176, 7598.207031], [1143.953493, 1784.992934, 6347.794922, 7589.913574], [1120.621881, 1792.923349, 6344.861816, 7586.678223], [1097.290053, 1800.853961, 6341.610352, 7588.164551], [1073.957876, 1808.784882, 6338.353516, 7593.086914], [1050.625247, 1816.716236, 6330.31543, 7604.013184], [1027.292021, 1824.648173, 6322.913574, 7629.245605], [1003.958085, 1832.580839, 6311.129395, 7643.427246], [980.6232574, 1840.514487, 6304.844727, 7639.246094], [957.2874111, 1848.449371, 6322.34375, 7629.60498], [933.9502726, 1856.385937, 6332.072754, 7623.208496], [910.6116693, 1864.324496, 6333.956055, 7623.783691], [887.2712673, 1872.265582, 6336.10498, 7625.34082], [863.9289599, 1880.20941, 6339.341309, 7627.574707], [840.5843904, 1888.156581, 6342.046875, 7629.615723], [817.2374996, 1896.107254, 6344.407715, 7631.452637], [793.8879242, 1904.061877, 6347.770996, 7633.445801], [770.5357196, 1912.020173, 6352.904785, 7626.888672], [747.1807684, 1919.982082, 6358.134277, 7624.180664], [723.8233233, 1927.947148, 6364.300293, 7618.796387], [700.4635322, 1935.91508, 6371.160645, 7616.527832], [677.1017403, 1943.885535, 6378.354492, 7615.362793], [653.7381769, 1951.857901, 6386.236328, 7611.901367], [630.3729808, 1959.832235, 6394.003906, 7607.32666], [607.0069093, 1967.808301, 6399.642578, 7603.170898], [583.6400304, 1975.786334, 6405.186523, 7599.373047], [560.2718437, 1983.765964, 6408.990234, 7596.238281], [536.9023274, 1991.746696, 6412.766113, 7594.666016], [513.5327955, 1999.728145, 6415.915527, 7595.216309], [490.1634385, 2007.709401, 6418.381836, 7596.323242], [466.793322, 2015.69069, 6421.012207, 7597.277344], [443.4229785, 2023.67198, 6423.359375, 7597.26416], [420.0529787, 2031.652167, 6425.745117, 7595.978516], [396.6837977, 2039.631803, 6428.066406, 7594.821289], [373.3158317, 2047.612102, 6430.188965, 7596.382324], [354.1079766, 2054.608781, 6313.772949, 7712.588867], [334.9001215, 2061.60546, 6313.660156, 7712.306641], [315.6922664, 2068.602139, 6313.415527, 7712.27832], [296.4844113, 2075.598819, 6313.199219, 7712.348633], [277.2765562, 2082.595498, 6313.083984, 7712.411133], [1703.338645, 1564.603783, 6308.192383, 7711.317383], [1683.410153, 1571.225771, 6308.224121, 7711.333008], [1663.481661, 1577.84776, 6308.298828, 7711.34375], [1643.553168, 1584.469748, 6308.434082, 7711.297852], [1623.624676, 1591.091737, 6308.669434, 7711.080078], [1603.696184, 1597.713725, 6309.08252, 7710.470703], [1583.767692, 1604.335714, 6426.421875, 7592.471191], [1560.167426, 1612.62921, 6423.265137, 7591], [1536.568144, 1620.92146, 6419.942871, 7590.772949], [1512.969749, 1629.2125, 6416.413086, 7590.784668], [1489.372328, 1637.502279, 6411.380371, 7592.154297], [1465.775722, 1645.790899, 6406.42041, 7594.535156], [1442.179967, 1654.078373, 6400.657227, 7595.825195], [1418.584896, 1662.364858, 6395.807617, 7596.977051], [1394.990483, 1670.650434, 6391.828613, 7597.07959], [1371.396606, 1678.935258, 6388.853027, 7598.17334], [1347.803224, 1687.219412, 6385.638672, 7598.603027], [1324.210252, 1695.503007, 6380.260254, 7603.071289], [1300.617644, 1703.786112, 6375.210449, 7606.666016], [1277.025332, 1712.068819, 6369.915039, 7609.458496], [1253.433262, 1720.351198, 6364.415039, 7611.918945], [1229.84138, 1728.633322, 6359.639648, 7613.774414], [1206.24964, 1736.915257, 6356.30957, 7611.239258], [1182.657996, 1745.197065, 6352.968262, 7607.468262], [1159.066399, 1753.478809, 6350.751953, 7601.672852], [1135.734819, 1761.408967, 6349.027832, 7596.291016], [1112.40313, 1769.33922, 6347.364746, 7592.852051], [1089.07122, 1777.269658, 6344.714355, 7593.325684], [1065.738977, 1785.200384, 6341.889648, 7596.737793], [1042.406291, 1793.131517, 6336.476563, 7601.641113], [1019.073024, 1801.063231, 6319.691406, 7622.657227], [995.7390331, 1808.99571, 6303.639648, 7636.491211], [972.4041291, 1816.929222, 6304.264648, 7638.820801], [949.068176, 1824.863989, 6322.898926, 7626.165039], [925.730945, 1832.800386, 6332.463379, 7620.370605], [902.3922701, 1840.738712, 6334.390625, 7620.964844], [879.0518558, 1848.679546, 6335.977051, 7625.186035], [855.7094988, 1856.623209, 6336.74707, 7628.540039], [832.3648644, 1864.570286, 6337.979492, 7630.616211], [809.0178392, 1872.520843, 6342.67627, 7631.400391], [785.6681885, 1880.475229, 6347.738281, 7628.862793], [762.3159504, 1888.433269, 6352.67334, 7625.293945], [738.9609992, 1896.395027, 6356.739258, 7622.585938], [715.6034659, 1904.36005, 6363.229492, 7617.355957], [692.2435608, 1912.327822, 6370.257813, 7614.063477], [668.8816817, 1920.298006, 6378.256348, 7615.237793], [645.5181278, 1928.27017, 6386.446777, 7613.960938], [622.1529141, 1936.244464, 6393.504395, 7609.091309], [598.7867238, 1944.220418, 6399.404785, 7604.082031], [575.4197258, 1952.19816, 6404.1875, 7600.547852], [552.0515514, 1960.17759, 6407.89502, 7598.958984], [528.6820266, 1968.158327, 6411.473145, 7598.187012], [505.3123888, 1976.139598, 6414.57373, 7599.19043], [481.9429155, 1984.120553, 6417.413086, 7600.119141], [458.5728037, 1992.101745, 6420.588379, 7599.818848], [435.2024573, 2000.082998, 6422.958984, 7598.658203], [411.8323379, 2008.062896, 6425.482422, 7596.896973], [388.463053, 2016.04232, 6427.788574, 7596.491211], [368.6719401, 2023.175353, 6311.503906, 7713.00293], [348.8808272, 2030.308385, 6311.617676, 7712.732422], [329.0897143, 2037.441418, 6311.546387, 7712.551758], [309.2986014, 2044.57445, 6311.412109, 7712.483398], [289.5074885, 2051.707483, 6311.282227, 7712.484375], [269.7163756, 2058.840515, 6311.213867, 7712.500977], [1695.184362, 1540.990079, 6308.17334, 7710.916992], [1675.245025, 1547.616994, 6308.197266, 7710.978516], [1655.305688, 1554.243908, 6308.251953, 7711.089844], [1635.366352, 1560.870822, 6308.348633, 7711.210938], [1615.427015, 1567.497736, 6308.52002, 7711.257813], [1595.487678, 1574.124651, 6308.804688, 7711.014648], [1575.548342, 1580.751565, 6425.993164, 7593.240234], [1551.948113, 1589.045066, 6422.978027, 7591.970703], [1528.348836, 1597.337367, 6419.737793, 7591.795898], [1504.750529, 1605.628435, 6416.316406, 7590.902832], [1481.153129, 1613.918228, 6412.633301, 7591.69043], [1457.556605, 1622.206842, 6408.635742, 7594.175293], [1433.960856, 1630.494339, 6403.660156, 7597.089844], [1410.365833, 1638.780855, 6399.166992, 7598.056641], [1386.771448, 1647.066468, 6394.320313, 7597.471191], [1363.177629, 1655.351304, 6390.350098, 7597.538574], [1339.584296, 1663.635464, 6386.390625, 7599.243164], [1315.991371, 1671.919063, 6380.801758, 7602.501953], [1292.398798, 1680.20219, 6375.11084, 7607.279785], [1268.806521, 1688.484921, 6370.237793, 7610.333008], [1245.214487, 1696.767329, 6365.194824, 7611.990234], [1221.622647, 1705.049475, 6360.993164, 7612.650391], [1198.030953, 1713.331426, 6356.810547, 7611.568848], [1174.439353, 1721.613247, 6353.244629, 7608.541504], [1150.847801, 1729.895003, 6350.820801, 7605.746582], [1127.516157, 1737.824957, 6348.918457, 7601.443359], [1104.184405, 1745.755008, 6347.07666, 7599.203613], [1080.852436, 1753.685257, 6345.971191, 7600.162109], [1057.52012, 1761.615817, 6345.030273, 7596.021484], [1034.187351, 1769.54681, 6342.336426, 7599.53418], [1010.853986, 1777.478382, 6321.259766, 7617.802246], [987.5199096, 1785.410683, 6302.513184, 7634.135742], [964.1849426, 1793.343967, 6311.917969, 7637.890625], [940.8489571, 1801.278488, 6327.905273, 7626.750488], [917.5116803, 1809.214695, 6333.393066, 7619.643555], [894.1729397, 1817.152896, 6334.908203, 7620.825195], [870.8324013, 1825.093627, 6336.162598, 7624.109375], [847.4899594, 1833.037102, 6337.180664, 7627.577637], [824.1452564, 1840.983923, 6339.754883, 7629.298828], [800.7982331, 1848.934247, 6343.888672, 7627.272461], [777.4485271, 1856.888528, 6347.833008, 7623.38623], [754.0961927, 1864.846485, 6351.074707, 7621.486816], [730.7411147, 1872.808062, 6354.927246, 7619.267578], [707.3835447, 1880.772798, 6361.261719, 7615.65918], [684.02363, 1888.740403, 6367.736328, 7613.955566], [660.6617165, 1896.710533, 6378.552734, 7615.004395], [637.2980335, 1904.682574, 6386.724121, 7614.466309], [613.9327191, 1912.656586, 6393.121094, 7609.825684], [590.5665303, 1920.632332, 6399.089844, 7604.944336], [567.1995361, 1928.610046, 6403.270508, 7601.199707], [543.8312348, 1936.589359, 6406.921875, 7601.034668], [520.4616051, 1944.569776, 6410.432617, 7599.227539], [497.0919611, 1952.550907, 6413.531738, 7600.999512], [473.7224926, 1960.531845, 6416.599609, 7602.42627], [450.3522659, 1968.512816, 6419.783203, 7601.496094], [426.9818127, 1976.493787, 6422.669434, 7599.225586], [403.6117033, 1984.473653, 6425.331543, 7596.388672], [380.2424131, 1992.452965, 6427.636719, 7596.107422], [360.462329, 1999.581815, 6309.904297, 7712.919922], [340.6822449, 2006.710666, 6309.642578, 7712.785156], [320.9021608, 2013.839516, 6309.504883, 7712.680664], [301.1220766, 2020.968367, 6309.402832, 7712.624023], [281.3419925, 2028.097217, 6309.321289, 7712.608398], [261.5619084, 2035.226068, 6309.274902, 7712.607422], [1687.030068, 1517.376376, 6308.132324, 7710.461914], [1667.079877, 1524.008216, 6308.142578, 7710.581055], [1647.129686, 1530.640055, 6308.160156, 7710.828125], [1627.179494, 1537.271895, 6308.198242, 7711.211914], [1607.229303, 1543.903735, 6308.251953, 7711.735352], [1587.279111, 1550.535575, 6308.350586, 7712.368164], [1567.32892, 1557.167415, 6425.546875, 7595.847656], [1543.728746, 1565.460954, 6422.566406, 7594.60791], [1520.129555, 1573.753245, 6419.510742, 7593.654297], [1496.53125, 1582.044327, 6416.378906, 7591.487793], [1472.933919, 1590.334146, 6412.770996, 7592.441406], [1449.3374, 1598.622806, 6409.144043, 7593.909668], [1425.741733, 1606.910319, 6405.263672, 7595.395996], [1402.146749, 1615.196842, 6401.213867, 7595.94043], [1378.552422, 1623.482456, 6396.841309, 7596.180664], [1354.958632, 1631.767318, 6391.632813, 7596.516113], [1331.365335, 1640.051509, 6386.356445, 7598.076172], [1307.77245, 1648.335139, 6380.671387, 7602.333008], [1284.179928, 1656.618282, 6375.221191, 7607.369141], [1260.587703, 1664.901025, 6370.614746, 7610.166504], [1236.995718, 1673.18344, 6366.014648, 7611.009766], [1213.403923, 1681.465601, 6362.652344, 7610.961914], [1189.81227, 1689.747572, 6358.996094, 7610.602539], [1166.220713, 1698.029417, 6355.462402, 7608.624023], [1142.629203, 1706.311197, 6352.274414, 7606.499023], [1119.29748, 1714.240991, 6349.368652, 7603.913086], [1095.965647, 1722.170879, 6346.881348, 7602.893066], [1072.633596, 1730.100951, 6346.668457, 7601.995117], [1049.301209, 1738.031312, 6347.438477, 7597.29248], [1025.968382, 1745.962079, 6342.938477, 7603.158691], [1002.634972, 1753.893429, 6326.777832, 7614.40918], [979.3008395, 1761.825545, 6311.226563, 7631.859375], [955.9657943, 1769.758691, 6320.794434, 7634.680664], [932.6297001, 1777.693095, 6333.526855, 7625.000977], [909.2923298, 1785.62913, 6335.659668, 7616.933105], [885.9535167, 1793.567095, 6338.216309, 7619.433594], [862.612964, 1801.50757, 6339.015625, 7624.414551], [839.2704707, 1809.450876, 6339.014648, 7626.873047], [815.9257009, 1817.397601, 6340.385254, 7628.043945], [792.5785421, 1825.347809, 6343.320313, 7625.01416], [769.2287598, 1833.30185, 6347.972656, 7615.278809], [745.8763931, 1841.25955, 6352.440918, 7612.878906], [722.5213136, 1849.220971, 6355.600586, 7616.436523], [699.1636553, 1857.18566, 6360.344238, 7612.647949], [675.8036263, 1865.153102, 6367.143066, 7613.704102], [652.441625, 1873.122959, 6377.618652, 7615.72168], [629.077951, 1881.094798, 6386.597656, 7613.615234], [605.7126181, 1889.068769, 6393.013184, 7609.695313], [582.3463105, 1897.044401, 6398.76416, 7604.398438], [558.9791961, 1905.021823, 6402.498535, 7601.494629], [535.6109068, 1913.000935, 6406.039063, 7599.508301], [512.241269, 1920.981355, 6409.329102, 7598.530273], [488.8715187, 1928.962309, 6412.625488, 7600.461426], [465.5019338, 1936.942946, 6415.794434, 7601.439941], [442.1317119, 1944.923819, 6419.209961, 7602.918457], [418.7612558, 1952.904754, 6422.375977, 7598.470703], [395.3910272, 1960.88433, 6425.046387, 7596.98877], [375.171947, 1968.115825, 6307.920898, 7713.236328], [354.9528669, 1975.34732, 6307.688965, 7712.943359], [334.7337867, 1982.578815, 6307.53418, 7712.821289], [314.5147065, 1989.81031, 6307.436035, 7712.754883], [294.2956263, 1997.041805, 6307.366211, 7712.728516], [274.0765462, 2004.273299, 6307.321289, 7712.717773], [253.857466, 2011.504794, 6307.290527, 7712.717773], [1678.875773, 1493.76267, 6308.086426, 7709.892578], [1658.914725, 1500.399432, 6308.07959, 7710.060547], [1638.953676, 1507.036195, 6308.058105, 7710.429688], [1618.992628, 1513.672958, 6308.017578, 7711.064453], [1599.031579, 1520.309721, 6307.951172, 7712.103516], [1579.070531, 1526.946484, 6307.826172, 7713.855469], [1559.109482, 1533.583247, 6425.035645, 7599.688965], [1535.509351, 1541.87679, 6422.103516, 7597.581543], [1511.91017, 1550.169135, 6419.292969, 7594.715332], [1488.311957, 1558.460244, 6416.174316, 7592.8125], [1464.71465, 1566.750076, 6412.887695, 7592.353516], [1441.118218, 1575.03873, 6409.408691, 7593.883789], [1417.522562, 1583.326267, 6405.465332, 7594.993652], [1393.92763, 1591.612822, 6401.541016, 7595.663574], [1370.333337, 1599.898472, 6396.841797, 7594.950195], [1346.739608, 1608.183347, 6391.646973, 7595.800781], [1323.146366, 1616.467546, 6386.459473, 7597.16748], [1299.553532, 1624.751183, 6381.021973, 7602.399902], [1275.961051, 1633.034348, 6375.894043, 7602.80127], [1252.368864, 1641.317118, 6370.737305, 7610.526855], [1228.776923, 1649.599563, 6366.227051, 7609.753906], [1205.185175, 1657.881747, 6363.853027, 7609.175293], [1181.593573, 1666.163737, 6361.063477, 7608.357422], [1158.002066, 1674.445596, 6357.954102, 7607.507324], [1134.410605, 1682.727391, 6354.687988, 7606.554688], [1111.078816, 1690.65698, 6351.821289, 7605.027344], [1087.746918, 1698.586665, 6348.60498, 7603.336914], [1064.414804, 1706.516547, 6347.445313, 7600.779297], [1041.082343, 1714.446738, 6348.625977, 7598.952148], [1017.749428, 1722.377362, 6343.236328, 7603.694824], [994.415919, 1730.308568, 6334.380371, 7611.242188], [971.0816988, 1738.240504, 6330.272949, 7623.094238], [947.7465888, 1746.173424, 6333.987793, 7625.187988], [924.4104612, 1754.10758, 6335.80127, 7618.09082], [901.0730432, 1762.043421, 6338.932617, 7618.392578], [877.7341624, 1769.981258, 6341.496094, 7622.230957], [854.3934848, 1777.921627, 6342.316895, 7625.306152], [831.0509046, 1785.864743, 6342.861816, 7626.977051], [807.7060643, 1793.811209, 6344.483887, 7626.57959], [784.3589074, 1801.761182, 6346.260254, 7625.291504], [761.0090689, 1809.715118, 6350.01416, 7619.021973], [737.6566058, 1817.672732, 6353.768066, 7612.001953], [714.3013995, 1825.633968, 6357.188477, 7614.851074], [690.9437031, 1833.598368, 6361.09082, 7614.333984], [667.583665, 1841.56564, 6369.080566, 7614.008789], [644.2216289, 1849.535441, 6378.77832, 7615.187012], [620.8578252, 1857.507157, 6386.642578, 7612.236816], [597.4923917, 1865.480844, 6392.812012, 7607.058594], [574.126085, 1873.456268, 6397.936035, 7602.700684], [550.7589745, 1881.43366, 6401.782227, 7598.143066], [527.3905578, 1889.412656, 6405.271973, 7596.861816], [504.0208151, 1897.392753, 6408.534668, 7595.943359], [480.6510586, 1905.373568, 6411.914551, 7597.21875], [457.2814785, 1913.354189, 6415.445313, 7597.328125], [433.9111407, 1921.334841, 6418.846191, 7596.589844], [410.5405783, 1929.315493, 6421.897461, 7595.673828], [389.9799526, 1936.626845, 6305.120117, 7713.02832], [369.419327, 1943.938197, 6305.364258, 7712.864258], [348.8587013, 1951.249549, 6305.395996, 7712.804688], [328.2980757, 1958.5609, 6305.373535, 7712.791992], [307.73745, 1965.872252, 6305.344727, 7712.801758], [287.1768243, 1973.183604, 6305.314453, 7712.813477], [266.6161987, 1980.494956, 6305.29541, 7712.825195], [246.055573, 1987.806308, 6305.283691, 7712.833008], [1670.721467, 1470.148964, 6308.045898, 7709.158203], [1650.749552, 1476.790651, 6308.028809, 7709.347656], [1630.777636, 1483.432337, 6307.969238, 7709.770508], [1610.805721, 1490.074024, 6307.870117, 7710.517578], [1590.833805, 1496.71571, 6307.700684, 7711.762695], [1570.861889, 1503.357397, 6307.439941, 7713.785156], [1550.889974, 1509.999083, 6424.537109, 7599.403809], [1527.2899, 1518.292665, 6421.71582, 7597.01123], [1503.690809, 1526.584998, 6418.946289, 7595.09375], [1480.092603, 1534.87612, 6415.961426, 7592.447266], [1456.49537, 1543.16598, 6412.835938, 7591.27002], [1432.898948, 1551.454679, 6409.398438, 7592.725098], [1409.303377, 1559.742231, 6405.753906, 7593.519043], [1385.70849, 1568.028794, 6401.956543, 7593.868164], [1362.114259, 1576.314447, 6397.349609, 7594.257813], [1338.520564, 1584.599348, 6392.659668, 7593.526855], [1314.927364, 1592.883578, 6386.949707, 7597.151855], [1291.334574, 1601.167248, 6381.412598, 7601.063965], [1267.742148, 1609.450429, 6375.543945, 7602.109863], [1244.150019, 1617.733212, 6369.787598, 7609.38916], [1220.558133, 1626.015667, 6366.467773, 7608.626465], [1196.966435, 1634.297869, 6364.568359, 7606.021973], [1173.37488, 1642.57988, 6361.802734, 7606.828613], [1149.78342, 1650.861765, 6359.259277, 7606.191895], [1126.192007, 1659.143585, 6356.902344, 7604.373535], [1102.860136, 1667.07301, 6353.533203, 7602.708496], [1079.528156, 1675.00253, 6350.623047, 7601.686035], [1056.195956, 1682.932235, 6348.995605, 7598.961426], [1032.863422, 1690.862227, 6348.783691, 7597.257324], [1009.530447, 1698.792626, 6341.375488, 7599.088379], [986.1968909, 1706.723607, 6338.285645, 7602.838867], [962.8626134, 1714.655353, 6332.176758, 7616.851563], [939.5274233, 1722.588132, 6335.249512, 7624.387207], [916.1911841, 1730.522167, 6336.971191, 7624.574707], [892.8536718, 1738.457835, 6338.165039, 7628.115723], [869.5147156, 1746.395435, 6340.593262, 7626.201172], [846.1740227, 1754.335546, 6342.980957, 7627.76416], [822.8313911, 1762.278493, 6345.82959, 7627.521484], [799.4864849, 1770.22486, 6348.639648, 7626.412598], [776.1391907, 1778.174715, 6351.066406, 7624.333984], [752.7892759, 1786.128407, 6353.754395, 7619.68457], [729.4367775, 1794.085761, 6356.727539, 7616.535645], [706.0815702, 1802.046842, 6360.284668, 7614.83252], [682.7237856, 1810.011194, 6363.489258, 7613.396484], [659.3636326, 1817.978303, 6371.367676, 7613.139648], [636.0015088, 1825.947828, 6380.363281, 7611.902344], [612.6377137, 1833.919338, 6386.955078, 7609.280762], [589.272262, 1841.892983, 6393.219238, 7605.40332], [565.9058362, 1849.868292, 6397.510254, 7600.829102], [542.5386054, 1857.845393, 6401.193848, 7597.302246], [519.1702012, 1865.824185, 6404.570313, 7594.750488], [495.8004499, 1873.804288, 6407.833496, 7593.76709], [472.4305871, 1881.784925, 6411.386719, 7594.49707], [449.0608906, 1889.765244, 6415.100586, 7591.583008], [425.6905585, 1897.7458, 6418.468262, 7592.918457], [404.8566536, 1905.121123, 6302.191895, 7711.328125], [384.0227486, 1912.496446, 6302.736816, 7712.018555], [363.1888436, 1919.871769, 6303.018066, 7712.395508], [342.3549387, 1927.247092, 6303.152832, 7712.609375], [321.5210337, 1934.622415, 6303.215332, 7712.750977], [300.6871288, 1941.997738, 6303.248047, 7712.838867], [279.8532238, 1949.373062, 6303.258789, 7712.900391], [259.0193188, 1956.748385, 6303.268066, 7712.9375], [238.1854139, 1964.123708, 6303.27002, 7712.955078], [1662.567159, 1446.535257, 6308.041504, 7708.234375], [1642.584374, 1453.181866, 6308.004395, 7708.40332], [1622.601588, 1459.828475, 6307.927246, 7708.788086], [1602.618803, 1466.475084, 6307.783203, 7709.477539], [1582.636018, 1473.121693, 6307.552246, 7710.647461], [1562.653232, 1479.768302, 6307.186523, 7712.638672], [1542.670447, 1486.414911, 6424.096191, 7598.732422], [1519.07042, 1494.708496, 6421.413574, 7595.243652], [1495.471343, 1503.000879, 6418.661621, 7592.051758], [1471.873234, 1511.292029, 6415.828125, 7590.177246], [1448.27603, 1519.581902, 6412.646973, 7590.40918], [1424.679701, 1527.870595, 6409.325684, 7592.160156], [1401.084145, 1536.15817, 6405.827637, 7593.559082], [1377.489314, 1544.444765, 6401.958496, 7594.026367], [1353.895122, 1552.730455, 6397.770996, 7593.963867], [1330.301495, 1561.015369, 6393.276367, 7594.408203], [1306.708353, 1569.299606, 6387.566406, 7597.006836], [1283.115619, 1577.583283, 6381.756348, 7600.451172], [1259.523239, 1585.866488, 6375.595703, 7603.500977], [1235.931156, 1594.149299, 6369.734375, 7607.767578], [1212.339316, 1602.431785, 6366.593262, 7608.037109], [1188.747671, 1610.714009, 6364.834473, 7607.763672], [1165.156172, 1618.996041, 6363.566406, 7606.641602], [1141.564767, 1627.277943, 6361.726074, 7606.268066], [1117.973409, 1635.559779, 6358.926758, 7603.15332], [1094.64147, 1643.488996, 6355.695801, 7600.207031], [1071.309421, 1651.41831, 6353.977539, 7599.313965], [1047.977157, 1659.347823, 6351.990234, 7598.339355], [1024.644547, 1667.277646, 6350.85498, 7597.865723], [1001.311483, 1675.207902, 6349.873535, 7592.962402], [977.9778255, 1683.138736, 6342.437012, 7597.978516], [954.6434584, 1691.070299, 6321.817871, 7614.712402], [931.3082006, 1699.002847, 6326.412109, 7626.04834], [907.9719271, 1706.936632, 6330.51709, 7633.669922], [884.6343651, 1714.872106, 6335.424316, 7632.521973], [861.2953412, 1722.809577, 6339.353027, 7630.444336], [837.9545216, 1730.749582, 6342.197754, 7631.932617], [814.6118022, 1738.692336, 6345.730957, 7629.603516], [791.2668254, 1746.638443, 6348.958984, 7627.828125], [767.9195332, 1754.588062, 6353.428223, 7624.669922], [744.5695611, 1762.541644, 6356.218262, 7621.906738], [721.2169664, 1770.498912, 6359.764648, 7617.777832], [697.8616313, 1778.459808, 6363.772949, 7615.621582], [674.5038086, 1786.42387, 6368.935059, 7615.564941], [651.1436455, 1794.390808, 6375.51709, 7613.188477], [627.7814874, 1802.360277, 6381.254395, 7610.980957], [604.4175626, 1810.331662, 6387.461426, 7607.393066], [581.0520103, 1818.305023, 6393.286133, 7603.575684], [557.6855859, 1826.280121, 6397.09668, 7600.006836], [534.3183585, 1834.257192, 6400.849121, 7595.866699], [510.9498274, 1842.235868, 6404.074707, 7594.929688], [487.5799712, 1850.215648, 6407.32959, 7593.520508], [464.2101026, 1858.196146, 6411.091309, 7592.069824], [440.840411, 1866.176449, 6414.711426, 7590.366699], [417.4699635, 1874.156784, 6418.082031, 7589.52002], [396.6437742, 1881.529146, 6300.486328, 7709.879883], [375.8175849, 1888.901508, 6300.624023, 7711.328125], [354.9913956, 1896.27387, 6300.825195, 7712.073242], [334.1652063, 1903.646231, 6300.979004, 7712.495117], [313.339017, 1911.018593, 6301.092773, 7712.75], [292.5128277, 1918.390955, 6301.162598, 7712.90918], [271.6866384, 1925.763316, 6301.21582, 7713.012695], [250.8604491, 1933.135678, 6301.242676, 7713.070313], [230.0342598, 1940.50804, 6301.259766, 7713.099609], [1654.412841, 1422.921553, 6308.067871, 7707.148438], [1634.419175, 1429.573086, 6308.032227, 7707.256836], [1614.42551, 1436.22462, 6307.948242, 7707.504883], [1594.431845, 1442.876154, 6307.791504, 7707.950195], [1574.438179, 1449.527687, 6307.532227, 7708.711914], [1554.444514, 1456.179221, 6307.121582, 7709.926758], [1534.450848, 1462.830755, 6423.628418, 7594.53125], [1510.850885, 1471.124376, 6421.066895, 7592.625], [1487.251903, 1479.416747, 6418.422363, 7589.603516], [1463.653804, 1487.707909, 6415.691895, 7588.973633], [1440.056678, 1495.997806, 6412.661133, 7589.749023], [1416.460364, 1504.286544, 6409.431641, 7591.964355], [1392.864899, 1512.574135, 6405.839844, 7593.720215], [1369.270118, 1520.860736, 6401.950684, 7594.739258], [1345.675993, 1529.146428, 6397.919434, 7593.799316], [1322.082405, 1537.431366, 6393.226074, 7595.461914], [1298.489311, 1545.715636, 6387.913086, 7597.515137], [1274.896627, 1553.999345, 6381.958496, 7600.858398], [1251.304308, 1562.282567, 6375.768555, 7605.166016], [1227.712285, 1570.56539, 6370.418945, 7606.755859], [1204.120505, 1578.847886, 6367.142578, 7608.163086], [1180.528915, 1587.130129, 6364.689941, 7608.561523], [1156.937468, 1595.412183, 6361.981934, 7606.850586], [1133.346116, 1603.69411, 6361.572754, 7605.410156], [1109.754811, 1611.975973, 6360.431641, 7602.927734], [1086.422788, 1619.905026, 6357.848633, 7599.019043], [1063.090655, 1627.834174, 6357.161133, 7597.075195], [1039.758304, 1635.763505, 6356.034668, 7594.852051], [1016.425619, 1643.693125, 6355.800293, 7595.782715], [993.0924931, 1651.623151, 6354.952148, 7593.17627], [969.7587869, 1659.55376, 6343.068848, 7609.068359], [946.4243597, 1667.485134, 6322.676758, 7622.163574], [923.0890217, 1675.417541, 6316.788574, 7638.518066], [899.7526367, 1683.351205, 6323.496094, 7640.522461], [876.4149775, 1691.286503, 6333.148926, 7636.081543], [853.0758773, 1699.223734, 6343.021973, 7634.333496], [829.7350423, 1707.16348, 6343.950684, 7634.257324], [806.3922705, 1715.106063, 6346.064941, 7632.642578], [783.0472251, 1723.052071, 6349.293945, 7628.962402], [759.6997955, 1731.00157, 6354.578125, 7624.313965], [736.3497461, 1738.95491, 6358.428711, 7621.589844], [712.9971171, 1746.911918, 6362.463379, 7620.434082], [689.6417811, 1754.872655, 6365.789063, 7619.73291], [666.2838697, 1762.836669, 6370.674805, 7617.008789], [642.9235922, 1770.803442, 6376.126953, 7614.667969], [619.5613463, 1778.772635, 6382.058594, 7611.41748], [596.1974305, 1786.743815, 6388.15625, 7606.806152], [572.8318601, 1794.717134, 6393.268066, 7603.532715], [549.465317, 1802.692117, 6397.114258, 7600.445313], [526.0979699, 1810.668896, 6400.558105, 7597.974121], [502.7294513, 1818.647369, 6403.654297, 7596.126465], [479.359587, 1826.627153, 6407.053711, 7594.788574], [455.989612, 1834.607474, 6410.995117, 7593.466309], [432.6198045, 1842.587475, 6414.658691, 7589.980469], [411.5693343, 1850.012412, 6297.931152, 7708.620117], [390.518864, 1857.437348, 6298.190918, 7710.204102], [369.4683938, 1864.862284, 6298.437012, 7711.342773], [348.4179236, 1872.28722, 6298.666992, 7712.081055], [327.3674534, 1879.712156, 6298.857422, 7712.545898], [306.3169831, 1887.137092, 6299.004883, 7712.851563], [285.2665129, 1894.562028, 6299.112793, 7713.043945], [264.2160427, 1901.986964, 6299.187988, 7713.166016], [243.1655725, 1909.4119, 6299.234375, 7713.237305], [222.1151023, 1916.836836, 6299.261719, 7713.271484], [1646.25852, 1399.307849, 6308.13623, 7705.958008], [1626.253972, 1405.964308, 6308.107422, 7705.976563], [1606.249425, 1412.620768, 6308.033691, 7706.026367], [1586.244877, 1419.277227, 6307.902344, 7706.119141], [1566.240329, 1425.933686, 6307.663086, 7706.318359], [1546.235781, 1432.590145, 6307.224609, 7706.743164], [1526.231234, 1439.246605, 6423.20752, 7590.819336], [1502.631322, 1447.540227, 6420.71875, 7589.814941], [1479.032358, 1455.832647, 6418.149902, 7588.663574], [1455.434361, 1464.123832, 6415.484375, 7588.611328], [1431.837269, 1472.413741, 6412.676758, 7590.033691], [1408.241051, 1480.702471, 6409.486328, 7592.881836], [1384.645607, 1488.990083, 6406.046387, 7595.447754], [1361.050888, 1497.276715, 6402.162109, 7595.266113], [1337.456807, 1505.562442, 6398.04834, 7595.282227], [1313.86329, 1513.847393, 6393.217285, 7596.173828], [1290.27026, 1522.131669, 6388.188965, 7598.720215], [1266.677637, 1530.415384, 6382.18457, 7602.400879], [1243.08537, 1538.698628, 6376.01416, 7605.556152], [1219.493397, 1546.981479, 6371.675293, 7605.493164], [1195.90167, 1555.264006, 6368.252441, 7605.819824], [1172.310137, 1563.546272, 6364.571289, 7607.053223], [1148.71875, 1571.828346, 6361.314453, 7607.450684], [1125.127458, 1580.110288, 6360.377441, 7607.129883], [1101.536213, 1588.392167, 6360.791504, 7604.647461], [1078.20412, 1596.321011, 6359, 7598.130859], [1054.871919, 1604.249952, 6359.144043, 7594.433105], [1031.539501, 1612.179089, 6358.999512, 7593.353516], [1008.206738, 1620.108536, 6357.53418, 7593.270508], [984.8735222, 1628.038415, 6355.929199, 7595.067871], [961.539713, 1635.968876, 6339.362305, 7608.14209], [938.2051952, 1643.900067, 6320.183594, 7625.672363], [914.8697895, 1651.832244, 6314.688965, 7640.724121], [891.5333682, 1659.765658, 6319.996094, 7638.79541], [868.1956594, 1667.70076, 6331.324219, 7634.730957], [844.8564905, 1675.637861, 6345.851563, 7632.816406], [821.5155278, 1683.577498, 6348.105957, 7633.552246], [798.1726663, 1691.519889, 6348.947266, 7632.895996], [774.8275503, 1699.465636, 6352.390137, 7629.253418], [751.4801207, 1707.414899, 6356.82959, 7627.5], [728.1300151, 1715.368132, 6360.067383, 7625.417969], [704.7772888, 1723.325052, 6362.960449, 7623.641113], [681.4218255, 1731.285603, 6366.161133, 7622.083496], [658.0638764, 1739.249326, 6371.226074, 7620.283691], [634.7035894, 1747.215927, 6375.822266, 7616.382813], [611.3413092, 1755.185064, 6382.774902, 7611.907715], [587.9772642, 1763.15612, 6388.817383, 7607.464355], [564.6115936, 1771.129153, 6393.205566, 7603.939453], [541.2450519, 1779.103928, 6397.311523, 7601.219238], [517.8777092, 1787.080677, 6400.577637, 7599.016602], [494.5090632, 1795.059033, 6403.688477, 7598.243164], [471.1390949, 1803.038495, 6407.184082, 7595.212891], [447.7691147, 1811.018678, 6410.967773, 7592.26123], [426.531788, 1818.487383, 6294.59668, 7709.639648], [405.2944612, 1825.956089, 6295.453613, 7710.115234], [384.0571345, 1833.424794, 6295.930664, 7710.973633], [362.8198077, 1840.8935, 6296.267578, 7711.757813], [341.5824809, 1848.362205, 6296.547852, 7712.347656], [320.3451542, 1855.83091, 6296.772949, 7712.767578], [299.1078274, 1863.299616, 6296.955078, 7713.051758], [277.8705006, 1870.768321, 6297.092773, 7713.244141], [256.6331739, 1878.237027, 6297.196777, 7713.368164], [235.3958471, 1885.705732, 6297.256836, 7713.441406], [214.1585204, 1893.174438, 6297.291016, 7713.480469], [1638.104189, 1375.69415, 6308.236328, 7704.750977], [1618.088749, 1382.35554, 6308.218262, 7704.671875], [1598.073309, 1389.01693, 6308.183105, 7704.493164], [1578.057869, 1395.678319, 6308.117676, 7704.18457], [1558.042429, 1402.339709, 6307.999023, 7703.707031], [1538.026989, 1409.001098, 6307.668457, 7703.162109], [1518.011549, 1415.662488, 6422.79541, 7587.013184], [1494.411704, 1423.956141, 6420.347168, 7587.915527], [1470.812839, 1432.248547, 6417.834473, 7587.349121], [1447.214859, 1440.539741, 6415.275391, 7587.369629], [1423.617849, 1448.829673, 6412.614258, 7589.903809], [1400.021653, 1457.118444, 6409.567383, 7592.138672], [1376.426304, 1465.406069, 6406.146973, 7594.352539], [1352.831639, 1473.692704, 6402.28418, 7595.159668], [1329.237631, 1481.978431, 6398.120605, 7595.584961], [1305.644158, 1490.263406, 6393.344727, 7596.807129], [1282.051179, 1498.547711, 6388.187012, 7599.496582], [1258.458612, 1506.831457, 6382.182129, 7602.748535], [1234.86641, 1515.114717, 6376.179199, 7605.833496], [1211.274504, 1523.397578, 6372.922852, 7604.824219], [1187.68284, 1531.680114, 6369.564453, 7603.69873], [1164.091367, 1539.962397, 6365.430664, 7605.6875], [1140.500037, 1548.24449, 6361.831543, 7606.424316], [1116.908803, 1556.526458, 6360.735352, 7607.770996], [1093.317615, 1564.808361, 6360.372559, 7603.616211], [1069.985437, 1572.737038, 6360.210449, 7597.385254], [1046.65315, 1580.66581, 6360.225098, 7592.280273], [1023.320645, 1588.594766, 6359.518555, 7590.647949], [999.9878064, 1596.524011, 6358.062012, 7590.401855], [976.6545284, 1604.453662, 6355.512207, 7593.947754], [953.3206696, 1612.383895, 6338.433105, 7607.54541], [929.9860917, 1620.314894, 6321.085938, 7623.842285], [906.650603, 1628.246925, 6317.40332, 7639.062012], [883.3140682, 1636.180218, 6319.61377, 7639.34668], [859.9762622, 1644.115144, 6335.530273, 7633.753418], [836.637017, 1652.052007, 6348.35791, 7628.130371], [813.2960381, 1659.991386, 6351.13623, 7629.661133], [789.9531241, 1667.933604, 6352.210449, 7629.043457], [766.6079404, 1675.879253, 6354.422852, 7627.526855], [743.2603735, 1683.828396, 6356.920898, 7627.17627], [719.9101897, 1691.781385, 6359.708496, 7627.339844], [696.5574291, 1699.738046, 6362.541992, 7628.264648], [673.2019643, 1707.698441, 6366.030273, 7623.51709], [649.8439265, 1715.662116, 6370.477539, 7622.520996], [626.4835255, 1723.628554, 6375.970703, 7618.012207], [603.1211576, 1731.597415, 6383.304199, 7612.804688], [579.7571226, 1739.568265, 6389.230957, 7607.834473], [556.391434, 1747.541256, 6393.483887, 7604.035645], [533.0247745, 1755.515916, 6397.46582, 7601.578613], [509.6573125, 1763.492373, 6400.628418, 7599.166504], [486.2886799, 1771.470527, 6403.722168, 7597.051758], [462.9187035, 1779.449994, 6407.439941, 7594.223633], [439.5486179, 1787.429999, 6411.197266, 7591.282227], [418.3177127, 1794.896208, 6292.970703, 7710.542969], [397.0868075, 1802.362418, 6293.365723, 7711.213867], [375.8559022, 1809.828627, 6293.79248, 7711.821289], [354.624997, 1817.294837, 6294.166504, 7712.352539], [333.3940918, 1824.761047, 6294.477051, 7712.787109], [312.1631865, 1832.227256, 6294.73877, 7713.120117], [290.9322813, 1839.693466, 6294.949707, 7713.352539], [269.7013761, 1847.159675, 6295.11377, 7713.514648], [248.4704708, 1854.625885, 6295.231445, 7713.62207], [227.2395656, 1862.092095, 6295.307129, 7713.688477], [206.0086604, 1869.558304, 6295.345215, 7713.720703], [1630.545581, 1351.809048, 6308.35498, 7703.623047], [1611.11497, 1358.203964, 6308.353027, 7703.463867], [1591.68436, 1364.598881, 6308.35791, 7703.098633], [1572.25375, 1370.993797, 6308.395996, 7702.416016], [1552.82314, 1377.388713, 6308.542969, 7701.168945], [1533.39253, 1383.78363, 6424.889648, 7582.960938], [1509.791852, 1392.078395, 6422.444336, 7584.188965], [1486.192062, 1400.372046, 6420.085449, 7586.067871], [1462.59322, 1408.664495, 6417.562988, 7587.12207], [1438.995346, 1416.955711, 6415.029785, 7588.519043], [1415.398376, 1425.24565, 6412.44873, 7590.000488], [1391.80228, 1433.53441, 6409.710449, 7591.14502], [1368.206957, 1441.822051, 6406.148926, 7593.878906], [1344.612358, 1450.108714, 6402.348633, 7595.206543], [1321.018398, 1458.394473, 6398.007813, 7595.368164], [1297.425003, 1466.679457, 6393.314453, 7596.972656], [1273.832093, 1474.963766, 6387.984375, 7600.068848], [1250.239592, 1483.247515, 6381.986328, 7602.585449], [1226.647444, 1491.530794, 6376.959473, 7604.59082], [1203.055594, 1499.813681, 6373.81543, 7603.291504], [1179.463987, 1508.096244, 6370.647949, 7602.661133], [1155.872575, 1516.378547, 6366.470215, 7603.131348], [1132.28131, 1524.660658, 6362.762695, 7603.365723], [1108.69014, 1532.942639, 6363.045898, 7605.555664], [1085.099017, 1541.224555, 6363.478516, 7603.509277], [1061.766769, 1549.15302, 6362.872559, 7596.500977], [1038.434413, 1557.081583, 6361.008789, 7592.441406], [1015.101841, 1565.010345, 6359.591797, 7588.627441], [991.7689241, 1572.939417, 6358.576172, 7587.697266], [968.4355555, 1580.868923, 6354.903809, 7589.693359], [945.1015937, 1588.799007, 6345.643555, 7604.980957], [921.7669243, 1596.729822, 6327.589355, 7622.435059], [898.431367, 1604.661622, 6320.282227, 7634.578613], [875.0947959, 1612.594662, 6322.495117, 7633.683105], [851.7569393, 1620.529394, 6338.241699, 7630.453613], [828.4176245, 1628.466126, 6349.825195, 7626.203613], [805.0765188, 1636.405398, 6352.303223, 7624.837402], [781.7335161, 1644.347426, 6353.545898, 7625.890625], [758.3882609, 1652.292814, 6355.008301, 7627.05957], [735.040694, 1660.241721, 6356.990723, 7629.063965], [711.6904539, 1668.194602, 6359.062012, 7629.334473], [688.337596, 1676.151176, 6361.68457, 7629.970215], [664.9820039, 1684.111387, 6365.725586, 7625.746094], [641.623929, 1692.074772, 6370.092285, 7619.526367], [618.2635184, 1700.041041, 6376.680176, 7618.688965], [594.9011171, 1708.009845, 6383.802734, 7612.833008], [571.5369534, 1715.980572, 6389.368652, 7607.796875], [548.1711656, 1723.953278, 6393.713379, 7604.165039], [524.804508, 1731.927729, 6397.509277, 7601.557617], [501.4370508, 1739.904157, 6400.772949, 7598.592285], [478.0682922, 1747.882195, 6403.894531, 7595.972168], [454.6982129, 1755.86134, 6407.459473, 7593.15918], [433.3086824, 1763.364767, 6290.15625, 7711.666016], [411.9191519, 1770.868193, 6290.737305, 7712.026367], [390.5296215, 1778.37162, 6291.246582, 7712.383789], [369.140091, 1785.875046, 6291.707031, 7712.728516], [347.7505605, 1793.378473, 6292.11377, 7713.055664], [326.36103, 1800.881899, 6292.463867, 7713.329102], [304.9714996, 1808.385326, 6292.752441, 7713.554688], [283.5819691, 1815.888752, 6292.991699, 7713.72168], [262.1924386, 1823.392179, 6293.175781, 7713.841797], [240.8029081, 1830.895605, 6293.30957, 7713.921875], [219.4133777, 1838.399032, 6293.404785, 7713.972656], [198.0238472, 1845.902458, 6293.444336, 7713.993164], [1622.389413, 1328.19618, 6308.474121, 7702.662109], [1602.946073, 1334.596858, 6308.48584, 7702.46875], [1583.502734, 1340.997536, 6308.501953, 7702.024414], [1564.059394, 1347.398214, 6308.561523, 7701.211914], [1544.616055, 1353.798891, 6308.697266, 7699.77832], [1525.172716, 1360.199569, 6424.66748, 7581.503418], [1501.572087, 1368.494355, 6422.289063, 7582.770508], [1477.972369, 1376.788032, 6419.878418, 7585.558105], [1454.373631, 1385.080462, 6417.562012, 7588.080566], [1430.775778, 1393.371682, 6415.216309, 7588.733887], [1407.178895, 1401.661638, 6412.607422, 7590.024414], [1383.582824, 1409.950435, 6409.83252, 7591.395508], [1359.987601, 1418.238086, 6406.145508, 7592.694824], [1336.393061, 1426.524749, 6402.402832, 7594.075684], [1312.799178, 1434.810504, 6397.785156, 7594.234375], [1289.205832, 1443.095506, 6393.129883, 7595.862793], [1265.612979, 1451.37984, 6387.497559, 7600.265137], [1242.020537, 1459.663617, 6381.611328, 7603.29541], [1218.42846, 1467.946908, 6377.953125, 7605.157715], [1194.83668, 1476.229801, 6375.067383, 7602.932129], [1171.245142, 1484.512368, 6371.548828, 7602.241699], [1147.653794, 1492.794684, 6367.505859, 7600.122559], [1124.062589, 1501.076811, 6363.715332, 7600.845215], [1100.471481, 1509.358812, 6364.46875, 7601.05127], [1076.880419, 1517.64075, 6364.971191, 7599.979492], [1053.548087, 1525.569049, 6362.186523, 7597.619629], [1030.215646, 1533.497443, 6359.522461, 7591.806152], [1006.882986, 1541.42602, 6357.679199, 7587.084961], [983.5499942, 1549.354888, 6357.174316, 7585.441406], [960.2165617, 1557.284161, 6356.130859, 7585.619141], [936.8825513, 1565.214019, 6350.290039, 7596.558105], [913.5478218, 1573.144643, 6336.376953, 7614.186523], [890.2121824, 1581.076301, 6322.848633, 7626.48584], [866.8754988, 1589.009221, 6328.634766, 7627.307129], [843.5375459, 1596.943777, 6341.518066, 7623.033203], [820.1981539, 1604.880271, 6349.364746, 7620.591309], [796.8570309, 1612.819284, 6352.438477, 7621.652832], [773.5139749, 1620.761142, 6354.918945, 7622.272461], [750.168652, 1628.706431, 6356.162109, 7624.650879], [726.8209487, 1636.655222, 6358.031738, 7627.674805], [703.4706314, 1644.60786, 6359.668945, 7629.525391], [680.1177391, 1652.564176, 6361.619141, 7629.192383], [656.7621456, 1660.524231, 6366.163574, 7622.678223], [633.4039824, 1668.487569, 6369.95459, 7614.848145], [610.0434589, 1676.453673, 6377.363281, 7618.458496], [586.6809703, 1684.422205, 6384.681152, 7612.650391], [563.3168166, 1692.392727, 6389.29834, 7607.855957], [539.9510116, 1700.365393, 6393.861328, 7604.508301], [516.5842372, 1708.33973, 6397.37207, 7601.666504], [493.2166617, 1716.315867, 6400.79248, 7598.940918], [469.847917, 1724.293702, 6404.085938, 7596.266602], [448.3224143, 1731.828956, 6286.668945, 7714.133789], [426.7969115, 1739.36421, 6287.810547, 7713.620117], [405.2714087, 1746.899463, 6288.563965, 7713.511719], [383.7459059, 1754.434717, 6289.171387, 7713.550781], [362.2204032, 1761.969971, 6289.682129, 7713.662109], [340.6949004, 1769.505225, 6290.122559, 7713.797852], [319.1693976, 1777.040479, 6290.50293, 7713.928711], [297.6438949, 1784.575733, 6290.824707, 7714.045898], [276.1183921, 1792.110986, 6291.084473, 7714.140625], [254.5928893, 1799.64624, 6291.287598, 7714.208008], [233.0673866, 1807.181494, 6291.438477, 7714.25], [211.5418838, 1814.716748, 6291.537109, 7714.280273], [190.016381, 1822.252002, 6291.584473, 7714.291992], [1614.233239, 1304.583323, 6308.59668, 7701.899414], [1594.777163, 1310.989773, 6308.600098, 7701.71582], [1575.321088, 1317.396223, 6308.61377, 7701.314453], [1555.865013, 1323.802674, 6308.646484, 7700.62793], [1536.408938, 1330.209124, 6308.709961, 7699.550781], [1516.952862, 1336.615574, 6424.566406, 7582.206055], [1493.352315, 1344.910357, 6422.240234, 7584.993652], [1469.752656, 1353.204026, 6419.975098, 7586.375977], [1446.153946, 1361.496494, 6417.745117, 7587.315918], [1422.556203, 1369.787729, 6415.387207, 7588.310547], [1398.959363, 1378.077688, 6412.84082, 7589.805664], [1375.363397, 1386.366468, 6409.902344, 7590.415527], [1351.768205, 1394.654132, 6406.455566, 7591.157715], [1328.173737, 1402.940817, 6402.452637, 7592.462891], [1304.579907, 1411.226598, 6397.756348, 7594.3125], [1280.986641, 1419.511605, 6392.742188, 7597.085938], [1257.393861, 1427.795938, 6386.719727, 7601.254883], [1233.80149, 1436.079713, 6380.831055, 7605.880859], [1210.209473, 1444.363017, 6378.230957, 7605.818848], [1186.617751, 1452.64593, 6376.26709, 7602.109375], [1163.026274, 1460.92852, 6371.797363, 7600.905273], [1139.434992, 1469.210851, 6368.489746, 7599.459473], [1115.843856, 1477.492989, 6365.089355, 7600.086426], [1092.252815, 1485.774999, 6363.304688, 7601.452148], [1068.661821, 1494.056944, 6362.231934, 7599.958496], [1045.32942, 1501.985033, 6360.143066, 7599.697266], [1021.99691, 1509.913218, 6358.544922, 7593.58252], [998.664185, 1517.8416, 6356.40918, 7589.199707], [975.3311148, 1525.770292, 6356.23877, 7583.546875], [951.9975927, 1533.699419, 6358.375977, 7584.333008], [928.6634802, 1541.629128, 6351.797852, 7593.17041], [905.3286601, 1549.55957, 6339.564453, 7605.63623], [881.9929531, 1557.490999, 6327.07373, 7614.099121], [858.6562342, 1565.423669, 6334.210449, 7616.75], [835.3182307, 1573.358029, 6344.824707, 7616.615723], [811.97877, 1581.294395, 6349.174805, 7617.199219], [788.6375202, 1589.233301, 6353.615234, 7618.15625], [765.2943755, 1597.174968, 6356.027832, 7619.157227], [741.9489811, 1605.119999, 6357.403809, 7621.52002], [718.6012787, 1613.068554, 6357.705078, 7625.555176], [695.2509051, 1621.021089, 6358.394531, 7627.291504], [671.8979166, 1628.977321, 6362.126465, 7627.723145], [648.5421967, 1636.93719, 6367.849121, 7626.456543], [625.1839968, 1644.90024, 6372.750977, 7613.506836], [601.8234637, 1652.866175, 6379.521484, 7611.964844], [578.4609427, 1660.834652, 6384.699219, 7612.443848], [555.0966612, 1668.805053, 6389.583496, 7608.247559], [531.730758, 1676.777435, 6393.998047, 7605.17041], [508.363986, 1684.751564, 6397.108398, 7602.86084], [484.9964157, 1692.727673, 6400.447754, 7600.174805], [461.6275461, 1700.705393, 6404.095215, 7596.929199], [440.1075385, 1708.238481, 6285.105957, 7715.694336], [418.5875309, 1715.771569, 6285.843262, 7715.166016], [397.0675233, 1723.304657, 6286.551758, 7714.832031], [375.5475157, 1730.837745, 6287.179199, 7714.646484], [354.0275081, 1738.370833, 6287.721191, 7714.564453], [332.5075005, 1745.903922, 6288.195801, 7714.540039], [310.987493, 1753.43701, 6288.604492, 7714.544922], [289.4674854, 1760.970098, 6288.952637, 7714.563477], [267.9474778, 1768.503186, 6289.231445, 7714.582031], [246.4274702, 1776.036274, 6289.453125, 7714.599609], [224.9074626, 1783.569362, 6289.620117, 7714.605469], [203.387455, 1791.10245, 6289.727539, 7714.608398], [181.8674474, 1798.635538, 6289.783691, 7714.607422], [1606.077059, 1280.970475, 6308.709473, 7701.330078], [1586.608242, 1287.382707, 6308.708984, 7701.1875], [1567.139425, 1293.794938, 6308.70459, 7700.896484], [1547.670609, 1300.20717, 6308.699707, 7700.439453], [1528.201792, 1306.619401, 6308.688477, 7699.833008], [1508.732975, 1313.031633, 6424.540039, 7583.289063], [1485.132482, 1321.326429, 6422.246582, 7585.376953], [1461.532899, 1329.62012, 6420.091797, 7587.07959], [1437.934296, 1337.912563, 6417.952637, 7587.653809], [1414.336578, 1346.203795, 6415.69043, 7587.391602], [1390.739829, 1354.493766, 6413.114258, 7587.543457], [1367.143893, 1362.782578, 6410.054688, 7588.429688], [1343.548806, 1371.070243, 6406.655273, 7589.497559], [1319.9544, 1379.356921, 6402.52832, 7590.956055], [1296.360651, 1387.642692, 6397.976074, 7594.104492], [1272.767439, 1395.927713, 6392.450684, 7596.587891], [1249.174719, 1404.212065, 6386.291504, 7600.338379], [1225.582411, 1412.495859, 6382.543457, 7602.935547], [1201.990467, 1420.779169, 6379.855469, 7603.524902], [1178.39882, 1429.062083, 6376.869141, 7601.144043], [1154.807415, 1437.344671, 6371.03125, 7599.541016], [1131.216201, 1445.627007, 6367.477051, 7599.48291], [1107.625128, 1453.909155, 6364.267578, 7600.830566], [1084.034152, 1462.191179, 6362.212891, 7601.220703], [1060.443223, 1470.473138, 6360.92334, 7602], [1037.110738, 1478.401058, 6359.369629, 7601.561035], [1013.778145, 1486.329075, 6357.850586, 7596.744141], [990.4453332, 1494.257276, 6355.95459, 7591.145508], [967.1121906, 1502.185767, 6353.707031, 7583.336426], [943.7786074, 1510.114665, 6356.58252, 7581.733398], [920.4444463, 1518.044147, 6352.80957, 7588.347656], [897.1095671, 1525.974397, 6341.251465, 7602.089355], [873.7737799, 1533.905683, 6333.167969, 7610.101074], [850.4369485, 1541.838231, 6333.626465, 7613.487793], [827.0988487, 1549.772418, 6344.506348, 7615.430664], [803.7593127, 1557.708547, 6351.120605, 7616.371094], [780.4180477, 1565.647197, 6354.925293, 7616.404297], [757.0748514, 1573.588695, 6356.845215, 7616.596191], [733.7293893, 1581.53363, 6358.46875, 7618.724121], [710.3815506, 1589.482068, 6357.66748, 7622.816406], [687.0311007, 1597.434362, 6358.036133, 7624.385742], [663.6780787, 1605.390335, 6362.369141, 7625.208008], [640.3223579, 1613.350053, 6368.533691, 7623.983887], [616.9640703, 1621.313057, 6373.93457, 7616.693848], [593.6034251, 1629.278832, 6379.130859, 7608.111328], [570.2408178, 1637.247035, 6384.133789, 7612.812012], [546.8765473, 1645.217232, 6389.307617, 7608.047363], [523.5106269, 1653.189576, 6393.586426, 7606.16748], [500.1437395, 1661.163591, 6396.805176, 7603.613281], [476.7760515, 1669.13941, 6400.204102, 7600.713867], [455.1379148, 1676.700115, 6282.144531, 7718.419922], [433.4997781, 1684.260821, 6283.099121, 7717.263672], [411.8616415, 1691.821527, 6283.894043, 7716.507813], [390.2235048, 1699.382233, 6284.617676, 7715.993164], [368.5853681, 1706.942939, 6285.263672, 7715.643555], [346.9472314, 1714.503645, 6285.836914, 7715.40918], [325.3090948, 1722.06435, 6286.344238, 7715.25293], [303.6709581, 1729.625056, 6286.775391, 7715.148438], [282.0328214, 1737.185762, 6287.144531, 7715.079102], [260.3946847, 1744.746468, 6287.443848, 7715.03125], [238.7565481, 1752.307174, 6287.685059, 7714.995117], [217.1184114, 1759.86788, 6287.86084, 7714.96875], [195.4802747, 1767.428585, 6287.976563, 7714.944336], [173.8421381, 1774.989291, 6288.035156, 7714.936523], [1597.920874, 1257.357641, 6308.824219, 7700.901367], [1578.43931, 1263.775668, 6308.816406, 7700.811523], [1558.957747, 1270.193695, 6308.79834, 7700.638672], [1539.476184, 1276.611721, 6308.76123, 7700.404297], [1519.99462, 1283.029748, 6308.685059, 7700.176758], [1500.513057, 1289.447774, 6424.503906, 7584.140625], [1476.912647, 1297.742562, 6422.381348, 7585.975098], [1453.313127, 1306.036236, 6420.31543, 7586.554199], [1429.714555, 1314.328711, 6418.177734, 7586.408203], [1406.116952, 1322.619953, 6415.869629, 7586.30127], [1382.520251, 1330.909918, 6413.408203, 7585.736328], [1358.924424, 1339.198707, 6410.37207, 7587.654297], [1335.32937, 1347.486378, 6407.002441, 7588.726563], [1311.735039, 1355.773072, 6402.42334, 7589.950195], [1288.141347, 1364.058863, 6398.044434, 7592.169922], [1264.54822, 1372.34388, 6394.320801, 7595.130371], [1240.955577, 1380.628224, 6390.001953, 7598.01709], [1217.363343, 1388.912009, 6386.766602, 7600.392578], [1193.771462, 1397.195326, 6381.067871, 7600.262207], [1170.179876, 1405.478251, 6375.65332, 7600.404297], [1146.588536, 1413.760854, 6370.715332, 7600.28418], [1122.997389, 1422.043198, 6366.353027, 7601.574707], [1099.406389, 1430.32535, 6362.489258, 7601.976074], [1075.815483, 1438.607373, 6360.519043, 7603.497559], [1052.224625, 1446.889332, 6359.19873, 7604.989258], [1028.892073, 1454.817042, 6357.995605, 7605.032715], [1005.559413, 1462.74485, 6356.933594, 7603.458496], [982.2265387, 1470.672857, 6355.472168, 7594.688477], [958.8933198, 1478.601176, 6353.083496, 7581.824707], [935.5596489, 1486.52993, 6353.450684, 7581.433594], [912.2253877, 1494.459264, 6353.453613, 7586.092773], [888.8904197, 1502.389331, 6342.622559, 7600.58252], [865.5545658, 1510.320387, 6337.602539, 7613.299316], [842.217701, 1518.252685, 6336.567383, 7616.234863], [818.8795526, 1526.18668, 6343.691406, 7615.126465], [795.5399498, 1534.12268, 6353.344238, 7616.352051], [772.1985579, 1542.061227, 6356.288086, 7614.64209], [748.8552749, 1550.002536, 6358.105469, 7614.905273], [725.5097441, 1557.947214, 6359.22168, 7616.622559], [702.1619063, 1565.895418, 6358.20459, 7619.418945], [678.8114011, 1573.847606, 6358.671387, 7621.0625], [655.4582838, 1581.803498, 6362.931152, 7621.626465], [632.1024371, 1589.763034, 6368.527344, 7621.261719], [608.7441142, 1597.725752, 6374.02002, 7621.302246], [585.3834605, 1605.691359, 6379.01709, 7610.750977], [562.0208212, 1613.659509, 6384.260254, 7613.657227], [538.6564234, 1621.629586, 6389.513184, 7609.574707], [515.2904057, 1629.601646, 6393.140137, 7606.693359], [491.9235211, 1637.575454, 6396.469727, 7605.351563], [468.5558389, 1645.551245, 6400.205078, 7600.482422], [446.9228205, 1653.10992, 6280.509277, 7719.432617], [425.2898021, 1660.668595, 6281.24707, 7718.416016], [403.6567837, 1668.22727, 6282.016602, 7717.607422], [382.0237653, 1675.785945, 6282.75, 7716.988281], [360.3907469, 1683.34462, 6283.422363, 7716.522461], [338.7577285, 1690.903294, 6284.02002, 7716.173828], [317.1247101, 1698.461969, 6284.550293, 7715.90918], [295.4916917, 1706.020644, 6285.011719, 7715.716797], [273.8586733, 1713.579319, 6285.399414, 7715.573242], [252.2256549, 1721.137994, 6285.72168, 7715.467773], [230.5926365, 1728.696669, 6285.975098, 7715.387695], [208.9596181, 1736.255343, 6286.165527, 7715.331055], [187.3265997, 1743.814018, 6286.287109, 7715.286133], [165.6935813, 1751.372693, 6286.351563, 7715.261719], [1589.764684, 1233.744819, 6308.952148, 7700.563477], [1570.270369, 1240.168652, 6308.943848, 7700.523438], [1550.776054, 1246.592485, 6308.918945, 7700.445313], [1531.281739, 1253.016318, 6308.85791, 7700.365234], [1511.787424, 1259.440152, 6308.745117, 7700.366211], [1492.29311, 1265.863985, 6424.547363, 7584.680176], [1468.692758, 1274.15878, 6422.522949, 7586.084473], [1445.093317, 1282.452468, 6420.534668, 7587.256836], [1421.494857, 1290.744909, 6418.394043, 7586.267578], [1397.89728, 1299.036141, 6416.155762, 7585.899902], [1374.300674, 1307.326112, 6413.625977, 7586.16748], [1350.70488, 1315.614923, 6410.570313, 7587.307129], [1327.109934, 1323.902591, 6406.956055, 7588.63916], [1303.515671, 1332.18927, 6402.246582, 7588.784668], [1279.922063, 1340.475043, 6397.604004, 7591.550293], [1256.32899, 1348.760065, 6392.990234, 7594.456055], [1232.736412, 1357.044421, 6390.39209, 7597.615723], [1209.144244, 1365.328219, 6384.43457, 7600.171875], [1185.55244, 1373.611532, 6378.361328, 7601.89502], [1161.960932, 1381.894449, 6372.632324, 7602.867676], [1138.369667, 1390.177041, 6366.573242, 7602.904785], [1114.778591, 1398.459382, 6364.685059, 7604.80127], [1091.187656, 1406.741535, 6361.081543, 7605.951172], [1067.596818, 1415.023562, 6358.566406, 7607.225586], [1044.006027, 1423.305526, 6357.020508, 7608.616699], [1020.673395, 1431.233071, 6356.206055, 7608.962891], [997.3406551, 1439.160712, 6355.61084, 7607.916992], [974.0076965, 1447.088537, 6353.955566, 7597.442871], [950.6744061, 1455.016653, 6351.913574, 7580.95752], [927.340677, 1462.945176, 6350.543457, 7577.070313], [904.00637, 1470.874286, 6349.272461, 7583.603516], [880.6713448, 1478.804164, 6345.272949, 7598.280762], [857.3354137, 1486.73508, 6340.048828, 7611.685547], [833.9984392, 1494.66726, 6338.494629, 7614.841309], [810.6601973, 1502.601082, 6344.350586, 7614.234375], [787.3205202, 1510.536846, 6354.09082, 7611.859375], [763.9791149, 1518.475136, 6357.557617, 7612.57666], [740.6357814, 1526.416277, 6359.463379, 7613.086914], [717.2901838, 1534.36086, 6359.949707, 7613.673828], [693.9422116, 1542.30895, 6359.486816, 7614.79248], [670.591631, 1550.260901, 6361.236328, 7618.987793], [647.2384823, 1558.216536, 6364.84082, 7620.45459], [623.882636, 1566.175919, 6368.585449, 7619.322266], [600.5242268, 1574.138593, 6373.952148, 7619.709961], [577.1634615, 1582.104039, 6379.233887, 7612.383301], [553.8007364, 1590.071918, 6383.249512, 7615.202148], [530.4363505, 1598.041792, 6387.297363, 7610.65918], [507.0703166, 1606.013815, 6392.668457, 7606.712402], [483.7033162, 1613.987512, 6396.13623, 7603.07373], [461.9666792, 1621.570338, 6277.437012, 7721.670898], [440.2300422, 1629.153165, 6278.467285, 7720.379883], [418.4934052, 1636.735992, 6279.349121, 7719.354492], [396.7567682, 1644.318818, 6280.174805, 7718.513672], [375.0201313, 1651.901645, 6280.943848, 7717.828125], [353.2834943, 1659.484472, 6281.644043, 7717.280273], [331.5468573, 1667.067298, 6282.273926, 7716.84375], [309.8102203, 1674.650125, 6282.831543, 7716.501953], [288.0735833, 1682.232952, 6283.316406, 7716.237305], [266.3369464, 1689.815779, 6283.726563, 7716.029297], [244.6003094, 1697.398605, 6284.067871, 7715.873047], [222.8636724, 1704.981432, 6284.337402, 7715.756836], [201.1270354, 1712.564259, 6284.535156, 7715.671875], [179.3903985, 1720.147085, 6284.668945, 7715.614258], [157.6537615, 1727.729912, 6284.731934, 7715.587891], [1581.60849, 1210.132012, 6309.091797, 7700.28125], [1562.101419, 1216.561668, 6309.086914, 7700.273438], [1542.594349, 1222.991324, 6309.070801, 7700.254883], [1523.087278, 1229.42098, 6309.013672, 7700.235352], [1503.580208, 1235.850636, 6308.897461, 7700.232422], [1484.073137, 1242.280292, 6424.649902, 7584.301758], [1460.472873, 1250.575069, 6422.672363, 7585.546875], [1436.873498, 1258.868733, 6420.755859, 7586.077637], [1413.275072, 1267.1612, 6418.616211, 7586.286621], [1389.677614, 1275.452433, 6416.459473, 7586.274414], [1366.081059, 1283.742391, 6413.768066, 7587.210938], [1342.485376, 1292.031172, 6410.848145, 7588.349609], [1318.890467, 1300.318836, 6407.577148, 7590.486816], [1295.296281, 1308.605523, 6402.658691, 7592.087402], [1271.702734, 1316.891307, 6397.116211, 7594.325195], [1248.10975, 1325.176318, 6391.649414, 7597.078613], [1224.517249, 1333.460657, 6387.044434, 7600.299316], [1200.925159, 1341.744436, 6380.461914, 7604.978027], [1177.333421, 1350.027747, 6373.917969, 7607.387695], [1153.741977, 1358.310667, 6367.931641, 7608.310059], [1130.150778, 1366.593265, 6363.253418, 7609.092285], [1106.559772, 1374.875603, 6361.800293, 7609.256348], [1082.968913, 1383.157749, 6359.502441, 7609.72998], [1059.378147, 1391.439767, 6356.842285, 7611.548828], [1035.787429, 1399.72172, 6355.149902, 7612.255371], [1012.454733, 1407.649058, 6354.006836, 7612.241211], [989.1219302, 1415.576491, 6353.908691, 7608.648438], [965.7889116, 1423.504123, 6353.240234, 7596.248047], [942.4555477, 1431.432065, 6352.095215, 7579.511719], [919.1217347, 1439.360444, 6350.676758, 7576.585938], [895.7873304, 1447.289408, 6349.952637, 7578.342773], [872.4522204, 1455.219106, 6347.963379, 7595.402832], [849.1162253, 1463.149794, 6343.397949, 7607.187988], [825.7792204, 1471.081726, 6342.250977, 7611.760742], [802.4409327, 1479.015354, 6346.916016, 7610.123047], [779.1011907, 1486.950992, 6353.652344, 7609.838379], [755.7596615, 1494.889179, 6356.198242, 7611.17627], [732.416243, 1502.830132, 6358.180176, 7611.466797], [709.0705777, 1510.774458, 6359.400391, 7611.980469], [685.7226103, 1518.722316, 6360.620605, 7614.196289], [662.3719754, 1526.674164, 6363.008301, 7616.626465], [639.0187322, 1534.629718, 6365.418457, 7617.987305], [615.662762, 1542.58892, 6369.983887, 7618.181152], [592.3043179, 1550.551307, 6374.461914, 7618.439453], [568.9435455, 1558.516588, 6378.195313, 7609.195313], [545.5807894, 1566.484414, 6380.132813, 7608.942871], [522.2162761, 1574.454171, 6384.935547, 7611.313965], [498.850145, 1582.425911, 6391.93457, 7605.805176], [475.4831484, 1590.399402, 6395.725586, 7601.92041], [453.751307, 1597.980321, 6275.649414, 7722.032227], [432.0194656, 1605.56124, 6276.569336, 7721.066406], [410.2876242, 1613.14216, 6277.503906, 7720.111328], [388.5557828, 1620.723079, 6278.384766, 7719.25293], [366.8239414, 1628.303998, 6279.201172, 7718.53125], [345.0921, 1635.884917, 6279.940918, 7717.916992], [323.3602586, 1643.465837, 6280.604004, 7717.421875], [301.6284172, 1651.046756, 6281.1875, 7717.017578], [279.8965758, 1658.627675, 6281.692383, 7716.691406], [258.1647344, 1666.208594, 6282.123047, 7716.438477], [236.432893, 1673.789513, 6282.478516, 7716.237305], [214.7010516, 1681.370433, 6282.76416, 7716.09082], [192.9692102, 1688.951352, 6282.979004, 7715.981445], [171.2373688, 1696.532271, 6283.115723, 7715.916992], [149.5055274, 1704.11319, 6283.188965, 7715.887695], [1573.452292, 1186.519219, 6309.230957, 7700.006836], [1553.932462, 1192.95471, 6309.242676, 7700.02832], [1534.412633, 1199.390201, 6309.249023, 7700.066406], [1514.892803, 1205.825693, 6309.234375, 7700.091797], [1495.372974, 1212.261184, 6309.147949, 7700.067383], [1475.853144, 1218.696676, 6424.870117, 7583.952148], [1452.25294, 1226.991453, 6423.005859, 7585.496582], [1428.653647, 1235.285124, 6421.062988, 7585.870605], [1405.055335, 1243.577548, 6418.903809, 7585.349121], [1381.457908, 1251.868764, 6416.652344, 7586.86084], [1357.86145, 1260.158719, 6413.84375, 7588.216797], [1334.265804, 1268.447516, 6411.100586, 7590.087891], [1310.671005, 1276.735167, 6407.750488, 7592.789063], [1287.076889, 1285.021832, 6403.661133, 7594.964844], [1263.483427, 1293.307589, 6397.542969, 7596.469727], [1239.890501, 1301.592596, 6391.765625, 7599.673828], [1216.298069, 1309.876936, 6384.069336, 7604.418945], [1192.706046, 1318.160719, 6375.602539, 7608.312012], [1169.114386, 1326.444017, 6370.196289, 7612.896973], [1145.523022, 1334.726918, 6366.173828, 7611.163086], [1121.931899, 1343.009494, 6363.185547, 7613.727051], [1098.340966, 1351.291819, 6361.06543, 7614.726563], [1074.750175, 1359.573955, 6358.576172, 7615.041016], [1051.15948, 1367.855967, 6355.597656, 7615.530273], [1027.568831, 1376.137914, 6353.316895, 7616.16748], [1004.236059, 1384.065086, 6351.632324, 7614.845215], [980.9031786, 1391.992353, 6351.37793, 7606.235352], [957.5700799, 1399.919806, 6351.606934, 7592.276367], [934.2366502, 1407.847549, 6351.270508, 7582.495605], [910.9027809, 1415.775701, 6352.260254, 7579.933105], [887.5683356, 1423.704439, 6352.48877, 7579.141113], [864.2331712, 1431.633947, 6349.428711, 7590.024902], [840.8971018, 1439.564495, 6345.456055, 7603.379395], [817.55999, 1447.496308, 6344.168945, 7608.166992], [794.2216108, 1455.429765, 6348.958008, 7606.97168], [770.8817982, 1463.365167, 6352.107422, 7608.48584], [747.5402595, 1471.303099, 6353.70166, 7610.820313], [724.1967933, 1479.243886, 6355.382324, 7611.213867], [700.8510651, 1487.188118, 6356.515137, 7612.042969], [677.5029641, 1495.135862, 6358.60791, 7613.172363], [654.1522568, 1503.087471, 6362.276367, 7615.293945], [630.798983, 1511.042769, 6365.574707, 7616.25], [607.4430152, 1519.00182, 6369.965332, 7616.738281], [584.0844858, 1526.964166, 6374.222656, 7616.840332], [560.7236027, 1534.929287, 6378.175293, 7614.052734], [537.3607618, 1542.896844, 6380.781738, 7606.908203], [513.9962609, 1550.866397, 6385.925781, 7609.228516], [490.6301136, 1558.838101, 6391.078125, 7605.296875], [468.806592, 1566.4403, 6272.10498, 7724.211914], [446.9830705, 1574.042499, 6273.493164, 7722.862305], [425.159549, 1581.644697, 6274.650879, 7721.745117], [403.3360275, 1589.246896, 6275.709961, 7720.74707], [381.5125059, 1596.849095, 6276.664063, 7719.869141], [359.6889844, 1604.451294, 6277.53418, 7719.102539], [337.8654629, 1612.053492, 6278.313477, 7718.449219], [316.0419413, 1619.655691, 6279.010254, 7717.899414], [294.2184198, 1627.25789, 6279.617188, 7717.449219], [272.3948983, 1634.860089, 6280.148926, 7717.085938], [250.5713768, 1642.462288, 6280.597656, 7716.792969], [228.7478552, 1650.064486, 6280.967773, 7716.55957], [206.9243337, 1657.666685, 6281.26709, 7716.383789], [185.1008122, 1665.268884, 6281.486328, 7716.258789], [163.2772907, 1672.871083, 6281.637207, 7716.1875], [141.4537691, 1680.473281, 6281.715332, 7716.147461], [1565.296091, 1162.906442, 6309.368164, 7699.713867], [1545.763499, 1169.347786, 6309.398926, 7699.771484], [1526.230907, 1175.789131, 6309.455566, 7699.87793], [1506.698315, 1182.230475, 6309.520996, 7700.007813], [1487.165723, 1188.671819, 6309.508789, 7700.088867], [1467.633131, 1195.113164, 6425.214355, 7584.180664], [1444.033018, 1203.407917, 6423.365723, 7583.97168], [1420.433793, 1211.701556, 6421.352539, 7584.160156], [1396.835519, 1219.993996, 6419.228516, 7584.92041], [1373.238211, 1228.285206, 6416.710449, 7586.788574], [1349.641806, 1236.57514, 6413.813477, 7590.196777], [1326.046274, 1244.863896, 6410.79248, 7590.416992], [1302.451515, 1253.151537, 6407.464355, 7592.09082], [1278.857478, 1261.4382, 6404.14502, 7594.425293], [1255.264079, 1269.72396, 6398.147461, 7597.26123], [1231.671243, 1278.008946, 6391.796387, 7601.07373], [1208.078891, 1286.293259, 6383.65918, 7605.07959], [1184.486947, 1294.577014, 6375.297852, 7611.13916], [1160.895355, 1302.860299, 6370.668945, 7616.53418], [1137.304057, 1311.143192, 6366.203125, 7614.671387], [1113.713004, 1319.425763, 6363.097168, 7616.640137], [1090.122142, 1327.708074, 6360.966309, 7618.773926], [1066.531427, 1335.990193, 6358.20459, 7618.370605], [1042.940807, 1344.272182, 6355.453613, 7618.679688], [1019.350233, 1352.554108, 6350.487793, 7620.580566], [996.0174018, 1360.48107, 6349.155273, 7620.304688], [972.6844614, 1368.408131, 6348.875977, 7604.756836], [949.3513073, 1376.335393, 6349.370117, 7590.085449], [926.017809, 1384.262967, 6349.703125, 7581.967285], [902.6838606, 1392.190976, 6353.587402, 7582.466309], [879.3493208, 1400.119569, 6355.64502, 7583.520996], [856.0140763, 1408.048896, 6349.565918, 7592.10791], [832.6779459, 1415.979214, 6347.390137, 7601.339844], [809.3408064, 1423.910779, 6347.830566, 7606.36084], [786.0023852, 1431.844044, 6349.805664, 7606.130371], [762.6625116, 1439.779321, 6351.61377, 7607.17041], [739.3208527, 1447.71715, 6354.393066, 7609.0625], [715.9773046, 1455.657748, 6354.911621, 7611.395508], [692.6315124, 1463.601725, 6354.589355, 7613.114258], [669.2834172, 1471.549236, 6356.725098, 7614.79834], [645.9326593, 1479.500742, 6360.959961, 7615.986328], [622.579293, 1487.455959, 6364.928223, 7617.520996], [599.2232022, 1495.41483, 6369.543945, 7617.428223], [575.8646394, 1503.376891, 6373.753418, 7615.397949], [552.5037501, 1511.341847, 6377.770996, 7613.46875], [529.1408782, 1519.309352, 6381.807129, 7606.333984], [505.776251, 1527.278787, 6386.01709, 7606.333984], [482.4100068, 1535.250209, 6390.342773, 7604.378906], [460.5909952, 1542.8506, 6270.166992, 7724.727539], [438.7719836, 1550.45099, 6271.562012, 7723.476563], [416.9529719, 1558.051381, 6272.843262, 7722.311523], [395.1339603, 1565.651772, 6274.001465, 7721.270508], [373.3149487, 1573.252162, 6275.03418, 7720.348633], [351.495937, 1580.852553, 6275.955078, 7719.553711], [329.6769254, 1588.452944, 6276.773438, 7718.87207], [307.8579138, 1596.053335, 6277.498047, 7718.291992], [286.0389022, 1603.653725, 6278.131348, 7717.808594], [264.2198905, 1611.254116, 6278.679688, 7717.40332], [242.4008789, 1618.854507, 6279.154785, 7717.081055], [220.5818673, 1626.454897, 6279.540527, 7716.826172], [198.7628557, 1634.055288, 6279.846191, 7716.632813], [176.943844, 1641.655679, 6280.074219, 7716.495117], [155.1248324, 1649.25607, 6280.231445, 7716.404297], [133.3058208, 1656.85646, 6280.312012, 7716.359375], [1557.139887, 1139.29368, 6309.471191, 7699.366211], [1537.59453, 1145.74089, 6309.534668, 7699.466797], [1518.049173, 1152.188101, 6309.664063, 7699.674805], [1498.503815, 1158.635312, 6309.864746, 7699.961914], [1478.958458, 1165.082523, 6310.054688, 7700.214844], [1459.4131, 1171.529734, 6425.566406, 7583.934082], [1435.813051, 1179.824478, 6423.721191, 7583.137207], [1412.213911, 1188.118116, 6421.583008, 7583.080078], [1388.615753, 1196.410508, 6419.344727, 7584.207031], [1365.018478, 1204.701691, 6416.616699, 7586.557617], [1341.422173, 1212.991612, 6413.791992, 7588.479004], [1317.826679, 1221.280376, 6410.484375, 7590.152832], [1294.232033, 1229.567995, 6406.968262, 7591.022461], [1270.638067, 1237.854626, 6403.389648, 7592.919434], [1247.044756, 1246.140349, 6398.484863, 7598.035645], [1223.45198, 1254.425323, 6391.058594, 7603.14209], [1199.859696, 1262.709628, 6383.007324, 7609.635254], [1176.267822, 1270.993375, 6376.487793, 7613.206055], [1152.67631, 1279.276636, 6372.303711, 7616.166016], [1129.085095, 1287.559501, 6368.40625, 7616.76709], [1105.494119, 1295.842039, 6365.343262, 7618.714355], [1081.903332, 1304.124325, 6361.938965, 7619.530762], [1058.312687, 1312.406423, 6358.694824, 7619.713379], [1034.722138, 1320.688394, 6355.532227, 7620.769531], [1011.131635, 1328.970302, 6349.381836, 7623.047363], [987.7987313, 1336.897101, 6345.61084, 7619.359863], [964.4657203, 1344.823998, 6344.89209, 7605.037109], [941.1324899, 1352.751079, 6345.686523, 7591.774414], [917.7989287, 1360.67845, 6350.100586, 7582.637207], [894.4649287, 1368.606231, 6361.535645, 7580.486328], [871.1303518, 1376.534598, 6358.3125, 7580.949219], [847.7950587, 1384.463738, 6348.254395, 7593.484863], [824.4588586, 1392.393918, 6347.364746, 7599.930176], [801.1216171, 1400.325365, 6348.607422, 7606.428711], [777.7831091, 1408.258457, 6350.666504, 7605.577148], [754.4431687, 1416.193498, 6353.663086, 7605.214355], [731.1015022, 1424.131071, 6356.102051, 7607.196289], [707.7579092, 1432.071502, 6356.13916, 7609.285645], [684.4120561, 1440.015384, 6355.977051, 7612.662109], [661.0638321, 1447.962783, 6358.755371, 7616.023438], [637.7130026, 1455.91405, 6360.669434, 7618.236816], [614.3596078, 1463.869012, 6364.612793, 7619.292969], [591.0035217, 1471.827731, 6369.066895, 7618.040039], [567.644875, 1479.789748, 6373.290527, 7615.750488], [544.2838761, 1487.754545, 6377.465332, 7613.03125], [520.9209202, 1495.72178, 6381.544434, 7607.011719], [497.5563054, 1503.691014, 6385.379395, 7607.340332], [475.6555868, 1511.310303, 6266.04834, 7727.165039], [453.7548682, 1518.929592, 6268.068359, 7725.449219], [431.8541496, 1526.548882, 6269.733398, 7723.999023], [409.953431, 1534.168171, 6271.166992, 7722.74707], [388.0527124, 1541.78746, 6272.412109, 7721.663086], [366.1519938, 1549.40675, 6273.508789, 7720.716797], [344.2512752, 1557.026039, 6274.475098, 7719.895508], [322.3505566, 1564.645328, 6275.327148, 7719.189453], [300.449838, 1572.264618, 6276.079102, 7718.589844], [278.5491195, 1579.883907, 6276.73877, 7718.080078], [256.6484009, 1587.503196, 6277.304688, 7717.65625], [234.7476823, 1595.122486, 6277.790039, 7717.304688], [212.8469637, 1602.741775, 6278.189453, 7717.03418], [190.9462451, 1610.361064, 6278.505371, 7716.832031], [169.0455265, 1617.980354, 6278.744141, 7716.673828], [147.1448079, 1625.599643, 6278.900879, 7716.571289], [125.2440893, 1633.218932, 6278.978516, 7716.523438], [1549.79222, 1115.312411, 6309.506348, 7698.916992], [1531.042633, 1121.396982, 6309.597656, 7699.066406], [1512.293046, 1127.481553, 6309.808594, 7699.387695], [1493.543459, 1133.566124, 6310.222168, 7699.962891], [1474.793873, 1139.650695, 6426.929688, 7585.207031], [1451.193055, 1147.946408, 6425.245605, 7583.577148], [1427.593097, 1156.241121, 6423.524902, 7582.450684], [1403.99403, 1164.53472, 6421.485352, 7582.267578], [1380.395911, 1172.82712, 6419.248047, 7583.524414], [1356.798759, 1181.118287, 6416.302246, 7585.755371], [1333.202508, 1189.40818, 6413.315918, 7587.296875], [1309.607129, 1197.696895, 6409.759277, 7587.939453], [1286.012524, 1205.984494, 6406.394043, 7590.180664], [1262.41864, 1214.271114, 6402.487793, 7594.052246], [1238.825393, 1222.55683, 6398.756348, 7599.240723], [1215.232708, 1230.841772, 6390.45166, 7605.509766], [1191.640507, 1239.126041, 6381.974121, 7615.148438], [1168.048713, 1247.409749, 6377.04834, 7616.599609], [1144.457271, 1255.692987, 6373.416992, 7621.284668], [1120.866122, 1263.975832, 6369.659668, 7617.652344], [1097.275217, 1272.258354, 6366.761719, 7617.899414], [1073.684504, 1280.540614, 6363.420898, 7618.357422], [1050.093937, 1288.822684, 6357.425781, 7617.827637], [1026.503463, 1297.104622, 6351.709961, 7620.022461], [1002.913037, 1305.386496, 6346.572754, 7623.171387], [979.5800789, 1313.313089, 6342.647461, 7618.522461], [956.2470126, 1321.239778, 6341.506348, 7605.311523], [932.9137317, 1329.166666, 6341.581055, 7594.027832], [909.5801065, 1337.093866, 6343.980957, 7584.511719], [886.2460312, 1345.021503, 6353.367188, 7579.200195], [862.9113666, 1352.949725, 6349.433594, 7580.084473], [839.5759952, 1360.878684, 6345.75, 7589.353516], [816.2397408, 1368.808636, 6347.90332, 7599.934082], [792.9024755, 1376.739834, 6349.626465, 7607.594727], [769.5639303, 1384.672734, 6352.155762, 7607.42041], [746.2239317, 1392.607647, 6353.655273, 7605.391113], [722.8821489, 1400.545116, 6354.910156, 7606.223145], [699.5384777, 1408.485359, 6355.945313, 7607.756836], [676.1925635, 1416.428983, 6357.455078, 7610.798828], [652.8443481, 1424.376149, 6358.967773, 7616.136719], [629.49347, 1432.327314, 6361.09668, 7619.127441], [606.1399855, 1440.282195, 6365.223633, 7619.559082], [582.7837788, 1448.240732, 6369.183105, 7617.494629], [559.4250997, 1456.202464, 6373.254883, 7615.191895], [536.0640955, 1464.167094, 6377.188477, 7611.279297], [512.7011095, 1472.134278, 6380.068359, 7608.333984], [489.3363684, 1480.103393, 6383.109375, 7607.849121], [467.4398997, 1487.72096, 6263.99707, 7727.898438], [445.543431, 1495.338526, 6266.320313, 7725.917969], [423.6469624, 1502.956093, 6268.145508, 7724.327148], [401.7504937, 1510.57366, 6269.66748, 7723.019531], [379.854025, 1518.191226, 6270.970703, 7721.908203], [357.9575563, 1525.808793, 6272.105957, 7720.948242], [336.0610877, 1533.42636, 6273.10791, 7720.121094], [314.164619, 1541.043926, 6273.991211, 7719.40332], [292.2681503, 1548.661493, 6274.76416, 7718.793945], [270.3716817, 1556.27906, 6275.437012, 7718.268555], [248.475213, 1563.896626, 6276.018555, 7717.830078], [226.5787443, 1571.514193, 6276.507813, 7717.469727], [204.6822756, 1579.131759, 6276.918457, 7717.181641], [182.785807, 1586.749326, 6277.243652, 7716.963867], [160.8893383, 1594.366893, 6277.487305, 7716.793945], [138.9928696, 1601.984459, 6277.645996, 7716.694336], [117.0964009, 1609.602026, 6277.722656, 7716.636719], [1541.633441, 1091.700858, 6309.456543, 7698.322266], [1522.868514, 1097.792505, 6309.545898, 7698.491211], [1504.103587, 1103.884153, 6309.746582, 7698.861328], [1485.33866, 1109.975801, 6310.115234, 7699.466797], [1466.573732, 1116.067448, 6426.557129, 7584.587402], [1442.972994, 1124.363163, 6424.87207, 7583.33252], [1419.373103, 1132.65786, 6422.963867, 7582.518555], [1395.774122, 1140.95145, 6420.838379, 7581.213379], [1372.176121, 1149.243793, 6418.372559, 7581.977539], [1348.579005, 1157.534927, 6415.607422, 7581.975586], [1324.982856, 1165.824798, 6412.57373, 7582.50293], [1301.387518, 1174.113512, 6409.076172, 7583.749023], [1277.793025, 1182.401079, 6405.345215, 7586.883789], [1254.199213, 1190.687658, 6401.049316, 7593.766602], [1230.606056, 1198.973328, 6397.446289, 7599.400879], [1207.013433, 1207.258247, 6390.978027, 7606.837891], [1183.421301, 1215.542497, 6381.380371, 7612.964844], [1159.829578, 1223.826188, 6377.71582, 7616.666016], [1136.238218, 1232.109391, 6374.20166, 7619.26123], [1112.647152, 1240.392196, 6369.273438, 7617.629883], [1089.056326, 1248.674675, 6366.144043, 7616.894043], [1065.465689, 1256.9569, 6360.183105, 7618.141113], [1041.875194, 1265.238936, 6353.469238, 7617.662598], [1018.284793, 1273.520845, 6348.870117, 7618.883301], [994.6944388, 1281.80269, 6345.166016, 7619.496582], [971.3614141, 1289.729117, 6341.850098, 7617.82666], [948.028281, 1297.655639, 6339.671875, 7607.875488], [924.6949295, 1305.582349, 6339.577148, 7600.895508], [901.3612462, 1313.509348, 6340.983398, 7593.09082], [878.0271251, 1321.436758, 6342.162598, 7586.963379], [854.6924271, 1329.364753, 6342.807617, 7586.416992], [831.3570119, 1337.293522, 6343.713379, 7593.400391], [808.0206907, 1345.223331, 6346.174316, 7602.796875], [784.6833281, 1353.154409, 6348.759277, 7607.821289], [761.3447, 1361.087136, 6350.385254, 7609.529785], [738.0046385, 1369.021812, 6352.011719, 7608.270996], [714.6628527, 1376.959025, 6352.912109, 7607.357422], [691.3191406, 1384.899099, 6353.695801, 7605.681152], [667.9731701, 1392.842627, 6356.516113, 7609.820801], [644.6248278, 1400.789678, 6358.697754, 7613.277832], [621.2738811, 1408.740602, 6361.53418, 7616.124512], [597.9203709, 1416.695227, 6365.331055, 7616.707031], [574.5641694, 1424.653612, 6369.107422, 7615.851563], [551.2054077, 1432.615301, 6372.620605, 7614.206055], [527.8442948, 1440.579773, 6376.555664, 7610.345703], [504.4812255, 1448.546685, 6380.601074, 7606.325684], [481.1164967, 1456.515598, 6383.184082, 7609.361816], [459.2242743, 1464.131452, 6262.994629, 7728.196289], [437.3320519, 1471.747305, 6265.085938, 7725.990234], [415.4398296, 1479.363159, 6266.855469, 7724.385742], [393.5476072, 1486.979013, 6268.373047, 7723.086914], [371.6553848, 1494.594866, 6269.694824, 7721.992188], [349.7631624, 1502.21072, 6270.847168, 7721.054688], [327.87094, 1509.826574, 6271.86377, 7720.230469], [305.9787176, 1517.442427, 6272.758301, 7719.518555], [284.0864953, 1525.058281, 6273.541016, 7718.898438], [262.1942729, 1532.674134, 6274.227051, 7718.371094], [240.3020505, 1540.289988, 6274.816895, 7717.931641], [218.4098281, 1547.905842, 6275.316895, 7717.55957], [196.5176057, 1555.521695, 6275.73291, 7717.265625], [174.6253834, 1563.137549, 6276.061523, 7717.02832], [152.733161, 1570.753403, 6276.304688, 7716.866211], [130.8409386, 1578.369256, 6276.473145, 7716.753906], [108.9487162, 1585.98511, 6276.550781, 7716.699219], [1533.474658, 1068.089337, 6309.317871, 7697.55957], [1514.694387, 1074.188093, 6309.383789, 7697.726563], [1495.914116, 1080.286849, 6309.52002, 7698.088867], [1477.133844, 1086.385605, 6309.731445, 7698.65918], [1458.353573, 1092.484361, 6425.806152, 7583.60791], [1434.752917, 1100.780019, 6424.214355, 7583.746582], [1411.153123, 1109.074677, 6422.154297, 7582.699707], [1387.554216, 1117.368221, 6420.09375, 7581.101563], [1363.956257, 1125.660564, 6417.394043, 7580.331543], [1340.359264, 1133.951674, 6414.600586, 7578.708984], [1316.763172, 1142.241508, 6411.356934, 7579.426758], [1293.167951, 1150.530164, 6407.961914, 7579.462402], [1269.5735, 1158.817702, 6404.274414, 7583.400879], [1245.979772, 1167.10426, 6399.912598, 7591.32666], [1222.38668, 1175.389915, 6396.077148, 7597.906738], [1198.794148, 1183.674793, 6392.585938, 7605.269043], [1175.2021, 1191.958996, 6383.085938, 7610.545898], [1151.610458, 1200.242638, 6376.665039, 7613.680664], [1128.019169, 1208.525807, 6373.895508, 7618.657227], [1104.428172, 1216.808582, 6369.431152, 7617.492676], [1080.837418, 1225.091034, 6364.561523, 7617.26416], [1057.246856, 1233.373222, 6358.225098, 7616.88623], [1033.656439, 1241.655218, 6352.05127, 7616.998535], [1010.066116, 1249.937083, 6348.202148, 7618.287598], [986.4758408, 1258.218884, 6344.764648, 7618.419922], [963.1427664, 1266.145101, 6341.249023, 7618.008789], [939.8095828, 1274.071415, 6337.993652, 7613.353027], [916.4761856, 1281.997931, 6337.709473, 7609.07373], [893.1424441, 1289.924759, 6336.088379, 7603.226074], [869.8082524, 1297.852024, 6341.601563, 7599.01709], [846.4734705, 1305.779873, 6342.973145, 7598.707031], [823.1379828, 1313.708457, 6343.073242, 7604.939941], [799.8016111, 1321.638034, 6344.500977, 7609.65625], [776.4642294, 1329.568862, 6346.691406, 7611.547363], [753.1255669, 1337.501393, 6348.456055, 7612.71875], [729.785453, 1345.435942, 6350.014648, 7610.222656], [706.4435547, 1353.373049, 6350.731934, 7609.225586], [683.0997681, 1361.312932, 6351.987305, 7608.423828], [659.7537385, 1369.256202, 6355.20459, 7608.650391], [636.4054087, 1377.203016, 6358.408691, 7610.762695], [613.0544161, 1385.153836, 6361.84668, 7612.089844], [589.7008172, 1393.108378, 6365.128906, 7613.061523], [566.344497, 1401.066581, 6368.455078, 7613.628906], [542.9857044, 1409.027984, 6371.765625, 7611.535645], [519.6245872, 1416.992289, 6376.025391, 7608.850098], [496.2614873, 1424.95915, 6380.950195, 7604.535645], [474.2957804, 1432.591949, 6260.380859, 7728.130859], [452.3300734, 1440.224748, 6262.324219, 7726.924805], [430.3643665, 1447.857547, 6264.161133, 7725.466797], [408.3986595, 1455.490346, 6265.814453, 7724.125977], [386.4329526, 1463.123145, 6267.279297, 7722.954102], [364.4672456, 1470.755945, 6268.578613, 7721.929688], [342.5015387, 1478.388744, 6269.730957, 7721.024414], [320.5358318, 1486.021543, 6270.743164, 7720.230469], [298.5701248, 1493.654342, 6271.639648, 7719.527344], [276.6044179, 1501.287141, 6272.427246, 7718.918945], [254.6387109, 1508.919941, 6273.116211, 7718.400391], [232.673004, 1516.55274, 6273.716309, 7717.954102], [210.707297, 1524.185539, 6274.216797, 7717.588867], [188.7415901, 1531.818338, 6274.634277, 7717.280273], [166.7758832, 1539.451137, 6274.963867, 7717.045898], [144.8101762, 1547.083937, 6275.210938, 7716.868164], [122.8444693, 1554.716736, 6275.374512, 7716.75293], [100.8787623, 1562.349535, 6275.457031, 7716.701172], [1525.315873, 1044.477821, 6309.115234, 7696.635742], [1506.520255, 1050.58369, 6309.148926, 7696.775391], [1487.724636, 1056.689559, 6309.208008, 7697.101563], [1468.929018, 1062.795429, 6309.261719, 7697.691406], [1450.1334, 1068.901298, 6425.077637, 7582.970703], [1426.532826, 1077.196952, 6423.300781, 7583.796387], [1402.933101, 1085.491587, 6421.297363, 7583.732422], [1379.334284, 1093.785113, 6419.117676, 7580.787109], [1355.736445, 1102.077392, 6416.343262, 7578.77002], [1332.139489, 1110.36846, 6413.510742, 7577.212891], [1308.5435, 1118.658264, 6410.111328, 7576.930664], [1284.94832, 1126.94691, 6406.710938, 7576.035645], [1261.353986, 1135.234408, 6403.017578, 7580.604492], [1237.76033, 1143.520916, 6398.879883, 7587.07959], [1214.167328, 1151.806515, 6394.603516, 7594.999023], [1190.57486, 1160.09136, 6391.215332, 7601.42334], [1166.982883, 1168.375535, 6384.716797, 7608.306152], [1143.391314, 1176.659149, 6375.458984, 7611.53125], [1119.800107, 1184.942274, 6372.348145, 7617.402832], [1096.209194, 1193.225, 6368.748535, 7617.933105], [1072.618521, 1201.507397, 6363.205078, 7618.032227], [1049.028036, 1209.78954, 6356.856934, 7617.300781], [1025.437693, 1218.071492, 6351.943848, 7617.029297], [1001.847445, 1226.353318, 6348.746582, 7616.304688], [978.2572428, 1234.635078, 6345.453125, 7616.570313], [954.9241064, 1242.561129, 6342.263184, 7616.695313], [931.5908608, 1250.487274, 6339.642578, 7615.752441], [908.2573978, 1258.413607, 6335.914063, 7612.625977], [884.9236028, 1266.340229, 6330.499512, 7609.534668], [861.5893702, 1274.267262, 6338.512207, 7609.387695], [838.2545596, 1282.194882, 6344.962891, 7610.51123], [814.9190319, 1290.123275, 6345.698242, 7612.008301], [791.5825982, 1298.052711, 6344.395996, 7613.635742], [768.245124, 1305.983417, 6345.250977, 7613.512207], [744.9063833, 1313.915772, 6346.845703, 7613.436523], [721.5662093, 1321.85008, 6348.350586, 7611.093262], [698.224311, 1329.786926, 6349.72168, 7611.071777], [674.8804863, 1337.726639, 6351.871094, 7608.34082], [651.5344033, 1345.669811, 6355.049316, 7607.132324], [628.1859495, 1353.616509, 6358.134766, 7608.276367], [604.8348911, 1361.567088, 6361.312012, 7609.251465], [581.4812689, 1369.521369, 6364.541016, 7610.637207], [558.1249553, 1377.479419, 6367.671875, 7611.431152], [534.7660816, 1385.440776, 6370.803223, 7610.435547], [511.4048562, 1393.40492, 6375.67627, 7608.065918], [488.0416728, 1401.371509, 6380.600098, 7604.499512], [466.0799857, 1409.002677, 6260.040527, 7726.733398], [444.1182985, 1416.633845, 6261.775879, 7725.911133], [422.1566114, 1424.265014, 6263.42627, 7724.818359], [400.1949242, 1431.896182, 6264.958008, 7723.71582], [378.2332371, 1439.52735, 6266.358398, 7722.674805], [356.2715499, 1447.158518, 6267.617188, 7721.733398], [334.3098628, 1454.789686, 6268.740234, 7720.889648], [312.3481756, 1462.420855, 6269.744629, 7720.123047], [290.3864885, 1470.052023, 6270.630859, 7719.446289], [268.4248013, 1477.683191, 6271.413574, 7718.859375], [246.4631142, 1485.314359, 6272.103516, 7718.344727], [224.501427, 1492.945528, 6272.696289, 7717.90625], [202.5397399, 1500.576696, 6273.205078, 7717.540039], [180.5780527, 1508.207864, 6273.621582, 7717.237305], [158.6163656, 1515.839032, 6273.952637, 7716.993164], [136.6546784, 1523.4702, 6274.198242, 7716.820313], [114.6929912, 1531.101369, 6274.358398, 7716.696289], [92.7313041, 1538.732537, 6274.442871, 7716.642578], [1517.157083, 1020.866335, 6308.879395, 7695.568359], [1498.346114, 1026.979348, 6308.897461, 7695.647461], [1479.535144, 1033.092361, 6308.901367, 7695.84668], [1460.724175, 1039.205374, 6308.833008, 7696.251953], [1441.913205, 1045.318386, 6424.281738, 7581.209961], [1418.312718, 1053.613978, 6422.464355, 7582.657715], [1394.71309, 1061.908568, 6420.481934, 7581.900879], [1371.11435, 1070.20204, 6418.067383, 7579.816895], [1347.516556, 1078.494311, 6415.310059, 7577.407715], [1323.919726, 1086.785347, 6412.255371, 7575.70166], [1300.323795, 1095.075106, 6408.851563, 7576.155762], [1276.728734, 1103.363685, 6405.507813, 7576.35791], [1253.134444, 1111.651145, 6401.809082, 7579.854492], [1229.540873, 1119.937624, 6397.845215, 7585.953125], [1205.947937, 1128.223197, 6393.473145, 7592.89502], [1182.355563, 1136.507993, 6389.562012, 7600.273926], [1158.76367, 1144.792112, 6384.57959, 7606.404297], [1135.172184, 1153.075667, 6375.894531, 7612.98877], [1111.581048, 1161.358749, 6371.261719, 7617.83252], [1087.990206, 1169.641434, 6367.899902, 7617.716797], [1064.399606, 1177.923794, 6362.57666, 7618.343262], [1040.809199, 1186.205891, 6357.05127, 7618.037109], [1017.218936, 1194.487794, 6353.162109, 7616.750488], [993.6287678, 1202.769565, 6349.811523, 7615.057129], [970.0386448, 1211.051272, 6347.020996, 7615.57373], [946.7054635, 1218.97711, 6344.638184, 7616.249023], [923.3721731, 1226.903045, 6342.260254, 7615.178223], [900.0386681, 1234.829179, 6340.181641, 7613.592285], [876.7048188, 1242.755625, 6338.603027, 7611.394531], [853.3705194, 1250.682508, 6344.345703, 7611.655273], [830.0356288, 1258.609978, 6345.729004, 7612.314453], [806.7000333, 1266.538187, 6343.788086, 7613.157715], [783.3635538, 1274.467389, 6342.120117, 7613.503906], [760.0260644, 1282.39784, 6343.974121, 7613.378906], [736.6872932, 1290.329998, 6345.67041, 7612.239258], [713.3470705, 1298.264173, 6348.571777, 7610.297852], [690.0050625, 1306.20091, 6349.570801, 7609.022949], [666.6611663, 1314.140429, 6351.894043, 7607.566895], [643.315027, 1322.083339, 6354.749512, 7606.381836], [619.9665875, 1330.029801, 6357.78125, 7607.107422], [596.6154853, 1337.980273, 6360.818359, 7608.516602], [573.2617767, 1345.934471, 6364.142578, 7609.766113], [549.9053449, 1353.892336, 6367.211914, 7609.562988], [526.5464412, 1361.853403, 6370.562988, 7609.052246], [503.185212, 1369.81738, 6375.427246, 7607.190918], [479.8219991, 1377.783915, 6380.681152, 7604.296875], [457.8643243, 1385.41345, 6259.792969, 7726.000977], [435.9066495, 1393.042985, 6261.306641, 7725.164063], [413.9489748, 1400.67252, 6262.809082, 7724.203125], [391.9913, 1408.302054, 6264.244629, 7723.229492], [370.0336252, 1415.931589, 6265.570801, 7722.296875], [348.0759505, 1423.561124, 6266.783203, 7721.439453], [326.1182757, 1431.190659, 6267.875, 7720.646484], [304.1606009, 1438.820193, 6268.854492, 7719.927734], [282.2029262, 1446.449728, 6269.730469, 7719.28125], [260.2452514, 1454.079263, 6270.501953, 7718.716797], [238.2875766, 1461.708798, 6271.187012, 7718.21875], [216.3299019, 1469.338332, 6271.777344, 7717.78418], [194.3722271, 1476.967867, 6272.280762, 7717.425781], [172.4145523, 1484.597402, 6272.692871, 7717.123047], [150.4568776, 1492.226937, 6273.019531, 7716.889648], [128.4992028, 1499.856472, 6273.266113, 7716.706055], [106.541528, 1507.486006, 6273.42627, 7716.588867], [84.58385327, 1515.115541, 6273.511719, 7716.52832], [1508.99829, 997.2548533, 6308.62793, 7694.431641], [1490.171966, 1003.375013, 6308.650391, 7694.395508], [1471.345642, 1009.495173, 6308.671387, 7694.387695], [1452.519318, 1015.615333, 6308.576172, 7694.571289], [1433.692994, 1021.735492, 6423.473145, 7579.549316], [1410.092591, 1030.031073, 6421.570801, 7579.930176], [1386.493036, 1038.325633, 6419.625488, 7580.560059], [1362.894388, 1046.619081, 6417.084961, 7576.859863], [1339.296716, 1054.911279, 6414.313965, 7574.88623], [1315.699925, 1063.202266, 6411.013672, 7574.28125], [1292.1041, 1071.491987, 6407.593262, 7575.199707], [1268.509083, 1079.780548, 6404.303223, 7575.96582], [1244.914908, 1088.06796, 6400.900391, 7578.091309], [1221.321412, 1096.354379, 6396.799316, 7584.356934], [1197.728569, 1104.639889, 6392.448242, 7590.84668], [1174.136259, 1112.924641, 6388.112305, 7598.091309], [1150.544439, 1121.208723, 6382.74707, 7605.125], [1126.953027, 1129.492242, 6376.75293, 7612.521484], [1103.361975, 1137.775269, 6371.090332, 7615.134766], [1079.771219, 1146.057896, 6367.337402, 7616.292969], [1056.180702, 1154.340194, 6362.244141, 7617.533691], [1032.590374, 1162.622235, 6357.671875, 7617.473145], [1009.000185, 1170.904085, 6354.28418, 7616.804688], [985.4100934, 1179.185808, 6350.902832, 7614.371582], [961.8200468, 1187.467466, 6348.783691, 7614.671387], [938.4868073, 1195.393132, 6347.502441, 7615.26416], [915.1534587, 1203.318894, 6345.969727, 7615.376953], [891.8198917, 1211.244842, 6343.370605, 7613.017578], [868.4859938, 1219.171081, 6342.34668, 7610.950195], [845.1516572, 1227.097731, 6343.833496, 7610.868164], [821.8167427, 1235.024967, 6344.970703, 7609.59082], [798.4811101, 1242.952977, 6344.713379, 7610.000977], [775.1445724, 1250.882031, 6343.341797, 7610.85791], [751.8069923, 1258.812357, 6344.041504, 7610.830078], [728.4681468, 1266.744334, 6345.133301, 7608.944824], [705.1278678, 1274.678267, 6347.927246, 7607.130371], [681.7858627, 1282.614742, 6350.125488, 7605.890137], [658.4419322, 1290.554088, 6352.692383, 7605.556152], [635.0957414, 1298.496897, 6354.966309, 7605.918457], [611.7471798, 1306.443238, 6357.933594, 7606.882813], [588.3960137, 1314.393464, 6360.597168, 7608.225586], [565.0422822, 1322.347401, 6363.693848, 7609.200684], [541.6858585, 1330.30511, 6367.017578, 7608.874512], [518.3268742, 1338.266133, 6370.819336, 7609.010254], [494.9655367, 1346.229947, 6375.369629, 7606.519043], [471.6022409, 1354.19621, 6380.984375, 7603.908203], [449.6485829, 1361.824117, 6259.506348, 7725.454102], [427.694925, 1369.452024, 6260.855469, 7724.541016], [405.7412671, 1377.079932, 6262.273438, 7723.609375], [383.7876091, 1384.707839, 6263.629395, 7722.703125], [361.8339512, 1392.335746, 6264.896484, 7721.848633], [339.8802932, 1399.963653, 6266.0625, 7721.060547], [317.9266353, 1407.59156, 6267.115723, 7720.329102], [295.9729774, 1415.219467, 6268.071777, 7719.65625], [274.0193194, 1422.847375, 6268.927734, 7719.049805], [252.0656615, 1430.475282, 6269.690918, 7718.503906], [230.1120036, 1438.103189, 6270.35791, 7718.016602], [208.1583456, 1445.731096, 6270.941895, 7717.601563], [186.2046877, 1453.359003, 6271.441406, 7717.244141], [164.2510297, 1460.986911, 6271.852539, 7716.950195], [142.2973718, 1468.614818, 6272.177246, 7716.71875], [120.3437139, 1476.242725, 6272.415527, 7716.545898], [98.39005593, 1483.870632, 6272.57666, 7716.424805], [76.436398, 1491.498539, 6272.656738, 7716.366211], [1502.029337, 973.1011166, 6308.358887, 7693.327148], [1484.377498, 978.686169, 6308.410645, 7693.112305], [1466.725659, 984.2712213, 6308.553711, 7692.744141], [1449.07382, 989.8562737, 6424.228516, 7577.194336], [1425.472755, 998.1527424, 6422.602051, 7576.0625], [1401.872444, 1006.448255, 6420.72168, 7575.311035], [1378.272989, 1014.742761, 6418.637695, 7574.162598], [1354.67442, 1023.036147, 6416.017578, 7572.425293], [1331.076796, 1031.328331, 6413.237793, 7570.689941], [1307.480133, 1039.619277, 6409.754395, 7571.434082], [1283.884369, 1047.908945, 6406.223633, 7573.131836], [1260.289472, 1056.197432, 6403.164551, 7575.558105], [1236.695344, 1064.484797, 6399.884766, 7578.954102], [1213.101934, 1072.771179, 6395.73877, 7582.865723], [1189.509159, 1081.056654, 6391.429688, 7589.515625], [1165.916944, 1089.34135, 6387.535645, 7595.87207], [1142.32521, 1097.625365, 6382.624023, 7601.861816], [1118.733882, 1105.908816, 6376.712402, 7609.135254], [1095.142905, 1114.191793, 6371.639648, 7615.382324], [1071.552221, 1122.474372, 6367.048828, 7614.080078], [1047.961779, 1130.756623, 6362.708984, 7616.352539], [1024.37153, 1139.038612, 6358.786133, 7614.640137], [1000.781425, 1147.320404, 6355.344727, 7615.451172], [977.1914134, 1155.602064, 6352.684082, 7616.271973], [953.6014488, 1163.88366, 6352.015137, 7616.260254], [930.2681673, 1171.809108, 6351.171387, 7615.848633], [906.9347777, 1179.734653, 6349.750488, 7614.629395], [883.6011726, 1187.6604, 6347.705566, 7611.405273], [860.2672241, 1195.586459, 6347.369629, 7608.119629], [836.9328236, 1203.512956, 6346.558594, 7605.086426], [813.5978338, 1211.440037, 6345.788086, 7604.936523], [790.2621372, 1219.367856, 6345.036133, 7605.537598], [766.9255547, 1227.29667, 6345.321777, 7606.356445], [743.5879632, 1235.226737, 6345.811523, 7607.583008], [720.2490891, 1243.158512, 6347.041504, 7604.411133], [696.9087624, 1251.09231, 6349.021484, 7602.031738], [673.5666515, 1259.028674, 6351.071777, 7601.911621], [650.2226513, 1266.967822, 6352.873047, 7603.149902], [626.8764071, 1274.910367, 6355.294922, 7604.768066], [603.5278608, 1282.856467, 6358.426758, 7607.008789], [580.1766518, 1290.806584, 6361.141113, 7607.851074], [556.8228349, 1298.760434, 6363.8125, 7609.105469], [533.4662944, 1306.717957, 6367.04248, 7609.07959], [510.1072806, 1314.678689, 6371.174316, 7608.420898], [486.7459397, 1322.642334, 6375.315918, 7606.237793], [464.7256078, 1330.285608, 6256.48584, 7726.629883], [442.7052759, 1337.928883, 6258.687012, 7725.073242], [420.684944, 1345.572157, 6260.341309, 7723.936523], [398.6646121, 1353.215431, 6261.789063, 7722.979492], [376.6442802, 1360.858705, 6263.105957, 7722.125977], [354.6239483, 1368.501979, 6264.320313, 7721.345703], [332.6036164, 1376.145253, 6265.438965, 7720.621094], [310.5832845, 1383.788528, 6266.462891, 7719.942383], [288.5629526, 1391.431802, 6267.387207, 7719.321289], [266.5426207, 1399.075076, 6268.222168, 7718.745117], [244.5222888, 1406.71835, 6268.967285, 7718.225586], [222.5019569, 1414.361624, 6269.624023, 7717.759766], [200.481625, 1422.004898, 6270.195313, 7717.353516], [178.461293, 1429.648172, 6270.684082, 7717.010742], [156.4409611, 1437.291447, 6271.091797, 7716.717773], [134.4206292, 1444.934721, 6271.414551, 7716.490234], [112.4002973, 1452.577995, 6271.651367, 7716.325195], [90.37996543, 1460.221269, 6271.812012, 7716.209961], [68.35963352, 1467.864543, 6271.888184, 7716.151367], [1493.866674, 949.4914858, 6308.034668, 7692.443359], [1476.19561, 955.0855366, 6308.087891, 7691.981445], [1458.524547, 960.6795873, 6308.196777, 7690.982422], [1440.853484, 966.2736381, 6423.447266, 7574.272461], [1417.252494, 974.570001, 6421.724609, 7572.390137], [1393.652271, 982.8654951, 6419.911133, 7569.632324], [1370.052893, 991.159964, 6417.660645, 7570.578125], [1346.454419, 999.4533199, 6415.099121, 7568.382813], [1322.85692, 1007.745423, 6412.23877, 7567.077148], [1299.2603, 1016.036312, 6408.401855, 7567.97168], [1275.664643, 1024.325934, 6404.972168, 7569.959473], [1252.069793, 1032.614394, 6402.034668, 7574.273438], [1228.475783, 1040.901702, 6398.675781, 7576.685059], [1204.88245, 1049.188018, 6394.757324, 7580.921875], [1181.28977, 1057.473421, 6390.55957, 7585.877441], [1157.697621, 1065.758066, 6386.780762, 7591.674805], [1134.105962, 1074.042036, 6382.645508, 7598.152344], [1110.514709, 1082.325444, 6376.413086, 7606.186035], [1086.923819, 1090.608358, 6370.875, 7611.05957], [1063.333222, 1098.890871, 6367.545898, 7610.317383], [1039.742866, 1107.173051, 6363.321777, 7610.816406], [1016.152697, 1115.454977, 6359.722168, 7611.267578], [992.5626699, 1123.736709, 6356.180176, 7613.664063], [968.9727371, 1132.018315, 6354.461426, 7615.265625], [945.3828508, 1140.299854, 6353.701172, 7618.810547], [922.0495149, 1148.225126, 6353.019531, 7615.856445], [898.716069, 1156.150493, 6352.273926, 7612.169922], [875.3824057, 1164.076046, 6351.316895, 7607.699219], [852.0484105, 1172.00189, 6351.345215, 7602.959473], [828.7139757, 1179.928145, 6350.500977, 7599.013672], [805.378963, 1187.85499, 6349.632813, 7598.040527], [782.043233, 1195.782608, 6348.513184, 7600.277832], [758.7065962, 1203.711272, 6346.906738, 7601.139648], [735.368917, 1211.641209, 6347.500488, 7601.110352], [712.0299703, 1219.5728, 6349.043945, 7600.393555], [688.6895893, 1227.50635, 6350.631836, 7597.898926], [665.3474822, 1235.442446, 6352.519531, 7598.823242], [642.0034486, 1243.381417, 6354.345703, 7600.688965], [618.6571539, 1251.323857, 6355.966309, 7603.594727], [595.3084874, 1259.269835, 6358.900879, 7604.494141], [571.9572145, 1267.219705, 6361.715332, 7606.199219], [548.6033762, 1275.173291, 6364.181152, 7607.79541], [525.2468438, 1283.130656, 6367.630371, 7608.215332], [501.8877498, 1291.091341, 6371.867676, 7608.514648], [478.5263012, 1299.054821, 6376.410156, 7605.585938], [456.5097793, 1306.696539, 6256.345215, 7725.919922], [434.4932574, 1314.338257, 6258.415039, 7724.285156], [412.4767355, 1321.979976, 6260.040527, 7723.149414], [390.4602136, 1329.621694, 6261.435547, 7722.255859], [368.4436917, 1337.263413, 6262.691895, 7721.487305], [346.4271698, 1344.905131, 6263.846191, 7720.782227], [324.4106479, 1352.546849, 6264.918945, 7720.12207], [302.394126, 1360.188568, 6265.898438, 7719.500977], [280.3776041, 1367.830286, 6266.792969, 7718.919922], [258.3610822, 1375.472004, 6267.603027, 7718.382813], [236.3445603, 1383.113723, 6268.333008, 7717.891602], [214.3280384, 1390.755441, 6268.974609, 7717.444336], [192.3115165, 1398.39716, 6269.532715, 7717.054688], [170.2949946, 1406.038878, 6270.015625, 7716.716797], [148.2784727, 1413.680596, 6270.414063, 7716.442383], [126.2619508, 1421.322315, 6270.734863, 7716.213867], [104.2454289, 1428.964033, 6270.970215, 7716.052734], [82.22890698, 1436.605751, 6271.130371, 7715.94043], [60.21238508, 1444.24747, 6271.20459, 7715.881836], [1485.703995, 925.8818581, 6307.656738, 7692.021484], [1468.01369, 931.4849104, 6307.702148, 7691.373047], [1450.323386, 937.0879626, 6307.77002, 7689.856445], [1432.633082, 942.6910149, 6422.741211, 7571.896484], [1409.032201, 950.987393, 6420.945801, 7570.618652], [1385.432072, 959.2828108, 6419.10791, 7568.765137], [1361.832799, 967.5772196, 6416.683105, 7567.459473], [1338.234408, 975.8705069, 6414.20752, 7566.685059], [1314.636959, 984.1625888, 6411.212402, 7565.690918], [1291.040471, 992.4534299, 6407.745117, 7564.155273], [1267.444877, 1000.742991, 6404.358398, 7568.139648], [1243.850149, 1009.031369, 6401.120117, 7570.274414], [1220.256188, 1017.318624, 6397.447754, 7573.806152], [1196.662945, 1025.604894, 6393.686523, 7577.751465], [1173.070335, 1033.890255, 6389.890625, 7582.703613], [1149.478284, 1042.174834, 6386.316406, 7587.915039], [1125.886713, 1050.458733, 6382.149902, 7594.933105], [1102.295549, 1058.742065, 6376.347656, 7603.760742], [1078.704734, 1067.024921, 6370.724609, 7610.702148], [1055.114212, 1075.307379, 6367.496582, 7606.20459], [1031.523933, 1083.589508, 6363.907715, 7605.720703], [1007.933845, 1091.871372, 6360.664551, 7608.350586], [984.343904, 1100.153041, 6357.151855, 7611.609863], [960.7540551, 1108.434577, 6356.290527, 7614.277832], [937.1642528, 1116.716048, 6355.423828, 7616.439453], [913.8308777, 1124.641096, 6354.048828, 7614.348145], [890.4973928, 1132.566241, 6352.702637, 7612.051758], [867.1636932, 1140.491586, 6351.685059, 7605.064941], [843.8296485, 1148.417242, 6351.668457, 7599.047363], [820.4951536, 1156.343338, 6352.119629, 7595.600098], [797.1600664, 1164.270021, 6352.464355, 7595.616211], [773.8242736, 1172.197445, 6351.517578, 7596.865723], [750.4875947, 1180.125866, 6348.813477, 7596.863281], [727.149905, 1188.05554, 6349.20166, 7596.776367], [703.8109326, 1195.986924, 6351.045898, 7596.230957], [680.4705059, 1203.920334, 6352.966309, 7596.221191], [657.1282929, 1211.856314, 6353.893555, 7597.748535], [633.7841897, 1219.795084, 6355.827148, 7600.146973], [610.4378425, 1227.737256, 6357.354492, 7602.134277], [587.0891913, 1235.682991, 6359.552734, 7602.974121], [563.7378774, 1243.632749, 6362.700684, 7604.340332], [540.3839532, 1251.586246, 6365.146973, 7604.81543], [517.0273045, 1259.543423, 6368.292969, 7606.230957], [493.6681809, 1267.503813, 6372.501465, 7605.608398], [470.306729, 1275.467122, 6377.713867, 7603.934082], [448.2940138, 1283.107294, 6257.00293, 7724.287109], [426.2812986, 1290.747466, 6258.589355, 7722.989258], [404.2685834, 1298.387638, 6259.96875, 7722.118164], [382.2558681, 1306.027809, 6261.220703, 7721.412109], [360.2431529, 1313.667981, 6262.374023, 7720.77832], [338.2304377, 1321.308153, 6263.461426, 7720.166992], [316.2177225, 1328.948325, 6264.477539, 7719.582031], [294.2050073, 1336.588497, 6265.418457, 7719.013672], [272.1922921, 1344.228669, 6266.285156, 7718.47168], [250.1795769, 1351.868841, 6267.069824, 7717.96875], [228.1668616, 1359.509012, 6267.78125, 7717.505859], [206.1541464, 1367.149184, 6268.40625, 7717.075195], [184.1414312, 1374.789356, 6268.956543, 7716.701172], [162.128716, 1382.429528, 6269.431152, 7716.379883], [140.1160008, 1390.0697, 6269.825684, 7716.110352], [118.1032856, 1397.709872, 6270.134277, 7715.895508], [96.09057037, 1405.350043, 6270.371582, 7715.727539], [74.07785515, 1412.990215, 6270.525391, 7715.623047], [52.06513994, 1420.630387, 6270.601563, 7715.5625], [1477.541315, 902.2722619, 6307.23291, 7692.244141], [1459.831771, 907.8843471, 6307.300781, 7691.629883], [1442.122226, 913.4964324, 6307.361328, 7690.257813], [1424.412681, 919.1085176, 6421.961426, 7572.862305], [1400.81188, 927.4047832, 6420.181152, 7570.129883], [1377.211843, 935.7001762, 6418.20459, 7569.402832], [1353.612649, 943.9945411, 6415.85498, 7568.652832], [1330.014358, 952.2877903, 6413.289551, 7567.486328], [1306.417038, 960.5797844, 6410.270508, 7566.836426], [1282.820595, 968.8705616, 6407.107422, 7567.49707], [1259.225113, 977.1600704, 6403.669434, 7568.853027], [1235.630434, 985.4484139, 6400.234863, 7569.03125], [1212.036594, 993.7356053, 6396.427734, 7574.063477], [1188.443432, 1002.021801, 6392.672852, 7576.322266], [1164.850918, 1010.307082, 6389.331543, 7580.150879], [1141.258936, 1018.591604, 6385.76416, 7586.029785], [1117.667443, 1026.875451, 6381.429688, 7592.505371], [1094.076356, 1035.158732, 6376.455078, 7596.996582], [1070.485631, 1043.441521, 6371.813477, 7609.08252], [1046.895201, 1051.723905, 6367.900879, 7605.082031], [1023.305008, 1060.005958, 6364.789551, 7604.724121], [999.715005, 1068.287754, 6361.46875, 7606.078125], [976.1251429, 1076.569357, 6358.998047, 7608.630859], [952.535376, 1084.850832, 6357.647461, 7611.659668], [928.9456548, 1093.132243, 6356.391602, 7613.334473], [905.6122253, 1101.057106, 6355.197754, 7612.899902], [882.278687, 1108.982065, 6353.586426, 7607.61377], [858.9449302, 1116.907211, 6352.350586, 7602.90625], [835.6108406, 1124.83265, 6351.532715, 7596.532227], [812.2763123, 1132.7585, 6351.96875, 7594.121582], [788.9412052, 1140.68494, 6352.354004, 7594.158691], [765.6053789, 1148.612154, 6351.232422, 7595.052246], [742.2686457, 1156.540417, 6349.980469, 7594.838379], [718.9308683, 1164.469956, 6351.312988, 7595.216797], [695.5918234, 1172.401153, 6354.800293, 7593.790527], [672.2513432, 1180.334311, 6355.496094, 7595.220215], [648.909136, 1188.270021, 6355.010742, 7597.69873], [625.5649994, 1196.20861, 6356.645996, 7600.861816], [602.2186017, 1204.150675, 6358.168945, 7601.940918], [578.8698312, 1212.096283, 6360.311035, 7601.785156], [555.5184525, 1220.045791, 6363.398926, 7601.709473], [532.1645069, 1227.999022, 6366.334961, 7602.064453], [508.8078667, 1235.956039, 6369.34668, 7603.601074], [485.4486626, 1243.916381, 6373.27002, 7602.470703], [462.0871034, 1251.879524, 6379.114258, 7600.311523], [440.0781975, 1259.518145, 6257.975586, 7721.677734], [418.0692917, 1267.156765, 6258.988281, 7721.280273], [396.0603858, 1274.795385, 6260.033691, 7720.915039], [374.0514799, 1282.434006, 6261.089355, 7720.496094], [352.0425741, 1290.072626, 6262.133789, 7720.029297], [330.0336682, 1297.711246, 6263.143555, 7719.52832], [308.0247624, 1305.349866, 6264.108398, 7719.012695], [286.0158565, 1312.988487, 6265.009277, 7718.493164], [264.0069507, 1320.627107, 6265.845703, 7717.989258], [241.9980448, 1328.265727, 6266.612305, 7717.514648], [219.989139, 1335.904347, 6267.308594, 7717.076172], [197.9802331, 1343.542968, 6267.92334, 7716.666992], [175.9713273, 1351.181588, 6268.458008, 7716.303711], [153.9624214, 1358.820208, 6268.928223, 7715.993164], [131.9535156, 1366.458828, 6269.313965, 7715.732422], [109.9446097, 1374.097449, 6269.622559, 7715.521484], [87.93570385, 1381.736069, 6269.851563, 7715.360352], [65.92679799, 1389.374689, 6270.001465, 7715.25293], [43.91789214, 1397.013309, 6270.076172, 7715.197266], [1471.336134, 877.7707054, 6306.734863, 7693.085938], [1455.564846, 882.4998633, 6306.914063, 7692.633789], [1439.793558, 887.2290213, 6422.833008, 7576.254395], [1416.19221, 895.5260231, 6420.95752, 7574.497559], [1392.591521, 903.8222973, 6419.225098, 7573.167969], [1368.991583, 912.1176074, 6417.23291, 7571.824707], [1345.392497, 920.4119055, 6414.970703, 7570.96582], [1321.794293, 928.7050793, 6412.348145, 7570.126465], [1298.197027, 936.9970439, 6409.482422, 7571.072266], [1274.600718, 945.2877677, 6406.274414, 7569.912598], [1251.005303, 953.5772079, 6402.873535, 7571.641113], [1227.410751, 961.8654626, 6399.307617, 7573.737793], [1203.816965, 970.152593, 6395.555176, 7575.643066], [1180.223893, 978.4387372, 6391.939453, 7577.491211], [1156.631453, 986.7239698, 6388.879395, 7579.683105], [1133.039572, 995.0084203, 6385.374512, 7585.630371], [1109.448171, 1003.292189, 6381.317871, 7591.533203], [1085.857175, 1011.575389, 6376.37793, 7598.834473], [1062.266529, 1019.858114, 6371.337891, 7604.777344], [1038.676175, 1028.140437, 6366.721191, 7603.540527], [1015.086064, 1036.422433, 6364.931152, 7604.210938], [991.4961447, 1044.704164, 6362.483887, 7605.270996], [967.9063712, 1052.985698, 6359.619629, 7605.768555], [944.3166903, 1061.2671, 6358.396484, 7607.897461], [920.7270568, 1069.548437, 6357.399414, 7609.718262], [897.3935882, 1077.473069, 6356.459473, 7609.55127], [874.0600117, 1085.397798, 6355.158203, 7604.597656], [850.7262187, 1093.32273, 6354.016113, 7598.411621], [827.3920814, 1101.247977, 6353.042969, 7596.280762], [804.0574921, 1109.173663, 6352.748535, 7594.317383], [780.7223115, 1117.099935, 6352.216797, 7593.908691], [757.3864223, 1125.026948, 6351.287598, 7587.92041], [734.0496472, 1132.95496, 6350.45166, 7586.125488], [710.7118592, 1140.884231, 6351.034668, 7593.812988], [687.3727876, 1148.815217, 6354.616699, 7594.089355], [664.0322617, 1156.748231, 6355.61084, 7595.981934], [640.6899485, 1164.683821, 6356.211426, 7598.841797], [617.3457443, 1172.622207, 6357.478516, 7602.13623], [593.9992932, 1180.564001, 6358.665527, 7603.05127], [570.650537, 1188.509362, 6361.248535, 7600.84668], [547.2991163, 1196.458754, 6364.675781, 7598.977539], [523.9450858, 1204.411893, 6367.589844, 7599.404785], [500.5883284, 1212.36872, 6370.592285, 7598.367188], [477.2290951, 1220.328767, 6374.591309, 7597.753906], [453.8675321, 1228.291739, 6380.520996, 7595.429199], [431.8624329, 1235.928817, 6258.935059, 7718.712891], [409.8573337, 1243.565895, 6259.353027, 7719.539063], [387.8522345, 1251.202973, 6260.086426, 7719.759766], [365.8471352, 1258.840051, 6260.974609, 7719.635742], [343.842036, 1266.477129, 6261.925293, 7719.322266], [321.8369368, 1274.114208, 6262.872559, 7718.90918], [299.8318376, 1281.751286, 6263.793945, 7718.446289], [277.8267384, 1289.388364, 6264.67041, 7717.960938], [255.8216392, 1297.025442, 6265.483398, 7717.483398], [233.81654, 1304.66252, 6266.233398, 7717.032227], [211.8114408, 1312.299598, 6266.911133, 7716.606445], [189.8063415, 1319.936676, 6267.513184, 7716.214844], [167.8012423, 1327.573754, 6268.041504, 7715.864258], [145.7961431, 1335.210832, 6268.499023, 7715.561523], [123.7910439, 1342.84791, 6268.882324, 7715.307617], [101.7859447, 1350.484988, 6269.185059, 7715.102539], [79.78084548, 1358.122066, 6269.414063, 7714.943359], [57.77574627, 1365.759144, 6269.558594, 7714.839844], [35.77064705, 1373.396222, 6269.635254, 7714.787109], [1463.166979, 854.1641659, 6306.05957, 7694.37793], [1447.369975, 858.9054136, 6306.12793, 7694.220703], [1431.572971, 863.6466613, 6421.954102, 7578.335449], [1407.971735, 871.9436441, 6420.039551, 7577.206055], [1384.371129, 880.2397991, 6418.170898, 7575.555664], [1360.771287, 888.5350776, 6416.099121, 7574.24707], [1337.172286, 896.8293253, 6413.884277, 7573.470215], [1313.574184, 905.1224542, 6411.402344, 7572.758301], [1289.977051, 913.4143244, 6408.581543, 7572.561035], [1266.380792, 921.7049766, 6405.433105, 7572.762695], [1242.785491, 929.9943577, 6402.121582, 7576.793945], [1219.190992, 938.2825724, 6398.460938, 7576.897949], [1195.597331, 946.5696331, 6394.717773, 7580.40918], [1172.004343, 954.8556963, 6391.48877, 7579.398438], [1148.412005, 963.140844, 6388.337891, 7582.123535], [1124.820195, 971.4252316, 6384.949219, 7586.497559], [1101.228875, 979.708943, 6381.25293, 7593.068359], [1077.637961, 987.992088, 6376.51123, 7599.113281], [1054.047407, 996.2747389, 6371.244141, 7600.813477], [1030.457147, 1004.556986, 6366.21875, 7600.971191], [1006.867128, 1012.8389, 6364.961914, 7602.253418], [983.2772949, 1021.120557, 6363.536621, 7603.001953], [959.6876044, 1029.402023, 6360.825195, 7603.692383], [936.0980083, 1037.68336, 6358.906738, 7604.653809], [912.5084588, 1045.964631, 6357.895996, 7606.240723], [889.1749367, 1053.889073, 6357.124512, 7604.367188], [865.8413049, 1061.813612, 6356.562988, 7601.177246], [842.5074547, 1069.738337, 6355.636719, 7596.891113], [819.1732716, 1077.663356, 6354.759766, 7594.645996], [795.8386489, 1085.588788, 6353.830078, 7592.597656], [772.5034464, 1093.51481, 6353.024414, 7592.746582], [749.1675238, 1101.441612, 6352.125, 7587.347168], [725.8306934, 1109.369464, 6351.209961, 7580.966797], [702.4928187, 1117.298595, 6351.930664, 7592.364258], [679.1536746, 1125.229387, 6353.013184, 7594.119141], [655.8130943, 1133.162145, 6354.919434, 7597.047363], [632.470785, 1141.09746, 6356.754395, 7600.682617], [609.1265454, 1149.035661, 6357.737305, 7602.401367], [585.7800438, 1156.977343, 6359.105957, 7602.26709], [562.4311674, 1164.922578, 6362.466797, 7601.19873], [539.0796828, 1172.871718, 6366.683105, 7598.660645], [515.7256295, 1180.824589, 6369.074707, 7597.696289], [492.3688801, 1188.781253, 6371.575684, 7596.707031], [469.0095668, 1196.741249, 6376.47168, 7595.134277], [445.6478965, 1204.704053, 6381.94873, 7591.189941], [423.6466071, 1212.339584, 6259.38623, 7716.710938], [401.6453177, 1219.975115, 6259.395508, 7718.399414], [379.6440284, 1227.610646, 6259.98877, 7718.942383], [357.642739, 1235.246177, 6260.808594, 7718.958008], [335.6414497, 1242.881707, 6261.711914, 7718.713867], [313.6401603, 1250.517238, 6262.632813, 7718.34082], [291.638871, 1258.152769, 6263.529297, 7717.892578], [269.6375816, 1265.7883, 6264.384766, 7717.427734], [247.6362923, 1273.423831, 6265.18457, 7716.961914], [225.6350029, 1281.059362, 6265.917969, 7716.518555], [203.6337136, 1288.694893, 6266.587402, 7716.105469], [181.6324242, 1296.330424, 6267.182129, 7715.722656], [159.6311349, 1303.965955, 6267.702148, 7715.383789], [137.6298455, 1311.601486, 6268.15332, 7715.088867], [115.6285562, 1319.237017, 6268.526367, 7714.838867], [93.62726681, 1326.872548, 6268.824707, 7714.638672], [71.62597746, 1334.508079, 6269.04834, 7714.487305], [49.6246881, 1342.143609, 6269.195801, 7714.382813], [27.62339875, 1349.77914, 6269.266113, 7714.332031], [1454.997807, 830.557649, 6305.316406, 7695.826172], [1439.175069, 835.311009, 6305.220215, 7695.895508], [1423.352332, 840.0643691, 6420.854492, 7580.132813], [1399.751186, 848.3612574, 6418.96582, 7578.51709], [1376.150697, 856.6574143, 6417.057617, 7577.147949], [1352.550956, 864.9526032, 6414.948242, 7576.09375], [1328.952067, 873.2467774, 6412.751953, 7575.355957], [1305.354056, 881.5398234, 6410.344238, 7574.108887], [1281.756981, 889.8316592, 6407.636719, 7573.683105], [1258.160861, 898.1222505, 6404.754395, 7574.888672], [1234.565632, 906.4115571, 6401.393066, 7576.305176], [1210.971263, 914.6996774, 6397.67334, 7578.65918], [1187.377658, 922.9866714, 6393.898438, 7580.971191], [1163.784766, 931.2726774, 6390.999512, 7580.937988], [1140.192505, 939.5577716, 6388.03125, 7581.776367], [1116.600801, 947.8420829, 6384.47168, 7585.784668], [1093.009576, 956.1257114, 6380.753906, 7590.906738], [1069.418755, 964.4087715, 6376.050781, 7596.760254], [1045.828284, 972.6913528, 6369.744141, 7598.56543], [1022.238106, 980.9735355, 6366.397461, 7599.804688], [998.64817, 989.2553902, 6366.51123, 7601.025391], [975.0584251, 997.5369778, 6365.103027, 7600.549316], [951.4688261, 1005.818371, 6362.053711, 7601.864746], [927.8793196, 1014.09963, 6359.622559, 7603.188477], [904.2898608, 1022.380825, 6358.484863, 7603.625977], [880.9562986, 1030.305031, 6357.702148, 7601.67627], [857.6226277, 1038.229333, 6357.518555, 7599.506348], [834.2887403, 1046.153837, 6356.692871, 7596.501953], [810.9545077, 1054.078655, 6355.660156, 7594.277344], [787.619822, 1062.003915, 6354.597168, 7593.295898], [764.2845451, 1069.929767, 6353.811523, 7592.332031], [740.9485586, 1077.856362, 6353.092285, 7589.956055], [717.6116853, 1085.78396, 6352.311035, 7581.266602], [694.2737981, 1093.712818, 6352.318848, 7592.421875], [670.9346274, 1101.643395, 6353.429688, 7593.704102], [647.5939984, 1109.576004, 6355.45166, 7596.314453], [624.2515823, 1117.511195, 6357.143555, 7600.19873], [600.9072731, 1125.449187, 6358.052734, 7602.250488], [577.5607162, 1133.390597, 6359.336914, 7602.283203], [554.2118551, 1141.335581, 6361.169434, 7601.297852], [530.8603266, 1149.284605, 6365.63623, 7599.397461], [507.5061879, 1157.237382, 6368.865723, 7597.895996], [484.1493222, 1165.193853, 6372.243652, 7596.661621], [460.7899788, 1173.153551, 6376.885254, 7594.401855], [438.7275356, 1180.803194, 6257.515625, 7716.273438], [416.6650924, 1188.452836, 6258.19873, 7717.624023], [394.6026491, 1196.102479, 6258.856445, 7718.410156], [372.5402059, 1203.752121, 6259.658691, 7718.645508], [350.4777627, 1211.401763, 6260.555664, 7718.543945], [328.4153194, 1219.051406, 6261.483398, 7718.240234], [306.3528762, 1226.701048, 6262.407715, 7717.830078], [284.290433, 1234.350691, 6263.304688, 7717.367188], [262.2279897, 1242.000333, 6264.154297, 7716.889648], [240.1655465, 1249.649975, 6264.947754, 7716.422852], [218.1031033, 1257.299618, 6265.674805, 7715.980469], [196.04066, 1264.94926, 6266.337402, 7715.570313], [173.9782168, 1272.598903, 6266.924316, 7715.19043], [151.9157736, 1280.248545, 6267.441895, 7714.861328], [129.8533303, 1287.898188, 6267.881348, 7714.574219], [107.7908871, 1295.54783, 6268.24707, 7714.325195], [85.72844388, 1303.197472, 6268.537598, 7714.130859], [63.66600065, 1310.847115, 6268.761719, 7713.985352], [41.60355742, 1318.496757, 6268.910156, 7713.882813], [19.54111419, 1326.1464, 6268.978516, 7713.833008], [1446.828625, 806.9511439, 6304.679199, 7697.207031], [1430.980143, 811.716628, 6304.500977, 7697.469727], [1415.131661, 816.4821121, 6419.805176, 7581.602051], [1391.53063, 824.7789747, 6417.898438, 7579.953125], [1367.930228, 833.0750057, 6415.961914, 7578.598145], [1344.330588, 841.3701564, 6413.935547, 7576.456543], [1320.731786, 849.6642734, 6411.811035, 7577.044434], [1297.133883, 857.9572689, 6409.357422, 7576.131348], [1273.536944, 866.2490045, 6406.75, 7574.888672], [1249.940878, 874.5395185, 6403.914063, 7573.755371], [1226.345767, 882.8287603, 6400.650391, 7574.904297], [1202.751456, 891.1168348, 6397.030273, 7577.818848], [1179.15798, 899.4037535, 6393.45166, 7580.123535], [1155.565177, 907.6896746, 6390.597168, 7581.33252], [1131.97302, 915.9746792, 6387.837402, 7581.856934], [1108.381392, 924.2589238, 6383.807617, 7585.527344], [1084.790252, 932.5424902, 6380.001953, 7590.599609], [1061.199517, 940.8254902, 6376.249023, 7594.362793], [1037.609143, 949.1079962, 6370.083496, 7596.631836], [1014.019061, 957.3900979, 6369.365234, 7597.248535], [990.4292191, 965.6718676, 6369.466797, 7597.276367], [966.8395657, 973.9533799, 6366.759766, 7597.307617], [943.2500526, 982.2347005, 6363.282715, 7598.970703], [919.6606348, 990.5158923, 6361.118164, 7601.798828], [896.0712628, 998.7970188, 6359.624512, 7602.763184], [872.7376443, 1006.721027, 6358.753906, 7599.602539], [849.4039162, 1014.645131, 6358.34082, 7596.625977], [826.0699696, 1022.569425, 6357.664063, 7594.116211], [802.7356893, 1030.494012, 6356.524902, 7593.496094], [779.4009684, 1038.419014, 6355.732422, 7592.526855], [756.0656676, 1046.344611, 6355.837891, 7591.949707], [732.7296459, 1054.270987, 6354.598145, 7588.717773], [709.3927153, 1062.198417, 6353.251953, 7585.19043], [686.0547385, 1070.12713, 6352.731934, 7591.947754], [662.7154924, 1078.057509, 6354.021484, 7592.17334], [639.3748082, 1085.989859, 6355.664551, 7594.986328], [616.0323939, 1093.924772, 6357.338379, 7600.000977], [592.6880495, 1101.862577, 6358.400391, 7601.671875], [569.341441, 1109.803872, 6359.415527, 7603.182129], [545.9924569, 1117.748725, 6361.130859, 7604.634277], [522.6408645, 1125.697493, 6363.965332, 7603.218262], [499.2867025, 1133.649999, 6367.595215, 7602.67627], [475.9298444, 1141.606306, 6371.617188, 7601.573242], [452.5704214, 1149.565954, 6376.198242, 7597.200684], [430.5116029, 1157.214118, 6255.708496, 7719.204102], [408.4527844, 1164.862283, 6257.04248, 7719.100586], [386.3939658, 1172.510448, 6258.176758, 7718.959961], [364.3351473, 1180.158613, 6259.233398, 7718.702148], [342.2763288, 1187.806777, 6260.264648, 7718.325195], [320.2175103, 1195.454942, 6261.260742, 7717.868164], [298.1586918, 1203.103107, 6262.216797, 7717.375977], [276.0998732, 1210.751272, 6263.130371, 7716.857422], [254.0410547, 1218.399436, 6263.97998, 7716.350586], [231.9822362, 1226.047601, 6264.774902, 7715.860352], [209.9234177, 1233.695766, 6265.500977, 7715.413086], [187.8645992, 1241.34393, 6266.158203, 7715], [165.8057807, 1248.992095, 6266.741211, 7714.621094], [143.7469621, 1256.64026, 6267.247559, 7714.292969], [121.6881436, 1264.288425, 6267.683105, 7714.010742], [99.6293251, 1271.936589, 6268.043945, 7713.776367], [77.57050658, 1279.584754, 6268.336426, 7713.584961], [55.51168806, 1287.232919, 6268.553223, 7713.4375], [33.45286955, 1294.881083, 6268.695313, 7713.341797], [11.39405103, 1302.529248, 6268.760742, 7713.291992], [1442.523059, 781.5846892, 6304.217773, 7698.329102], [1430.512451, 784.6023478, 6420.680176, 7582.780762], [1406.910938, 792.8999114, 6418.96875, 7582.667969], [1383.309999, 801.1966729, 6417.018555, 7581.067383], [1359.709718, 809.4926991, 6415.065918, 7579.966309], [1336.110184, 817.7877545, 6412.938477, 7578.993652], [1312.511498, 826.0817914, 6410.802246, 7578.226563], [1288.913689, 834.3746991, 6408.544434, 7579.733398], [1265.316814, 842.6663928, 6406.087402, 7576.301758], [1241.72089, 850.9568419, 6403.275879, 7574.858887], [1218.125854, 859.2460046, 6400.027344, 7573.878906], [1194.531678, 867.533979, 6396.333496, 7575.701172], [1170.938263, 875.820828, 6393.145508, 7577.961914], [1147.34556, 884.1066871, 6390.304688, 7580.477539], [1123.753484, 892.3916345, 6387.819824, 7580.030273], [1100.161965, 900.675797, 6384.548828, 7583.660645], [1076.570925, 908.9592777, 6380.978027, 7589.627441], [1052.980287, 917.2421899, 6375.907715, 7590.749512], [1029.389998, 925.5246244, 6372.247559, 7592.10791], [1005.800003, 933.8066593, 6371.617188, 7592.067383], [982.2102481, 942.0883661, 6370.674805, 7593.498047], [958.6206844, 950.3698069, 6367.48291, 7595.581543], [935.0312667, 958.6510521, 6364.414551, 7597.952148], [911.4419424, 966.9321648, 6362.708496, 7599.166016], [887.8526648, 975.2132128, 6360.846191, 7599.644043], [864.5190034, 983.1369768, 6360.194824, 7596.409668], [841.1852323, 991.0608403, 6359.703613, 7591.477051], [817.8512457, 998.9849068, 6358.949219, 7590.927734], [794.5169139, 1006.909291, 6357.648926, 7590.50293], [771.1821281, 1014.834118, 6357.039063, 7589.604004], [747.8467491, 1022.759535, 6357.433105, 7589.163574], [724.5106616, 1030.685699, 6356.162598, 7589.241211], [701.1736843, 1038.612869, 6353.822754, 7583.961426], [677.8356932, 1046.541304, 6353.656738, 7590.026367], [654.4964166, 1054.471464, 6354.635742, 7588.307617], [631.1556827, 1062.403662, 6355.973633, 7591.75], [607.8131598, 1070.338449, 6357.355957, 7597.612793], [584.4687438, 1078.276044, 6358.730469, 7603.848633], [561.1220791, 1086.21706, 6359.532715, 7605.352539], [537.7731093, 1094.16166, 6360.970703, 7609.60498], [514.4214721, 1102.110308, 6363.397949, 7609.693359], [491.0672237, 1110.062719, 6366.832031, 7610.984863], [467.7102488, 1118.018832, 6370.30957, 7607.032227], [444.3507967, 1125.978182, 6374.107422, 7602.319824], [422.2956061, 1133.624877, 6254.195313, 7722.141602], [400.2404155, 1141.271572, 6256.096191, 7720.612305], [378.1852249, 1148.918268, 6257.571777, 7719.638672], [356.1300343, 1156.564963, 6258.84375, 7718.87207], [334.0748437, 1164.211658, 6259.997559, 7718.188477], [312.0196531, 1171.858354, 6261.066406, 7717.540039], [289.9644625, 1179.505049, 6262.074219, 7716.926758], [267.9092719, 1187.151744, 6263.005859, 7716.339844], [245.8540813, 1194.79844, 6263.873047, 7715.785156], [223.7988907, 1202.445135, 6264.67041, 7715.273438], [201.7437001, 1210.09183, 6265.395996, 7714.813477], [179.6885095, 1217.738526, 6266.049316, 7714.387695], [157.6333189, 1225.385221, 6266.625, 7714.012695], [135.5781283, 1233.031916, 6267.132813, 7713.6875], [113.5229377, 1240.678612, 6267.561035, 7713.40918], [91.46774708, 1248.325307, 6267.919434, 7713.176758], [69.41255648, 1255.972002, 6268.203125, 7712.990234], [47.35736588, 1263.618698, 6268.414063, 7712.848633], [25.30217527, 1271.265393, 6268.558105, 7712.754883], [3.246984672, 1278.912088, 6268.623535, 7712.707031], [1434.340892, 757.9843305, 6303.501465, 7698.786133], [1422.291555, 761.0202596, 6419.786133, 7583.253418], [1398.690184, 769.3177364, 6418.018555, 7582.729492], [1375.089364, 777.6144655, 6416.240234, 7581.22168], [1351.489174, 785.9103592, 6414.445801, 7580.658691], [1327.889743, 794.2053707, 6412.310547, 7579.314941], [1304.291148, 802.4993446, 6410.101563, 7578.928711], [1280.693451, 810.7921951, 6407.826172, 7578.646484], [1257.096715, 819.0837839, 6405.306641, 7577.648438], [1233.50085, 827.3741501, 6402.70459, 7576.159668], [1209.905937, 835.6632441, 6399.444336, 7573.688477], [1186.311822, 843.9511688, 6395.870605, 7573.977051], [1162.71854, 852.2379378, 6392.937988, 7575.327148], [1139.125929, 860.5237091, 6390.120117, 7575.80127], [1115.533963, 868.8085631, 6387.827148, 7577.030273], [1091.942524, 877.092656, 6385.68457, 7579.270508], [1068.351572, 885.3760727, 6383.018555, 7584.553223], [1044.761025, 893.658923, 6379.60498, 7585.748047], [1021.170837, 901.9412783, 6376.251465, 7586.740234], [997.580941, 910.2232312, 6374.345215, 7588.23584], [973.9912839, 918.5048512, 6371.370117, 7590.176758], [950.4018156, 926.7862147, 6368.296875, 7593.539551], [926.8124874, 935.0673865, 6365.983398, 7595.629395], [903.2232537, 943.3484286, 6364.852539, 7596.225586], [879.6340668, 951.6294069, 6362.79248, 7595.353516], [856.3003453, 959.5529699, 6361.651855, 7593.021973], [832.9665151, 967.4766311, 6361.056641, 7589.838379], [809.6324646, 975.4004802, 6360.144531, 7587.542969], [786.2980812, 983.324625, 6359.073242, 7586.305664], [762.9632564, 991.2491874, 6358.470215, 7585.90332], [739.6278507, 999.1743459, 6358.683105, 7584.601563], [716.291724, 1007.100288, 6358.250488, 7583.955078], [692.9546876, 1015.027288, 6355.387695, 7578.116699], [669.616605, 1022.955576, 6354.62793, 7588.223633], [646.2772501, 1030.885533, 6355.263672, 7586.67627], [622.9364581, 1038.817469, 6356.608887, 7591.696289], [599.5939352, 1046.751971, 6358.473633, 7599.835449], [576.2494811, 1054.689374, 6359.436035, 7607.895996], [552.9027629, 1062.630276, 6359.801758, 7616.121094], [529.5536691, 1070.574743, 6360.966797, 7615.637695], [506.2019671, 1078.523133, 6363.385742, 7615.049805], [482.8476954, 1086.475271, 6366.519531, 7611.553223], [459.4907281, 1094.431218, 6371.152344, 7607.561523], [436.1311964, 1102.390513, 6374.123047, 7603.759277], [414.0796325, 1110.035734, 6253.680176, 7723.623047], [392.0280687, 1117.680955, 6255.587891, 7721.567383], [369.9765048, 1125.326176, 6257.171387, 7720.103516], [347.924941, 1132.971397, 6258.563477, 7718.962891], [325.8733771, 1140.616618, 6259.814941, 7718.010742], [303.8218133, 1148.261839, 6260.94873, 7717.183594], [281.7702494, 1155.90706, 6261.992676, 7716.448242], [259.7186856, 1163.552281, 6262.954102, 7715.78418], [237.6671218, 1171.197502, 6263.834961, 7715.185547], [215.6155579, 1178.842723, 6264.640625, 7714.643555], [193.5639941, 1186.487944, 6265.36377, 7714.162109], [171.5124302, 1194.133166, 6266.01709, 7713.734375], [149.4608664, 1201.778387, 6266.592285, 7713.358398], [127.4093025, 1209.423608, 6267.087402, 7713.037109], [105.3577387, 1217.068829, 6267.51123, 7712.759766], [83.30617485, 1224.71405, 6267.865234, 7712.53418], [61.254611, 1232.359271, 6268.142578, 7712.349609], [39.20304716, 1240.004492, 6268.347168, 7712.216797], [17.15148331, 1247.649713, 6268.491699, 7712.128906], [-4.90008053, 1255.294934, 6268.557617, 7712.081055], [1426.158735, 734.3839756, 6302.848145, 7698.438477], [1414.070679, 737.4381791, 6418.918945, 7582.475098], [1390.469381, 745.7356062, 6417.25, 7581.327148], [1366.868657, 754.0322285, 6415.577148, 7580.561035], [1343.26859, 762.3281108, 6413.720215, 7579.987305], [1319.669267, 770.6230202, 6411.680176, 7579.298828], [1296.070793, 778.9169093, 6409.518066, 7578.4375], [1272.473193, 787.2096663, 6407.241211, 7579.44873], [1248.876525, 795.5012094, 6404.848145, 7579.109375], [1225.280805, 803.7915059, 6402.160156, 7577.987793], [1201.685972, 812.080516, 6398.875977, 7576.431152], [1178.091996, 820.3683377, 6395.712891, 7575.807617], [1154.498779, 828.6550332, 6393.041504, 7574.23584], [1130.906271, 836.9407398, 6390.557129, 7573.04834], [1107.314391, 845.2255336, 6388.937988, 7572.564941], [1083.723066, 853.5095445, 6386.470703, 7574.60498], [1060.132217, 861.7928726, 6384.634277, 7577.394043], [1036.541771, 870.0756332, 6383.1875, 7580.134766], [1012.951672, 878.357916, 6379.956055, 7582.54834], [989.3618652, 886.6397993, 6376.635254, 7585.08252], [965.7722996, 894.9213554, 6373.867188, 7586.670898], [942.1829247, 903.2026455, 6370.397949, 7589.472168], [918.5936958, 911.483741, 6368.176758, 7591.549316], [895.0045584, 919.764704, 6366.64502, 7592.260742], [871.4154688, 928.045601, 6364.95459, 7591.755371], [848.0817005, 935.9689171, 6363.131836, 7589.394531], [824.7478236, 943.8923323, 6362.473633, 7586.481934], [801.4137292, 951.8159497, 6361.592285, 7584.512695], [778.0792886, 959.7398846, 6360.708008, 7583.313477], [754.7443951, 967.6642649, 6360.17334, 7582.32373], [731.4089084, 975.5892432, 6359.875488, 7580.11377], [708.0727112, 983.514971, 6359.959961, 7577.633789], [684.7356261, 991.4417088, 6357.960938, 7574.594238], [661.3975253, 999.369715, 6355.67041, 7581.538574], [638.0581381, 1007.299449, 6356.277832, 7587.380371], [614.7172926, 1015.231228, 6358.58252, 7593.688477], [591.3746591, 1023.165602, 6361.206543, 7602.828613], [568.0301306, 1031.10279, 6360.802246, 7613.373535], [544.6833552, 1039.043411, 6360.020508, 7620.286621], [521.3342738, 1046.987624, 6361.207031, 7619.23877], [497.982527, 1054.935894, 6363.385254, 7616.500977], [474.6281694, 1062.887934, 6366.706543, 7612.076172], [451.2710858, 1070.843685, 6371.188477, 7607.358887], [427.9115259, 1078.802679, 6375.34668, 7603.822266], [405.8635922, 1086.446434, 6253.783203, 7724.060547], [383.8156584, 1094.090189, 6255.403809, 7721.948242], [361.7677247, 1101.733943, 6256.978516, 7720.244141], [339.7197909, 1109.377698, 6258.418457, 7718.864258], [317.6718572, 1117.021452, 6259.724121, 7717.711914], [295.6239234, 1124.665207, 6260.915039, 7716.736328], [273.5759897, 1132.308961, 6261.998047, 7715.895508], [251.5280559, 1139.952716, 6262.981934, 7715.165039], [229.4801222, 1147.596471, 6263.877441, 7714.516602], [207.4321884, 1155.240225, 6264.683105, 7713.960938], [185.3842547, 1162.88398, 6265.411133, 7713.464844], [163.3363209, 1170.527734, 6266.058594, 7713.03125], [141.2883872, 1178.171489, 6266.626465, 7712.65332], [119.2404534, 1185.815243, 6267.116699, 7712.334961], [97.19251968, 1193.458998, 6267.53418, 7712.06543], [75.14458593, 1201.102752, 6267.882324, 7711.84375], [53.09665218, 1208.746507, 6268.15332, 7711.672852], [31.04871843, 1216.390262, 6268.355469, 7711.537109], [9.00078468, 1224.034016, 6268.493164, 7711.453125], [-13.04714907, 1231.677771, 6268.559082, 7711.412109], [1417.976529, 710.7836498, 6302.474121, 7697.680664], [1405.849706, 713.8561567, 6418.092285, 7580.984863], [1382.248552, 722.1534914, 6416.49707, 7579.27832], [1358.647949, 730.4500736, 6414.880859, 7578.507324], [1335.047975, 738.7458185, 6413.120117, 7578.947266], [1311.44876, 747.0406784, 6411.016113, 7579.649902], [1287.85038, 755.3344997, 6408.866699, 7580.427734], [1264.252894, 763.6271948, 6406.618164, 7580.784668], [1240.656369, 771.9186291, 6404.362305, 7581.225098], [1217.060712, 780.2088398, 6401.587891, 7580.525391], [1193.466005, 788.4977774, 6398.541504, 7580.64209], [1169.872094, 796.7855458, 6395.674805, 7576.717773], [1146.279014, 805.0721592, 6393.141602, 7574.142578], [1122.686603, 813.3577752, 6391.20166, 7571.356934], [1099.094835, 821.6424736, 6389.688477, 7570.581055], [1075.503594, 829.926413, 6387.629883, 7570.683105], [1051.912837, 838.2096762, 6385.345215, 7573.414063], [1028.322485, 846.492372, 6383.581543, 7577.116211], [1004.73249, 854.7745757, 6380.85498, 7579.813477], [981.1427874, 863.056375, 6378.38623, 7581.147461], [957.5533229, 871.3378444, 6376.050293, 7582.733398], [933.9640463, 879.6190562, 6373.134766, 7584.446777], [910.3749089, 887.9000764, 6371.30127, 7587.867188], [886.7858669, 896.1809678, 6369.025391, 7588.362305], [863.1968708, 904.461795, 6367.01709, 7587.327148], [839.8630376, 912.3849054, 6365.101563, 7585.631348], [816.5290958, 920.3081127, 6363.890625, 7583.276855], [793.1949347, 928.2315116, 6363.126953, 7581.646484], [769.8604388, 936.1552072, 6362.38623, 7579.88623], [746.5255024, 944.0793224, 6361.820313, 7578.620605], [723.1899842, 952.0040365, 6361.599609, 7576.992188], [699.853744, 959.9295374, 6361.441406, 7577.947754], [676.5165941, 967.8560997, 6360.490234, 7573.666992], [653.178398, 975.7839533, 6357.972168, 7580.3125], [629.8389306, 983.7134834, 6357.664551, 7588.565918], [606.4980242, 991.6449963, 6359.866211, 7596.583984], [583.1553877, 999.5790859, 6362.458008, 7605.068359], [559.8108211, 1007.516081, 6361.393555, 7615.507324], [536.4639904, 1015.456583, 6360.404297, 7620.45752], [513.1147851, 1023.40066, 6361.647461, 7619.508301], [489.7629724, 1031.34867, 6363.328613, 7617.062012], [466.4085915, 1039.300435, 6367.344238, 7612.875977], [443.0515159, 1047.256019, 6371.737793, 7607.81543], [419.6918774, 1055.214961, 6374.661133, 7603.220703], [397.6475727, 1062.857243, 6253.558105, 7724.003906], [375.603268, 1070.499526, 6255.275391, 7721.90918], [353.5589633, 1078.141809, 6256.902832, 7720.074219], [331.5146586, 1085.784091, 6258.400391, 7718.530273], [309.4703539, 1093.426374, 6259.762695, 7717.236328], [287.4260492, 1101.068657, 6260.987793, 7716.152344], [265.3817445, 1108.710939, 6262.102051, 7715.233398], [243.3374398, 1116.353222, 6263.105469, 7714.449219], [221.2931351, 1123.995504, 6264, 7713.779297], [199.2488304, 1131.637787, 6264.810059, 7713.202148], [177.2045257, 1139.28007, 6265.53418, 7712.701172], [155.160221, 1146.922352, 6266.177734, 7712.273438], [133.1159163, 1154.564635, 6266.736816, 7711.901367], [111.0716116, 1162.206918, 6267.220215, 7711.587891], [89.02730693, 1169.8492, 6267.630371, 7711.322266], [66.98300223, 1177.491483, 6267.967773, 7711.113281], [44.93869753, 1185.133766, 6268.234375, 7710.944336], [22.89439283, 1192.776048, 6268.435059, 7710.822266], [0.8500881344, 1200.418331, 6268.571289, 7710.743164], [-21.19421656, 1208.060613, 6268.633789, 7710.702148], [1421.230241, 681.9762226, 6418.980469, 7581.121582], [1397.628759, 690.2741333, 6417.523438, 7578.904297], [1374.02768, 698.5714118, 6415.889648, 7577.363281], [1350.427176, 706.8678815, 6414.227539, 7577.933594], [1326.827327, 715.1636092, 6412.42627, 7579.229492], [1303.228223, 723.4583623, 6410.330566, 7580.970215], [1279.629965, 731.752094, 6408.169922, 7582.158691], [1256.03258, 740.0446917, 6405.878418, 7582.685547], [1232.436125, 748.3360755, 6403.587891, 7583.154297], [1208.840618, 756.6262128, 6400.826172, 7582.388184], [1185.245994, 764.9150645, 6398.084961, 7580.330566], [1161.652226, 773.202728, 6395.847656, 7577.95459], [1138.059214, 781.4892652, 6393.460938, 7574.534668], [1114.466911, 789.7748153, 6391.82666, 7570.337402], [1090.875233, 798.0594528, 6390.190918, 7568.46582], [1067.284107, 806.3433073, 6388.279297, 7570.941406], [1043.693458, 814.6264808, 6386.270508, 7574.187988], [1020.10321, 822.909087, 6384.102539, 7577.910645], [996.5133087, 831.1912163, 6381.75, 7579.726563], [972.9236973, 839.4729469, 6379.453613, 7579.830566], [949.3343272, 847.7543495, 6377.378418, 7579.369141], [925.7451479, 856.0354879, 6375.377441, 7581.006836], [902.1561116, 864.3164318, 6373.17334, 7582.605469], [878.5671687, 872.5972422, 6371.016113, 7583.291992], [854.9782728, 880.8779891, 6369.02832, 7582.266602], [831.644388, 888.8008479, 6367.07666, 7580.95752], [808.3103938, 896.7238072, 6365.11377, 7579.610352], [784.9761841, 904.6469725, 6364.421387, 7577.748047], [761.6416272, 912.5704573, 6363.955078, 7576.157227], [738.3066173, 920.4943904, 6363.47168, 7574.880859], [714.9710132, 928.4189204, 6363.466309, 7573.563965], [691.6346997, 936.3442019, 6363.460449, 7572.944336], [668.2974963, 944.2704972, 6361.411621, 7567.019531], [644.9592783, 952.1980666, 6359.199219, 7580.006348], [621.6197747, 960.1273717, 6358.672363, 7589.125488], [598.2788139, 968.0587272, 6361.383789, 7597.929688], [574.9360639, 975.9926852, 6362.34082, 7606.541992], [551.5914219, 983.9294643, 6361.222168, 7617.239746], [528.2445331, 991.8696832, 6360.62793, 7620.23877], [504.8953401, 999.8135032, 6361.499023, 7619.591309], [481.5434817, 1007.76139, 6363.531738, 7617.368652], [458.1890149, 1015.713057, 6367.870605, 7612.731934], [434.8318235, 1023.668444, 6372.263672, 7607.734863], [411.4721583, 1031.627085, 6374.365234, 7603.681152], [389.431486, 1039.267903, 6253.377441, 7723.96875], [367.3908137, 1046.908721, 6255.232422, 7721.62207], [345.3501414, 1054.549539, 6256.95459, 7719.613281], [323.3094692, 1062.190358, 6258.52002, 7717.941406], [301.2687969, 1069.831176, 6259.928711, 7716.553711], [279.2281246, 1077.471994, 6261.188477, 7715.398438], [257.1874523, 1085.112812, 6262.314453, 7714.433594], [235.14678, 1092.75363, 6263.320801, 7713.626953], [213.1061077, 1100.394449, 6264.223145, 7712.939453], [191.0654354, 1108.035267, 6265.025879, 7712.366211], [169.0247632, 1115.676085, 6265.742188, 7711.873047], [146.9840909, 1123.316903, 6266.375488, 7711.451172], [124.9434186, 1130.957721, 6266.922852, 7711.088867], [102.9027463, 1138.598539, 6267.395996, 7710.789063], [80.86207401, 1146.239358, 6267.803223, 7710.541016], [58.82140172, 1153.880176, 6268.128906, 7710.338867], [36.78072944, 1161.520994, 6268.384766, 7710.183594], [14.74005715, 1169.161812, 6268.583984, 7710.0625], [-7.300615132, 1176.80263, 6268.711914, 7709.985352], [-29.34128742, 1184.443449, 6268.772461, 7709.945313], [1413.009138, 658.3942718, 6418.368164, 7579.37793], [1389.407723, 666.6921596, 6416.921875, 7577.271484], [1365.806789, 674.9893388, 6415.297852, 7575.920898], [1342.206407, 683.2857637, 6413.630859, 7575.144043], [1318.606654, 691.5813493, 6411.680664, 7578.675293], [1295.00766, 699.8760471, 6409.602539, 7582.804199], [1271.409499, 708.1697063, 6407.352539, 7583.366211], [1247.812231, 716.4622393, 6405.136719, 7583.989746], [1224.215922, 724.7535105, 6402.69043, 7584.015625], [1200.62048, 733.0435591, 6400.007324, 7584.138184], [1177.025986, 741.3323355, 6397.520508, 7579.884277], [1153.432286, 749.6199436, 6395.447266, 7576.167969], [1129.839414, 757.9063979, 6393.585938, 7572.438965], [1106.247211, 766.1918555, 6392.124512, 7570.375], [1082.655648, 774.4763976, 6390.521484, 7569.961426], [1059.064611, 782.7601805, 6388.825195, 7572.148926], [1035.474056, 791.0432873, 6387.20752, 7575.67041], [1011.883905, 799.3258286, 6384.950684, 7577.952637], [988.2941108, 807.6078778, 6383.01709, 7579.109375], [964.7046072, 815.8895245, 6381.111328, 7579.075195], [941.115341, 824.1708404, 6379.202637, 7577.331543], [917.5262609, 832.4518996, 6377.046387, 7577.822266], [893.9373209, 840.7327682, 6374.688965, 7577.902832], [870.3484743, 849.013508, 6372.651855, 7579.498047], [846.7596748, 857.2941831, 6370.818848, 7578.452637], [823.4257204, 865.2168361, 6368.908691, 7576.999023], [800.0916565, 873.1395875, 6366.863281, 7575.898926], [776.7573733, 881.0625297, 6365.713867, 7573.834961], [753.4227564, 888.9857713, 6365.407715, 7571.308105], [730.0876978, 896.9094335, 6365.32373, 7570.915527], [706.7520595, 904.8336984, 6365.637207, 7569.873535], [683.4156982, 912.758754, 6365.515625, 7570.491699], [660.0784281, 920.6848747, 6362.513672, 7572.912109], [636.7401118, 928.6122915, 6359.88916, 7578.123535], [613.4005243, 936.5413897, 6359.726074, 7588.745117], [590.0594996, 944.4724762, 6361.446289, 7597.49707], [566.7167459, 952.4061453, 6361.474121, 7606.558105], [543.3720629, 960.3427298, 6360.724121, 7617.239258], [520.0251177, 968.2828295, 6360.93457, 7618.612305], [496.6757999, 976.2265131, 6361.425293, 7619.205078], [473.3238766, 984.1741383, 6364.133301, 7616.676758], [449.9693869, 992.1255295, 6368.363281, 7612.85791], [426.6122051, 1000.080749, 6371.964355, 7608.132324], [403.2524626, 1008.039334, 6374.066895, 7603.79834], [381.2154216, 1015.678681, 6253.285645, 7723.62793], [359.1783806, 1023.318029, 6255.327637, 7720.992188], [337.1413396, 1030.957377, 6257.163086, 7718.830078], [315.1042986, 1038.596725, 6258.795898, 7717.073242], [293.0672576, 1046.236073, 6260.238281, 7715.632813], [271.0302167, 1053.87542, 6261.515625, 7714.455078], [248.9931757, 1061.514768, 6262.647461, 7713.485352], [226.9561347, 1069.154116, 6263.652832, 7712.677734], [204.9190937, 1076.793464, 6264.539551, 7712.003906], [182.8820527, 1084.432812, 6265.333496, 7711.443359], [160.8450117, 1092.07216, 6266.033203, 7710.96875], [138.8079707, 1099.711507, 6266.654785, 7710.568359], [116.7709297, 1107.350855, 6267.1875, 7710.225586], [94.73388876, 1114.990203, 6267.64502, 7709.942383], [72.69684777, 1122.629551, 6268.035645, 7709.709961], [50.65980679, 1130.268899, 6268.353516, 7709.521484], [28.6227658, 1137.908246, 6268.60498, 7709.371094], [6.585724812, 1145.547594, 6268.790039, 7709.265625], [-15.45131617, 1153.186942, 6268.921875, 7709.195313], [-37.48835716, 1160.82629, 6268.97998, 7709.157227], [1404.787981, 634.8124239, 6417.80957, 7577.461426], [1381.18672, 643.1101763, 6416.339844, 7575.562988], [1357.585863, 651.4072936, 6414.691895, 7574.335449], [1333.985581, 659.7036011, 6413.019531, 7575.802246], [1310.385956, 667.9991639, 6410.958984, 7577.806152], [1286.787074, 676.293751, 6408.881836, 7581.607422], [1263.189038, 684.5873168, 6406.501465, 7582.603027], [1239.591874, 692.8797496, 6404.205566, 7583.540527], [1215.995637, 701.1709683, 6401.701172, 7583.592285], [1192.400347, 709.4609416, 6399.124023, 7581.530273], [1168.805938, 717.7496293, 6397.070801, 7578.507324], [1145.212382, 726.0371307, 6395.135742, 7574.118652], [1121.619583, 734.3235086, 6393.450195, 7571.739258], [1098.027489, 742.6088985, 6392.27002, 7570.826172], [1074.43602, 750.8933776, 6391.01416, 7570.986816], [1050.845101, 759.1770757, 6389.609863, 7572.804688], [1027.254657, 767.4600939, 6388.383301, 7575.775879], [1003.664613, 775.7425445, 6386.806152, 7578.064941], [980.0749138, 784.0245203, 6385.11084, 7579.366699], [956.4855046, 792.3060965, 6383.08252, 7578.140137], [932.8963348, 800.5873465, 6380.895996, 7576.179199], [909.3073548, 808.8683323, 6378.494141, 7574.779297], [885.7185187, 817.1491236, 6376.134766, 7574.624023], [862.1297743, 825.4297833, 6373.665527, 7575.535645], [838.5410768, 833.7103772, 6371.313477, 7575.785645], [815.2070651, 841.6327795, 6370.056152, 7573.459961], [791.872944, 849.5552821, 6368.335449, 7571.782227], [768.5386075, 857.4779896, 6367.505371, 7570.172363], [745.2039247, 865.4010176, 6367.172852, 7568.464355], [721.8687879, 873.3244948, 6367.353027, 7566.910156], [698.533058, 881.2485757, 6367.958496, 7565.956055], [675.1966195, 889.1734128, 6367.566406, 7567.065918], [651.8592932, 897.0992665, 6365.721191, 7569.239258], [628.5209521, 905.0263982, 6362.846191, 7575.595215], [605.1813264, 912.9552693, 6361.891113, 7584.703613], [581.8402445, 920.8861966, 6361.14502, 7595.644531], [558.4973754, 928.8197332, 6361.143066, 7605.790039], [535.1526161, 936.7561002, 6361.140625, 7613.399414], [511.8056118, 944.6959157, 6360.769043, 7615.687988], [488.4563054, 952.6393409, 6361.365234, 7616.975098], [465.1043372, 960.586844, 6364.873047, 7614.974609], [441.7497623, 968.5381361, 6368.923828, 7610.816895], [418.3924664, 976.493157, 6371.57666, 7607.469727], [396.2987708, 984.1456048, 6250.739746, 7726.478516], [374.2050752, 991.7980526, 6253.36084, 7722.775391], [352.1113796, 999.4505004, 6255.629883, 7719.898438], [330.0176841, 1007.102948, 6257.578613, 7717.647461], [307.9239885, 1014.755396, 6259.257813, 7715.875977], [285.8302929, 1022.407844, 6260.714844, 7714.452148], [263.7365973, 1030.060292, 6261.984375, 7713.310547], [241.6429017, 1037.712739, 6263.105957, 7712.368164], [219.5492061, 1045.365187, 6264.092773, 7711.599609], [197.4555105, 1053.017635, 6264.965332, 7710.961914], [175.3618149, 1060.670083, 6265.730957, 7710.429688], [153.2681193, 1068.322531, 6266.410156, 7709.991211], [131.1744237, 1075.974978, 6267.009766, 7709.619141], [109.0807281, 1083.627426, 6267.526855, 7709.307617], [86.98703255, 1091.279874, 6267.966309, 7709.046875], [64.89333696, 1098.932322, 6268.342773, 7708.836914], [42.79964137, 1106.584769, 6268.648438, 7708.665039], [20.70594577, 1114.237217, 6268.882813, 7708.529297], [-1.387749817, 1121.889665, 6269.06543, 7708.431641], [-23.48144541, 1129.542113, 6269.189453, 7708.363281], [-45.575141, 1137.194561, 6269.244629, 7708.333984], [1396.566829, 611.2305141, 6417.245605, 7575.022949], [1372.965637, 619.5282369, 6415.719238, 7573.400391], [1349.364927, 627.8252502, 6414.077637, 7572.803223], [1325.76477, 636.1215072, 6412.303223, 7574.006836], [1302.165241, 644.4169241, 6410.304199, 7576.013184], [1278.56647, 652.711453, 6408.119629, 7579.059082], [1254.968533, 661.0049425, 6405.687012, 7581.171875], [1231.371486, 669.2973066, 6403.226074, 7582.187012], [1207.775399, 677.58841, 6400.660156, 7582.129883], [1184.180175, 685.8782927, 6398.111816, 7581.105469], [1160.585898, 694.1669041, 6396.305664, 7576.460938], [1136.992414, 702.4543492, 6394.569824, 7574.068359], [1113.399757, 710.7406422, 6393.637695, 7572.625488], [1089.807765, 719.0259406, 6392.790039, 7572.465332], [1066.216413, 727.3103234, 6391.85791, 7572.51709], [1042.625585, 735.593949, 6391.041992, 7573.705566], [1019.035238, 743.8769004, 6389.845703, 7575.606934], [995.4452929, 752.1592862, 6388.771484, 7576.454102], [971.8557035, 760.4411818, 6387.145996, 7577.727051], [948.266403, 768.7226741, 6384.702637, 7576.677734], [924.67734, 777.0038373, 6382.500488, 7574.698242], [901.088462, 785.284744, 6380.650391, 7571.783203], [877.4997233, 793.5654599, 6378.498047, 7571.226074], [853.911078, 801.8460481, 6375.58252, 7571.182617], [830.3224788, 810.1265712, 6372.449219, 7571.033691], [806.9883927, 818.0487668, 6370.999023, 7569.885742], [783.6541972, 825.9710605, 6369.794922, 7568.316895], [760.3197824, 833.8935478, 6369.000488, 7566.711914], [736.9850338, 841.8163345, 6367.944336, 7564.875488], [713.6498447, 849.7395447, 6370.098145, 7563.203613], [690.3140756, 857.6633594, 6370.414063, 7563.162598], [666.9775866, 865.5879677, 6369.672852, 7568.270508], [643.6401878, 873.513644, 6368.661621, 7569.40625], [620.3017456, 881.4406221, 6366.979492, 7576.999023], [596.9620331, 889.3692864, 6365.200684, 7584.939453], [573.6208864, 897.2999457, 6363.549805, 7594.240234], [550.2780115, 905.2331951, 6362.629883, 7604.020996], [526.9332102, 913.1693657, 6361.625488, 7609.142578], [503.5861497, 921.1090611, 6361.053711, 7612.067871], [480.2367184, 929.0523499, 6361.796387, 7612.030273], [456.8846854, 936.9995898, 6366.398926, 7610.64209], [433.5300889, 944.9506053, 6371.102539, 7607.519043], [410.1728036, 952.9054593, 6372.407715, 7605.554688], [386.81296, 960.8636884, 6373.415527, 7602.405762], [364.7831869, 968.5001022, 6253.788574, 7721.107422], [342.7534138, 976.1365161, 6256.257324, 7718.173828], [320.7236407, 983.7729299, 6258.259277, 7716.001953], [298.6938676, 991.4093438, 6259.9375, 7714.324219], [276.6640945, 999.0457576, 6261.371582, 7713.003906], [254.6343214, 1006.682171, 6262.61377, 7711.943359], [232.6045483, 1014.318585, 6263.699219, 7711.09082], [210.5747752, 1021.954999, 6264.648438, 7710.387695], [188.5450021, 1029.591413, 6265.486816, 7709.816406], [166.515229, 1037.227827, 6266.222168, 7709.339844], [144.4854559, 1044.864241, 6266.872559, 7708.945313], [122.4556828, 1052.500655, 6267.441895, 7708.613281], [100.4259098, 1060.137068, 6267.93457, 7708.338867], [78.39613665, 1067.773482, 6268.354492, 7708.109375], [56.36636356, 1075.409896, 6268.71582, 7707.922852], [34.33659046, 1083.04631, 6269.00293, 7707.771484], [12.30681736, 1090.682724, 6269.231445, 7707.650391], [-9.722955741, 1098.319138, 6269.401855, 7707.567383], [-31.75272884, 1105.955552, 6269.51709, 7707.506836], [-53.78250194, 1113.591965, 6269.571777, 7707.473633], [1388.345632, 587.6487006, 6416.695801, 7571.946777], [1364.744596, 595.9462842, 6415.091309, 7572.366211], [1341.143964, 604.2432297, 6413.467773, 7572.147461], [1317.543907, 612.5393647, 6411.664063, 7572.524414], [1293.944507, 620.8347558, 6409.618652, 7574.019531], [1270.345851, 629.1291703, 6407.307129, 7576.98584], [1246.748039, 637.4225635, 6404.737793, 7579.271484], [1223.151097, 645.7148246, 6402.173828, 7580.424805], [1199.555083, 654.0058736, 6399.615234, 7579.379395], [1175.960014, 662.2956781, 6397.37207, 7576.828613], [1152.365824, 670.5842008, 6395.69043, 7574.183105], [1128.772487, 678.8715381, 6394.181641, 7572.052246], [1105.179903, 687.1577529, 6393.644531, 7573.390137], [1081.588023, 695.4429826, 6393.310547, 7573.287598], [1057.996766, 703.7273044, 6393.306641, 7573.819824], [1034.406059, 712.0108442, 6392.611816, 7574.423828], [1010.815824, 720.2937059, 6392.42334, 7574.807129], [987.2259873, 728.5760021, 6391.779785, 7574.857422], [963.6364961, 736.8578224, 6389.642578, 7575.251953], [940.0472919, 745.139246, 6387.694824, 7574.73291], [916.4583271, 753.4203434, 6385.634277, 7572.160645], [892.8695512, 761.7011767, 6383.540039, 7569.439453], [869.2809173, 769.9818154, 6380.819824, 7567.352051], [845.692376, 778.2623225, 6377.983887, 7566.98877], [822.1038809, 786.5427653, 6374.663086, 7567.332031], [798.7697317, 794.4647103, 6372.007813, 7566.253418], [775.4354743, 802.3867569, 6371.417969, 7564.069824], [752.1010013, 810.3090106, 6370.180176, 7562.859375], [728.7661821, 818.2315884, 6369.434082, 7560.606445], [705.4309109, 826.1546164, 6371.966309, 7558.941895], [682.0950475, 834.0782472, 6373.147949, 7560.939453], [658.7584764, 842.002636, 6372.36084, 7566.324707], [635.4210185, 849.9280454, 6372.625977, 7567.976074], [612.0825477, 857.8547383, 6369.405273, 7572.327637], [588.7427952, 865.7831765, 6367.716309, 7581.817383], [565.4015883, 873.7136775, 6366.20166, 7591.887207], [542.0585981, 881.6467944, 6364.836914, 7600.984863], [518.7137196, 889.5827495, 6363.26123, 7604.046875], [495.366599, 897.5221607, 6362.021973, 7607.188965], [472.01718, 905.4651901, 6362.003418, 7606.756348], [448.6651022, 913.4123069, 6368.06543, 7603.702148], [425.3104218, 921.3632242, 6372.198242, 7602.180176], [401.953023, 929.3178808, 6372.785156, 7600.98584], [378.5931561, 937.2758076, 6374.519043, 7599.169922], [356.5670194, 944.9107572, 6255.023926, 7718.180664], [334.5408828, 952.5457068, 6257.356445, 7715.703125], [312.5147461, 960.1806565, 6259.263184, 7713.850586], [290.4886095, 967.8156061, 6260.862305, 7712.416016], [268.4624728, 975.4505558, 6262.21875, 7711.283203], [246.4363362, 983.0855054, 6263.393066, 7710.381836], [224.4101995, 990.7204551, 6264.418945, 7709.648438], [202.3840629, 998.3554047, 6265.317871, 7709.057617], [180.3579263, 1005.990354, 6266.108398, 7708.568359], [158.3317896, 1013.625304, 6266.804688, 7708.165039], [136.305653, 1021.260254, 6267.415527, 7707.832031], [114.2795163, 1028.895203, 6267.950684, 7707.557617], [92.25337968, 1036.530153, 6268.418945, 7707.322266], [70.22724303, 1044.165103, 6268.8125, 7707.129883], [48.20110639, 1051.800052, 6269.146973, 7706.969727], [26.17496975, 1059.435002, 6269.422852, 7706.839844], [4.1488331, 1067.069951, 6269.637695, 7706.745117], [-17.87730354, 1074.704901, 6269.797363, 7706.670898], [-39.90344019, 1082.339851, 6269.904785, 7706.621094], [-61.92957683, 1089.9748, 6269.956543, 7706.59668], [1380.124447, 564.0668222, 6416.16748, 7572.601074], [1356.52348, 572.3643714, 6414.508301, 7571.896484], [1332.922996, 580.6612083, 6412.888184, 7571.983887], [1309.323065, 588.9572899, 6411.165527, 7572.166992], [1285.723762, 597.2525303, 6409.155273, 7573.271484], [1262.125218, 605.5468828, 6406.573242, 7574.915527], [1238.527507, 613.8401978, 6403.810059, 7577.061523], [1214.930685, 622.1323883, 6401.097168, 7578.167969], [1191.334821, 630.423321, 6398.51709, 7577.120117], [1167.739819, 638.7130339, 6396.590332, 7574.404785], [1144.145763, 647.0014775, 6395.021484, 7571.039063], [1120.552497, 655.2887575, 6394.445801, 7570.40625], [1096.960057, 663.5748875, 6394.109863, 7571.750977], [1073.368281, 671.8600247, 6394.133301, 7572.776367], [1049.777144, 680.1442492, 6394.504395, 7573.705566], [1026.186528, 688.4277175, 6394.152344, 7574.107422], [1002.596392, 696.7105124, 6394.16748, 7574.399414], [979.0066568, 704.9927438, 6394.077148, 7573.291504], [955.4172753, 713.274484, 6392.663086, 7572.731445], [931.8281827, 721.5558236, 6391.064453, 7571.062012], [908.2393257, 729.8368333, 6388.442383, 7568.598145], [884.6506527, 738.1175874, 6385.820313, 7565.898926], [861.062119, 746.3981517, 6383.025879, 7562.986328], [837.4736778, 754.6785873, 6380.075684, 7562.726563], [813.8852829, 762.9589594, 6376.678711, 7562.547363], [790.5510545, 770.8807014, 6373.351563, 7561.594727], [767.2167179, 778.802544, 6372.85498, 7559.371094], [743.882162, 786.7245782, 6372.515137, 7556.360352], [720.5472732, 794.6469139, 6373.063965, 7555.494141], [697.2119457, 802.5696749, 6374.916992, 7554.208984], [673.8760384, 810.4930424, 6376.692383, 7556.526855], [650.539413, 818.4172071, 6377.466797, 7559.683594], [627.2018806, 826.3424438, 6376.324219, 7563.589355], [603.8633069, 834.2689852, 6372.041016, 7572.085449], [580.5234657, 842.1972174, 6369.98877, 7580.435059], [557.182192, 850.1274504, 6368.341797, 7588.922852], [533.8391942, 858.0602803, 6367.007813, 7595.362305], [510.4942727, 865.9960398, 6364.945801, 7598.048828], [487.1470959, 873.9353318, 6363.045898, 7600.404785], [463.797552, 881.8782267, 6363.421387, 7599.755859], [440.4454103, 889.8250832, 6366.643555, 7597.300781], [417.0907085, 897.775723, 6369.392578, 7595.767578], [393.7333216, 905.7302117, 6371.493164, 7594.3125], [370.3733802, 913.6880832, 6376.506348, 7594.44873], [348.3508787, 921.3215611, 6256.902832, 7714.270508], [326.3283772, 928.9550391, 6258.887207, 7712.616211], [304.3058756, 936.5885171, 6260.577637, 7711.277344], [282.2833741, 944.2219951, 6262.016602, 7710.206055], [260.2608726, 951.8554731, 6263.25, 7709.34375], [238.238371, 959.4889511, 6264.321777, 7708.640625], [216.2158695, 967.1224291, 6265.26416, 7708.077148], [194.193368, 974.755907, 6266.096191, 7707.617188], [172.1708665, 982.389385, 6266.825195, 7707.237305], [150.1483649, 990.022863, 6267.467773, 7706.922852], [128.1258634, 997.656341, 6268.03125, 7706.666016], [106.1033619, 1005.289819, 6268.533691, 7706.446289], [84.08086033, 1012.923297, 6268.962891, 7706.266602], [62.0583588, 1020.556775, 6269.329102, 7706.114258], [40.03585726, 1028.190253, 6269.640137, 7705.985352], [18.01335573, 1035.823731, 6269.899414, 7705.891602], [-4.009145798, 1043.457209, 6270.100586, 7705.811523], [-26.03164733, 1051.090687, 6270.24707, 7705.754883], [-48.05414886, 1058.724165, 6270.348145, 7705.719727], [-70.07665039, 1066.357643, 6270.395508, 7705.696289], [1371.903223, 540.4850382, 6415.811035, 7573.181152], [1348.302412, 548.7824425, 6414.158203, 7572.894531], [1324.702007, 557.0792098, 6412.548828, 7572.57959], [1301.102178, 565.3751654, 6410.649902, 7572.318848], [1277.503005, 573.6703763, 6408.562988, 7572.613281], [1253.904576, 581.9646125, 6406.022949, 7573.894043], [1230.306991, 590.2578282, 6403.30127, 7575.350098], [1206.710275, 598.5499139, 6400.515137, 7575.544922], [1183.114486, 606.8407893, 6397.849609, 7574.15625], [1159.519639, 615.1304231, 6396.154297, 7572.118164], [1135.925671, 623.418777, 6394.495605, 7569.685547], [1112.332553, 631.7059484, 6394.486816, 7568.843262], [1088.740188, 639.9920011, 6394.347168, 7569.353027], [1065.148525, 648.2770687, 6394.686035, 7571.828613], [1041.557483, 656.5612302, 6395.156738, 7573.17627], [1017.966989, 664.8446136, 6395.929688, 7573.73584], [994.3769663, 673.1273189, 6396.66748, 7574.229004], [970.7873416, 681.4094597, 6395.993652, 7572.01123], [947.1980593, 689.6911255, 6394.786621, 7570.584473], [923.6090649, 697.9723955, 6392.976563, 7567.543457], [900.0203071, 706.2533394, 6390.490723, 7564.722656], [876.4317381, 714.5340201, 6387.649414, 7561.12793], [852.8433112, 722.8145071, 6384.857422, 7559.069336], [829.2549749, 731.0948626, 6381.730469, 7558.271484], [805.6666849, 739.3751534, 6378.165039, 7558.187988], [782.3323906, 747.2966506, 6375.044922, 7556.522461], [758.9979863, 755.218249, 6374.088867, 7554.499023], [735.6633684, 763.1400534, 6374.344727, 7552.300293], [712.3284043, 771.0621812, 6376.027832, 7550.458496], [688.99299, 778.9847628, 6377.522461, 7549.567383], [665.6569855, 786.9079501, 6379.685059, 7548.94873], [642.3202752, 794.8319003, 6381.116211, 7553.565918], [618.9826808, 802.7568748, 6379.421387, 7561.727539], [595.6440765, 810.6831338, 6375.377441, 7571.128906], [572.3041924, 818.6111419, 6372.245117, 7578.703613], [548.9628578, 826.5412195, 6370.47168, 7586.773926], [525.6197426, 834.4739187, 6368.692383, 7590.293945], [502.274743, 842.4094627, 6366.48584, 7592.513672], [478.927506, 850.3484724, 6364.465332, 7594.165527], [455.5779745, 858.2911108, 6364.124023, 7593.204102], [432.225788, 866.2378462, 6365.316406, 7591.57959], [408.8710037, 874.1883886, 6368.587402, 7590.146973], [385.5135042, 882.142679, 6371.851563, 7588.118652], [362.15354, 890.1002481, 6377.945801, 7589.65625], [340.1346767, 897.7322597, 6259.001953, 7710.041016], [318.1158133, 905.3642713, 6260.709961, 7709.204102], [296.09695, 912.9962829, 6262.139648, 7708.441406], [274.0780866, 920.6282945, 6263.364746, 7707.77832], [252.0592233, 928.2603061, 6264.435547, 7707.232422], [230.0403599, 935.8923177, 6265.379395, 7706.770508], [208.0214966, 943.5243293, 6266.216797, 7706.402344], [186.0026332, 951.1563409, 6266.967285, 7706.092773], [163.9837699, 958.7883525, 6267.628906, 7705.836914], [141.9649065, 966.4203641, 6268.209961, 7705.626953], [119.9460432, 974.0523757, 6268.725586, 7705.451172], [97.9271798, 981.6843873, 6269.174805, 7705.308594], [75.90831645, 989.3163989, 6269.569336, 7705.175781], [53.8894531, 996.9484105, 6269.907227, 7705.067383], [31.87058975, 1004.580422, 6270.190918, 7704.983398], [9.851726396, 1012.212434, 6270.427734, 7704.918945], [-12.16713696, 1019.844445, 6270.61377, 7704.860352], [-34.18600031, 1027.476457, 6270.75, 7704.826172], [-56.20486366, 1035.108468, 6270.845215, 7704.800781], [-78.22372701, 1042.74048, 6270.888184, 7704.786133], [1363.682015, 516.9031885, 6415.599121, 7574.333984], [1340.081274, 525.2005546, 6413.956055, 7573.188965], [1316.481018, 533.4972093, 6412.350098, 7571.954102], [1292.881315, 541.7931078, 6410.603516, 7572.3125], [1269.282241, 550.088166, 6408.540527, 7571.617676], [1245.683925, 558.3823383, 6405.792969, 7572.629883], [1222.086441, 566.675473, 6402.92334, 7573.470703], [1198.489845, 574.9674872, 6400.088867, 7573.84375], [1174.894207, 583.2582443, 6397.838379, 7571.667969], [1151.299429, 591.5477846, 6396.240234, 7568.972168], [1127.705595, 599.8360594, 6394.958984, 7567.483398], [1104.112551, 608.1231736, 6394.817383, 7568.018066], [1080.520329, 616.4091385, 6394.667969, 7569.160645], [1056.92877, 624.6941136, 6395.182129, 7570.794434], [1033.337849, 632.9781788, 6395.65625, 7572.390137], [1009.747448, 641.2614888, 6396.344727, 7572.919434], [986.1575252, 649.5441264, 6397.38623, 7572.906738], [962.5680026, 657.8262023, 6397.123535, 7572.680176], [938.9788318, 666.107788, 6396.774414, 7570.885254], [915.389949, 674.3889741, 6394.297852, 7565.285645], [891.8012999, 682.6698302, 6391.217285, 7560.356445], [868.2128358, 690.9504327, 6388.441895, 7556.507324], [844.624509, 699.2308435, 6385.64502, 7555.487793], [821.0362757, 707.5111274, 6382.729004, 7554.502441], [797.4480869, 715.7913475, 6379.57666, 7553.649902], [774.1137087, 723.7126455, 6377.090332, 7551.639648], [750.7792214, 731.6340437, 6375.417969, 7548.5], [727.4445167, 739.5556354, 6376.065918, 7547.185059], [704.1094801, 747.4775295, 6378.155273, 7546.054199], [680.7740058, 755.3998499, 6379.793457, 7545.345215], [657.4379545, 763.3227787, 6382.191895, 7545.984375], [634.1011869, 771.2465067, 6384.66748, 7549.349609], [610.7635144, 779.1713095, 6381.781738, 7555.646973], [587.4248033, 787.0974207, 6378.322266, 7562.426758], [564.0848295, 795.0252276, 6374.686035, 7575.812012], [540.7434262, 802.955041, 6372.708984, 7584.280273], [517.4003025, 810.8874569, 6370.647461, 7586.725098], [494.0552599, 818.8228093, 6368.134766, 7587.867188], [470.7079657, 826.7617026, 6365.925293, 7590.709961], [447.3583093, 834.7042065, 6364.013184, 7588.978027], [424.0060589, 842.6506816, 6365.818359, 7590.151367], [400.6512531, 850.6009484, 6368.840332, 7585.515137], [377.2937661, 858.5550729, 6373.760254, 7585.238281], [353.9337289, 866.5125895, 6380.719727, 7585.22998], [331.9185023, 874.1431263, 6261.619629, 7705.863281], [309.9032758, 881.7736632, 6262.821777, 7705.731445], [287.8880492, 889.4042, 6263.89502, 7705.495117], [265.8728227, 897.0347368, 6264.867676, 7705.245117], [243.8575961, 904.6652736, 6265.744141, 7705.018555], [221.8423696, 912.2958104, 6266.543945, 7704.824219], [199.827143, 919.9263472, 6267.266113, 7704.65625], [177.8119164, 927.556884, 6267.919922, 7704.517578], [155.7966899, 935.1874208, 6268.499512, 7704.398438], [133.7814633, 942.8179576, 6269.018066, 7704.293945], [111.7662368, 950.4484944, 6269.473633, 7704.208984], [89.75101021, 958.0790312, 6269.881348, 7704.133789], [67.73578366, 965.709568, 6270.236816, 7704.067383], [45.7205571, 973.3401048, 6270.541504, 7704.012695], [23.70533054, 980.9706416, 6270.793457, 7703.967773], [1.690103982, 988.6011784, 6271.009766, 7703.930664], [-20.32512258, 996.2317152, 6271.17627, 7703.904297], [-42.34034913, 1003.862252, 6271.30127, 7703.881836], [-64.35557569, 1011.492789, 6271.38623, 7703.868164], [-86.37080225, 1019.123326, 6271.425781, 7703.861328], [1355.460769, 493.3214322, 6415.690918, 7574.328613], [1331.860186, 501.6186515, 6413.999512, 7571.950195], [1308.26001, 509.9152327, 6412.345703, 7570.599121], [1284.66041, 518.2110024, 6410.569336, 7569.654785], [1261.061466, 526.5060292, 6408.418457, 7569.810547], [1237.463267, 534.8000823, 6406.004395, 7571.101563], [1213.865909, 543.0931178, 6403.262207, 7571.279297], [1190.269421, 551.3850242, 6400.28418, 7570.168457], [1166.673857, 559.6757232, 6398.135254, 7568.70166], [1143.079235, 567.9651843, 6396.308105, 7567.148926], [1119.485489, 576.2533676, 6395.54834, 7566.314941], [1095.892594, 584.5403711, 6395.29248, 7567.384766], [1072.300447, 592.8262578, 6395.075195, 7568.207031], [1048.709003, 601.1111633, 6395.336426, 7569.635254], [1025.118178, 609.3951646, 6396.041016, 7571.472656], [1001.5279, 617.6783888, 6396.880371, 7572.236328], [977.9380908, 625.9609367, 6397.351563, 7572.326172], [954.3486788, 634.2429211, 6396.928711, 7572.547363], [930.7596081, 642.5244333, 6396.155762, 7570.214844], [907.1708245, 650.8055489, 6393.650879, 7565.734863], [883.5822775, 659.0863392, 6390.79248, 7558.557617], [859.9939173, 667.3668663, 6388.661133, 7553.509766], [836.4056983, 675.6472008, 6385.963867, 7552.124512], [812.8175709, 683.9274037, 6383.043945, 7550.852539], [789.2294889, 692.2075415, 6379.988281, 7549.31543], [765.8950401, 700.1285994, 6378.439453, 7547.262695], [742.5604822, 708.0497592, 6377.055664, 7545.812988], [719.2257107, 715.9711287, 6377.953125, 7542.975098], [695.8905969, 723.8928235, 6380.121094, 7542.089844], [672.5550329, 731.8149722, 6381.821777, 7541.497559], [649.2188805, 739.7377265, 6383.567383, 7540.148926], [625.8820243, 747.6612428, 6385.717773, 7543.824219], [602.5442879, 755.5857871, 6384.368652, 7550.497559], [579.2055444, 763.5116208, 6381.030273, 7561.837891], [555.8655248, 771.4392093, 6377.806152, 7574.919434], [532.5240595, 779.368872, 6374.919922, 7582.705078], [509.1808175, 787.3011621, 6372.971191, 7584.513184], [485.8356958, 795.2363027, 6370.575195, 7585.819824], [462.4883406, 803.1749176, 6368.795898, 7587.188477], [439.1386956, 811.1171669, 6365.910156, 7588.049805], [415.7864004, 819.0635208, 6366.334961, 7588.946777], [392.4315111, 827.0136923, 6369.066406, 7583.655273], [369.073912, 834.9676212, 6375.76709, 7583.617676], [345.713852, 842.9248356, 6383.502441, 7581.525879], [323.7022654, 850.5539021, 6264.39502, 7702.009766], [301.6906787, 858.1829687, 6265.072754, 7702.359375], [279.6790921, 865.8120352, 6265.758789, 7702.55957], [257.6675055, 873.4411018, 6266.457031, 7702.686523], [235.6559188, 881.0701684, 6267.137207, 7702.775391], [213.6443322, 888.6992349, 6267.775391, 7702.835938], [191.6327456, 896.3283015, 6268.376953, 7702.880859], [169.6211589, 903.957368, 6268.929688, 7702.915039], [147.6095723, 911.5864346, 6269.431152, 7702.935547], [125.5979857, 919.2155011, 6269.878418, 7702.947266], [103.5863991, 926.8445677, 6270.28125, 7702.955078], [81.57481242, 934.4736342, 6270.637207, 7702.958008], [59.56322579, 942.1027008, 6270.948242, 7702.950195], [37.55163916, 949.7317673, 6271.216309, 7702.948242], [15.54005253, 957.3608339, 6271.446777, 7702.941406], [-6.471534099, 964.9899005, 6271.637207, 7702.939453], [-28.48312073, 972.618967, 6271.782227, 7702.935547], [-50.49470736, 980.2480336, 6271.896484, 7702.928711], [-72.50629399, 987.8771001, 6271.969727, 7702.928711], [-94.51788062, 995.5061667, 6272.004883, 7702.928711], [1347.239539, 469.739612, 6415.621582, 7573.105469], [1323.639027, 478.0367902, 6414.161621, 7570.372559], [1300.039002, 486.3332561, 6412.633789, 7566.130859], [1276.439529, 494.6289676, 6410.791016, 7567.374512], [1252.840685, 502.9238399, 6408.653809, 7568.125977], [1229.242599, 511.2178272, 6406.279785, 7569.553223], [1205.645343, 519.5107798, 6403.507813, 7570.069824], [1182.048977, 527.8026127, 6400.800293, 7568.609375], [1158.453563, 536.0931925, 6398.894043, 7566.335938], [1134.859011, 544.3825583, 6397.049805, 7565.470215], [1111.2654, 552.6706614, 6396.512695, 7565.361328], [1087.672577, 560.9576058, 6395.844238, 7566.321777], [1064.080576, 569.2434058, 6395.512695, 7567.274902], [1040.489237, 577.5282168, 6395.393066, 7568.54834], [1016.898532, 585.8121209, 6396.126465, 7570.751953], [993.3083479, 594.0952706, 6396.392578, 7572.831055], [969.7186411, 602.3777509, 6396.424316, 7572.278809], [946.1293311, 610.6596703, 6396.321289, 7572.53125], [922.540374, 618.9410996, 6394.703125, 7572.1875], [898.9517029, 627.2221303, 6391.678223, 7568.050781], [875.3632655, 635.5028329, 6388.999023, 7555.59668], [851.7750112, 643.7832809, 6386.91748, 7551.13623], [828.1868943, 652.0635381, 6384.823242, 7549.1875], [804.5988698, 660.3436695, 6382.593262, 7547.825195], [781.0108909, 668.6237356, 6380.666504, 7545.728516], [757.6763552, 676.5446039, 6379.529297, 7543.764648], [734.3417106, 684.4655719, 6378.305176, 7542.135254], [711.0068495, 692.3867336, 6380.339355, 7539.119629], [687.6716584, 700.3081995, 6381.998047, 7538.245605], [664.3360305, 708.2300917, 6383.143555, 7537.820313], [640.9998285, 716.1525951, 6385.14209, 7536.727539], [617.6629132, 724.0758987, 6386.46875, 7538.92627], [594.3250967, 732.00028, 6387.118652, 7546.161621], [570.9862444, 739.9259735, 6383.300781, 7562.59082], [547.6461333, 747.8533655, 6379.571777, 7578.029785], [524.3045965, 755.7827679, 6377.015137, 7582.395996], [500.961344, 763.7147786, 6375.106445, 7584.724121], [477.6161775, 771.6497323, 6373.339355, 7585.549316], [454.2687641, 779.5882346, 6371.889648, 7587.558105], [430.9189932, 787.5303542, 6369.595703, 7590.088379], [407.5666331, 795.4764516, 6368.165527, 7588.737793], [384.2117229, 803.4263503, 6370.557617, 7584.45752], [360.8541353, 811.3801124, 6377.94043, 7580.319336], [337.4940018, 819.3372733, 6386.145996, 7578.538574], [315.4860538, 826.9648605, 6267.189453, 7698.494141], [293.4781058, 834.5924477, 6267.318848, 7699.142578], [271.4701578, 842.2200348, 6267.625488, 7699.701172], [249.4622099, 849.847622, 6268.055664, 7700.166992], [227.4542619, 857.4752092, 6268.54541, 7700.555664], [205.4463139, 865.1027964, 6269.047852, 7700.866211], [183.4383659, 872.7303835, 6269.529785, 7701.120117], [161.430418, 880.3579707, 6269.989746, 7701.319336], [139.42247, 887.9855579, 6270.409668, 7701.483398], [117.414522, 895.6131451, 6270.791504, 7701.608398], [95.40657405, 903.2407323, 6271.132324, 7701.706055], [73.39862608, 910.8683194, 6271.437012, 7701.78418], [51.3906781, 918.4959066, 6271.706543, 7701.84082], [29.38273013, 926.1234938, 6271.938477, 7701.882813], [7.374782152, 933.751081, 6272.13623, 7701.922852], [-14.63316582, 941.3786681, 6272.302246, 7701.948242], [-36.6411138, 949.0062553, 6272.429199, 7701.969727], [-58.64906177, 956.6338425, 6272.526855, 7701.982422], [-80.65700975, 964.2614297, 6272.592773, 7701.989258], [-102.6649577, 971.8890168, 6272.620117, 7701.992188], [1339.018269, 446.1578862, 6415.633301, 7571.017578], [1315.417916, 454.4549147, 6414.265137, 7568.674805], [1291.817971, 462.7513062, 6412.783691, 7566.779785], [1268.218603, 471.046888, 6411.013184, 7565.897949], [1244.619891, 479.341727, 6409.04541, 7566.219727], [1221.021922, 487.6355931, 6406.588379, 7569.882324], [1197.424795, 495.9284446, 6403.928711, 7571.740234], [1173.828535, 504.2201697, 6401.443848, 7568.835938], [1150.233199, 512.5106895, 6399.593262, 7566.751953], [1126.638802, 520.7999742, 6398.066406, 7565.199707], [1103.045281, 529.0879838, 6397.144043, 7564.565918], [1079.452606, 537.3748186, 6396.191895, 7564.915527], [1055.860681, 545.6605375, 6395.314453, 7566.15625], [1032.269457, 553.9452789, 6395.349121, 7567.824219], [1008.67885, 562.2291172, 6395.322266, 7569.124512], [985.0887885, 570.5121811, 6395.337891, 7570.273438], [961.4991962, 578.7945698, 6394.763184, 7571.362305], [937.9099988, 587.0763967, 6394.129883, 7571.441406], [914.3211427, 595.3577507, 6391.688965, 7572.504883], [890.7325718, 603.6387108, 6389.354492, 7571.996094], [867.1442364, 611.9193457, 6387.321289, 7561.108398], [843.556088, 620.1997183, 6385.30957, 7553.439941], [819.9680807, 628.4798973, 6383.338379, 7548.443848], [796.380164, 636.7599457, 6381.623047, 7545.131836], [772.7922929, 645.0399296, 6380.405273, 7542.518066], [749.4576828, 652.9605683, 6379.723633, 7540.604004], [726.1229647, 660.8813075, 6380.165039, 7538.717773], [702.788034, 668.8022536, 6381.92627, 7536.413086], [679.4527609, 676.7235259, 6383.350586, 7535.101563], [656.1170415, 684.6452531, 6383.943848, 7534.006348], [632.7807355, 692.5675906, 6385.80957, 7533.933105], [609.4437287, 700.490693, 6388.806641, 7535.467773], [586.1058444, 708.4148254, 6389.188477, 7541.695313], [562.7669578, 716.340249, 6385.515137, 7558.829102], [539.4268, 724.2674283, 6381.203613, 7578.958496], [516.0851983, 732.1966857, 6378.630859, 7582.240723], [492.7418256, 740.1285762, 6375.578125, 7584.928223], [469.3965771, 748.063323, 6375.012207, 7585.491211], [446.0491017, 756.0015497, 6374.213867, 7586.897949], [422.6993404, 763.9434194, 6372.885254, 7589.220703], [399.3469345, 771.8894014, 6371.602539, 7588.45752], [375.9919394, 779.8392067, 6373.878418, 7585.442871], [352.6342393, 787.7927732, 6380.44043, 7579.525879], [329.2740824, 795.7496328, 6387.138672, 7576.852539], [305.9116134, 803.7094822, 6388.888672, 7576.307617], [283.9752155, 811.3189068, 6269.397461, 7696.012695], [262.0388176, 818.9283315, 6269.367676, 7696.935547], [240.1024197, 826.5377561, 6269.604004, 7697.736328], [218.1660219, 834.1471807, 6269.94873, 7698.405273], [196.229624, 841.7566054, 6270.32373, 7698.957031], [174.2932261, 849.36603, 6270.710449, 7699.400391], [152.3568282, 856.9754546, 6271.077637, 7699.763672], [130.4204304, 864.5848792, 6271.425781, 7700.05957], [108.4840325, 872.1943039, 6271.740234, 7700.292969], [86.54763462, 879.8037285, 6272.020996, 7700.480469], [64.61123674, 887.4131531, 6272.275391, 7700.628906], [42.67483887, 895.0225778, 6272.501465, 7700.74707], [20.73844099, 902.6320024, 6272.690918, 7700.838867], [-1.197956886, 910.241427, 6272.862305, 7700.911133], [-23.13435476, 917.8508517, 6273.001953, 7700.967773], [-45.07075264, 925.4602763, 6273.11084, 7701.010742], [-67.00715051, 933.0697009, 6273.191895, 7701.037109], [-88.94354839, 940.6791255, 6273.247559, 7701.055664], [-110.8799463, 948.2885502, 6273.273438, 7701.060547], [1330.797011, 422.5760984, 6415.644531, 7569.796875], [1307.196732, 430.873084, 6414.290527, 7568.000488], [1283.596938, 439.1693592, 6412.840332, 7566.44043], [1259.997699, 447.46488, 6411.084961, 7566.169922], [1236.399087, 455.7595634, 6409.175781, 7568.097656], [1212.801233, 464.0533638, 6406.849609, 7570.447754], [1189.204208, 472.3461304, 6404.339844, 7571.846191], [1165.608071, 480.6377802, 6402.098145, 7570.255371], [1142.012886, 488.9281798, 6400.094727, 7566.474609], [1118.418561, 497.2173691, 6398.463379, 7565.497559], [1094.825174, 505.5052977, 6397.458008, 7564.019043], [1071.232575, 513.7920714, 6396.352539, 7562.991699], [1047.640796, 522.0777026, 6395.466797, 7563.378906], [1024.049676, 530.3623477, 6395.127441, 7563.996094], [1000.459192, 538.6460868, 6394.474609, 7566.211914], [976.8692244, 546.9290753, 6393.740234, 7567.539551], [953.2797342, 555.2113944, 6392.874023, 7569.458008], [929.6906406, 563.4931546, 6391.677734, 7570.082031], [906.1018981, 571.7744266, 6389.723633, 7570.995605], [882.5134416, 580.0552989, 6387.624023, 7568.433594], [858.9252178, 588.3358451, 6385.634766, 7561.190918], [835.3371772, 596.6161367, 6383.668457, 7555.575195], [811.7492738, 604.8962385, 6382.228516, 7551.158203], [788.161462, 613.1762134, 6380.882813, 7547.02002], [764.5736949, 621.4561237, 6380.605469, 7542.511719], [741.2389942, 629.3765794, 6380.276367, 7538.803223], [717.9041864, 637.2971365, 6381.454102, 7535.621094], [694.5691623, 645.2178871, 6383.180176, 7533.362305], [671.23381, 653.1389429, 6384.320313, 7532.100098], [647.8980238, 661.0604259, 6385.035156, 7532.472168], [624.5616654, 668.9825203, 6386.910645, 7532.568848], [601.2245966, 676.9054167, 6390.604004, 7533.014648], [577.8866293, 684.8293926, 6390.822754, 7536.844727], [554.5476312, 692.7546818, 6387.343262, 7562.790527], [531.207377, 700.6816742, 6382.829102, 7578.754883], [507.8657028, 708.6106799, 6378.297363, 7582.69043], [484.5223178, 716.5422986, 6375.297363, 7585.909668], [461.1770225, 724.4768641, 6376.029297, 7586.992676], [437.8294861, 732.414984, 6376.160156, 7587.688477], [414.479597, 740.3567269, 6374.418457, 7590.646973], [391.1271244, 748.3024543, 6373.18457, 7590.132813], [367.7721059, 756.2519877, 6376.312988, 7586.384277], [344.4144157, 764.2053922, 6383.384277, 7579.757324], [321.0541836, 772.1621993, 6387.38916, 7576.646484], [297.6916158, 780.121878, 6389.170898, 7572.502441], [275.7590459, 787.7297513, 6270.759766, 7692.923828], [253.826476, 795.3376247, 6270.847168, 7694.300781], [231.8939061, 802.9454981, 6271.043457, 7695.432617], [209.9613361, 810.5533715, 6271.302246, 7696.37207], [188.0287662, 818.1612449, 6271.595215, 7697.141602], [166.0961963, 825.7691183, 6271.896973, 7697.779297], [144.1636264, 833.3769916, 6272.189453, 7698.282227], [122.2310565, 840.984865, 6272.465332, 7698.694336], [100.2984865, 848.5927384, 6272.717773, 7699.026367], [78.36591661, 856.2006118, 6272.942871, 7699.292969], [56.43334669, 863.8084852, 6273.140137, 7699.506836], [34.50077678, 871.4163585, 6273.32373, 7699.678711], [12.56820686, 879.0242319, 6273.481934, 7699.81543], [-9.364363063, 886.6321053, 6273.615723, 7699.918945], [-31.29693298, 894.2399787, 6273.731934, 7700.000977], [-53.2295029, 901.8478521, 6273.817871, 7700.061523], [-75.16207282, 909.4557255, 6273.883301, 7700.103516], [-97.09464274, 917.0635988, 6273.928711, 7700.130859], [-119.0272127, 924.6714722, 6273.948242, 7700.139648], [1311.607121, 403.9801031, 6298.692871, 7683.629883], [1298.97559, 407.2912429, 6414.119141, 7568.395508], [1275.375879, 415.5874417, 6412.795898, 7567.185059], [1251.776744, 423.8828309, 6411.079102, 7567.141602], [1228.178266, 432.17748, 6409.15625, 7568.086914], [1204.580531, 440.4711583, 6406.947754, 7570.641602], [1180.983635, 448.7638229, 6404.536621, 7571.444336], [1157.387606, 457.055364, 6402.531738, 7571.233887], [1133.792499, 465.3457025, 6400.55957, 7569.258301], [1110.19833, 473.6348089, 6399.054199, 7566.870605], [1086.605035, 481.922644, 6397.726563, 7564.015625], [1063.012584, 490.2093051, 6396.151367, 7561.246094], [1039.420882, 498.4948543, 6395.15625, 7558.838379], [1015.829879, 506.7794279, 6393.912598, 7559.359863], [992.239492, 515.0631012, 6393.030273, 7561.228027], [968.6496498, 523.346001, 6391.94043, 7563.135742], [945.0602759, 531.6282267, 6390.849609, 7564.883789], [921.4712959, 539.9098925, 6389.310547, 7566.589844], [897.8826553, 548.1910872, 6387.688477, 7568.369141], [874.2943009, 556.471888, 6386.035645, 7564.300293], [850.706182, 564.7523636, 6384.034668, 7559.866211], [827.1182482, 573.0325789, 6382.338379, 7555.597656], [803.5304555, 581.3126006, 6381.361328, 7551.506836], [779.9427534, 589.5924916, 6380.565918, 7547.425293], [756.3550969, 597.8723178, 6380.48584, 7543.637207], [733.0203198, 605.7925534, 6380.780273, 7540.381836], [709.6854349, 613.7128911, 6382.644043, 7537.073242], [686.3503382, 621.6334395, 6384.391113, 7533.067383], [663.0149011, 629.5543141, 6385.67041, 7530.475586], [639.6790195, 637.4756436, 6387.049316, 7530.392578], [616.3425543, 645.3975825, 6387.560547, 7529.972656], [593.005391, 653.3202853, 6390.94873, 7531.163574], [569.6673532, 661.244019, 6390.992676, 7531.527344], [546.3283169, 669.1690479, 6388.828613, 7570.130859], [522.9880132, 677.0958362, 6383.990234, 7577.32959], [499.6462713, 685.0247064, 6377.943359, 7581.997559], [476.3027623, 692.9562126, 6376.538574, 7586.846191], [452.957384, 700.8905788, 6377.605469, 7588.816406], [429.6097818, 708.8284288, 6377.88623, 7590.558594], [406.2598994, 716.7699247, 6376.172363, 7592.001953], [382.9073781, 724.7155395, 6374.891602, 7592.900879], [359.5522729, 732.6649824, 6379.090332, 7588.962891], [336.1944673, 740.6181932, 6385.107422, 7582.958496], [312.8342098, 748.5747009, 6387.342773, 7576.864258], [289.471645, 756.5342013, 6389.374512, 7572.894531], [267.5429017, 764.140527, 6271.97998, 7690.560547], [245.6141584, 771.7468528, 6272.228516, 7691.902344], [223.6854151, 779.3531785, 6272.415527, 7693.322266], [201.7566718, 786.9595043, 6272.631348, 7694.514648], [179.8279285, 794.56583, 6272.859375, 7695.490234], [157.8991852, 802.1721558, 6273.09082, 7696.269531], [135.9704419, 809.7784816, 6273.312012, 7696.900391], [114.0416986, 817.3848073, 6273.519531, 7697.410156], [92.11295526, 824.9911331, 6273.713867, 7697.820313], [70.18421196, 832.5974588, 6273.882324, 7698.154297], [48.25546866, 840.2037846, 6274.040039, 7698.428711], [26.32672537, 847.8101103, 6274.17334, 7698.639648], [4.397982066, 855.4164361, 6274.291992, 7698.8125], [-17.53076123, 863.0227619, 6274.393066, 7698.951172], [-39.45950453, 870.6290876, 6274.481934, 7699.054688], [-61.38824783, 878.2354134, 6274.551758, 7699.131836], [-83.31699113, 885.8417391, 6274.599121, 7699.183594], [-105.2457344, 893.4480649, 6274.630371, 7699.22168], [-127.1744777, 901.0543906, 6274.649902, 7699.239258], [1299.781746, 382.035399, 6297.154785, 7681.852539], [1283.468277, 387.020464, 6297.134766, 7681.897461], [1267.154809, 392.005529, 6412.50293, 7566.583984], [1243.555805, 400.3008581, 6410.9375, 7566.138184], [1219.95743, 408.5953499, 6409.223633, 7566.530273], [1196.359811, 416.8889605, 6406.943848, 7568.931152], [1172.76302, 425.1815401, 6404.79248, 7570.357422], [1149.167114, 433.4730059, 6402.762695, 7572.475098], [1125.57216, 441.7632233, 6400.833496, 7569.591309], [1101.978063, 450.0522324, 6399.189941, 7566.885742], [1078.384904, 458.3399846, 6397.667969, 7563.01123], [1054.79253, 466.6265837, 6396.109863, 7559.206543], [1031.200974, 474.9120432, 6394.655273, 7555.011719], [1007.610078, 483.1965186, 6393.145508, 7555.240723], [984.0198144, 491.4800908, 6392.069336, 7556.174316], [960.4300676, 499.7629134, 6390.643555, 7558.411133], [936.8407976, 508.0450684, 6389.239746, 7560.293457], [913.2519225, 516.3266656, 6387.790039, 7562.623535], [889.6633993, 524.6077754, 6386.384277, 7563.014648], [866.0751602, 532.8884866, 6384.629395, 7558.104492], [842.4871539, 541.1688716, 6382.974121, 7555.353027], [818.8993307, 549.449003, 6381.788574, 7553.20166], [795.3116438, 557.7289455, 6380.850586, 7550.833984], [771.7240485, 566.0087612, 6380.632813, 7547.446777], [748.1364989, 574.2885118, 6380.792969, 7543.771973], [724.8016283, 582.2085798, 6381.752441, 7540.791016], [701.4666499, 590.1287468, 6383.755859, 7537.52832], [678.1314569, 598.0491092, 6385.51123, 7533.827637], [654.7959377, 605.969776, 6387.26416, 7531.575684], [631.4599856, 613.8908699, 6388.805176, 7529.439453], [608.1234651, 621.8125771, 6389.398438, 7528.697266], [584.786236, 629.7350872, 6390.927734, 7528.95752], [561.4481133, 637.6586779, 6389.684082, 7529.830566], [538.1089616, 645.5835837, 6390.335938, 7559.316406], [514.7685597, 653.5101937, 6384.819336, 7576.199707], [491.4267406, 661.4388188, 6378.862305, 7582.911133], [468.0832163, 669.3700589, 6377.780273, 7586.932129], [444.7377865, 677.3042506, 6379.271973, 7590.419922], [421.3901204, 685.2419995, 6379.275879, 7592.679688], [398.0401073, 693.1833762, 6378.29541, 7594.802246], [374.6875164, 701.1287402, 6378.825684, 7593.914063], [351.3323845, 709.0779151, 6382.674316, 7589.45459], [327.9745861, 717.0309638, 6385.529785, 7583.154297], [304.6142509, 724.987419, 6387.614258, 7577.224609], [281.2515849, 732.9467467, 6389.716309, 7572.709961], [257.8869768, 740.9085988, 6391.594238, 7568.483887], [236.037838, 748.4945719, 6273.675293, 7689.424805], [214.1886993, 756.080545, 6273.777832, 7691.4375], [192.3395605, 763.666518, 6273.944824, 7692.897461], [170.4904218, 771.2524911, 6274.120117, 7694.024414], [148.641283, 778.8384642, 6274.289063, 7694.924805], [126.7921443, 786.4244373, 6274.450195, 7695.642578], [104.9430055, 794.0104103, 6274.597656, 7696.224609], [83.09386679, 801.5963834, 6274.727051, 7696.692383], [61.24472804, 809.1823565, 6274.845703, 7697.078125], [39.39558929, 816.7683295, 6274.946777, 7697.393555], [17.54645054, 824.3543026, 6275.040527, 7697.644531], [-4.302688213, 831.9402757, 6275.120605, 7697.84375], [-26.15182696, 839.5262488, 6275.192383, 7698.007813], [-48.00096571, 847.1122218, 6275.25, 7698.133789], [-69.85010447, 854.6981949, 6275.30127, 7698.224609], [-91.69924322, 862.284168, 6275.331543, 7698.290039], [-113.548382, 869.870141, 6275.351563, 7698.333008], [-135.3975207, 877.4561141, 6275.368164, 7698.356445], [1289.797535, 359.2534902, 6295.627441, 7680.016602], [1271.643294, 365.0752755, 6295.594727, 7679.938477], [1253.489052, 370.8970609, 6295.537598, 7679.706055], [1235.334811, 376.7188462, 6410.76709, 7563.796387], [1211.736571, 385.0133027, 6409.173828, 7563.206055], [1188.139072, 393.3067912, 6407.138672, 7564.726074], [1164.542412, 401.5992679, 6405.128418, 7567.960449], [1140.946617, 409.890623, 6403.061035, 7569.579102], [1117.351742, 418.1807784, 6401.09082, 7569.02832], [1093.757803, 426.4697036, 6399.253418, 7567.172852], [1070.164736, 434.7573604, 6397.488281, 7562.277344], [1046.572513, 443.0438461, 6395.697266, 7558.179688], [1022.981036, 451.3292226, 6394.123047, 7553.901855], [999.3902564, 459.6136236, 6392.550781, 7552.472656], [975.8000929, 467.8971271, 6390.991699, 7552.055664], [952.2104729, 476.1798591, 6389.570313, 7554.039063], [928.6213203, 484.4619198, 6388.164063, 7555.432617], [905.0325615, 492.7434197, 6386.770996, 7556.193359], [881.4441422, 501.0244503, 6385.422363, 7554.824707], [857.8560071, 509.3050871, 6383.793945, 7552.476563], [834.2681076, 517.5854006, 6382.230469, 7550.711426], [810.6803941, 525.8654528, 6381.538574, 7549.131836], [787.0928207, 534.1453123, 6380.853516, 7547.245605], [763.5053389, 542.4250412, 6380.931152, 7545.07959], [739.9179009, 550.7047059, 6381.193359, 7543.121094], [716.5829502, 558.6245671, 6382.798828, 7540.95459], [693.2478926, 566.544529, 6384.78418, 7537.69043], [669.9126233, 574.4646998, 6386.518066, 7533.607422], [646.5770164, 582.3851958, 6388.106934, 7530.625977], [623.2409661, 590.3061477, 6389.276367, 7526.804199], [599.904334, 598.2277099, 6389.499512, 7528.417969], [576.5670086, 606.1500407, 6389.987793, 7528.910156], [553.2288105, 614.0734025, 6392.24707, 7531.504395], [529.8896188, 621.9980575, 6392.415527, 7556.630371], [506.5491625, 629.9244729, 6385.743164, 7576.382324], [483.2072718, 637.8529703, 6379.974121, 7582.147949], [459.8636197, 645.7841054, 6380.850098, 7587.066895], [436.5181013, 653.7181045, 6380.699707, 7591.466797], [413.1703665, 661.6555902, 6380.460938, 7593.580566], [389.8203563, 669.5967256, 6380.187988, 7594.531738], [366.467713, 677.5419828, 6382.028809, 7594.0625], [343.1124909, 685.49107, 6384.393066, 7591.223633], [319.7545742, 693.443928, 6386.48877, 7582.65918], [296.3942104, 701.4000818, 6388.38916, 7576.275879], [273.031544, 709.3592322, 6390.17627, 7571.588379], [249.6669134, 717.3210213, 6391.91748, 7568.125], [227.8218076, 724.9053601, 6274.799805, 7688.205078], [205.9767017, 732.4896988, 6275.074219, 7690.100586], [184.1315959, 740.0740376, 6275.256348, 7691.605469], [162.28649, 747.6583764, 6275.389648, 7692.805664], [140.4413841, 755.2427152, 6275.5, 7693.760742], [118.5962783, 762.8270539, 6275.597656, 7694.52832], [96.75117241, 770.4113927, 6275.682617, 7695.154297], [74.90606655, 777.9957315, 6275.75293, 7695.65918], [53.06096069, 785.5800702, 6275.812012, 7696.071289], [31.21585483, 793.164409, 6275.867676, 7696.416992], [9.370748971, 800.7487478, 6275.916016, 7696.696289], [-12.47435689, 808.3330866, 6275.962891, 7696.917969], [-34.31946275, 815.9174253, 6275.998047, 7697.098633], [-56.16456861, 823.5017641, 6276.030273, 7697.238281], [-78.00967447, 831.0861029, 6276.061523, 7697.345703], [-99.85478033, 838.6704417, 6276.075684, 7697.416016], [-121.6998862, 846.2547804, 6276.089844, 7697.469727], [-143.5449921, 853.8391192, 6276.097656, 7697.494141], [1280.549808, 336.1367028, 6294.138672, 7678.260742], [1261.291279, 342.4603301, 6294.087402, 7678.124023], [1242.032749, 348.7839573, 6293.979492, 7677.801758], [1222.774219, 355.1075845, 6293.818359, 7677.208984], [1203.51569, 361.4312117, 6408.810059, 7561.071777], [1179.918309, 369.7246315, 6407.399902, 7562.382813], [1156.321756, 378.0170223, 6405.444824, 7564.413574], [1132.726086, 386.3083012, 6403.396484, 7566.604004], [1109.131365, 394.5983345, 6401.032227, 7566.322266], [1085.537502, 402.8871615, 6399.29541, 7564.24707], [1061.944572, 411.1747344, 6397.320801, 7560.896484], [1038.352427, 419.4611552, 6395.337891, 7556.502441], [1014.761099, 427.7464392, 6393.649902, 7552.438477], [991.1704282, 436.030742, 6392.023926, 7548.962891], [967.5803895, 444.3141425, 6390.456543, 7549.747559], [943.9908678, 452.5967954, 6388.937012, 7550.644043], [920.401821, 460.8787816, 6387.473145, 7551.947754], [896.81317, 469.1602099, 6386.008789, 7551.929688], [873.224869, 477.4411529, 6384.627441, 7549.443848], [849.6368531, 485.7216991, 6383.379395, 7547.855469], [826.049069, 494.0019182, 6382.32666, 7547.519043], [802.4614679, 502.2818845, 6381.608887, 7546.393555], [778.8740033, 510.561662, 6381.17041, 7545.129395], [755.2866302, 518.8413127, 6381.451172, 7543.53418], [731.6993029, 527.1208999, 6381.949707, 7541.776855], [708.3642558, 535.040604, 6383.750488, 7539.450684], [685.0291019, 542.9604086, 6385.469238, 7536.630859], [661.6937334, 550.8804087, 6387.387207, 7533.862305], [638.3580398, 558.800712, 6388.933594, 7530.157715], [615.021916, 566.7214445, 6388.280762, 7525.529785], [591.6852257, 574.6427874, 6387.212402, 7527.503418], [568.3478297, 582.5649332, 6388.796875, 7529.702637], [545.009543, 590.4881605, 6391.20459, 7532.795898], [521.6702311, 598.412703, 6391.463867, 7568.695801], [498.3296718, 606.3389506, 6386.339844, 7578.013184], [474.987701, 614.2672133, 6381.848633, 7583.131836], [451.6440289, 622.1980929, 6381.680176, 7587.825195], [428.2984561, 630.1319251, 6381.428223, 7590.625977], [404.9506527, 638.0693164, 6381.219238, 7593.370117], [381.600508, 646.0103364, 6381.284668, 7593.868652], [358.2477893, 653.9553466, 6383.473633, 7591.116211], [334.8925372, 661.9041696, 6385.592285, 7586.660645], [311.5346234, 669.8568673, 6387.283691, 7581.505859], [288.1741785, 677.8129726, 6389.117676, 7575.385254], [264.8114072, 685.7719512, 6390.900879, 7572.020508], [241.4466994, 693.7334523, 6392.769043, 7569.56543], [219.6056343, 701.3161564, 6276.161621, 7687.541992], [197.7645693, 708.8988604, 6276.477539, 7689.158203], [175.9235043, 716.4815644, 6276.612793, 7690.639648], [154.0824392, 724.0642684, 6276.691406, 7691.833984], [132.2413742, 731.6469725, 6276.729492, 7692.791016], [110.4003092, 739.2296765, 6276.758301, 7693.567383], [88.55924411, 746.8123805, 6276.777344, 7694.199219], [66.71817907, 754.3950845, 6276.787598, 7694.716797], [44.87711404, 761.9777885, 6276.79248, 7695.148438], [23.036049, 769.5604926, 6276.79248, 7695.500977], [1.194983957, 777.1431966, 6276.799316, 7695.797852], [-20.64608108, 784.7259006, 6276.809082, 7696.036133], [-42.48714612, 792.3086046, 6276.812012, 7696.223633], [-64.32821116, 799.8913087, 6276.812988, 7696.378906], [-86.1692762, 807.4740127, 6276.821777, 7696.493164], [-108.0103412, 815.0567167, 6276.827637, 7696.572266], [-129.8514063, 822.6394207, 6276.828613, 7696.628906], [-151.6924713, 830.2221247, 6276.833984, 7696.658203], [1271.670336, 312.8524559, 6292.700195, 7676.634766], [1251.675774, 319.5104654, 6292.625977, 7676.482422], [1231.681211, 326.1684749, 6292.48291, 7676.15332], [1211.686648, 332.8264843, 6292.251465, 7675.638672], [1191.692085, 339.4844938, 6291.901367, 7674.981445], [1171.697522, 346.1425033, 6406.633789, 7559.25293], [1148.101101, 354.4347902, 6405.109375, 7559.757324], [1124.505545, 362.7259574, 6403.340332, 7561.023926], [1100.910906, 371.0159278, 6401.266602, 7561.763184], [1077.317201, 379.3046699, 6399.159668, 7561.145508], [1053.724367, 387.5921455, 6397.044922, 7558.644531], [1030.132375, 395.8784519, 6394.987305, 7554.854004], [1006.541128, 404.1636501, 6393.272949, 7551.418945], [982.950577, 412.4478765, 6391.63916, 7548.897949], [959.3606404, 420.7312065, 6390.094238, 7548.577148], [935.7712474, 429.0137659, 6388.631348, 7550.078613], [912.1823208, 437.2956539, 6387.191895, 7550.564453], [888.593788, 445.576984, 6385.811523, 7549.334473], [865.0055938, 453.8578459, 6384.540527, 7548.32373], [841.4176848, 462.1383139, 6383.296875, 7546.927246], [817.8300103, 470.4184586, 6382.489258, 7546.000488], [794.2425218, 478.6983429, 6381.836914, 7545.356445], [770.6551745, 486.9780346, 6381.707031, 7544.890137], [747.0679168, 495.2575966, 6381.957031, 7543.881348], [723.4807049, 503.537094, 6382.740234, 7542.177246], [700.1455738, 511.4566046, 6384.370605, 7539.685059], [676.810337, 519.3762175, 6386.145508, 7536.782227], [653.4748893, 527.2960402, 6388.131348, 7533.158691], [630.1391051, 535.2161891, 6389.666504, 7525.447266], [606.8028792, 543.1367929, 6390.231934, 7522.628418], [583.4660745, 551.0580051, 6388.156738, 7525.592773], [560.1285775, 558.9799821, 6387.65918, 7530.037598], [536.7902116, 566.9029891, 6390.130859, 7535.828613], [513.4508539, 574.8272912, 6389.192383, 7566.644043], [490.1102364, 582.7533548, 6386.592773, 7577.336914], [466.7681893, 590.6815011, 6382.998535, 7582.741211], [443.4243856, 598.6122854, 6381.985352, 7586.386719], [420.0787203, 606.5459325, 6382.212402, 7589.137207], [396.7308435, 614.4830673, 6381.97168, 7589.781738], [373.3806959, 622.4238518, 6382.82959, 7589.529297], [350.0279219, 630.368759, 6384.869141, 7587.493164], [326.672574, 638.3174971, 6386.78418, 7583.562012], [303.3145376, 646.2700069, 6388.446777, 7579.611328], [279.9540598, 654.2258146, 6390.10791, 7575.339355], [256.5912842, 662.1846159, 6391.914551, 7572.393555], [233.2265502, 670.1460551, 6393.725098, 7569.978027], [209.8600805, 678.109495, 6395.555176, 7568.289551], [188.1080219, 685.6693119, 6278.069824, 7688.34668], [166.3559632, 693.2291288, 6278.038086, 7689.955078], [144.6039046, 700.7889458, 6278.018555, 7691.103516], [122.851846, 708.3487627, 6277.978516, 7692.006836], [101.0997874, 715.9085796, 6277.931152, 7692.750977], [79.34772873, 723.4683965, 6277.874023, 7693.366211], [57.5956701, 731.0282134, 6277.825684, 7693.868164], [35.84361148, 738.5880304, 6277.770508, 7694.296875], [14.09155285, 746.1478473, 6277.719238, 7694.652344], [-7.660505781, 753.7076642, 6277.682617, 7694.948242], [-29.41256441, 761.2674811, 6277.654297, 7695.196289], [-51.16462304, 768.827298, 6277.626465, 7695.397461], [-72.91668166, 776.387115, 6277.601563, 7695.553711], [-94.66874029, 783.9469319, 6277.588867, 7695.676758], [-116.4207989, 791.5067488, 6277.580078, 7695.763672], [-138.1728575, 799.0665657, 6277.572754, 7695.820313], [-159.9249162, 806.6263826, 6277.572754, 7695.845703], [1263.001309, 289.4724988, 6291.32666, 7675.160156], [1242.481157, 296.3691804, 6291.240723, 7675.006836], [1221.961004, 303.2658621, 6291.068848, 7674.691406], [1201.440852, 310.1625437, 6290.793945, 7674.200195], [1180.9207, 317.0592253, 6290.402344, 7673.481445], [1160.400548, 323.9559069, 6289.886719, 7672.388672], [1139.880396, 330.8525885, 6404.398926, 7554.952637], [1116.284967, 339.1436775, 6402.491211, 7556.926758], [1092.690485, 347.433524, 6400.821289, 7557.217773], [1069.096858, 355.7221659, 6399.028809, 7557.66748], [1045.504163, 364.0095557, 6396.696289, 7556.045898], [1021.912252, 372.2957963, 6394.754395, 7553.231934], [998.3211554, 380.580902, 6393.180664, 7549.483887], [974.7307163, 388.8650264, 6391.612305, 7548.768066], [951.1409075, 397.1482505, 6390.057129, 7547.955566], [927.5516146, 405.4307279, 6388.542969, 7549.824707], [903.9627967, 413.7125405, 6387.101563, 7549.987793], [880.3743746, 421.9937963, 6385.722656, 7549.004883], [856.7863015, 430.2745675, 6384.641602, 7547.368164], [833.1985145, 438.5549411, 6383.584961, 7545.459473], [809.6109593, 446.8349895, 6382.875488, 7544.508789], [786.0235862, 455.1147851, 6382.152344, 7544.234375], [762.4363504, 463.394391, 6382.229492, 7544.105469], [738.8492062, 471.673872, 6382.466309, 7543.929199], [715.2621069, 479.9532881, 6383.608887, 7543.597168], [691.9268757, 487.8726587, 6385.05957, 7542.514648], [668.5915396, 495.7921285, 6387.138672, 7539.785645], [645.255989, 503.7117929, 6389.083008, 7535.819824], [621.9201151, 511.6317606, 6390.379883, 7519.816895], [598.583812, 519.5521555, 6390.987793, 7518.634277], [575.2469434, 527.4731617, 6389.769043, 7522.348633], [551.9093729, 535.39497, 6386.783691, 7530.412598], [528.5709135, 543.3178578, 6388.838379, 7536.886719], [505.2314328, 551.2420597, 6389.063477, 7557.395996], [481.8907085, 559.167965, 6386.76709, 7573.509277], [458.5485756, 567.0958853, 6384.394531, 7578.012695], [435.2047462, 575.0264216, 6382.233887, 7581.294434], [411.8590208, 582.9599095, 6382.720703, 7583.713379], [388.5110705, 590.8969575, 6382.798828, 7585.078613], [365.1607837, 598.8376332, 6384.389648, 7585.619141], [341.8079296, 606.7822991, 6386.215332, 7583.222168], [318.4525468, 614.7307769, 6387.870117, 7579.959961], [295.0945091, 622.6831294, 6389.523438, 7576.869629], [271.7339459, 630.6388875, 6391.256836, 7573.227051], [248.3710621, 638.5975181, 6393.134277, 7571.115234], [225.006246, 646.5586683, 6394.956543, 7570.492188], [201.6397925, 654.5218908, 6396.701172, 7570.091797], [179.8920033, 662.0799841, 6279.487305, 7688.71582], [158.1442141, 669.6380774, 6279.459961, 7689.738281], [136.3964249, 677.1961707, 6279.362305, 7690.623047], [114.6486357, 684.754264, 6279.240234, 7691.390625], [92.90084649, 692.3123573, 6279.103027, 7692.052734], [71.15305728, 699.8704506, 6278.975586, 7692.626953], [49.40526807, 707.4285439, 6278.856445, 7693.112305], [27.65747886, 714.9866373, 6278.745605, 7693.515625], [5.909689648, 722.5447306, 6278.642578, 7693.860352], [-15.83809956, 730.1028239, 6278.558594, 7694.15625], [-37.58588877, 737.6609172, 6278.493652, 7694.40332], [-59.33367798, 745.2190105, 6278.437988, 7694.602539], [-81.08146719, 752.7771038, 6278.391113, 7694.766602], [-102.8292564, 760.3351971, 6278.354492, 7694.890625], [-124.5770456, 767.8932904, 6278.329102, 7694.976563], [-146.3248348, 775.4513837, 6278.308594, 7695.033203], [-168.072624, 783.009477, 6278.301758, 7695.066406], [1254.166017, 266.1676295, 6290.038086, 7673.832031], [1232.954013, 273.3780709, 6289.941895, 7673.695313], [1211.742008, 280.5885124, 6289.750488, 7673.418945], [1190.530003, 287.7989539, 6289.447266, 7672.977539], [1169.317998, 295.0093953, 6289.021484, 7672.361328], [1148.105993, 302.2198368, 6288.438965, 7671.53125], [1126.893988, 309.4302782, 6287.647461, 7670.555664], [1105.681983, 316.6407197, 6286.376953, 7670.490234], [1084.469978, 323.8511611, 6400.711426, 7553.972656], [1060.876513, 332.1397163, 6398.88916, 7555.065918], [1037.283916, 340.4270069, 6396.77002, 7554.816895], [1013.69216, 348.7131311, 6395.01123, 7552.576172], [990.1011469, 356.9981481, 6393.29248, 7550.750488], [966.5108308, 365.2821953, 6391.643066, 7549.210938], [942.9211269, 373.5653459, 6390.062012, 7548.702148], [919.3319657, 381.847728, 6388.594238, 7549.896484], [895.7432708, 390.1294395, 6387.205566, 7551.45752], [872.1549688, 398.4105942, 6385.981934, 7548.016113], [848.5670073, 406.6912796, 6384.902832, 7545.779297], [824.97933, 414.9715721, 6383.945313, 7543.69873], [801.3918872, 423.2515423, 6383.238281, 7543.291992], [777.8046305, 431.5312521, 6382.721191, 7543.403809], [754.2175139, 439.8107703, 6382.712891, 7543.274414], [730.6304889, 448.0901587, 6383.10791, 7543.02832], [707.0435089, 456.3694821, 6384.360352, 7542.730469], [683.7081918, 464.2886746, 6385.777832, 7542.21582], [660.372768, 472.207968, 6388.028809, 7541.553223], [637.0371354, 480.1274684, 6390.173828, 7535.476563], [613.7011651, 488.0472939, 6391.20752, 7523.085449], [590.3647562, 495.9675735, 6391.923828, 7517.728516], [567.0277703, 503.8884624, 6390.509766, 7519.65332], [543.6900939, 511.8101161, 6387.97168, 7530.318359], [520.3515516, 519.7327989, 6387.471191, 7540.251465], [497.0120213, 527.6567729, 6389.099609, 7560.403809], [473.6712331, 535.5825046, 6387.061035, 7568.169434], [450.3290201, 543.5103172, 6384.370117, 7572.930664], [426.9850533, 551.4407667, 6382.89209, 7575.6875], [403.6392307, 559.3740772, 6383.217773, 7577.466309], [380.2912002, 567.3108753, 6383.883301, 7579.357422], [356.9409068, 575.2513222, 6385.509766, 7580.061035], [333.5879916, 583.1958908, 6387.12207, 7578.91748], [310.2325092, 591.1442894, 6388.801758, 7575.830566], [286.8743436, 599.096456, 6390.507324, 7572.90918], [263.5137429, 607.0519175, 6392.433594, 7571.643066], [240.1508504, 615.0103707, 6394.382324, 7570.694824], [216.7860043, 622.9714598, 6396.191895, 7570.29834], [193.4194278, 630.9345478, 6397.931152, 7572.601563], [171.6759123, 638.490903, 6281.065918, 7689.349609], [149.9323968, 646.0472582, 6280.959473, 7689.655273], [128.1888812, 653.6036134, 6280.736328, 7690.248047], [106.4453657, 661.1599686, 6280.49707, 7690.87207], [84.70185017, 668.7163238, 6280.275391, 7691.455078], [62.95833465, 676.2726789, 6280.060547, 7691.969727], [41.21481912, 683.8290341, 6279.876953, 7692.416016], [19.47130359, 691.3853893, 6279.703125, 7692.801758], [-2.272211937, 698.9417445, 6279.55127, 7693.128906], [-24.01572746, 706.4980997, 6279.42627, 7693.411133], [-45.75924299, 714.0544549, 6279.32373, 7693.655273], [-67.50275852, 721.61081, 6279.235352, 7693.854492], [-89.24627405, 729.1671652, 6279.162598, 7694.009766], [-110.9897896, 736.7235204, 6279.109375, 7694.134766], [-132.7333051, 744.2798756, 6279.067871, 7694.225586], [-154.4768206, 751.8362308, 6279.039063, 7694.280273], [-176.2203362, 759.392586, 6279.022949, 7694.311523], [1245.776738, 242.6604287, 6288.839355, 7672.65332], [1224.318892, 249.9822987, 6288.742188, 7672.533203], [1202.861046, 257.3041686, 6288.541504, 7672.293945], [1181.403199, 264.6260385, 6288.228027, 7671.923828], [1159.945353, 271.9479084, 6287.786621, 7671.432617], [1138.487507, 279.2697784, 6287.197266, 7670.833984], [1117.029661, 286.5916483, 6286.429199, 7670.200195], [1095.571815, 293.9135182, 6285.44043, 7669.734375], [1074.113969, 301.2353882, 6284.402832, 7669.001953], [1052.656123, 308.5572581, 6398.638184, 7552.743652], [1029.063668, 316.8444609, 6396.943359, 7552.972168], [1005.471996, 325.1305165, 6395.209961, 7552.821289], [981.8811374, 333.4154382, 6393.472656, 7551.395996], [958.2909338, 341.6993804, 6391.89502, 7550.644531], [934.7013616, 349.9824233, 6390.430664, 7549.277344], [911.1123033, 358.2647204, 6388.915039, 7549.01709], [887.523721, 366.5463529, 6387.398926, 7548.07959], [863.9355325, 374.8274293, 6386.302246, 7546.956055], [840.3476949, 383.1080213, 6385.285156, 7543.493652], [816.7601416, 391.3882175, 6384.297363, 7543.516602], [793.1728219, 399.6680875, 6383.516602, 7542.938477], [769.5856844, 407.9477048, 6383.128906, 7542.810547], [745.9986832, 416.2271343, 6383.257813, 7542.46875], [722.4117745, 424.5064369, 6383.897949, 7541.882813], [698.8249109, 432.7856762, 6385.021973, 7541.234375], [675.4894898, 440.704742, 6386.658691, 7536.238281], [652.153963, 448.6239067, 6388.791504, 7531.884766], [628.8182235, 456.5432659, 6390.874023, 7525.010742], [605.4821608, 464.4629274, 6391.955078, 7518.589844], [582.1456708, 472.3830143, 6392.57373, 7518.419434], [558.8086172, 480.3037096, 6390.567383, 7523.300781], [535.4708626, 488.2252051, 6388.252441, 7534.516113], [512.1322231, 496.1477782, 6386.634277, 7547.628418], [488.792563, 504.0716626, 6388.043945, 7557.84082], [465.4516642, 511.9972483, 6387.297363, 7564.512207], [442.1093606, 519.9248463, 6384.486816, 7568.366699], [418.7653633, 527.8550574, 6383.657227, 7571.246582], [395.4194768, 535.7882182, 6383.760254, 7572.917969], [372.0713681, 543.7249362, 6384.712402, 7574.178711], [348.7209297, 551.66528, 6386.258301, 7574.131348], [325.3679297, 559.6096122, 6387.981934, 7573.97998], [302.0124068, 567.5577533, 6389.772949, 7573.686523], [278.6542355, 575.5097673, 6391.560547, 7571.778809], [255.2935441, 583.4651839, 6393.539063, 7570.293457], [231.9305381, 591.4234693, 6395.495117, 7570.056152], [208.5656062, 599.3842704, 6397.287598, 7570.217285], [185.1990412, 607.3471401, 6399.066406, 7570.626465], [161.8308563, 615.3122327, 6400.491211, 7571.833984], [140.1874359, 622.842708, 6282.581543, 7689.287109], [118.5440155, 630.3731832, 6282.11377, 7689.84375], [96.90059514, 637.9036585, 6281.743164, 7690.405273], [75.25717476, 645.4341337, 6281.419434, 7690.922852], [53.61375439, 652.964609, 6281.132324, 7691.384766], [31.97033401, 660.4950842, 6280.874512, 7691.791016], [10.32691363, 668.0255595, 6280.646484, 7692.144531], [-11.31650674, 675.5560347, 6280.446777, 7692.448242], [-32.95992712, 683.08651, 6280.276855, 7692.711914], [-54.6033475, 690.6169852, 6280.135254, 7692.943359], [-76.24676787, 698.1474605, 6280.01709, 7693.134766], [-97.89018825, 705.6779357, 6279.923828, 7693.290039], [-119.5336086, 713.208411, 6279.846191, 7693.413086], [-141.177029, 720.7388862, 6279.796387, 7693.501953], [-162.8204494, 728.2693614, 6279.753906, 7693.558594], [-184.4638698, 735.7998367, 6279.739746, 7693.589844], [1237.271205, 219.2055933, 6287.746094, 7671.597656], [1215.451265, 226.691257, 6287.64502, 7671.501953], [1193.631325, 234.1769208, 6287.451172, 7671.297852], [1171.811385, 241.6625845, 6287.132813, 7671.00293], [1149.991445, 249.1482482, 6286.700195, 7670.608398], [1128.171505, 256.6339119, 6286.131836, 7670.155273], [1106.351564, 264.1195757, 6285.415527, 7669.6875], [1084.531624, 271.6052394, 6284.550781, 7669.25293], [1062.711684, 279.0909031, 6283.554199, 7668.818359], [1040.891744, 286.5765668, 6282.398926, 7668.500977], [1019.071804, 294.0622305, 6280.966797, 7668.714844], [997.2518637, 301.5478943, 6395.271484, 7553.530762], [973.6610917, 309.8327253, 6393.802246, 7552.782715], [950.071014, 318.1165874, 6392.415039, 7551.303711], [926.4815485, 326.3995541, 6390.950195, 7549.529785], [902.8926257, 334.681752, 6389.515137, 7547.40332], [879.3041683, 342.9632814, 6388.144531, 7547.019531], [855.7161047, 351.244253, 6386.989746, 7545.85791], [832.1283797, 359.5247563, 6385.850586, 7544.526855], [808.5409408, 367.8048676, 6384.728027, 7543.136719], [784.9537365, 376.0846556, 6383.779297, 7542.38916], [761.3667182, 384.3641842, 6383.477539, 7541.853516], [737.7798401, 392.6435212, 6383.451172, 7541.509766], [714.1930535, 400.9227275, 6384.33252, 7538.30957], [690.6063129, 409.2018702, 6385.616699, 7537.126465], [667.2708011, 417.1207713, 6387.513184, 7527.635742], [643.9351838, 425.0397748, 6389.567871, 7519.39502], [620.5993585, 432.9589862, 6391.310059, 7507.671387], [597.2631965, 440.8785209, 6392.608887, 7506.967773], [573.9265969, 448.7985086, 6392.724609, 7510.949707], [550.5894212, 456.7190999, 6390.920898, 7520.959961], [527.2515579, 464.6404523, 6388.881836, 7533.989258], [503.9128296, 472.5628299, 6387.249512, 7557.927246], [480.5731153, 480.4864978, 6386.924805, 7560.604492], [457.2321487, 488.4119215, 6387.08252, 7561.814453], [433.8897593, 496.3394231, 6384.660645, 7565.430664], [410.5456218, 504.2695579, 6383.940918, 7567.759277], [387.1996313, 512.2025509, 6384.213867, 7568.573242], [363.8514397, 520.1390257, 6385.566406, 7569.888184], [340.5009899, 528.0791473, 6386.95459, 7569.440918], [317.1479231, 536.023386, 6388.724121, 7570.575195], [293.7922952, 543.9714527, 6390.629883, 7571.791504], [270.4339909, 551.9232855, 6392.605957, 7570.970215], [247.0732575, 559.8784094, 6394.626465, 7570.631836], [223.7102382, 567.8365212, 6396.549805, 7570.149902], [200.3452711, 575.7972622, 6398.325684, 7569.433105], [176.9785792, 583.7599974, 6399.981445, 7570.009277], [153.6102979, 591.7247859, 6401.363281, 7570.470703], [131.971414, 599.2534268, 6283.908691, 7688.680664], [110.3325301, 606.7820678, 6283.397461, 7689.435547], [88.69364621, 614.3107088, 6282.935059, 7689.984375], [67.05476229, 621.8393498, 6282.521973, 7690.443359], [45.41587838, 629.3679908, 6282.158203, 7690.84668], [23.77699447, 636.8966318, 6281.838379, 7691.208008], [2.138110556, 644.4252728, 6281.557617, 7691.529297], [-19.50077336, 651.9539138, 6281.315918, 7691.808594], [-41.13965727, 659.4825548, 6281.10498, 7692.05957], [-62.77854118, 667.0111958, 6280.923828, 7692.271484], [-84.41742509, 674.5398368, 6280.77832, 7692.451172], [-106.056309, 682.0684778, 6280.663574, 7692.605469], [-127.6951929, 689.5971188, 6280.570801, 7692.723633], [-149.3340768, 697.1257598, 6280.501465, 7692.810547], [-170.9729607, 704.6544007, 6280.456055, 7692.866211], [-192.6118447, 712.1830417, 6280.43457, 7692.895508], [1228.985656, 195.6512049, 6286.759277, 7670.663086], [1207.023605, 203.2011094, 6286.661621, 7670.577148], [1185.061554, 210.751014, 6286.461914, 7670.410156], [1163.099503, 218.3009185, 6286.160156, 7670.160156], [1141.137452, 225.850823, 6285.747559, 7669.848633], [1119.175401, 233.4007275, 6285.212402, 7669.493164], [1097.21335, 240.9506321, 6284.552246, 7669.12793], [1075.251299, 248.5005366, 6283.776855, 7668.786133], [1053.289248, 256.0504411, 6282.87793, 7668.488281], [1031.327197, 263.6003456, 6281.847168, 7668.334961], [1009.365146, 271.1502502, 6280.679199, 7668.429688], [987.4030951, 278.7001547, 6279.452637, 7668.724609], [965.4410441, 286.2500592, 6394.117676, 7553.040527], [941.8510827, 294.5338145, 6392.754883, 7551.450195], [918.2617517, 302.8166696, 6391.416504, 7548.939941], [894.6729357, 311.0987798, 6390.088867, 7547.070801], [871.0845927, 319.3802262, 6388.930664, 7546.027344], [847.4966455, 327.6611167, 6387.78418, 7545.888672], [823.9090493, 335.9415227, 6386.675293, 7544.327637], [800.3217372, 344.2215329, 6385.588379, 7542.758301], [776.7346578, 352.501217, 6384.582031, 7541.343262], [753.1477625, 360.7806493, 6384.043457, 7539.560547], [729.5610026, 369.0598928, 6383.831055, 7537.45166], [705.9743362, 377.3390104, 6384.797852, 7533.12207], [682.3877149, 385.6180643, 6386.032227, 7525.887695], [659.0520963, 393.5368559, 6388.111328, 7519.839844], [635.7163721, 401.4557459, 6390.234375, 7512.112793], [612.3804362, 409.3748285, 6392.098145, 7505.826172], [589.0441779, 417.2942106, 6393.245117, 7502.918945], [565.7074934, 425.2140171, 6392.718262, 7506.702148], [542.3702462, 433.1344301, 6391.564941, 7531.10791], [519.0322999, 441.0556395, 6389.721191, 7514.27002], [495.6934706, 448.9779236, 6387.021484, 7567.92041], [472.3536255, 456.9015143, 6386.111328, 7562.124023], [449.0125417, 464.8268025, 6385.929688, 7561.014648], [425.6700579, 472.7540982, 6385.36084, 7563.751465], [402.3258851, 480.6840031, 6384.231934, 7565.372559], [378.9798259, 488.616853, 6384.609863, 7566.682129], [355.6315504, 496.5532573, 6386.354492, 7566.543457], [332.2809508, 504.4932826, 6387.790039, 7566.881836], [308.9277944, 512.4372933, 6389.696289, 7567.736328], [285.5721217, 520.3851073, 6391.602539, 7568.995605], [262.2138064, 528.3367913, 6393.654297, 7570.45752], [238.8529777, 536.2918723, 6395.715332, 7571.719238], [215.4898406, 544.2498182, 6397.548828, 7570.825684], [192.1247833, 552.210275, 6399.226563, 7570.490234], [168.7580986, 560.1727937, 6400.708496, 7570.22168], [145.3897992, 568.1375316, 6402.129395, 7570.591309], [123.7554483, 575.664327, 6285.212891, 7688.625], [102.1210973, 583.1911224, 6284.635254, 7689.220703], [80.48674636, 590.7179178, 6284.068848, 7689.648438], [58.85239541, 598.2447132, 6283.574219, 7690.018555], [37.21804445, 605.7715086, 6283.140137, 7690.353516], [15.5836935, 613.2983041, 6282.763184, 7690.666016], [-6.05065746, 620.8250995, 6282.429688, 7690.949219], [-27.68500842, 628.3518949, 6282.145508, 7691.207031], [-49.31935937, 635.8786903, 6281.900879, 7691.436523], [-70.95371033, 643.4054857, 6281.691406, 7691.634766], [-92.58806128, 650.9322811, 6281.51416, 7691.803711], [-114.2224122, 658.4590765, 6281.375977, 7691.942383], [-135.8567632, 665.9858719, 6281.26416, 7692.060547], [-157.4911141, 673.5126673, 6281.186523, 7692.145508], [-179.1254651, 681.0394627, 6281.132324, 7692.202148], [-200.7598161, 688.5662581, 6281.102051, 7692.233398], [1220.836322, 172.0353423, 6285.875, 7669.817383], [1198.868375, 179.5880133, 6285.776855, 7669.742188], [1176.900429, 187.1406844, 6285.584961, 7669.591797], [1154.932482, 194.6933554, 6285.304199, 7669.386719], [1132.964536, 202.2460265, 6284.908203, 7669.128906], [1110.996589, 209.7986976, 6284.417969, 7668.839844], [1089.028643, 217.3513686, 6283.817871, 7668.541992], [1067.060696, 224.9040397, 6283.117188, 7668.260742], [1045.092749, 232.4567108, 6282.315918, 7668.041016], [1023.124803, 240.0093818, 6281.42334, 7667.90332], [1001.156856, 247.5620529, 6280.449707, 7667.942383], [979.1889096, 255.1147239, 6279.46582, 7668.1875], [957.2209631, 262.667395, 6394.424805, 7552.957031], [933.6311304, 270.9510654, 6393.118652, 7551.683594], [910.0419101, 279.2338413, 6391.871094, 7548.931641], [886.4532304, 287.5158495, 6390.626465, 7546.143555], [862.8650172, 295.7971882, 6389.535645, 7545.682617], [839.2771968, 304.07797, 6388.483398, 7544.843262], [815.6897169, 312.3582835, 6387.42627, 7543.475586], [792.1025212, 320.638205, 6386.43457, 7541.087891], [768.515561, 328.9178042, 6385.57959, 7538.698242], [744.9287868, 337.197143, 6384.902832, 7536.525391], [721.3421547, 345.4762892, 6384.770508, 7534.387695], [697.7556132, 353.7553057, 6385.413574, 7529.609863], [674.1691169, 362.0342583, 6386.619629, 7521.896484], [650.8334048, 369.9529023, 6388.730957, 7515.047363], [627.4975871, 377.8716454, 6390.902832, 7508.434082], [604.1615606, 385.7905927, 6393.253906, 7503.943848], [580.8252003, 393.7098622, 6394.349121, 7501.172852], [557.4884013, 401.629581, 6394.005859, 7506.459961], [534.1510292, 409.5499034, 6392.484375, 7524.214844], [510.8129704, 417.470985, 6388.053711, 7527.951172], [487.4740505, 425.3930879, 6384.348633, 7571.848633], [464.1341454, 433.3164745, 6385.069336, 7567.444336], [440.7929909, 441.2416111, 6385.600098, 7560.663086], [417.4504175, 449.16882, 6385.779785, 7562.791992], [394.1060987, 457.0986572, 6384.838379, 7564.350098], [370.7599318, 465.0313478, 6385.331543, 7565.671875], [347.4115686, 472.9675165, 6387.008301, 7564.816895], [324.0609518, 480.9073282, 6388.760742, 7564.435059], [300.7077258, 488.8512522, 6391.041504, 7563.896973], [277.3519434, 496.7989985, 6392.92627, 7567.270996], [253.9934908, 504.7505041, 6394.524902, 7569.250488], [230.6326154, 512.7052962, 6396.615234, 7571.173828], [207.2694602, 520.6630713, 6398.259277, 7571.543457], [183.9043633, 528.6234719, 6399.867188, 7571.785645], [160.5375469, 536.5858599, 6401.287598, 7571.765137], [137.169147, 544.5502965, 6402.708008, 7572.065918], [113.7999021, 552.5165373, 6403.871582, 7572.305664], [92.27880786, 560.0139053, 6285.868164, 7689.182617], [70.75771364, 567.5112732, 6285.125488, 7689.369141], [49.23661941, 575.0086412, 6284.550293, 7689.617188], [27.71552519, 582.5060091, 6284.061523, 7689.881836], [6.194430973, 590.003377, 6283.632324, 7690.143555], [-15.32666325, 597.500745, 6283.262207, 7690.394531], [-36.84775747, 604.9981129, 6282.937988, 7690.630859], [-58.36885169, 612.4954808, 6282.65918, 7690.84082], [-79.88994591, 619.9928488, 6282.418945, 7691.025391], [-101.4110401, 627.4902167, 6282.224121, 7691.183594], [-122.9321344, 634.9875846, 6282.062988, 7691.31543], [-144.4532286, 642.4849526, 6281.932129, 7691.427734], [-165.9743228, 649.9823205, 6281.84375, 7691.515625], [-187.495417, 657.4796884, 6281.780762, 7691.568359], [-209.0165112, 664.9770564, 6281.749512, 7691.599609], [1212.571569, 148.4714919, 6285.077148, 7669.03418], [1190.482308, 156.0789417, 6284.986328, 7668.973633], [1168.393046, 163.6863916, 6284.8125, 7668.847656], [1146.303785, 171.2938415, 6284.54248, 7668.671875], [1124.214524, 178.9012913, 6284.182617, 7668.453125], [1102.125262, 186.5087412, 6283.730469, 7668.203125], [1080.036001, 194.1161911, 6283.183594, 7667.945313], [1057.94674, 201.723641, 6282.557129, 7667.693359], [1035.857478, 209.3310908, 6281.852539, 7667.479492], [1013.768217, 216.9385407, 6281.070313, 7667.320313], [991.6789555, 224.5459906, 6280.236328, 7667.235352], [969.5896942, 232.1534405, 6279.384766, 7667.248047], [947.5004328, 239.7608903, 6278.544434, 7667.304688], [925.4111715, 247.3683402, 6393.473633, 7551.343262], [901.8220875, 255.6510016, 6392.300293, 7549.257813], [878.2335176, 263.9329173, 6391.203613, 7547.076172], [854.6454216, 272.2141702, 6390.208496, 7545.013184], [831.0577204, 280.4948661, 6389.15332, 7543.719238], [807.4703702, 288.7750785, 6388.019531, 7541.817383], [783.8833051, 297.0548942, 6387.029297, 7538.830078], [760.2964728, 305.3343847, 6386.268066, 7536.179199], [736.7098235, 313.6136215, 6385.70459, 7534.04248], [713.1233116, 321.8926704, 6385.830078, 7531.540039], [689.5368931, 330.1715934, 6386.095215, 7527.196289], [665.9505189, 338.4504524, 6387.408203, 7520.100098], [642.6146961, 346.3689983, 6389.249023, 7512.342773], [619.2787688, 354.2876423, 6391.796387, 7507.137695], [595.9426297, 362.2064779, 6394.033691, 7503.009277], [572.6061684, 370.1256121, 6395.269043, 7499.845215], [549.2692826, 378.0451658, 6395.421875, 7499.614258], [525.9318351, 385.9653223, 6393.483887, 7535.317871], [502.5936914, 393.8862713, 6389.692383, 7541.893066], [479.2546647, 401.8082894, 6385.964844, 7573.381836], [455.9146251, 409.7316102, 6385.781738, 7565.096191], [432.5733505, 417.6566218, 6385.381836, 7560.498047], [409.2306788, 425.5836371, 6385.623535, 7562.154297], [385.886321, 433.513256, 6385.358398, 7563.421875], [362.5400816, 441.4458131, 6386.768555, 7564.253906], [339.1916316, 449.3819188, 6387.975586, 7563.893555], [315.8408613, 457.3216399, 6389.96582, 7562.746582], [292.4875408, 465.2653417, 6392.643066, 7563.366699], [269.1317094, 473.2128409, 6394.250488, 7565.393555], [245.7732415, 481.1642055, 6395.256348, 7569.420898], [222.4122664, 489.1189613, 6397.158691, 7570.899414], [199.0489886, 497.0765743, 6398.788574, 7571.872559], [175.6837968, 505.0366935, 6400.347168, 7572.162598], [152.3169833, 512.9988689, 6401.822266, 7572.430664], [128.94856, 520.9632577, 6403.213867, 7572.402344], [105.5791959, 528.9293699, 6404.344238, 7572.490723], [84.06293095, 536.4247715, 6286.696289, 7688.990234], [62.54666596, 543.920173, 6286.009277, 7689.029297], [41.03040097, 551.4155746, 6285.422852, 7689.202148], [19.51413598, 558.9109762, 6284.908691, 7689.415039], [-2.002129013, 566.4063778, 6284.447754, 7689.635742], [-23.518394, 573.9017794, 6284.043945, 7689.863281], [-45.03465899, 581.3971809, 6283.684082, 7690.077148], [-66.55092398, 588.8925825, 6283.379883, 7690.261719], [-88.06718897, 596.3879841, 6283.115723, 7690.441406], [-109.583454, 603.8833857, 6282.891113, 7690.589844], [-131.099719, 611.3787872, 6282.712891, 7690.712891], [-152.6159839, 618.8741888, 6282.574219, 7690.821289], [-174.1322489, 626.3695904, 6282.46875, 7690.90332], [-195.6485139, 633.864992, 6282.403809, 7690.962891], [-217.1647789, 641.3603935, 6282.37207, 7690.988281], [1204.323047, 124.9002667, 6284.371094, 7668.319336], [1182.128703, 132.5551207, 6284.291504, 7668.262695], [1159.934358, 140.2099746, 6284.124512, 7668.154297], [1137.740013, 147.8648286, 6283.875488, 7668.001953], [1115.545669, 155.5196825, 6283.546387, 7667.804688], [1093.351324, 163.1745365, 6283.135742, 7667.581055], [1071.15698, 170.8293904, 6282.64502, 7667.337891], [1048.962635, 178.4842444, 6282.083496, 7667.102539], [1026.76829, 186.1390983, 6281.452637, 7666.864258], [1004.573946, 193.7939523, 6280.767578, 7666.644531], [982.3796013, 201.4488062, 6280.035156, 7666.445313], [960.1852567, 209.1036602, 6279.284668, 7666.256836], [937.9909122, 216.7585141, 6278.532227, 7666.017578], [915.7965676, 224.4133681, 6277.780273, 7665.62793], [893.602223, 232.068222, 6392.72168, 7549.460449], [870.0137932, 240.3500309, 6391.69043, 7546.443359], [846.4258279, 248.6311712, 6390.705078, 7544.553711], [822.8382564, 256.9117546, 6389.681641, 7542.14502], [799.2510245, 265.1918688, 6388.630371, 7539.678223], [775.6640777, 273.471591, 6387.648438, 7536.744629], [752.0773674, 281.7509909, 6386.790527, 7533.328613], [728.4908431, 290.0301304, 6386.256836, 7532.93457], [704.9044599, 298.3090773, 6386.165527, 7530.268555], [681.3181673, 306.5878936, 6386.670898, 7525.668945], [657.7319209, 314.8666465, 6388.153809, 7519.647949], [634.3960017, 322.7850572, 6389.772949, 7513.024902], [611.0599771, 330.7035676, 6392.552734, 7507.236816], [587.7237456, 338.622284, 6395.049805, 7502.620605], [564.3871793, 346.54132, 6396.381348, 7499.094727], [541.0501772, 354.4608012, 6396.525879, 7506.696777], [517.7126019, 362.3808805, 6394.768066, 7545.196289], [494.3743419, 370.3017112, 6390.970215, 7507.18457], [471.0352217, 378.2235595, 6388.568359, 7570.607422], [447.6951192, 386.1466867, 6386.246094, 7559.663574], [424.3537702, 394.0715591, 6385.532227, 7560.274902], [401.011006, 401.9984972, 6386.146973, 7561.350586], [377.6664994, 409.9280588, 6386.384277, 7562.29834], [354.3201503, 417.8604662, 6387.523926, 7562.586914], [330.9716087, 425.7963459, 6388.849609, 7561.987793], [307.6208184, 433.7358601, 6390.837402, 7561.196289], [284.2674226, 441.6794817, 6393.301758, 7562.311035], [260.9114777, 449.626919, 6394.649902, 7564.804199], [237.5528686, 457.5781128, 6396.108887, 7567.983398], [214.1918425, 465.5325854, 6397.666016, 7570.575684], [190.8285423, 473.4900343, 6399.252441, 7571.540039], [167.4633062, 481.4501011, 6400.755371, 7571.996582], [144.0963564, 489.4121497, 6402.206543, 7572.268066], [120.7278281, 497.376241, 6403.504883, 7572.228516], [97.35845975, 505.3421309, 6404.700195, 7571.678711], [75.84702587, 512.8355706, 6287.389648, 7688.448242], [54.33559199, 520.3290103, 6286.796387, 7688.563477], [32.82415811, 527.82245, 6286.228516, 7688.729492], [11.31272423, 535.3158897, 6285.692871, 7688.926758], [-10.19870965, 542.8093293, 6285.205566, 7689.126953], [-31.71014353, 550.302769, 6284.766602, 7689.333984], [-53.22157742, 557.7962087, 6284.382813, 7689.529297], [-74.7330113, 565.2896484, 6284.049805, 7689.708008], [-96.24444518, 572.7830881, 6283.765137, 7689.871094], [-117.7558791, 580.2765278, 6283.525879, 7690.013672], [-139.2673129, 587.7699675, 6283.327148, 7690.138672], [-160.7787468, 595.2634072, 6283.175293, 7690.240234], [-182.2901807, 602.7568468, 6283.06543, 7690.320313], [-203.8016146, 610.2502865, 6282.992676, 7690.375977], [-225.3130485, 617.7437262, 6282.955078, 7690.407227], [1196.08771, 101.3230563, 6283.748047, 7667.65625], [1173.801467, 109.019329, 6283.675293, 7667.603516], [1151.515224, 116.7156018, 6283.522461, 7667.504883], [1129.228981, 124.4118745, 6283.294922, 7667.364258], [1106.942738, 132.1081473, 6282.995117, 7667.181641], [1084.656495, 139.80442, 6282.621582, 7666.97168], [1062.370251, 147.5006927, 6282.179688, 7666.737305], [1040.084008, 155.1969655, 6281.673828, 7666.487305], [1017.797765, 162.8932382, 6281.109375, 7666.226563], [995.511522, 170.5895109, 6280.501953, 7665.951172], [973.2252788, 178.2857837, 6279.851074, 7665.651367], [950.9390357, 185.9820564, 6279.182129, 7665.306641], [928.6527926, 193.6783291, 6278.507813, 7664.875], [906.3665494, 201.3746019, 6277.851563, 7664.230469], [884.0803063, 209.0708746, 6277.243164, 7663.189453], [861.7940632, 216.7671474, 6392.131348, 7545.783691], [838.206218, 225.0481961, 6391.141113, 7543.86084], [814.6187677, 233.3286889, 6390.047363, 7541.231934], [791.0316673, 241.6086963, 6388.869141, 7537.368652], [767.4448531, 249.8883079, 6387.900391, 7536.183105], [743.8582725, 258.1675933, 6387.191406, 7534.719727], [720.271874, 266.4466261, 6386.787109, 7533.655762], [696.6856139, 274.7254699, 6386.553223, 7532.404785], [673.0994462, 283.004187, 6387.166992, 7527.283203], [649.5133229, 291.2828405, 6388.399902, 7519.271973], [626.1772912, 299.2011694, 6390.540527, 7513.417969], [602.841155, 307.119595, 6393.38623, 7507.400879], [579.5048071, 315.0382093, 6395.519043, 7502.314941], [556.1681388, 322.9571203, 6397.030762, 7499.197266], [532.831046, 330.8764471, 6397.625977, 7512.904297], [509.4933935, 338.7963738, 6396.308594, 7553.527344], [486.1550458, 346.7170863, 6392.897461, 7558.001465], [462.8158178, 354.638864, 6388.51123, 7568.415527], [439.4755789, 362.5619368, 6385.603027, 7556.587891], [416.1341079, 370.4866957, 6385.662109, 7559.421387], [392.7912416, 378.4134497, 6386.915527, 7560.146973], [369.446694, 386.3428006, 6387.433105, 7560.269531], [346.1002677, 394.275084, 6388.388672, 7560.085449], [322.7516365, 402.2109084, 6389.732422, 7560.049805], [299.4006888, 410.1503434, 6391.733887, 7560.963867], [276.0471967, 418.0937495, 6393.63623, 7562.237305], [252.6911988, 426.0409494, 6395.180176, 7564.804199], [229.3325707, 433.9920049, 6396.724121, 7568.168945], [205.9714411, 441.9464469, 6398.26123, 7570.606934], [182.6080145, 449.9037395, 6399.756836, 7571.293457], [159.2426792, 457.8635316, 6401.17334, 7571.578613], [135.8757275, 465.8253732, 6402.590332, 7571.684082], [112.5071711, 473.7894226, 6403.782227, 7571.76416], [89.13767875, 481.7551885, 6404.977539, 7570.959473], [67.63107878, 489.2466478, 6288.059082, 7687.858398], [46.12447881, 496.7381071, 6287.546387, 7688.041992], [24.61787884, 504.2295663, 6286.979492, 7688.229492], [3.111278865, 511.7210256, 6286.424805, 7688.421875], [-18.3953211, 519.2124848, 6285.907227, 7688.613281], [-39.90192108, 526.7039441, 6285.442383, 7688.807617], [-61.40852105, 534.1954034, 6285.032227, 7688.988281], [-82.91512102, 541.6868626, 6284.67627, 7689.166016], [-104.421721, 549.1783219, 6284.367188, 7689.321289], [-125.928321, 556.6697811, 6284.10791, 7689.461914], [-147.4349209, 564.1612404, 6283.903809, 7689.586914], [-168.9415209, 571.6526997, 6283.739258, 7689.682617], [-190.4481209, 579.1441589, 6283.622559, 7689.764648], [-211.9547208, 586.6356182, 6283.54834, 7689.817383], [-233.4613208, 594.1270774, 6283.505859, 7689.842773], [1187.863227, 77.74092428, 6283.198242, 7667.033203], [1165.495938, 85.4736942, 6283.132324, 7666.979492], [1143.12865, 93.20646412, 6282.990723, 7666.889648], [1120.761362, 100.939234, 6282.784668, 7666.758789], [1098.394073, 108.672004, 6282.51123, 7666.587891], [1076.026785, 116.4047739, 6282.172363, 7666.380859], [1053.659497, 124.1375438, 6281.775391, 7666.145508], [1031.292208, 131.8703137, 6281.317871, 7665.881836], [1008.92492, 139.6030836, 6280.8125, 7665.588867], [986.5576319, 147.3358535, 6280.266113, 7665.268555], [964.1903436, 155.0686235, 6279.689453, 7664.898438], [941.8230553, 162.8013934, 6279.083008, 7664.466797], [919.455767, 170.5341633, 6278.469727, 7663.936523], [897.0884787, 178.2669332, 6277.87207, 7663.235352], [874.7211904, 185.9997031, 6277.297363, 7662.249023], [852.3539021, 193.7324731, 6276.750488, 7660.847656], [829.9866138, 201.465243, 6391.416504, 7543.932617], [806.3992951, 209.7456175, 6390.187988, 7541.557129], [782.8123159, 218.0255219, 6389.035156, 7539.227051], [759.2256208, 226.3050343, 6388.152832, 7537.171387], [735.6391614, 234.5842234, 6387.349121, 7535.563965], [712.0528898, 242.8631522, 6387.010742, 7534.10791], [688.4667593, 251.1418873, 6386.841309, 7532.143555], [664.8807194, 259.4204928, 6387.647461, 7528.528809], [641.2947249, 267.6990346, 6388.776855, 7521.570313], [617.9585949, 275.6172425, 6391.29248, 7514.620605], [594.6223605, 283.5355479, 6394.297852, 7508.930176], [571.2859182, 291.4540546, 6395.348145, 7502.762695], [547.9491421, 299.3728768, 6396.220703, 7498.907227], [524.6119311, 307.2921426, 6398.046875, 7497.613281], [501.2741489, 315.2120025, 6396.997559, 7552.45459], [477.9356829, 323.132612, 6394.55127, 7559.735352], [454.5963595, 331.0542324, 6389.634766, 7570.52832], [431.2560577, 338.977124, 6386.599609, 7560.556152], [407.9145094, 346.9017522, 6386.533691, 7558.354492], [384.5715487, 354.8284395, 6387.5625, 7557.666992], [361.2268505, 362.7577417, 6388.277832, 7557.738281], [337.8803116, 370.689884, 6389.274414, 7557.922363], [314.531585, 378.6254919, 6390.718262, 7558.325684], [291.1806154, 386.5647276, 6392.431641, 7559.789551], [267.8270451, 394.5080641, 6394.148926, 7562.224609], [244.4709313, 402.4552096, 6395.705566, 7565.387207], [221.1121587, 410.4061011, 6397.232422, 7568.375977], [197.7509743, 418.3602656, 6398.760254, 7570.410645], [174.3875216, 426.3173998, 6400.228516, 7571.401367], [151.0221381, 434.2771462, 6401.647461, 7570.619629], [127.6550456, 442.2388676, 6402.992676, 7571.70166], [104.2863796, 450.2026251, 6404.159668, 7571.608887], [80.91687772, 458.1681746, 6405.303223, 7571.130859], [59.41511291, 465.6576579, 6288.901855, 7687.380859], [37.9133481, 473.1471412, 6288.360352, 7687.520508], [16.41158329, 480.6366245, 6287.719238, 7687.711914], [-5.090181518, 488.1261078, 6287.102051, 7687.912109], [-26.59194633, 495.6155911, 6286.547852, 7688.102539], [-48.09371114, 503.1050744, 6286.055664, 7688.285156], [-69.59547595, 510.5945578, 6285.620605, 7688.467773], [-91.09724076, 518.0840411, 6285.244141, 7688.638672], [-112.5990056, 525.5735244, 6284.927246, 7688.789063], [-134.1007704, 533.0630077, 6284.657227, 7688.928711], [-155.6025352, 540.552491, 6284.435059, 7689.051758], [-177.1043, 548.0419743, 6284.265137, 7689.150391], [-198.6060648, 555.5314576, 6284.14209, 7689.231445], [-220.1078296, 563.0209409, 6284.060547, 7689.286133], [-241.6095944, 570.5104242, 6284.020508, 7689.314453], [1179.715307, 54.12439518, 6282.710938, 7666.452148], [1157.343538, 61.8592652, 6282.648926, 7666.40625], [1134.971768, 69.59413522, 6282.527344, 7666.320313], [1112.599999, 77.32900525, 6282.337402, 7666.188477], [1090.22823, 85.06387527, 6282.09668, 7666.017578], [1067.856461, 92.7987453, 6281.789063, 7665.814453], [1045.484691, 100.5336153, 6281.427734, 7665.574219], [1023.112922, 108.2684853, 6281.013672, 7665.293945], [1000.741153, 116.0033554, 6280.560547, 7664.980469], [978.3693834, 123.7382254, 6280.064453, 7664.62207], [955.9976141, 131.4730954, 6279.541992, 7664.21875], [933.6258447, 139.2079654, 6278.994141, 7663.741211], [911.2540754, 146.9428355, 6278.430664, 7663.178711], [888.8823061, 154.6777055, 6277.868164, 7662.513672], [866.5105368, 162.4125755, 6277.310547, 7661.710938], [844.1387675, 170.1474455, 6276.766113, 7660.825195], [821.7669982, 177.8823156, 6391.61084, 7544.858398], [798.1798006, 186.1625928, 6390.311035, 7543.545898], [774.5929539, 194.4423856, 6389.20166, 7540.402344], [751.0063924, 202.7217817, 6388.27832, 7538.295898], [727.4200645, 211.0008506, 6387.620605, 7536.363281], [703.8339188, 219.2796659, 6387.297852, 7534.57373], [680.2479114, 227.5582924, 6387.243652, 7533.103027], [656.6619965, 235.8367929, 6388.145996, 7529.796875], [633.076127, 244.1152286, 6389.295898, 7523.410156], [609.7398834, 252.0333643, 6391.57666, 7515.978516], [586.4035355, 259.9515963, 6394.841309, 7509.370605], [563.0669759, 267.8700152, 6395.181641, 7504.133789], [539.7300968, 275.7887268, 6395.14502, 7500.817383], [516.3927942, 283.7078514, 6397.010254, 7504.384766], [493.0549338, 291.6275692, 6397.5, 7557.610352], [469.7163791, 299.548069, 6395.249512, 7524.424316], [446.376947, 307.4696265, 6390.859863, 7565.188965], [423.036505, 315.3924733, 6387.90918, 7555.952148], [399.6948337, 323.3169995, 6387.892578, 7556.008301], [376.35177, 331.2435122, 6388.225586, 7556.484863], [353.0070289, 339.1726161, 6388.59375, 7555.211426], [329.6604127, 347.1046439, 6389.686035, 7555.509766], [306.3115946, 355.0402051, 6391.19873, 7557.716309], [282.9604657, 362.9793693, 6392.980469, 7560.115723], [259.6067972, 370.9224979, 6394.611816, 7562.972168], [236.2506267, 378.8694116, 6396.151367, 7565.484863], [212.8918317, 386.8201762, 6397.666992, 7568.074219], [189.5305404, 394.7743188, 6399.189941, 7569.953613], [166.1669575, 402.7313043, 6400.700195, 7570.45459], [142.801471, 410.6907827, 6402.121582, 7571.390625], [119.4343724, 418.6523029, 6403.382813, 7571.736816], [96.06567396, 426.6160242, 6404.557617, 7572.367188], [72.69604331, 434.5814564, 6405.681152, 7571.219727], [49.32564352, 442.5487377, 6406.796387, 7570.108887], [27.9536141, 450.0042404, 6289.265625, 7686.933594], [6.58158469, 457.4597431, 6288.414063, 7687.194336], [-14.79044472, 464.9152458, 6287.714844, 7687.396484], [-36.16247413, 472.3707485, 6287.119141, 7687.584961], [-57.53450355, 479.8262512, 6286.601074, 7687.766602], [-78.90653296, 487.2817539, 6286.151855, 7687.948242], [-100.2785624, 494.7372566, 6285.758301, 7688.120117], [-121.6505918, 502.1927593, 6285.425781, 7688.276367], [-143.0226212, 509.648262, 6285.151855, 7688.420898], [-164.3946506, 517.1037648, 6284.922363, 7688.541992], [-185.76668, 524.5592675, 6284.744629, 7688.643555], [-207.1387094, 532.0147702, 6284.62207, 7688.720703], [-228.5107388, 539.4702729, 6284.536621, 7688.780273], [-249.8827683, 546.9257756, 6284.494141, 7688.807617], [1171.500121, 30.53804424, 6282.285645, 7665.923828], [1149.056603, 38.30519254, 6282.236328, 7665.875], [1126.613086, 46.07234083, 6282.121582, 7665.789063], [1104.169568, 53.83948913, 6281.949707, 7665.65625], [1081.726051, 61.60663742, 6281.730469, 7665.486328], [1059.282534, 69.37378572, 6281.452148, 7665.272461], [1036.839016, 77.14093402, 6281.119629, 7665.026367], [1014.395499, 84.90808231, 6280.748535, 7664.733398], [991.9519816, 92.67523061, 6280.337891, 7664.404297], [969.5084642, 100.4423789, 6279.891602, 7664.03125], [947.0649468, 108.2095272, 6279.420898, 7663.604492], [924.6214294, 115.9766755, 6278.919434, 7663.111328], [902.1779121, 123.7438238, 6278.393555, 7662.544922], [879.7343947, 131.5109721, 6277.85791, 7661.920898], [857.2908773, 139.2781204, 6277.301758, 7661.239258], [834.8473599, 147.0452687, 6276.710449, 7660.556641], [812.4038425, 154.812417, 6276.038086, 7659.974609], [789.9603252, 162.5795653, 6390.466309, 7543.95459], [766.3735996, 170.8592493, 6389.371582, 7541.638672], [742.7871583, 179.1385386, 6388.350586, 7539.085938], [719.2009525, 187.4175055, 6387.885254, 7536.071289], [695.6149336, 195.6962102, 6387.585449, 7533.609863], [672.0290568, 203.9747231, 6387.824219, 7532.5625], [648.4432697, 212.2531054, 6388.713379, 7529.294922], [624.857529, 220.5314227, 6390.051758, 7524.037109], [601.5211861, 228.449446, 6392.01123, 7516.972168], [578.1847391, 236.3675683, 6394.072266, 7511.456055], [554.848085, 244.2858909, 6394.563477, 7507.875], [531.5110991, 252.2045272, 6395.699219, 7505.849121], [508.1736783, 260.1236022, 6396.540527, 7505.083496], [484.8356873, 268.0432647, 6397.941895, 7517.140625], [461.4970143, 275.9636692, 6395.199219, 7553.460449], [438.157485, 283.8850778, 6391.725586, 7566.935059], [414.816979, 291.807752, 6388.774902, 7560.10791], [391.4752295, 299.7321581, 6388.291992, 7553.986328], [368.1320715, 307.6586155, 6388.698242, 7554.83252], [344.7871777, 315.5876802, 6389.160156, 7555.091309], [321.440449, 323.5195764, 6390.087891, 7555.832031], [298.0915346, 331.4549297, 6391.371582, 7556.98291], [274.7403809, 339.3939032, 6393.084473, 7560.013672], [251.3866323, 347.3369688, 6394.726074, 7563.102539], [228.0303435, 355.2838368, 6396.415039, 7564.387207], [204.6714012, 363.234446, 6398.057617, 7565.984375], [181.3100522, 371.1883206, 6399.617676, 7567.204102], [157.9464397, 379.1451563, 6401.130371, 7568.810547], [134.5809008, 387.1045956, 6402.589355, 7570.530762], [111.2136577, 395.0660033, 6403.766113, 7570.580078], [87.8448448, 403.0294394, 6404.952637, 7571.11084], [64.47520031, 410.9946618, 6406.017578, 7570.895996], [41.10479003, 418.9619145, 6407.146484, 7570.186523], [19.73792162, 426.4152968, 6289.804199, 7686.595703], [-1.628946789, 433.8686791, 6288.953613, 7686.733398], [-22.9958152, 441.3220614, 6288.226563, 7686.893555], [-44.36268361, 448.7754437, 6287.606934, 7687.066406], [-65.72955202, 456.228826, 6287.075195, 7687.25], [-87.09642043, 463.6822083, 6286.608887, 7687.435547], [-108.4632888, 471.1355906, 6286.214355, 7687.610352], [-129.8301572, 478.588973, 6285.875, 7687.773438], [-151.1970257, 486.0423553, 6285.594727, 7687.923828], [-172.5638941, 493.4957376, 6285.362305, 7688.054688], [-193.9307625, 500.9491199, 6285.181641, 7688.160156], [-215.2976309, 508.4025022, 6285.056641, 7688.240234], [-236.6644993, 515.8558845, 6284.967285, 7688.299805], [-258.0313677, 523.3092668, 6284.929688, 7688.328125], [1163.352457, 6.921395659, 6281.927246, 7665.43457], [1140.904714, 14.69052458, 6281.873047, 7665.384766], [1118.456972, 22.4596535, 6281.772461, 7665.293945], [1096.009229, 30.22878242, 6281.616211, 7665.158203], [1073.561486, 37.99791134, 6281.412109, 7664.982422], [1051.113744, 45.76704026, 6281.158203, 7664.771484], [1028.666001, 53.53616918, 6280.863281, 7664.510742], [1006.218258, 61.3052981, 6280.520508, 7664.210938], [983.7705156, 69.07442702, 6280.146973, 7663.874023], [961.3227729, 76.84355594, 6279.744141, 7663.483398], [938.8750303, 84.61268486, 6279.315918, 7663.042969], [916.4272876, 92.38181379, 6278.85791, 7662.537109], [893.9795449, 100.1509427, 6278.373047, 7661.978516], [871.5318023, 107.9200716, 6277.864258, 7661.378906], [849.0840596, 115.6892005, 6277.325684, 7660.766602], [826.6363169, 123.4583295, 6276.733887, 7660.200195], [804.1885743, 131.2274584, 6276.044434, 7659.860352], [781.7408316, 138.9965873, 6390.626953, 7544.855469], [758.1542386, 147.2761512, 6389.580078, 7541.652832], [734.5679298, 155.5553184, 6388.513184, 7538.379883], [710.9818556, 163.8341585, 6388.213867, 7535.542969], [687.3959636, 172.1127449, 6387.872559, 7533.410156], [663.8102099, 180.3911415, 6388.476074, 7531.855957], [640.2245476, 188.6694113, 6389.277344, 7529.799805], [616.638931, 196.9476167, 6390.487793, 7525.019043], [593.3024756, 204.8655802, 6392.487793, 7520.220215], [569.965915, 212.7836376, 6394.354492, 7514.223633], [546.6291446, 220.7018801, 6396.003418, 7510.938965], [523.2920548, 228.6204125, 6396.733398, 7509.857422], [499.9545424, 236.539354, 6396.955566, 7512.899414], [476.6164732, 244.4588839, 6397.399902, 7550.028809], [453.2777115, 252.3791901, 6395.331543, 7564.500488], [429.9380744, 260.3005482, 6392.277832, 7566.783691], [406.5974292, 268.223189, 6390.232422, 7558.11084], [383.2555567, 276.1474997, 6388.476563, 7553.093262], [359.9122947, 284.0737912, 6388.966797, 7554.276367], [336.567358, 292.0026652, 6389.438477, 7555.391113], [313.2205492, 299.9344556, 6389.791992, 7556.101074], [289.8715423, 307.8697717, 6391.361328, 7557.480957], [266.5202284, 315.8086831, 6393.117676, 7559.241699], [243.1663786, 323.7515514, 6394.752441, 7561.919434], [219.8100327, 331.6981971, 6396.529785, 7562.183594], [196.451066, 339.6486862, 6398.316406, 7561.978516], [173.0896074, 347.6025455, 6399.887695, 7563.702148], [149.7258618, 355.5592401, 6401.456543, 7565.716797], [126.3602161, 363.51842, 6402.918457, 7567.937012], [102.9929625, 371.479635, 6404.170898, 7569.478516], [79.62411338, 379.4430444, 6405.313477, 7570.066895], [56.25433491, 387.4081571, 6406.294922, 7569.640625], [32.88379111, 395.3751133, 6407.369141, 7570.050781], [11.5220934, 402.8263737, 6290.157715, 7686.216797], [-9.839604311, 410.2776342, 6289.339844, 7686.250977], [-31.20130202, 417.7288946, 6288.626465, 7686.368164], [-52.56299973, 425.180155, 6288.006836, 7686.535156], [-73.92469745, 432.6314155, 6287.466797, 7686.726563], [-95.28639516, 440.0826759, 6287.006836, 7686.925781], [-116.6480929, 447.5339364, 6286.60791, 7687.116211], [-138.0097906, 454.9851968, 6286.266602, 7687.289063], [-159.3714883, 462.4364572, 6285.983887, 7687.448242], [-180.733186, 469.8877177, 6285.758301, 7687.588867], [-202.0948837, 477.3389781, 6285.57666, 7687.702148], [-223.4565814, 484.7902385, 6285.445313, 7687.787109], [-244.8182791, 492.241499, 6285.363281, 7687.845703], [-266.1799769, 499.6927594, 6285.322266, 7687.876953], [1155.145084, -16.66849844, 6281.615723, 7664.988281], [1132.633406, -8.870634415, 6281.564453, 7664.938477], [1110.121728, -1.072770388, 6281.467773, 7664.844727], [1087.610051, 6.725093639, 6281.327637, 7664.705078], [1065.098373, 14.52295767, 6281.136719, 7664.521484], [1042.586696, 22.3208217, 6280.911621, 7664.297852], [1020.075018, 30.11868572, 6280.637695, 7664.038086], [997.5633405, 37.91654975, 6280.331543, 7663.728516], [975.0516629, 45.71441378, 6279.992676, 7663.376953], [952.5399853, 53.5122778, 6279.626953, 7662.983398], [930.0283078, 61.31014183, 6279.239258, 7662.52832], [907.5166302, 69.10800586, 6278.819336, 7662.019531], [885.0049526, 76.90586989, 6278.375977, 7661.451172], [862.4932751, 84.70373391, 6277.902344, 7660.848633], [839.9815975, 92.50159794, 6277.39209, 7660.231445], [817.4699199, 100.299462, 6276.834961, 7659.609375], [794.9582423, 108.097326, 6276.199707, 7658.999023], [772.4465648, 115.89519, 6275.453125, 7658.277344], [749.9348872, 123.6930541, 6389.733887, 7541.185547], [726.3486995, 131.9721087, 6388.969727, 7538.224121], [702.7627464, 140.2508401, 6388.754883, 7535.04541], [679.1769803, 148.5293091, 6388.535645, 7533.111816], [655.5913553, 156.8075846, 6389.067871, 7531.223633], [632.0058218, 165.0857304, 6389.822266, 7529.526367], [608.420333, 173.3638108, 6391.191406, 7526.267578], [585.0837793, 181.2816714, 6392.788086, 7522.484863], [561.7471214, 189.1996278, 6394.512207, 7517.117676], [538.4102567, 197.1177816, 6396.210449, 7513.959961], [515.0730609, 205.0362443, 6396.77832, 7513.138184], [491.7354313, 212.955142, 6397.46875, 7518.166992], [468.3972323, 220.8746251, 6396.845215, 7541.675781], [445.0583534, 228.7948465, 6395.492188, 7555.880859], [421.7186199, 236.7160654, 6392.208984, 7566.589844], [398.3779109, 244.6385421, 6389.241211, 7551.704102], [375.0359621, 252.5627413, 6388.383789, 7552.090332], [351.6926047, 260.488985, 6389.016113, 7553.963379], [328.3475154, 268.4178285, 6389.647461, 7555.445313], [305.0005932, 276.3494959, 6389.905273, 7556.673828], [281.6514889, 284.2846127, 6390.976074, 7557.350586], [258.3001502, 292.2233429, 6393.015625, 7557.67041], [234.9462194, 300.1661587, 6394.681152, 7558.331543], [211.5897528, 308.1127682, 6396.710449, 7558.679199], [188.2306369, 316.0631085, 6398.53125, 7558.491699], [164.8691182, 324.0167075, 6400.144531, 7559.836914], [141.5053398, 331.97326, 6401.712891, 7561.61377], [118.1396387, 339.9324112, 6403.067871, 7565.228516], [94.77223681, 347.8935223, 6404.340332, 7567.800781], [71.40326896, 355.8566552, 6405.538574, 7568.862305], [48.03347189, 363.8215667, 6406.583984, 7569.643066], [24.66291283, 371.7885018, 6407.458008, 7569.869141], [3.306377776, 379.2376277, 6290.387695, 7685.706055], [-18.05015728, 386.6867537, 6289.615723, 7685.663086], [-39.40669234, 394.1358796, 6288.924805, 7685.788086], [-60.76322739, 401.5850055, 6288.318359, 7685.984375], [-82.11976245, 409.0341314, 6287.790039, 7686.202148], [-103.4762975, 416.4832574, 6287.331543, 7686.419922], [-124.8328326, 423.9323833, 6286.939941, 7686.628906], [-146.1893676, 431.3815092, 6286.604492, 7686.822266], [-167.5459027, 438.8306351, 6286.328613, 7686.998047], [-188.9024377, 446.279761, 6286.102051, 7687.149414], [-210.2589728, 453.728887, 6285.923828, 7687.266602], [-231.6155078, 461.1780129, 6285.792969, 7687.363281], [-252.9720429, 468.6271388, 6285.711914, 7687.418945], [-274.3285779, 476.0762647, 6285.669434, 7687.455078], [1146.997649, -40.28525554, 6281.345215, 7664.581055], [1124.481976, -32.48551939, 6281.29834, 7664.52832], [1101.966303, -24.68578325, 6281.217773, 7664.431641], [1079.45063, -16.88604711, 6281.082031, 7664.295898], [1056.934957, -9.086310966, 6280.907715, 7664.105469], [1034.419284, -1.286574823, 6280.697266, 7663.879883], [1011.903611, 6.513161319, 6280.452148, 7663.605469], [989.3879375, 14.31289746, 6280.172852, 7663.288086], [966.8722643, 22.1126336, 6279.868652, 7662.932617], [944.3565912, 29.91236975, 6279.534668, 7662.522461], [921.840918, 37.71210589, 6279.177734, 7662.060547], [899.3252449, 45.51184203, 6278.802246, 7661.537109], [876.8095718, 53.31157817, 6278.393555, 7660.966797], [854.2938986, 61.11131432, 6277.972656, 7660.341797], [831.7782255, 68.91105046, 6277.516113, 7659.685547], [809.2625523, 76.7107866, 6277.019043, 7658.992188], [786.7468792, 84.51052274, 6276.466797, 7658.267578], [764.231206, 92.31025889, 6275.799805, 7657.493164], [741.7155329, 100.109995, 6390.017578, 7541.668945], [718.1294768, 108.3889209, 6389.501465, 7538.662109], [694.5436534, 116.6675188, 6389.245605, 7535.421387], [670.9580132, 124.9458629, 6389.305664, 7532.91748], [647.3725112, 133.2240164, 6389.607422, 7530.98584], [623.7871007, 141.5020429, 6390.339844, 7529.585938], [600.201735, 149.7800049, 6391.417969, 7527.120117], [576.8650697, 157.6978094, 6392.756348, 7523.839844], [553.5283002, 165.6157076, 6394.537598, 7520.099121], [530.191321, 173.5337898, 6396.043945, 7516.814941], [506.8540233, 181.4521582, 6396.314453, 7517.158203], [483.516304, 189.3709309, 6396.799805, 7521.745117], [460.1780287, 197.2902882, 6396.075684, 7530.597656], [436.839062, 205.2104161, 6394.799805, 7544.171875], [413.4992208, 213.1315892, 6391.99707, 7565.088867], [390.1583735, 221.0540383, 6388.472656, 7556.359863], [366.8163016, 228.9781516, 6388.18457, 7551.381836], [343.4728422, 236.904238, 6388.706543, 7553.334473], [320.12771, 244.8328994, 6389.446289, 7555.183105], [296.7807086, 252.7644694, 6389.921387, 7556.372559], [273.4315128, 260.6995585, 6390.962402, 7556.57959], [250.080012, 268.6382335, 6392.755371, 7556.46582], [226.7259801, 276.5808595, 6394.76123, 7556.706055], [203.3694544, 284.5272554, 6396.926758, 7556.20752], [180.0103117, 292.477486, 6398.762207, 7556.150391], [156.648681, 300.4310802, 6400.425781, 7557.295898], [133.2847667, 308.3875021, 6401.96582, 7559.367188], [109.9189555, 316.3464016, 6403.222656, 7562.524902], [86.55153972, 324.3073276, 6404.486328, 7565.931152], [63.18253087, 332.2704414, 6405.63623, 7567.319824], [39.81259599, 340.2352527, 6406.728027, 7568.627441], [16.44189866, 348.2018999, 6407.526367, 7568.983887], [-4.909464685, 355.6488907, 6290.567383, 7684.825195], [-26.26082803, 363.0958814, 6289.803223, 7684.90625], [-47.61219137, 370.5428722, 6289.128418, 7685.129883], [-68.96355471, 377.989863, 6288.549805, 7685.398438], [-90.31491805, 385.4368538, 6288.035645, 7685.670898], [-111.6662814, 392.8838445, 6287.595703, 7685.925781], [-133.0176447, 400.3308353, 6287.214355, 7686.166016], [-154.3690081, 407.7778261, 6286.887207, 7686.375977], [-175.7203714, 415.2248168, 6286.617188, 7686.572266], [-197.0717347, 422.6718076, 6286.402832, 7686.734375], [-218.4230981, 430.1187984, 6286.22998, 7686.865234], [-239.7744614, 437.5657891, 6286.098145, 7686.962891], [-261.1258248, 445.0127799, 6286.012207, 7687.02832], [-282.4771881, 452.4597707, 6285.975098, 7687.060547], [1138.796903, -63.87815266, 6281.118652, 7664.206055], [1116.223921, -56.05268443, 6281.075195, 7664.163086], [1093.65094, -48.2272162, 6280.996094, 7664.067383], [1071.077958, -40.40174798, 6280.87793, 7663.923828], [1048.504976, -32.57627975, 6280.71875, 7663.736328], [1025.931995, -24.75081152, 6280.525391, 7663.504883], [1003.359013, -16.9253433, 6280.29834, 7663.227539], [980.7860318, -9.09987507, 6280.046387, 7662.90625], [958.2130502, -1.274406843, 6279.767578, 7662.536133], [935.6400687, 6.551061383, 6279.466309, 7662.114258], [913.0670871, 14.37652961, 6279.145996, 7661.637695], [890.4941056, 22.20199784, 6278.800781, 7661.106445], [867.921124, 30.02746606, 6278.444824, 7660.518555], [845.3481425, 37.85293429, 6278.070801, 7659.870117], [822.7751609, 45.67840252, 6277.672852, 7659.175781], [800.2021794, 53.50387075, 6277.266113, 7658.415039], [777.6291978, 61.32933897, 6276.846191, 7657.573242], [755.0562163, 69.1548072, 6276.413086, 7656.606445], [732.4832347, 76.98027543, 6275.991211, 7655.4375], [709.9102532, 84.80574365, 6390.57959, 7538.87207], [686.3245509, 93.0842261, 6391.075195, 7535.850586], [662.7390356, 101.3624463, 6390.705078, 7532.98291], [639.1536604, 109.6404729, 6390.697754, 7531.539063], [615.5683759, 117.9183679, 6390.851563, 7530.38623], [591.983137, 126.1961989, 6391.556641, 7528.344727], [568.6463762, 134.1139035, 6392.730957, 7525.940918], [545.3095115, 142.0317054, 6394.102051, 7523.013672], [521.9724407, 149.9497047, 6395.313477, 7520.507813], [498.635039, 157.868011, 6395.756348, 7521.794434], [475.2972043, 165.7867475, 6395.777832, 7525.572754], [451.9588022, 173.7060638, 6395.044922, 7532.016602], [428.6197192, 181.6261096, 6393.731934, 7548.281738], [405.2797845, 189.5471483, 6391.370605, 7563.601563], [381.9388742, 197.4694391, 6388.334473, 7557.090332], [358.5967261, 205.3934484, 6388.5, 7551.396484], [335.2531722, 213.3194948, 6388.314941, 7553.103516], [311.9078884, 221.2481333, 6389.168945, 7554.555664], [288.5607745, 229.1795889, 6389.858887, 7555.723145], [265.2114814, 237.1144863, 6391.35498, 7555.757324], [241.8599558, 245.0529886, 6392.637207, 7555.331543], [218.5058409, 252.9955689, 6394.930664, 7555.521973], [195.1491936, 260.9419361, 6397.056152, 7555.271484], [171.7899003, 268.8920294, 6398.978027, 7555.318359], [148.4282071, 276.8453728, 6400.684082, 7554.493652], [125.0642575, 284.8016621, 6402.148926, 7557.613281], [101.6983876, 292.7605416, 6403.40918, 7561.671387], [78.33081976, 300.7213723, 6404.634277, 7563.830566], [54.96168883, 308.6842181, 6405.763184, 7565.340332], [31.59173059, 316.6488377, 6406.831055, 7566.191895], [8.221013222, 324.6154735, 6407.55957, 7567.179688], [-13.12518699, 332.0603174, 6290.680664, 7683.560547], [-34.47138719, 339.5051613, 6289.900879, 7683.998047], [-55.8175874, 346.9500052, 6289.247559, 7684.416992], [-77.16378761, 354.3948491, 6288.69043, 7684.799805], [-98.50998782, 361.839693, 6288.208008, 7685.143555], [-119.856188, 369.284537, 6287.791992, 7685.450195], [-141.2023882, 376.7293809, 6287.430664, 7685.725586], [-162.5485884, 384.1742248, 6287.124512, 7685.963867], [-183.8947886, 391.6190687, 6286.864258, 7686.172852], [-205.2409889, 399.0639126, 6286.651855, 7686.351563], [-226.5871891, 406.5087566, 6286.484863, 7686.492188], [-247.9333893, 413.9536005, 6286.362793, 7686.594727], [-269.2795895, 421.3984444, 6286.27832, 7686.664063], [-290.6257897, 428.8432883, 6286.237305, 7686.693359], [1130.601637, -87.47352729, 6280.925781, 7663.889648], [1107.976829, -79.6248045, 6280.891113, 7663.839844], [1085.35202, -71.7760817, 6280.816895, 7663.744141], [1062.727211, -63.9273589, 6280.705078, 7663.601563], [1040.102403, -56.0786361, 6280.560059, 7663.415039], [1017.477594, -48.22991331, 6280.38623, 7663.172852], [994.8527857, -40.38119051, 6280.17627, 7662.892578], [972.2279771, -32.53246771, 6279.943359, 7662.560547], [949.6031685, -24.68374491, 6279.687988, 7662.185547], [926.9783599, -16.83502212, 6279.411133, 7661.751953], [904.3535513, -8.986299319, 6279.122559, 7661.267578], [881.7287428, -1.137576521, 6278.81543, 7660.717773], [859.1039342, 6.711146276, 6278.502441, 7660.12207], [836.4791256, 14.55986907, 6278.180176, 7659.453125], [813.854317, 22.40859187, 6277.856934, 7658.724609], [791.2295084, 30.25731467, 6277.535645, 7657.913086], [768.6046999, 38.10603747, 6277.241699, 7656.991211], [745.9798913, 45.95476026, 6277.011719, 7655.911133], [723.3550827, 53.80348306, 6276.933105, 7654.591797], [700.7302741, 61.65220586, 6277.267578, 7652.866211], [678.1054655, 69.50092866, 6392.976563, 7536.249023], [654.5200742, 77.77901819, 6392.476563, 7532.668457], [630.9348192, 86.05691603, 6392.13623, 7530.908691], [607.3496567, 94.33468608, 6391.276367, 7531.652832], [583.764539, 102.612393, 6391.992676, 7530.681641], [560.4276695, 110.5300472, 6392.694824, 7528.475586], [537.0906969, 118.4477947, 6393.752441, 7526.271973], [513.7535146, 126.3657225, 6394.446289, 7525.153809], [490.4160137, 134.2839344, 6395.021973, 7523.963379], [467.0780913, 142.2025488, 6394.916504, 7530.070801], [443.7396148, 150.1217431, 6394.276367, 7533.600098], [420.4004478, 158.0417021, 6392.989746, 7537.054199], [397.0604063, 165.9627026, 6390.331055, 7563.666992], [373.7193606, 173.8849724, 6388.592773, 7548.428223], [350.3770923, 181.8089007, 6387.772461, 7551.356934], [327.0334364, 189.7347945, 6387.739746, 7552.400879], [303.6881106, 197.6632575, 6389.053711, 7553.146484], [280.3409176, 205.5946216, 6389.882324, 7554.008789], [256.991532, 213.529499, 6390.967773, 7554.831543], [233.6398442, 221.4679555, 6392.101074, 7554.94043], [210.2856274, 229.4103555, 6394.838867, 7555.668457], [186.9289204, 237.3565177, 6397.266113, 7556.23291], [163.5695985, 245.306508, 6399.248535, 7555.834473], [140.2077918, 253.2598543, 6400.95459, 7556.371582], [116.8437034, 261.2160215, 6402.344727, 7557.673828], [93.47772105, 269.1746587, 6403.594238, 7560.73291], [70.11013603, 277.1353159, 6404.782715, 7562.911621], [46.7409598, 285.0981531, 6405.925293, 7562.622559], [23.37085994, 293.0626812, 6406.864746, 7564.70166], [-1.862645149e-9, 301.0290384, 6407.602539, 7564.993652], [-21.34102856, 308.4717361, 6290.667969, 7682.264648], [-42.68205711, 315.9144337, 6289.876465, 7683.124023], [-64.02308567, 323.3571313, 6289.267578, 7683.739258], [-85.36411422, 330.799829, 6288.757813, 7684.231445], [-106.7051428, 338.2425266, 6288.313965, 7684.648438], [-128.0461713, 345.6852243, 6287.927734, 7685.008789], [-149.3871999, 353.1279219, 6287.591797, 7685.314453], [-170.7282284, 360.5706196, 6287.304199, 7685.583008], [-192.069257, 368.0133172, 6287.059082, 7685.814453], [-213.4102856, 375.4560148, 6286.859863, 7686.001953], [-234.7513141, 382.8987125, 6286.700684, 7686.15332], [-256.0923427, 390.3414101, 6286.580566, 7686.266602], [-277.4333712, 397.7841078, 6286.503418, 7686.332031], [-298.7743998, 405.2268054, 6286.464355, 7686.366211], [1122.454596, -111.0904728, 6280.771484, 7663.614258], [1099.826185, -103.2400662, 6280.73877, 7663.5625], [1077.197773, -95.3896597, 6280.666992, 7663.467773], [1054.569362, -87.53925316, 6280.570313, 7663.324219], [1031.940951, -79.68884663, 6280.435059, 7663.129883], [1009.312539, -71.8384401, 6280.27002, 7662.891602], [986.6841281, -63.98803356, 6280.078613, 7662.605469], [964.0557168, -56.13762703, 6279.862305, 7662.266602], [941.4273055, -48.28722049, 6279.625488, 7661.875977], [918.7988941, -40.43681396, 6279.373535, 7661.436523], [896.1704828, -32.58640742, 6279.11377, 7660.939453], [873.5420715, -24.73600089, 6278.844238, 7660.393555], [850.9136602, -16.88559436, 6278.567871, 7659.776367], [828.2852489, -9.035187822, 6278.290527, 7659.109375], [805.6568376, -1.184781288, 6278.023926, 7658.358398], [783.0284262, 6.665625246, 6277.774902, 7657.516602], [760.4000149, 14.51603178, 6277.569336, 7656.5625], [737.7716036, 22.36643832, 6277.448242, 7655.464844], [715.1431923, 30.21684485, 6277.46875, 7654.15625], [692.514781, 38.06725138, 6277.721191, 7652.5625], [669.8863697, 45.91765792, 6392.625, 7536.295898], [646.3011013, 54.19561775, 6392.868652, 7534.391113], [622.7159722, 62.47338303, 6392.800293, 7533.695313], [599.1309337, 70.75101671, 6392.401855, 7534.456055], [575.545941, 79.02858704, 6392.285645, 7533.362305], [552.2089799, 86.94614421, 6392.640625, 7530.022461], [528.8719148, 94.86379634, 6393.554688, 7531.688477], [505.5346438, 102.7816421, 6394.023926, 7530.875977], [482.1970418, 110.6997911, 6394.413574, 7531.403809], [458.8590078, 118.6183692, 6393.977051, 7532.714355], [435.5204064, 126.5375244, 6393.578613, 7535.375], [412.1811259, 134.4574081, 6392.209473, 7543.501465], [388.8409939, 142.3782789, 6390.05127, 7561.76123], [365.4998881, 150.3003952, 6388.478516, 7548.047363], [342.1575454, 158.2242224, 6387.122559, 7547.359375], [318.813797, 166.1500809, 6387.413574, 7550.14502], [295.4683205, 174.0785257, 6388.789063, 7551.29834], [272.1210149, 182.009782, 6389.995117, 7551.925293], [248.771532, 189.9444735, 6391.246094, 7553.052734], [225.4198185, 197.882765, 6392.683594, 7553.976074], [202.0655187, 205.8251288, 6395.066895, 7555.395508], [178.7086897, 213.7712719, 6397.461914, 7556.415039], [155.3492157, 221.7211325, 6399.403809, 7556.891602], [131.9873441, 229.6742365, 6401.210938, 7557.363281], [108.6232181, 237.6302798, 6402.547363, 7558.016602], [85.25717417, 245.5889056, 6403.8125, 7559.968262], [61.88943418, 253.5494788, 6404.895508, 7562.007813], [38.52013254, 261.5120576, 6406.059082, 7563.044434], [15.1500055, 269.4764035, 6406.897949, 7563.780762], [-6.313049017, 276.9498079, 6290.849609, 7680.547852], [-27.77610353, 284.4232123, 6290.246582, 7681.641602], [-49.23915805, 291.8966167, 6289.68457, 7682.503906], [-70.70221257, 299.3700211, 6289.188965, 7683.186523], [-92.16526709, 306.8434255, 6288.750488, 7683.739258], [-113.6283216, 314.3168299, 6288.365723, 7684.212891], [-135.0913761, 321.7902343, 6288.015137, 7684.612305], [-156.5544306, 329.2636387, 6287.712891, 7684.949219], [-178.0174852, 336.7370431, 6287.442383, 7685.240234], [-199.4805397, 344.2104475, 6287.217285, 7685.493164], [-220.9435942, 351.6838519, 6287.029785, 7685.696289], [-242.4066487, 359.1572562, 6286.880371, 7685.855469], [-263.8697032, 366.6306606, 6286.763184, 7685.970703], [-285.3327577, 374.104065, 6286.688477, 7686.044922], [-306.7958123, 381.5774694, 6286.648926, 7686.078125], [1114.264231, -134.6880671, 6280.652344, 7663.394531], [1091.588894, -126.8166257, 6280.614258, 7663.344727], [1068.913556, -118.9451843, 6280.555176, 7663.240234], [1046.238219, -111.073743, 6280.458984, 7663.09082], [1023.562882, -103.2023016, 6280.331055, 7662.899414], [1000.887544, -95.33086017, 6280.179199, 7662.651367], [978.2122066, -87.45941878, 6280.000488, 7662.355469], [955.5368692, -79.5879774, 6279.798828, 7662.016602], [932.8615317, -71.71653601, 6279.580078, 7661.625], [910.1861942, -63.84509462, 6279.352539, 7661.175781], [887.5108568, -55.97365323, 6279.115723, 7660.671875], [864.8355193, -48.10221184, 6278.869141, 7660.114258], [842.1601819, -40.23077045, 6278.626953, 7659.50293], [819.4848444, -32.35932906, 6278.396484, 7658.823242], [796.8095069, -24.48788767, 6278.167969, 7658.075195], [774.1341695, -16.61644628, 6277.981445, 7657.229492], [751.458832, -8.745004893, 6277.825195, 7656.28418], [728.7834945, -0.8735635048, 6277.748047, 7655.220703], [706.1081571, 6.997877885, 6277.768066, 7654.004883], [683.4328196, 14.86931927, 6277.899414, 7652.579102], [660.7574822, 22.74076066, 6278.080566, 7650.831055], [638.0821447, 30.61220205, 6392.241211, 7534.231934], [614.4971339, 38.88983477, 6392.046875, 7534.429688], [590.9122165, 47.16734065, 6392.269043, 7536.100098], [567.327343, 55.44478109, 6392.56543, 7536.945313], [543.9902769, 63.36228505, 6392.924805, 7537.566895], [520.653107, 71.27988092, 6393.299316, 7537.569824], [497.3157282, 79.19765799, 6393.786133, 7538.285645], [473.9780318, 87.11571639, 6394.007813, 7537.21875], [450.6399139, 95.03417343, 6393.80957, 7536.657227], [427.3012409, 102.9532074, 6393.281738, 7535.812012], [403.9618784, 110.8730025, 6391.806641, 7548.409668], [380.6216424, 118.7938342, 6389.989746, 7557.847656], [357.2804031, 126.7159314, 6388.578125, 7550.441895], [333.9379403, 134.6396813, 6387.256348, 7544.716797], [310.5940927, 142.565393, 6388.346191, 7547.844238], [287.2485752, 150.4936671, 6389.529297, 7549.007813], [263.9011914, 158.4248376, 6390.171387, 7550.284668], [240.551617, 166.3595157, 6391.446777, 7551.359375], [217.1997423, 174.2977672, 6393.361328, 7552.581543], [193.8453404, 182.2399564, 6395.533691, 7554.735352], [170.4884485, 190.1859022, 6397.717773, 7555.605469], [147.1289449, 198.1356693, 6399.657715, 7557.291016], [123.7669574, 206.0887867, 6401.340332, 7557.643555], [100.4026907, 214.0447174, 6402.705566, 7558.76123], [77.03653193, 222.0031114, 6403.966309, 7560.383789], [53.66877095, 229.9635177, 6405.02002, 7562.560547], [31.99815561, 237.4895581, 6289.73291, 7678.72168], [10.32754027, 245.0155985, 6290.11377, 7679.446289], [-11.34307508, 252.5416389, 6290.064941, 7680.34082], [-33.01369042, 260.0676793, 6289.780762, 7681.258789], [-54.68430576, 267.5937196, 6289.425293, 7682.069336], [-76.35492111, 275.11976, 6289.055664, 7682.760742], [-98.02553645, 282.6458004, 6288.70166, 7683.348633], [-119.6961518, 290.1718408, 6288.370605, 7683.84668], [-141.3667671, 297.6978812, 6288.064941, 7684.271484], [-163.0373825, 305.2239216, 6287.790039, 7684.636719], [-184.7079978, 312.7499619, 6287.546387, 7684.949219], [-206.3786132, 320.2760023, 6287.335938, 7685.212891], [-228.0492285, 327.8020427, 6287.157227, 7685.428711], [-249.7198438, 335.3280831, 6287.01709, 7685.592773], [-271.3904592, 342.8541235, 6286.908691, 7685.716797], [-293.0610745, 350.3801639, 6286.833984, 7685.797852], [-314.7316899, 357.9062042, 6286.796387, 7685.831055], [1106.077963, -158.2875096, 6280.557617, 7663.224609], [1083.359796, -150.3968815, 6280.526855, 7663.166016], [1060.641629, -142.5062534, 6280.462891, 7663.066406], [1037.923462, -134.6156253, 6280.373535, 7662.910156], [1015.205295, -126.7249972, 6280.256836, 7662.710938], [992.4871285, -118.8343692, 6280.112793, 7662.463867], [969.7689615, -110.9437411, 6279.941895, 7662.164063], [947.0507945, -103.053113, 6279.755371, 7661.822266], [924.3326276, -95.16248487, 6279.554688, 7661.421875], [901.6144606, -87.27185677, 6279.344238, 7660.964844], [878.8962936, -79.38122868, 6279.119141, 7660.464844], [856.1781266, -71.49060059, 6278.90332, 7659.898438], [833.4599596, -63.59997249, 6278.681641, 7659.282227], [810.7417926, -55.7093444, 6278.474121, 7658.610352], [788.0236256, -47.8187163, 6278.289551, 7657.858398], [765.3054587, -39.92808821, 6278.129883, 7657.03418], [742.5872917, -32.03746012, 6278.009277, 7656.133789], [719.8691247, -24.14683202, 6277.953613, 7655.149414], [697.1509577, -16.25620393, 6277.958008, 7654.067383], [674.4327907, -8.365575833, 6278.03125, 7652.897461], [651.7146237, -0.4749477394, 6278.119141, 7651.643555], [628.9964567, 7.415680355, 6278.149414, 7650.40332], [606.2782898, 15.30630845, 6392.424316, 7535.472168], [582.6934944, 23.58367414, 6392.536621, 7536.875], [559.108745, 31.86097515, 6392.853027, 7539.92041], [535.7715912, 39.77837821, 6393.195313, 7542.59668], [512.4343335, 47.69587681, 6393.512695, 7542.257324], [489.0968698, 55.613569, 6393.874512, 7542.317871], [465.7590761, 63.53156541, 6393.748047, 7541.78125], [442.4208495, 71.44998717, 6393.555664, 7539.393066], [419.0820554, 79.36898112, 6393.117676, 7537.486816], [395.7425823, 87.28869797, 6392.299805, 7550.256836], [372.4022576, 95.20939805, 6390.438477, 7553.031738], [349.0609592, 103.1313417, 6388.805664, 7543.838867], [325.7184238, 111.0549934, 6388.331543, 7543.871582], [302.3744856, 118.9806726, 6389.479004, 7546.103027], [279.0288184, 126.9089344, 6390.418457, 7548.080566], [255.681324, 134.8400009, 6390.610352, 7548.829102], [232.3316533, 142.7744988, 6391.759766, 7549.942871], [208.9797519, 150.712591, 6393.72998, 7551.682129], [185.6252661, 158.6547488, 6395.982422, 7553.125], [162.2682511, 166.6006821, 6397.965332, 7554.773926], [138.908594, 174.5503291, 6399.922363, 7556.585938], [115.5465403, 182.5032128, 6401.418945, 7557.62207], [92.18223349, 190.45903, 6402.804199, 7558.911621], [68.81600984, 198.4174222, 6403.976074, 7560.279297], [47.06012808, 205.9645902, 6288.78418, 7677.421875], [25.30424632, 213.5117583, 6289.180176, 7678.380859], [3.548364552, 221.0589264, 6289.453613, 7679.253906], [-18.20751721, 228.6060944, 6289.510254, 7680.128906], [-39.96339898, 236.1532625, 6289.393066, 7680.976563], [-61.71928074, 243.7004306, 6289.174805, 7681.755859], [-83.4751625, 251.2475986, 6288.914551, 7682.443359], [-105.2310443, 258.7947667, 6288.629883, 7683.041016], [-126.986926, 266.3419348, 6288.353027, 7683.553711], [-148.7428078, 273.8891028, 6288.087891, 7684], [-170.4986896, 281.4362709, 6287.840332, 7684.382813], [-192.2545713, 288.983439, 6287.616211, 7684.711914], [-214.0104531, 296.530607, 6287.423828, 7684.985352], [-235.7663348, 304.0777751, 6287.258301, 7685.205078], [-257.5222166, 311.6249432, 6287.119629, 7685.378906], [-279.2780984, 319.1721112, 6287.02002, 7685.505859], [-301.0339801, 326.7192793, 6286.947266, 7685.584961], [-322.7898619, 334.2664473, 6286.910645, 7685.620117], [1097.895279, -181.8885683, 6280.486328, 7663.085938], [1075.137866, -173.9803697, 6280.458008, 7663.03418], [1052.380453, -166.0721711, 6280.396973, 7662.933594], [1029.62304, -158.1639724, 6280.308594, 7662.772461], [1006.865627, -150.2557738, 6280.192871, 7662.570313], [984.1082135, -142.3475752, 6280.056152, 7662.321289], [961.3508004, -134.4393766, 6279.897949, 7662.025391], [938.5933874, -126.5311779, 6279.724609, 7661.680664], [915.8359743, -118.6229793, 6279.537598, 7661.275391], [893.0785612, -110.7147807, 6279.334473, 7660.818359], [870.3211481, -102.8065821, 6279.129395, 7660.299805], [847.5637351, -94.89838346, 6278.92041, 7659.742188], [824.806322, -86.99018484, 6278.725586, 7659.123047], [802.0489089, -79.08198622, 6278.540527, 7658.447266], [779.2914958, -71.1737876, 6278.367188, 7657.71875], [756.5340828, -63.26558897, 6278.242188, 7656.921875], [733.7766697, -55.35739035, 6278.146484, 7656.072266], [711.0192566, -47.44919173, 6278.087402, 7655.166992], [688.2618435, -39.54099311, 6278.090332, 7654.236328], [665.5044305, -31.63279449, 6278.145508, 7653.305664], [642.7470174, -23.72459587, 6278.223145, 7652.444336], [619.9896043, -15.81639724, 6278.314941, 7651.768555], [597.2321912, -7.908198623, 6278.498535, 7651.496094], [574.4747781, -9.313225746e-10, 6393.375, 7537.17334], [550.890147, 8.277169209, 6393.45752, 7540.707031], [527.552892, 16.1945162, 6393.580078, 7544.47168], [504.2155342, 24.11195566, 6393.896973, 7545.717285], [480.8779665, 32.02957347, 6394.18457, 7546.466309], [457.5400804, 39.94747165, 6394.040527, 7543.819336], [434.2017727, 47.86576752, 6394.017578, 7541.349609], [410.8629109, 55.7846375, 6393.296387, 7538.833496], [387.5233586, 63.70426661, 6392.733398, 7542.931152], [364.1829338, 71.62492949, 6390.929199, 7550.242676], [340.8415047, 79.54685505, 6389.11377, 7543.547852], [317.4988521, 87.4704295, 6389.569336, 7544.544434], [294.1548147, 95.39596185, 6390.635254, 7546.850098], [270.8091075, 103.3240539, 6390.92041, 7548.054688], [247.4615348, 111.2550384, 6391.231445, 7549.370605], [224.1117725, 119.1895267, 6392.223633, 7550.595703], [200.759709, 127.1275846, 6394.112305, 7551.167969], [177.4051202, 135.0695754, 6396.180664, 7552.982422], [154.0480428, 143.015319, 6398.222656, 7554.849121], [130.6883542, 150.9648792, 6400.180664, 7556.648926], [107.3261832, 158.9177829, 6401.478516, 7557.786133], [83.96173335, 166.8734953, 6402.887695, 7558.991211], [62.12918757, 174.4395698, 6287.847168, 7675.852539], [40.2966418, 182.0056444, 6288.346191, 7677.083008], [18.46409603, 189.5717189, 6288.741211, 7678.124023], [-3.368449744, 197.1377934, 6289.016602, 7679.05957], [-25.20099552, 204.703868, 6289.123535, 7679.942383], [-47.03354129, 212.2699425, 6289.100098, 7680.771484], [-68.86608706, 219.8360171, 6288.972656, 7681.530273], [-90.69863283, 227.4020916, 6288.782227, 7682.213867], [-112.5311786, 234.9681662, 6288.558594, 7682.813477], [-134.3637244, 242.5342407, 6288.327637, 7683.341797], [-156.1962702, 250.1003153, 6288.095703, 7683.794922], [-178.0288159, 257.6663898, 6287.867676, 7684.191406], [-199.8613617, 265.2324644, 6287.664063, 7684.525391], [-221.6939075, 272.7985389, 6287.481934, 7684.805664], [-243.5264532, 280.3646135, 6287.327148, 7685.032227], [-265.358999, 287.930688, 6287.197754, 7685.208008], [-287.1915448, 295.4967626, 6287.099609, 7685.336914], [-309.0240906, 303.0628371, 6287.029297, 7685.418945], [-330.8566363, 310.6289117, 6286.992188, 7685.455078], [1089.657463, -205.4917939, 6280.433105, 7662.987305], [1066.805672, -197.5681916, 6280.404785, 7662.9375], [1043.953882, -189.6445893, 6280.354004, 7662.834961], [1021.102091, -181.7209871, 6280.264648, 7662.679688], [998.2503009, -173.7973848, 6280.155273, 7662.479492], [975.3985103, -165.8737825, 6280.023926, 7662.227539], [952.5467198, -157.9501803, 6279.873047, 7661.93457], [929.6949293, -150.026578, 6279.70752, 7661.584961], [906.8431387, -142.1029757, 6279.529297, 7661.1875], [883.9913482, -134.1793735, 6279.335449, 7660.727539], [861.1395577, -126.2557712, 6279.135742, 7660.210938], [838.2877671, -118.3321689, 6278.941895, 7659.644531], [815.4359766, -110.4085667, 6278.753418, 7659.023438], [792.5841861, -102.4849644, 6278.581055, 7658.351563], [769.7323956, -94.56136214, 6278.430176, 7657.628906], [746.880605, -86.63775988, 6278.313477, 7656.863281], [724.0288145, -78.71415761, 6278.227051, 7656.054688], [701.177024, -70.79055535, 6278.179199, 7655.216797], [678.3252334, -62.86695308, 6278.17627, 7654.398438], [655.4734429, -54.94335081, 6278.225098, 7653.648438], [632.6216524, -47.01974855, 6278.293457, 7653.046875], [609.7698618, -39.09614628, 6278.401367, 7652.720703], [586.9180713, -31.17254402, 6278.556152, 7652.867188], [564.0662808, -23.24894175, 6278.762207, 7653.743164], [541.2144902, -15.32533949, 6278.777832, 7656.030273], [518.3626997, -7.40173722, 6278.806152, 7658.630859], [495.5109092, 0.5218650457, 6279.035156, 7660.599609], [472.6591186, 8.445467312, 6394.794922, 7547.54248], [449.321139, 16.36329683, 6394.741699, 7546.542969], [425.9827264, 24.28154979, 6394.662109, 7543.714844], [402.6437464, 32.2003759, 6394.804688, 7541.203613], [379.3040864, 40.11992489, 6394.257813, 7545.097656], [355.9635747, 48.04045617, 6391.642578, 7549.713379], [332.6220894, 55.96222723, 6389.751953, 7547.638184], [309.2793671, 63.88570155, 6390.281738, 7545.412109], [285.9352392, 71.81120147, 6391.694336, 7547.191895], [262.5893831, 79.73928109, 6391.520996, 7548.614746], [239.2416999, 87.67016355, 6391.541992, 7550.172852], [215.8918393, 95.60447542, 6392.499023, 7551.993652], [192.5397501, 103.5423788, 6394.357422, 7553.838379], [169.1850764, 111.4843459, 6396.370117, 7555.174316], [147.1010057, 119.1131796, 6282.310059, 7671.389648], [125.016935, 126.7420134, 6284.003906, 7672.429688], [102.9328643, 134.3708472, 6285.407715, 7673.514648], [80.84879357, 141.999681, 6286.604492, 7674.650391], [58.76472287, 149.6285148, 6287.412109, 7675.80957], [36.68065216, 157.2573486, 6288.008789, 7676.935547], [14.59658146, 164.8861824, 6288.444336, 7677.974609], [-7.487489251, 172.5150162, 6288.734375, 7678.924805], [-29.57155996, 180.14385, 6288.882324, 7679.807617], [-51.65563066, 187.7726838, 6288.902832, 7680.632813], [-73.73970137, 195.4015176, 6288.833008, 7681.383789], [-95.82377208, 203.0303514, 6288.691406, 7682.061523], [-117.9078428, 210.6591852, 6288.504883, 7682.666016], [-139.9919135, 218.288019, 6288.303711, 7683.194336], [-162.0759842, 225.9168528, 6288.092773, 7683.660156], [-184.1600549, 233.5456866, 6287.88623, 7684.05957], [-206.2441256, 241.1745204, 6287.695313, 7684.397461], [-228.3281963, 248.8033542, 6287.516602, 7684.681641], [-250.412267, 256.432188, 6287.364746, 7684.911133], [-272.4963377, 264.0610218, 6287.247559, 7685.089844], [-294.5804084, 271.6898556, 6287.147461, 7685.217773], [-316.6644791, 279.3186894, 6287.080078, 7685.299805], [-338.7485498, 286.9475232, 6287.044434, 7685.341797], [1081.414215, -229.1101652, 6280.410645, 7662.943359], [1058.462615, -221.186305, 6280.386719, 7662.892578], [1035.511016, -213.2624448, 6280.333008, 7662.791016], [1012.559416, -205.3385847, 6280.246582, 7662.631836], [989.6078158, -197.4147245, 6280.137695, 7662.432617], [966.656216, -189.4908644, 6280.006348, 7662.186523], [943.7046161, -181.5670042, 6279.861816, 7661.886719], [920.7530163, -173.643144, 6279.700195, 7661.544922], [897.8014164, -165.7192839, 6279.524414, 7661.139648], [874.8498165, -157.7954237, 6279.336914, 7660.680664], [851.8982167, -149.8715635, 6279.143066, 7660.169922], [828.9466168, -141.9477034, 6278.953613, 7659.599609], [805.995017, -134.0238432, 6278.772461, 7658.973633], [783.0434171, -126.099983, 6278.604492, 7658.30957], [760.0918173, -118.1761229, 6278.460449, 7657.594727], [737.1402174, -110.2522627, 6278.347168, 7656.839844], [714.1886176, -102.3284025, 6278.27002, 7656.054688], [691.2370177, -94.40454238, 6278.225098, 7655.260742], [668.2854179, -86.48068222, 6278.226563, 7654.492188], [645.333818, -78.55682206, 6278.257813, 7653.839844], [622.3822181, -70.63296189, 6278.333008, 7653.365234], [599.4306183, -62.70910173, 6278.429688, 7653.198242], [576.4790184, -54.78524156, 6278.565918, 7653.517578], [553.5274186, -46.8613814, 6278.716309, 7654.509766], [530.5758187, -38.93752123, 6278.810059, 7656.288086], [507.6242189, -31.01366107, 6278.914063, 7658.333984], [484.672619, -23.08980091, 6279.114746, 7660.050781], [461.7210192, -15.16594074, 6279.376465, 7661.211914], [438.7694193, -7.242080578, 6279.487793, 7660.75], [415.8178194, 0.6817795867, 6279.520508, 7659.324219], [392.8662196, 8.605639751, 6279.320801, 7658.592773], [369.9146197, 16.52949992, 6278.261719, 7660.621094], [346.9630199, 24.45336008, 6276.289551, 7663.103516], [324.01142, 32.37722024, 6274.777832, 7663.163086], [301.0598202, 40.30108041, 6389.817383, 7547.220215], [277.7155949, 48.22643347, 6391.259277, 7548.462402], [254.3696998, 56.15434523, 6391.759277, 7550.066406], [231.0219393, 64.08514758, 6391.857422, 7552.22168], [208.7997912, 71.747095, 6276.991699, 7668.643555], [186.5776431, 79.40904241, 6278.606445, 7669.737305], [164.355495, 87.07098983, 6280.421387, 7670.783203], [142.1333469, 94.73293724, 6282.169922, 7671.566406], [119.9111989, 102.3948847, 6283.779785, 7672.521484], [97.68905077, 110.0568321, 6285.172363, 7673.571289], [75.46690269, 117.7187795, 6286.321777, 7674.668945], [53.2447546, 125.3807269, 6287.186523, 7675.789063], [31.02260652, 133.0426743, 6287.827148, 7676.876953], [8.800458437, 140.7046217, 6288.290527, 7677.902344], [-13.42168965, 148.3665691, 6288.593262, 7678.861328], [-35.64383773, 156.0285166, 6288.763672, 7679.744141], [-57.86598582, 163.690464, 6288.807129, 7680.5625], [-80.0881339, 171.3524114, 6288.763184, 7681.30957], [-102.310282, 179.0143588, 6288.644531, 7681.990234], [-124.5324301, 186.6763062, 6288.478027, 7682.59082], [-146.7545782, 194.3382536, 6288.288574, 7683.121094], [-168.9767262, 202.0002011, 6288.091797, 7683.586914], [-191.1988743, 209.6621485, 6287.89209, 7683.990234], [-213.4210224, 217.3240959, 6287.705566, 7684.332031], [-235.6431705, 224.9860433, 6287.538574, 7684.617188], [-257.8653186, 232.6479907, 6287.390625, 7684.851563], [-280.0874667, 240.3099381, 6287.273926, 7685.027344], [-302.3096147, 247.9718855, 6287.172363, 7685.15625], [-324.5317628, 255.633833, 6287.108887, 7685.239258], [-346.7539109, 263.2957804, 6287.071289, 7685.280273], [null, null, null, null]]
};
},{}],"node_modules/three/examples/jsm/controls/OrbitControls.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OrbitControls = exports.MapControls = void 0;
var _threeModule = require("../../../build/three.module.js");
// This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
//
//    Orbit - left mouse / touch: one-finger move
//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move
var OrbitControls = function (object, domElement) {
  if (domElement === undefined) console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.');
  if (domElement === document) console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.');
  this.object = object;
  this.domElement = domElement;

  // Set to false to disable this control
  this.enabled = true;

  // "target" sets the location of focus, where the object orbits around
  this.target = new _threeModule.Vector3();

  // How far you can dolly in and out ( PerspectiveCamera only )
  this.minDistance = 0;
  this.maxDistance = Infinity;

  // How far you can zoom in and out ( OrthographicCamera only )
  this.minZoom = 0;
  this.maxZoom = Infinity;

  // How far you can orbit vertically, upper and lower limits.
  // Range is 0 to Math.PI radians.
  this.minPolarAngle = 0; // radians
  this.maxPolarAngle = Math.PI; // radians

  // How far you can orbit horizontally, upper and lower limits.
  // If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )
  this.minAzimuthAngle = -Infinity; // radians
  this.maxAzimuthAngle = Infinity; // radians

  // Set to true to enable damping (inertia)
  // If damping is enabled, you must call controls.update() in your animation loop
  this.enableDamping = false;
  this.dampingFactor = 0.05;

  // This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
  // Set to false to disable zooming
  this.enableZoom = true;
  this.zoomSpeed = 1.0;

  // Set to false to disable rotating
  this.enableRotate = true;
  this.rotateSpeed = 1.0;

  // Set to false to disable panning
  this.enablePan = true;
  this.panSpeed = 1.0;
  this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up
  this.keyPanSpeed = 7.0; // pixels moved per arrow key push

  // Set to true to automatically rotate around the target
  // If auto-rotate is enabled, you must call controls.update() in your animation loop
  this.autoRotate = false;
  this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

  // The four arrow keys
  this.keys = {
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    BOTTOM: 40
  };

  // Mouse buttons
  this.mouseButtons = {
    LEFT: _threeModule.MOUSE.ROTATE,
    MIDDLE: _threeModule.MOUSE.DOLLY,
    RIGHT: _threeModule.MOUSE.PAN
  };

  // Touch fingers
  this.touches = {
    ONE: _threeModule.TOUCH.ROTATE,
    TWO: _threeModule.TOUCH.DOLLY_PAN
  };

  // for reset
  this.target0 = this.target.clone();
  this.position0 = this.object.position.clone();
  this.zoom0 = this.object.zoom;

  // the target DOM element for key events
  this._domElementKeyEvents = null;

  //
  // public methods
  //

  this.getPolarAngle = function () {
    return spherical.phi;
  };
  this.getAzimuthalAngle = function () {
    return spherical.theta;
  };
  this.listenToKeyEvents = function (domElement) {
    domElement.addEventListener('keydown', onKeyDown);
    this._domElementKeyEvents = domElement;
  };
  this.saveState = function () {
    scope.target0.copy(scope.target);
    scope.position0.copy(scope.object.position);
    scope.zoom0 = scope.object.zoom;
  };
  this.reset = function () {
    scope.target.copy(scope.target0);
    scope.object.position.copy(scope.position0);
    scope.object.zoom = scope.zoom0;
    scope.object.updateProjectionMatrix();
    scope.dispatchEvent(changeEvent);
    scope.update();
    state = STATE.NONE;
  };

  // this method is exposed, but perhaps it would be better if we can make it private...
  this.update = function () {
    var offset = new _threeModule.Vector3();

    // so camera.up is the orbit axis
    var quat = new _threeModule.Quaternion().setFromUnitVectors(object.up, new _threeModule.Vector3(0, 1, 0));
    var quatInverse = quat.clone().invert();
    var lastPosition = new _threeModule.Vector3();
    var lastQuaternion = new _threeModule.Quaternion();
    var twoPI = 2 * Math.PI;
    return function update() {
      var position = scope.object.position;
      offset.copy(position).sub(scope.target);

      // rotate offset to "y-axis-is-up" space
      offset.applyQuaternion(quat);

      // angle from z-axis around y-axis
      spherical.setFromVector3(offset);
      if (scope.autoRotate && state === STATE.NONE) {
        rotateLeft(getAutoRotationAngle());
      }
      if (scope.enableDamping) {
        spherical.theta += sphericalDelta.theta * scope.dampingFactor;
        spherical.phi += sphericalDelta.phi * scope.dampingFactor;
      } else {
        spherical.theta += sphericalDelta.theta;
        spherical.phi += sphericalDelta.phi;
      }

      // restrict theta to be between desired limits

      var min = scope.minAzimuthAngle;
      var max = scope.maxAzimuthAngle;
      if (isFinite(min) && isFinite(max)) {
        if (min < -Math.PI) min += twoPI;else if (min > Math.PI) min -= twoPI;
        if (max < -Math.PI) max += twoPI;else if (max > Math.PI) max -= twoPI;
        if (min <= max) {
          spherical.theta = Math.max(min, Math.min(max, spherical.theta));
        } else {
          spherical.theta = spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta);
        }
      }

      // restrict phi to be between desired limits
      spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
      spherical.makeSafe();
      spherical.radius *= scale;

      // restrict radius to be between desired limits
      spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));

      // move target to panned location

      if (scope.enableDamping === true) {
        scope.target.addScaledVector(panOffset, scope.dampingFactor);
      } else {
        scope.target.add(panOffset);
      }
      offset.setFromSpherical(spherical);

      // rotate offset back to "camera-up-vector-is-up" space
      offset.applyQuaternion(quatInverse);
      position.copy(scope.target).add(offset);
      scope.object.lookAt(scope.target);
      if (scope.enableDamping === true) {
        sphericalDelta.theta *= 1 - scope.dampingFactor;
        sphericalDelta.phi *= 1 - scope.dampingFactor;
        panOffset.multiplyScalar(1 - scope.dampingFactor);
      } else {
        sphericalDelta.set(0, 0, 0);
        panOffset.set(0, 0, 0);
      }
      scale = 1;

      // update condition is:
      // min(camera displacement, camera rotation in radians)^2 > EPS
      // using small-angle approximation cos(x/2) = 1 - x^2 / 8

      if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {
        scope.dispatchEvent(changeEvent);
        lastPosition.copy(scope.object.position);
        lastQuaternion.copy(scope.object.quaternion);
        zoomChanged = false;
        return true;
      }
      return false;
    };
  }();
  this.dispose = function () {
    scope.domElement.removeEventListener('contextmenu', onContextMenu);
    scope.domElement.removeEventListener('pointerdown', onPointerDown);
    scope.domElement.removeEventListener('wheel', onMouseWheel);
    scope.domElement.removeEventListener('touchstart', onTouchStart);
    scope.domElement.removeEventListener('touchend', onTouchEnd);
    scope.domElement.removeEventListener('touchmove', onTouchMove);
    scope.domElement.ownerDocument.removeEventListener('pointermove', onPointerMove);
    scope.domElement.ownerDocument.removeEventListener('pointerup', onPointerUp);
    if (scope._domElementKeyEvents !== null) {
      scope._domElementKeyEvents.removeEventListener('keydown', onKeyDown);
    }

    //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?
  };

  //
  // internals
  //

  var scope = this;
  var changeEvent = {
    type: 'change'
  };
  var startEvent = {
    type: 'start'
  };
  var endEvent = {
    type: 'end'
  };
  var STATE = {
    NONE: -1,
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2,
    TOUCH_ROTATE: 3,
    TOUCH_PAN: 4,
    TOUCH_DOLLY_PAN: 5,
    TOUCH_DOLLY_ROTATE: 6
  };
  var state = STATE.NONE;
  var EPS = 0.000001;

  // current position in spherical coordinates
  var spherical = new _threeModule.Spherical();
  var sphericalDelta = new _threeModule.Spherical();
  var scale = 1;
  var panOffset = new _threeModule.Vector3();
  var zoomChanged = false;
  var rotateStart = new _threeModule.Vector2();
  var rotateEnd = new _threeModule.Vector2();
  var rotateDelta = new _threeModule.Vector2();
  var panStart = new _threeModule.Vector2();
  var panEnd = new _threeModule.Vector2();
  var panDelta = new _threeModule.Vector2();
  var dollyStart = new _threeModule.Vector2();
  var dollyEnd = new _threeModule.Vector2();
  var dollyDelta = new _threeModule.Vector2();
  function getAutoRotationAngle() {
    return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
  }
  function getZoomScale() {
    return Math.pow(0.95, scope.zoomSpeed);
  }
  function rotateLeft(angle) {
    sphericalDelta.theta -= angle;
  }
  function rotateUp(angle) {
    sphericalDelta.phi -= angle;
  }
  var panLeft = function () {
    var v = new _threeModule.Vector3();
    return function panLeft(distance, objectMatrix) {
      v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix
      v.multiplyScalar(-distance);
      panOffset.add(v);
    };
  }();
  var panUp = function () {
    var v = new _threeModule.Vector3();
    return function panUp(distance, objectMatrix) {
      if (scope.screenSpacePanning === true) {
        v.setFromMatrixColumn(objectMatrix, 1);
      } else {
        v.setFromMatrixColumn(objectMatrix, 0);
        v.crossVectors(scope.object.up, v);
      }
      v.multiplyScalar(distance);
      panOffset.add(v);
    };
  }();

  // deltaX and deltaY are in pixels; right and down are positive
  var pan = function () {
    var offset = new _threeModule.Vector3();
    return function pan(deltaX, deltaY) {
      var element = scope.domElement;
      if (scope.object.isPerspectiveCamera) {
        // perspective
        var position = scope.object.position;
        offset.copy(position).sub(scope.target);
        var targetDistance = offset.length();

        // half of the fov is center to top of screen
        targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180.0);

        // we use only clientHeight here so aspect ratio does not distort speed
        panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
        panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
      } else if (scope.object.isOrthographicCamera) {
        // orthographic
        panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);
        panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);
      } else {
        // camera neither orthographic nor perspective
        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');
        scope.enablePan = false;
      }
    };
  }();
  function dollyOut(dollyScale) {
    if (scope.object.isPerspectiveCamera) {
      scale /= dollyScale;
    } else if (scope.object.isOrthographicCamera) {
      scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));
      scope.object.updateProjectionMatrix();
      zoomChanged = true;
    } else {
      console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
      scope.enableZoom = false;
    }
  }
  function dollyIn(dollyScale) {
    if (scope.object.isPerspectiveCamera) {
      scale *= dollyScale;
    } else if (scope.object.isOrthographicCamera) {
      scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));
      scope.object.updateProjectionMatrix();
      zoomChanged = true;
    } else {
      console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
      scope.enableZoom = false;
    }
  }

  //
  // event callbacks - update the object state
  //

  function handleMouseDownRotate(event) {
    rotateStart.set(event.clientX, event.clientY);
  }
  function handleMouseDownDolly(event) {
    dollyStart.set(event.clientX, event.clientY);
  }
  function handleMouseDownPan(event) {
    panStart.set(event.clientX, event.clientY);
  }
  function handleMouseMoveRotate(event) {
    rotateEnd.set(event.clientX, event.clientY);
    rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
    var element = scope.domElement;
    rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height

    rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
    rotateStart.copy(rotateEnd);
    scope.update();
  }
  function handleMouseMoveDolly(event) {
    dollyEnd.set(event.clientX, event.clientY);
    dollyDelta.subVectors(dollyEnd, dollyStart);
    if (dollyDelta.y > 0) {
      dollyOut(getZoomScale());
    } else if (dollyDelta.y < 0) {
      dollyIn(getZoomScale());
    }
    dollyStart.copy(dollyEnd);
    scope.update();
  }
  function handleMouseMovePan(event) {
    panEnd.set(event.clientX, event.clientY);
    panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
    pan(panDelta.x, panDelta.y);
    panStart.copy(panEnd);
    scope.update();
  }
  function handleMouseUp( /*event*/
  ) {

    // no-op
  }
  function handleMouseWheel(event) {
    if (event.deltaY < 0) {
      dollyIn(getZoomScale());
    } else if (event.deltaY > 0) {
      dollyOut(getZoomScale());
    }
    scope.update();
  }
  function handleKeyDown(event) {
    var needsUpdate = false;
    switch (event.keyCode) {
      case scope.keys.UP:
        pan(0, scope.keyPanSpeed);
        needsUpdate = true;
        break;
      case scope.keys.BOTTOM:
        pan(0, -scope.keyPanSpeed);
        needsUpdate = true;
        break;
      case scope.keys.LEFT:
        pan(scope.keyPanSpeed, 0);
        needsUpdate = true;
        break;
      case scope.keys.RIGHT:
        pan(-scope.keyPanSpeed, 0);
        needsUpdate = true;
        break;
    }
    if (needsUpdate) {
      // prevent the browser from scrolling on cursor keys
      event.preventDefault();
      scope.update();
    }
  }
  function handleTouchStartRotate(event) {
    if (event.touches.length == 1) {
      rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
    } else {
      var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
      var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
      rotateStart.set(x, y);
    }
  }
  function handleTouchStartPan(event) {
    if (event.touches.length == 1) {
      panStart.set(event.touches[0].pageX, event.touches[0].pageY);
    } else {
      var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
      var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
      panStart.set(x, y);
    }
  }
  function handleTouchStartDolly(event) {
    var dx = event.touches[0].pageX - event.touches[1].pageX;
    var dy = event.touches[0].pageY - event.touches[1].pageY;
    var distance = Math.sqrt(dx * dx + dy * dy);
    dollyStart.set(0, distance);
  }
  function handleTouchStartDollyPan(event) {
    if (scope.enableZoom) handleTouchStartDolly(event);
    if (scope.enablePan) handleTouchStartPan(event);
  }
  function handleTouchStartDollyRotate(event) {
    if (scope.enableZoom) handleTouchStartDolly(event);
    if (scope.enableRotate) handleTouchStartRotate(event);
  }
  function handleTouchMoveRotate(event) {
    if (event.touches.length == 1) {
      rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);
    } else {
      var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
      var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
      rotateEnd.set(x, y);
    }
    rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
    var element = scope.domElement;
    rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height

    rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
    rotateStart.copy(rotateEnd);
  }
  function handleTouchMovePan(event) {
    if (event.touches.length == 1) {
      panEnd.set(event.touches[0].pageX, event.touches[0].pageY);
    } else {
      var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
      var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
      panEnd.set(x, y);
    }
    panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
    pan(panDelta.x, panDelta.y);
    panStart.copy(panEnd);
  }
  function handleTouchMoveDolly(event) {
    var dx = event.touches[0].pageX - event.touches[1].pageX;
    var dy = event.touches[0].pageY - event.touches[1].pageY;
    var distance = Math.sqrt(dx * dx + dy * dy);
    dollyEnd.set(0, distance);
    dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));
    dollyOut(dollyDelta.y);
    dollyStart.copy(dollyEnd);
  }
  function handleTouchMoveDollyPan(event) {
    if (scope.enableZoom) handleTouchMoveDolly(event);
    if (scope.enablePan) handleTouchMovePan(event);
  }
  function handleTouchMoveDollyRotate(event) {
    if (scope.enableZoom) handleTouchMoveDolly(event);
    if (scope.enableRotate) handleTouchMoveRotate(event);
  }
  function handleTouchEnd( /*event*/
  ) {

    // no-op
  }

  //
  // event handlers - FSM: listen for events and reset state
  //

  function onPointerDown(event) {
    if (scope.enabled === false) return;
    switch (event.pointerType) {
      case 'mouse':
      case 'pen':
        onMouseDown(event);
        break;

      // TODO touch
    }
  }

  function onPointerMove(event) {
    if (scope.enabled === false) return;
    switch (event.pointerType) {
      case 'mouse':
      case 'pen':
        onMouseMove(event);
        break;

      // TODO touch
    }
  }

  function onPointerUp(event) {
    switch (event.pointerType) {
      case 'mouse':
      case 'pen':
        onMouseUp(event);
        break;

      // TODO touch
    }
  }

  function onMouseDown(event) {
    // Prevent the browser from scrolling.
    event.preventDefault();

    // Manually set the focus since calling preventDefault above
    // prevents the browser from setting it automatically.

    scope.domElement.focus ? scope.domElement.focus() : window.focus();
    var mouseAction;
    switch (event.button) {
      case 0:
        mouseAction = scope.mouseButtons.LEFT;
        break;
      case 1:
        mouseAction = scope.mouseButtons.MIDDLE;
        break;
      case 2:
        mouseAction = scope.mouseButtons.RIGHT;
        break;
      default:
        mouseAction = -1;
    }
    switch (mouseAction) {
      case _threeModule.MOUSE.DOLLY:
        if (scope.enableZoom === false) return;
        handleMouseDownDolly(event);
        state = STATE.DOLLY;
        break;
      case _threeModule.MOUSE.ROTATE:
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          if (scope.enablePan === false) return;
          handleMouseDownPan(event);
          state = STATE.PAN;
        } else {
          if (scope.enableRotate === false) return;
          handleMouseDownRotate(event);
          state = STATE.ROTATE;
        }
        break;
      case _threeModule.MOUSE.PAN:
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          if (scope.enableRotate === false) return;
          handleMouseDownRotate(event);
          state = STATE.ROTATE;
        } else {
          if (scope.enablePan === false) return;
          handleMouseDownPan(event);
          state = STATE.PAN;
        }
        break;
      default:
        state = STATE.NONE;
    }
    if (state !== STATE.NONE) {
      scope.domElement.ownerDocument.addEventListener('pointermove', onPointerMove);
      scope.domElement.ownerDocument.addEventListener('pointerup', onPointerUp);
      scope.dispatchEvent(startEvent);
    }
  }
  function onMouseMove(event) {
    if (scope.enabled === false) return;
    event.preventDefault();
    switch (state) {
      case STATE.ROTATE:
        if (scope.enableRotate === false) return;
        handleMouseMoveRotate(event);
        break;
      case STATE.DOLLY:
        if (scope.enableZoom === false) return;
        handleMouseMoveDolly(event);
        break;
      case STATE.PAN:
        if (scope.enablePan === false) return;
        handleMouseMovePan(event);
        break;
    }
  }
  function onMouseUp(event) {
    scope.domElement.ownerDocument.removeEventListener('pointermove', onPointerMove);
    scope.domElement.ownerDocument.removeEventListener('pointerup', onPointerUp);
    if (scope.enabled === false) return;
    handleMouseUp(event);
    scope.dispatchEvent(endEvent);
    state = STATE.NONE;
  }
  function onMouseWheel(event) {
    if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE && state !== STATE.ROTATE) return;
    event.preventDefault();
    event.stopPropagation();
    scope.dispatchEvent(startEvent);
    handleMouseWheel(event);
    scope.dispatchEvent(endEvent);
  }
  function onKeyDown(event) {
    if (scope.enabled === false || scope.enablePan === false) return;
    handleKeyDown(event);
  }
  function onTouchStart(event) {
    if (scope.enabled === false) return;
    event.preventDefault(); // prevent scrolling

    switch (event.touches.length) {
      case 1:
        switch (scope.touches.ONE) {
          case _threeModule.TOUCH.ROTATE:
            if (scope.enableRotate === false) return;
            handleTouchStartRotate(event);
            state = STATE.TOUCH_ROTATE;
            break;
          case _threeModule.TOUCH.PAN:
            if (scope.enablePan === false) return;
            handleTouchStartPan(event);
            state = STATE.TOUCH_PAN;
            break;
          default:
            state = STATE.NONE;
        }
        break;
      case 2:
        switch (scope.touches.TWO) {
          case _threeModule.TOUCH.DOLLY_PAN:
            if (scope.enableZoom === false && scope.enablePan === false) return;
            handleTouchStartDollyPan(event);
            state = STATE.TOUCH_DOLLY_PAN;
            break;
          case _threeModule.TOUCH.DOLLY_ROTATE:
            if (scope.enableZoom === false && scope.enableRotate === false) return;
            handleTouchStartDollyRotate(event);
            state = STATE.TOUCH_DOLLY_ROTATE;
            break;
          default:
            state = STATE.NONE;
        }
        break;
      default:
        state = STATE.NONE;
    }
    if (state !== STATE.NONE) {
      scope.dispatchEvent(startEvent);
    }
  }
  function onTouchMove(event) {
    if (scope.enabled === false) return;
    event.preventDefault(); // prevent scrolling
    event.stopPropagation();
    switch (state) {
      case STATE.TOUCH_ROTATE:
        if (scope.enableRotate === false) return;
        handleTouchMoveRotate(event);
        scope.update();
        break;
      case STATE.TOUCH_PAN:
        if (scope.enablePan === false) return;
        handleTouchMovePan(event);
        scope.update();
        break;
      case STATE.TOUCH_DOLLY_PAN:
        if (scope.enableZoom === false && scope.enablePan === false) return;
        handleTouchMoveDollyPan(event);
        scope.update();
        break;
      case STATE.TOUCH_DOLLY_ROTATE:
        if (scope.enableZoom === false && scope.enableRotate === false) return;
        handleTouchMoveDollyRotate(event);
        scope.update();
        break;
      default:
        state = STATE.NONE;
    }
  }
  function onTouchEnd(event) {
    if (scope.enabled === false) return;
    handleTouchEnd(event);
    scope.dispatchEvent(endEvent);
    state = STATE.NONE;
  }
  function onContextMenu(event) {
    if (scope.enabled === false) return;
    event.preventDefault();
  }

  //

  scope.domElement.addEventListener('contextmenu', onContextMenu);
  scope.domElement.addEventListener('pointerdown', onPointerDown);
  scope.domElement.addEventListener('wheel', onMouseWheel);
  scope.domElement.addEventListener('touchstart', onTouchStart);
  scope.domElement.addEventListener('touchend', onTouchEnd);
  scope.domElement.addEventListener('touchmove', onTouchMove);

  // force an update at start

  this.update();
};
exports.OrbitControls = OrbitControls;
OrbitControls.prototype = Object.create(_threeModule.EventDispatcher.prototype);
OrbitControls.prototype.constructor = OrbitControls;

// This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
// This is very similar to OrbitControls, another set of touch behavior
//
//    Orbit - right mouse, or left mouse + ctrl/meta/shiftKey / touch: two-finger rotate
//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
//    Pan - left mouse, or arrow keys / touch: one-finger move

var MapControls = function (object, domElement) {
  OrbitControls.call(this, object, domElement);
  this.screenSpacePanning = false; // pan orthogonal to world-space direction camera.up

  this.mouseButtons.LEFT = _threeModule.MOUSE.PAN;
  this.mouseButtons.RIGHT = _threeModule.MOUSE.ROTATE;
  this.touches.ONE = _threeModule.TOUCH.PAN;
  this.touches.TWO = _threeModule.TOUCH.DOLLY_ROTATE;
};
exports.MapControls = MapControls;
MapControls.prototype = Object.create(_threeModule.EventDispatcher.prototype);
MapControls.prototype.constructor = MapControls;
},{"../../../build/three.module.js":"node_modules/three/build/three.module.js"}],"node_modules/three/examples/jsm/math/ConvexHull.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ConvexHull = void 0;
var _threeModule = require("../../../build/three.module.js");
/**
 * Ported from: https://github.com/maurizzzio/quickhull3d/ by Mauricio Poppe (https://github.com/maurizzzio)
 */

var ConvexHull = function () {
  var Visible = 0;
  var Deleted = 1;
  var v1 = new _threeModule.Vector3();
  function ConvexHull() {
    this.tolerance = -1;
    this.faces = []; // the generated faces of the convex hull
    this.newFaces = []; // this array holds the faces that are generated within a single iteration

    // the vertex lists work as follows:
    //
    // let 'a' and 'b' be 'Face' instances
    // let 'v' be points wrapped as instance of 'Vertex'
    //
    //     [v, v, ..., v, v, v, ...]
    //      ^             ^
    //      |             |
    //  a.outside     b.outside
    //
    this.assigned = new VertexList();
    this.unassigned = new VertexList();
    this.vertices = []; // vertices of the hull (internal representation of given geometry data)
  }

  Object.assign(ConvexHull.prototype, {
    setFromPoints: function (points) {
      if (Array.isArray(points) !== true) {
        console.error('THREE.ConvexHull: Points parameter is not an array.');
      }
      if (points.length < 4) {
        console.error('THREE.ConvexHull: The algorithm needs at least four points.');
      }
      this.makeEmpty();
      for (var i = 0, l = points.length; i < l; i++) {
        this.vertices.push(new VertexNode(points[i]));
      }
      this.compute();
      return this;
    },
    setFromObject: function (object) {
      var points = [];
      object.updateMatrixWorld(true);
      object.traverse(function (node) {
        var i, l, point;
        var geometry = node.geometry;
        if (geometry !== undefined) {
          if (geometry.isGeometry) {
            console.error('THREE.ConvexHull no longer supports Geometry. Use THREE.BufferGeometry instead.');
            return;
          } else if (geometry.isBufferGeometry) {
            var attribute = geometry.attributes.position;
            if (attribute !== undefined) {
              for (i = 0, l = attribute.count; i < l; i++) {
                point = new _threeModule.Vector3();
                point.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);
                points.push(point);
              }
            }
          }
        }
      });
      return this.setFromPoints(points);
    },
    containsPoint: function (point) {
      var faces = this.faces;
      for (var i = 0, l = faces.length; i < l; i++) {
        var face = faces[i];

        // compute signed distance and check on what half space the point lies

        if (face.distanceToPoint(point) > this.tolerance) return false;
      }
      return true;
    },
    intersectRay: function (ray, target) {
      // based on "Fast Ray-Convex Polyhedron Intersection"  by Eric Haines, GRAPHICS GEMS II

      var faces = this.faces;
      var tNear = -Infinity;
      var tFar = Infinity;
      for (var i = 0, l = faces.length; i < l; i++) {
        var face = faces[i];

        // interpret faces as planes for the further computation

        var vN = face.distanceToPoint(ray.origin);
        var vD = face.normal.dot(ray.direction);

        // if the origin is on the positive side of a plane (so the plane can "see" the origin) and
        // the ray is turned away or parallel to the plane, there is no intersection

        if (vN > 0 && vD >= 0) return null;

        // compute the distance from the ray’s origin to the intersection with the plane

        var t = vD !== 0 ? -vN / vD : 0;

        // only proceed if the distance is positive. a negative distance means the intersection point
        // lies "behind" the origin

        if (t <= 0) continue;

        // now categorized plane as front-facing or back-facing

        if (vD > 0) {
          //  plane faces away from the ray, so this plane is a back-face

          tFar = Math.min(t, tFar);
        } else {
          // front-face

          tNear = Math.max(t, tNear);
        }
        if (tNear > tFar) {
          // if tNear ever is greater than tFar, the ray must miss the convex hull

          return null;
        }
      }

      // evaluate intersection point

      // always try tNear first since its the closer intersection point

      if (tNear !== -Infinity) {
        ray.at(tNear, target);
      } else {
        ray.at(tFar, target);
      }
      return target;
    },
    intersectsRay: function (ray) {
      return this.intersectRay(ray, v1) !== null;
    },
    makeEmpty: function () {
      this.faces = [];
      this.vertices = [];
      return this;
    },
    // Adds a vertex to the 'assigned' list of vertices and assigns it to the given face

    addVertexToFace: function (vertex, face) {
      vertex.face = face;
      if (face.outside === null) {
        this.assigned.append(vertex);
      } else {
        this.assigned.insertBefore(face.outside, vertex);
      }
      face.outside = vertex;
      return this;
    },
    // Removes a vertex from the 'assigned' list of vertices and from the given face

    removeVertexFromFace: function (vertex, face) {
      if (vertex === face.outside) {
        // fix face.outside link

        if (vertex.next !== null && vertex.next.face === face) {
          // face has at least 2 outside vertices, move the 'outside' reference

          face.outside = vertex.next;
        } else {
          // vertex was the only outside vertex that face had

          face.outside = null;
        }
      }
      this.assigned.remove(vertex);
      return this;
    },
    // Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertext list

    removeAllVerticesFromFace: function (face) {
      if (face.outside !== null) {
        // reference to the first and last vertex of this face

        var start = face.outside;
        var end = face.outside;
        while (end.next !== null && end.next.face === face) {
          end = end.next;
        }
        this.assigned.removeSubList(start, end);

        // fix references

        start.prev = end.next = null;
        face.outside = null;
        return start;
      }
    },
    // Removes all the visible vertices that 'face' is able to see

    deleteFaceVertices: function (face, absorbingFace) {
      var faceVertices = this.removeAllVerticesFromFace(face);
      if (faceVertices !== undefined) {
        if (absorbingFace === undefined) {
          // mark the vertices to be reassigned to some other face

          this.unassigned.appendChain(faceVertices);
        } else {
          // if there's an absorbing face try to assign as many vertices as possible to it

          var vertex = faceVertices;
          do {
            // we need to buffer the subsequent vertex at this point because the 'vertex.next' reference
            // will be changed by upcoming method calls

            var nextVertex = vertex.next;
            var distance = absorbingFace.distanceToPoint(vertex.point);

            // check if 'vertex' is able to see 'absorbingFace'

            if (distance > this.tolerance) {
              this.addVertexToFace(vertex, absorbingFace);
            } else {
              this.unassigned.append(vertex);
            }

            // now assign next vertex

            vertex = nextVertex;
          } while (vertex !== null);
        }
      }
      return this;
    },
    // Reassigns as many vertices as possible from the unassigned list to the new faces

    resolveUnassignedPoints: function (newFaces) {
      if (this.unassigned.isEmpty() === false) {
        var vertex = this.unassigned.first();
        do {
          // buffer 'next' reference, see .deleteFaceVertices()

          var nextVertex = vertex.next;
          var maxDistance = this.tolerance;
          var maxFace = null;
          for (var i = 0; i < newFaces.length; i++) {
            var face = newFaces[i];
            if (face.mark === Visible) {
              var distance = face.distanceToPoint(vertex.point);
              if (distance > maxDistance) {
                maxDistance = distance;
                maxFace = face;
              }
              if (maxDistance > 1000 * this.tolerance) break;
            }
          }

          // 'maxFace' can be null e.g. if there are identical vertices

          if (maxFace !== null) {
            this.addVertexToFace(vertex, maxFace);
          }
          vertex = nextVertex;
        } while (vertex !== null);
      }
      return this;
    },
    // Computes the extremes of a simplex which will be the initial hull

    computeExtremes: function () {
      var min = new _threeModule.Vector3();
      var max = new _threeModule.Vector3();
      var minVertices = [];
      var maxVertices = [];
      var i, l, j;

      // initially assume that the first vertex is the min/max

      for (i = 0; i < 3; i++) {
        minVertices[i] = maxVertices[i] = this.vertices[0];
      }
      min.copy(this.vertices[0].point);
      max.copy(this.vertices[0].point);

      // compute the min/max vertex on all six directions

      for (i = 0, l = this.vertices.length; i < l; i++) {
        var vertex = this.vertices[i];
        var point = vertex.point;

        // update the min coordinates

        for (j = 0; j < 3; j++) {
          if (point.getComponent(j) < min.getComponent(j)) {
            min.setComponent(j, point.getComponent(j));
            minVertices[j] = vertex;
          }
        }

        // update the max coordinates

        for (j = 0; j < 3; j++) {
          if (point.getComponent(j) > max.getComponent(j)) {
            max.setComponent(j, point.getComponent(j));
            maxVertices[j] = vertex;
          }
        }
      }

      // use min/max vectors to compute an optimal epsilon

      this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(min.x), Math.abs(max.x)) + Math.max(Math.abs(min.y), Math.abs(max.y)) + Math.max(Math.abs(min.z), Math.abs(max.z)));
      return {
        min: minVertices,
        max: maxVertices
      };
    },
    // Computes the initial simplex assigning to its faces all the points
    // that are candidates to form part of the hull

    computeInitialHull: function () {
      var line3, plane, closestPoint;
      return function computeInitialHull() {
        if (line3 === undefined) {
          line3 = new _threeModule.Line3();
          plane = new _threeModule.Plane();
          closestPoint = new _threeModule.Vector3();
        }
        var vertex,
          vertices = this.vertices;
        var extremes = this.computeExtremes();
        var min = extremes.min;
        var max = extremes.max;
        var v0, v1, v2, v3;
        var i, l, j;

        // 1. Find the two vertices 'v0' and 'v1' with the greatest 1d separation
        // (max.x - min.x)
        // (max.y - min.y)
        // (max.z - min.z)

        var distance,
          maxDistance = 0;
        var index = 0;
        for (i = 0; i < 3; i++) {
          distance = max[i].point.getComponent(i) - min[i].point.getComponent(i);
          if (distance > maxDistance) {
            maxDistance = distance;
            index = i;
          }
        }
        v0 = min[index];
        v1 = max[index];

        // 2. The next vertex 'v2' is the one farthest to the line formed by 'v0' and 'v1'

        maxDistance = 0;
        line3.set(v0.point, v1.point);
        for (i = 0, l = this.vertices.length; i < l; i++) {
          vertex = vertices[i];
          if (vertex !== v0 && vertex !== v1) {
            line3.closestPointToPoint(vertex.point, true, closestPoint);
            distance = closestPoint.distanceToSquared(vertex.point);
            if (distance > maxDistance) {
              maxDistance = distance;
              v2 = vertex;
            }
          }
        }

        // 3. The next vertex 'v3' is the one farthest to the plane 'v0', 'v1', 'v2'

        maxDistance = -1;
        plane.setFromCoplanarPoints(v0.point, v1.point, v2.point);
        for (i = 0, l = this.vertices.length; i < l; i++) {
          vertex = vertices[i];
          if (vertex !== v0 && vertex !== v1 && vertex !== v2) {
            distance = Math.abs(plane.distanceToPoint(vertex.point));
            if (distance > maxDistance) {
              maxDistance = distance;
              v3 = vertex;
            }
          }
        }
        var faces = [];
        if (plane.distanceToPoint(v3.point) < 0) {
          // the face is not able to see the point so 'plane.normal' is pointing outside the tetrahedron

          faces.push(Face.create(v0, v1, v2), Face.create(v3, v1, v0), Face.create(v3, v2, v1), Face.create(v3, v0, v2));

          // set the twin edge

          for (i = 0; i < 3; i++) {
            j = (i + 1) % 3;

            // join face[ i ] i > 0, with the first face

            faces[i + 1].getEdge(2).setTwin(faces[0].getEdge(j));

            // join face[ i ] with face[ i + 1 ], 1 <= i <= 3

            faces[i + 1].getEdge(1).setTwin(faces[j + 1].getEdge(0));
          }
        } else {
          // the face is able to see the point so 'plane.normal' is pointing inside the tetrahedron

          faces.push(Face.create(v0, v2, v1), Face.create(v3, v0, v1), Face.create(v3, v1, v2), Face.create(v3, v2, v0));

          // set the twin edge

          for (i = 0; i < 3; i++) {
            j = (i + 1) % 3;

            // join face[ i ] i > 0, with the first face

            faces[i + 1].getEdge(2).setTwin(faces[0].getEdge((3 - i) % 3));

            // join face[ i ] with face[ i + 1 ]

            faces[i + 1].getEdge(0).setTwin(faces[j + 1].getEdge(1));
          }
        }

        // the initial hull is the tetrahedron

        for (i = 0; i < 4; i++) {
          this.faces.push(faces[i]);
        }

        // initial assignment of vertices to the faces of the tetrahedron

        for (i = 0, l = vertices.length; i < l; i++) {
          vertex = vertices[i];
          if (vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3) {
            maxDistance = this.tolerance;
            var maxFace = null;
            for (j = 0; j < 4; j++) {
              distance = this.faces[j].distanceToPoint(vertex.point);
              if (distance > maxDistance) {
                maxDistance = distance;
                maxFace = this.faces[j];
              }
            }
            if (maxFace !== null) {
              this.addVertexToFace(vertex, maxFace);
            }
          }
        }
        return this;
      };
    }(),
    // Removes inactive faces

    reindexFaces: function () {
      var activeFaces = [];
      for (var i = 0; i < this.faces.length; i++) {
        var face = this.faces[i];
        if (face.mark === Visible) {
          activeFaces.push(face);
        }
      }
      this.faces = activeFaces;
      return this;
    },
    // Finds the next vertex to create faces with the current hull

    nextVertexToAdd: function () {
      // if the 'assigned' list of vertices is empty, no vertices are left. return with 'undefined'

      if (this.assigned.isEmpty() === false) {
        var eyeVertex,
          maxDistance = 0;

        // grap the first available face and start with the first visible vertex of that face

        var eyeFace = this.assigned.first().face;
        var vertex = eyeFace.outside;

        // now calculate the farthest vertex that face can see

        do {
          var distance = eyeFace.distanceToPoint(vertex.point);
          if (distance > maxDistance) {
            maxDistance = distance;
            eyeVertex = vertex;
          }
          vertex = vertex.next;
        } while (vertex !== null && vertex.face === eyeFace);
        return eyeVertex;
      }
    },
    // Computes a chain of half edges in CCW order called the 'horizon'.
    // For an edge to be part of the horizon it must join a face that can see
    // 'eyePoint' and a face that cannot see 'eyePoint'.

    computeHorizon: function (eyePoint, crossEdge, face, horizon) {
      // moves face's vertices to the 'unassigned' vertex list

      this.deleteFaceVertices(face);
      face.mark = Deleted;
      var edge;
      if (crossEdge === null) {
        edge = crossEdge = face.getEdge(0);
      } else {
        // start from the next edge since 'crossEdge' was already analyzed
        // (actually 'crossEdge.twin' was the edge who called this method recursively)

        edge = crossEdge.next;
      }
      do {
        var twinEdge = edge.twin;
        var oppositeFace = twinEdge.face;
        if (oppositeFace.mark === Visible) {
          if (oppositeFace.distanceToPoint(eyePoint) > this.tolerance) {
            // the opposite face can see the vertex, so proceed with next edge

            this.computeHorizon(eyePoint, twinEdge, oppositeFace, horizon);
          } else {
            // the opposite face can't see the vertex, so this edge is part of the horizon

            horizon.push(edge);
          }
        }
        edge = edge.next;
      } while (edge !== crossEdge);
      return this;
    },
    // Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order

    addAdjoiningFace: function (eyeVertex, horizonEdge) {
      // all the half edges are created in ccw order thus the face is always pointing outside the hull

      var face = Face.create(eyeVertex, horizonEdge.tail(), horizonEdge.head());
      this.faces.push(face);

      // join face.getEdge( - 1 ) with the horizon's opposite edge face.getEdge( - 1 ) = face.getEdge( 2 )

      face.getEdge(-1).setTwin(horizonEdge.twin);
      return face.getEdge(0); // the half edge whose vertex is the eyeVertex
    },

    //  Adds 'horizon.length' faces to the hull, each face will be linked with the
    //  horizon opposite face and the face on the left/right

    addNewFaces: function (eyeVertex, horizon) {
      this.newFaces = [];
      var firstSideEdge = null;
      var previousSideEdge = null;
      for (var i = 0; i < horizon.length; i++) {
        var horizonEdge = horizon[i];

        // returns the right side edge

        var sideEdge = this.addAdjoiningFace(eyeVertex, horizonEdge);
        if (firstSideEdge === null) {
          firstSideEdge = sideEdge;
        } else {
          // joins face.getEdge( 1 ) with previousFace.getEdge( 0 )

          sideEdge.next.setTwin(previousSideEdge);
        }
        this.newFaces.push(sideEdge.face);
        previousSideEdge = sideEdge;
      }

      // perform final join of new faces

      firstSideEdge.next.setTwin(previousSideEdge);
      return this;
    },
    // Adds a vertex to the hull

    addVertexToHull: function (eyeVertex) {
      var horizon = [];
      this.unassigned.clear();

      // remove 'eyeVertex' from 'eyeVertex.face' so that it can't be added to the 'unassigned' vertex list

      this.removeVertexFromFace(eyeVertex, eyeVertex.face);
      this.computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon);
      this.addNewFaces(eyeVertex, horizon);

      // reassign 'unassigned' vertices to the new faces

      this.resolveUnassignedPoints(this.newFaces);
      return this;
    },
    cleanup: function () {
      this.assigned.clear();
      this.unassigned.clear();
      this.newFaces = [];
      return this;
    },
    compute: function () {
      var vertex;
      this.computeInitialHull();

      // add all available vertices gradually to the hull

      while ((vertex = this.nextVertexToAdd()) !== undefined) {
        this.addVertexToHull(vertex);
      }
      this.reindexFaces();
      this.cleanup();
      return this;
    }
  });

  //

  function Face() {
    this.normal = new _threeModule.Vector3();
    this.midpoint = new _threeModule.Vector3();
    this.area = 0;
    this.constant = 0; // signed distance from face to the origin
    this.outside = null; // reference to a vertex in a vertex list this face can see
    this.mark = Visible;
    this.edge = null;
  }
  Object.assign(Face, {
    create: function (a, b, c) {
      var face = new Face();
      var e0 = new HalfEdge(a, face);
      var e1 = new HalfEdge(b, face);
      var e2 = new HalfEdge(c, face);

      // join edges

      e0.next = e2.prev = e1;
      e1.next = e0.prev = e2;
      e2.next = e1.prev = e0;

      // main half edge reference

      face.edge = e0;
      return face.compute();
    }
  });
  Object.assign(Face.prototype, {
    getEdge: function (i) {
      var edge = this.edge;
      while (i > 0) {
        edge = edge.next;
        i--;
      }
      while (i < 0) {
        edge = edge.prev;
        i++;
      }
      return edge;
    },
    compute: function () {
      var triangle;
      return function compute() {
        if (triangle === undefined) triangle = new _threeModule.Triangle();
        var a = this.edge.tail();
        var b = this.edge.head();
        var c = this.edge.next.head();
        triangle.set(a.point, b.point, c.point);
        triangle.getNormal(this.normal);
        triangle.getMidpoint(this.midpoint);
        this.area = triangle.getArea();
        this.constant = this.normal.dot(this.midpoint);
        return this;
      };
    }(),
    distanceToPoint: function (point) {
      return this.normal.dot(point) - this.constant;
    }
  });

  // Entity for a Doubly-Connected Edge List (DCEL).

  function HalfEdge(vertex, face) {
    this.vertex = vertex;
    this.prev = null;
    this.next = null;
    this.twin = null;
    this.face = face;
  }
  Object.assign(HalfEdge.prototype, {
    head: function () {
      return this.vertex;
    },
    tail: function () {
      return this.prev ? this.prev.vertex : null;
    },
    length: function () {
      var head = this.head();
      var tail = this.tail();
      if (tail !== null) {
        return tail.point.distanceTo(head.point);
      }
      return -1;
    },
    lengthSquared: function () {
      var head = this.head();
      var tail = this.tail();
      if (tail !== null) {
        return tail.point.distanceToSquared(head.point);
      }
      return -1;
    },
    setTwin: function (edge) {
      this.twin = edge;
      edge.twin = this;
      return this;
    }
  });

  // A vertex as a double linked list node.

  function VertexNode(point) {
    this.point = point;
    this.prev = null;
    this.next = null;
    this.face = null; // the face that is able to see this vertex
  }

  // A double linked list that contains vertex nodes.

  function VertexList() {
    this.head = null;
    this.tail = null;
  }
  Object.assign(VertexList.prototype, {
    first: function () {
      return this.head;
    },
    last: function () {
      return this.tail;
    },
    clear: function () {
      this.head = this.tail = null;
      return this;
    },
    // Inserts a vertex before the target vertex

    insertBefore: function (target, vertex) {
      vertex.prev = target.prev;
      vertex.next = target;
      if (vertex.prev === null) {
        this.head = vertex;
      } else {
        vertex.prev.next = vertex;
      }
      target.prev = vertex;
      return this;
    },
    // Inserts a vertex after the target vertex

    insertAfter: function (target, vertex) {
      vertex.prev = target;
      vertex.next = target.next;
      if (vertex.next === null) {
        this.tail = vertex;
      } else {
        vertex.next.prev = vertex;
      }
      target.next = vertex;
      return this;
    },
    // Appends a vertex to the end of the linked list

    append: function (vertex) {
      if (this.head === null) {
        this.head = vertex;
      } else {
        this.tail.next = vertex;
      }
      vertex.prev = this.tail;
      vertex.next = null; // the tail has no subsequent vertex

      this.tail = vertex;
      return this;
    },
    // Appends a chain of vertices where 'vertex' is the head.

    appendChain: function (vertex) {
      if (this.head === null) {
        this.head = vertex;
      } else {
        this.tail.next = vertex;
      }
      vertex.prev = this.tail;

      // ensure that the 'tail' reference points to the last vertex of the chain

      while (vertex.next !== null) {
        vertex = vertex.next;
      }
      this.tail = vertex;
      return this;
    },
    // Removes a vertex from the linked list

    remove: function (vertex) {
      if (vertex.prev === null) {
        this.head = vertex.next;
      } else {
        vertex.prev.next = vertex.next;
      }
      if (vertex.next === null) {
        this.tail = vertex.prev;
      } else {
        vertex.next.prev = vertex.prev;
      }
      return this;
    },
    // Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b

    removeSubList: function (a, b) {
      if (a.prev === null) {
        this.head = b.next;
      } else {
        a.prev.next = b.next;
      }
      if (b.next === null) {
        this.tail = a.prev;
      } else {
        b.next.prev = a.prev;
      }
      return this;
    },
    isEmpty: function () {
      return this.head === null;
    }
  });
  return ConvexHull;
}();
exports.ConvexHull = ConvexHull;
},{"../../../build/three.module.js":"node_modules/three/build/three.module.js"}],"node_modules/three/examples/jsm/geometries/ConvexGeometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ConvexGeometry = void 0;
var _threeModule = require("../../../build/three.module.js");
var _ConvexHull = require("../math/ConvexHull.js");
// ConvexGeometry

var ConvexGeometry = function (points) {
  _threeModule.BufferGeometry.call(this);

  // buffers

  var vertices = [];
  var normals = [];
  if (_ConvexHull.ConvexHull === undefined) {
    console.error('THREE.ConvexBufferGeometry: ConvexBufferGeometry relies on ConvexHull');
  }
  var convexHull = new _ConvexHull.ConvexHull().setFromPoints(points);

  // generate vertices and normals

  var faces = convexHull.faces;
  for (var i = 0; i < faces.length; i++) {
    var face = faces[i];
    var edge = face.edge;

    // we move along a doubly-connected edge list to access all face points (see HalfEdge docs)

    do {
      var point = edge.head().point;
      vertices.push(point.x, point.y, point.z);
      normals.push(face.normal.x, face.normal.y, face.normal.z);
      edge = edge.next;
    } while (edge !== face.edge);
  }

  // build geometry

  this.setAttribute('position', new _threeModule.Float32BufferAttribute(vertices, 3));
  this.setAttribute('normal', new _threeModule.Float32BufferAttribute(normals, 3));
};
exports.ConvexGeometry = ConvexGeometry;
ConvexGeometry.prototype = Object.create(_threeModule.BufferGeometry.prototype);
ConvexGeometry.prototype.constructor = ConvexGeometry;
},{"../../../build/three.module.js":"node_modules/three/build/three.module.js","../math/ConvexHull.js":"node_modules/three/examples/jsm/math/ConvexHull.js"}],"node_modules/three/examples/jsm/utils/BufferGeometryUtils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BufferGeometryUtils = void 0;
var _threeModule = require("../../../build/three.module.js");
var BufferGeometryUtils = {
  computeTangents: function (geometry) {
    geometry.computeTangents();
    console.warn('THREE.BufferGeometryUtils: .computeTangents() has been removed. Use BufferGeometry.computeTangents() instead.');
  },
  /**
   * @param  {Array<BufferGeometry>} geometries
   * @param  {Boolean} useGroups
   * @return {BufferGeometry}
   */
  mergeBufferGeometries: function (geometries, useGroups) {
    var isIndexed = geometries[0].index !== null;
    var attributesUsed = new Set(Object.keys(geometries[0].attributes));
    var morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));
    var attributes = {};
    var morphAttributes = {};
    var morphTargetsRelative = geometries[0].morphTargetsRelative;
    var mergedGeometry = new _threeModule.BufferGeometry();
    var offset = 0;
    for (var i = 0; i < geometries.length; ++i) {
      var geometry = geometries[i];
      var attributesCount = 0;

      // ensure that all geometries are indexed, or none

      if (isIndexed !== (geometry.index !== null)) {
        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.');
        return null;
      }

      // gather attributes, exit early if they're different

      for (var name in geometry.attributes) {
        if (!attributesUsed.has(name)) {
          console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure "' + name + '" attribute exists among all geometries, or in none of them.');
          return null;
        }
        if (attributes[name] === undefined) attributes[name] = [];
        attributes[name].push(geometry.attributes[name]);
        attributesCount++;
      }

      // ensure geometries have the same number of attributes

      if (attributesCount !== attributesUsed.size) {
        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.');
        return null;
      }

      // gather morph attributes, exit early if they're different

      if (morphTargetsRelative !== geometry.morphTargetsRelative) {
        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.');
        return null;
      }
      for (var name in geometry.morphAttributes) {
        if (!morphAttributesUsed.has(name)) {
          console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.');
          return null;
        }
        if (morphAttributes[name] === undefined) morphAttributes[name] = [];
        morphAttributes[name].push(geometry.morphAttributes[name]);
      }

      // gather .userData

      mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];
      mergedGeometry.userData.mergedUserData.push(geometry.userData);
      if (useGroups) {
        var count;
        if (isIndexed) {
          count = geometry.index.count;
        } else if (geometry.attributes.position !== undefined) {
          count = geometry.attributes.position.count;
        } else {
          console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute');
          return null;
        }
        mergedGeometry.addGroup(offset, count, i);
        offset += count;
      }
    }

    // merge indices

    if (isIndexed) {
      var indexOffset = 0;
      var mergedIndex = [];
      for (var i = 0; i < geometries.length; ++i) {
        var index = geometries[i].index;
        for (var j = 0; j < index.count; ++j) {
          mergedIndex.push(index.getX(j) + indexOffset);
        }
        indexOffset += geometries[i].attributes.position.count;
      }
      mergedGeometry.setIndex(mergedIndex);
    }

    // merge attributes

    for (var name in attributes) {
      var mergedAttribute = this.mergeBufferAttributes(attributes[name]);
      if (!mergedAttribute) {
        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.');
        return null;
      }
      mergedGeometry.setAttribute(name, mergedAttribute);
    }

    // merge morph attributes

    for (var name in morphAttributes) {
      var numMorphTargets = morphAttributes[name][0].length;
      if (numMorphTargets === 0) break;
      mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};
      mergedGeometry.morphAttributes[name] = [];
      for (var i = 0; i < numMorphTargets; ++i) {
        var morphAttributesToMerge = [];
        for (var j = 0; j < morphAttributes[name].length; ++j) {
          morphAttributesToMerge.push(morphAttributes[name][j][i]);
        }
        var mergedMorphAttribute = this.mergeBufferAttributes(morphAttributesToMerge);
        if (!mergedMorphAttribute) {
          console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' morphAttribute.');
          return null;
        }
        mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);
      }
    }
    return mergedGeometry;
  },
  /**
   * @param {Array<BufferAttribute>} attributes
   * @return {BufferAttribute}
   */
  mergeBufferAttributes: function (attributes) {
    var TypedArray;
    var itemSize;
    var normalized;
    var arrayLength = 0;
    for (var i = 0; i < attributes.length; ++i) {
      var attribute = attributes[i];
      if (attribute.isInterleavedBufferAttribute) {
        console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported.');
        return null;
      }
      if (TypedArray === undefined) TypedArray = attribute.array.constructor;
      if (TypedArray !== attribute.array.constructor) {
        console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.');
        return null;
      }
      if (itemSize === undefined) itemSize = attribute.itemSize;
      if (itemSize !== attribute.itemSize) {
        console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.');
        return null;
      }
      if (normalized === undefined) normalized = attribute.normalized;
      if (normalized !== attribute.normalized) {
        console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.');
        return null;
      }
      arrayLength += attribute.array.length;
    }
    var array = new TypedArray(arrayLength);
    var offset = 0;
    for (var i = 0; i < attributes.length; ++i) {
      array.set(attributes[i].array, offset);
      offset += attributes[i].array.length;
    }
    return new _threeModule.BufferAttribute(array, itemSize, normalized);
  },
  /**
   * @param {Array<BufferAttribute>} attributes
   * @return {Array<InterleavedBufferAttribute>}
   */
  interleaveAttributes: function (attributes) {
    // Interleaves the provided attributes into an InterleavedBuffer and returns
    // a set of InterleavedBufferAttributes for each attribute
    var TypedArray;
    var arrayLength = 0;
    var stride = 0;

    // calculate the the length and type of the interleavedBuffer
    for (var i = 0, l = attributes.length; i < l; ++i) {
      var attribute = attributes[i];
      if (TypedArray === undefined) TypedArray = attribute.array.constructor;
      if (TypedArray !== attribute.array.constructor) {
        console.error('AttributeBuffers of different types cannot be interleaved');
        return null;
      }
      arrayLength += attribute.array.length;
      stride += attribute.itemSize;
    }

    // Create the set of buffer attributes
    var interleavedBuffer = new _threeModule.InterleavedBuffer(new TypedArray(arrayLength), stride);
    var offset = 0;
    var res = [];
    var getters = ['getX', 'getY', 'getZ', 'getW'];
    var setters = ['setX', 'setY', 'setZ', 'setW'];
    for (var j = 0, l = attributes.length; j < l; j++) {
      var attribute = attributes[j];
      var itemSize = attribute.itemSize;
      var count = attribute.count;
      var iba = new _threeModule.InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);
      res.push(iba);
      offset += itemSize;

      // Move the data for each attribute into the new interleavedBuffer
      // at the appropriate offset
      for (var c = 0; c < count; c++) {
        for (var k = 0; k < itemSize; k++) {
          iba[setters[k]](c, attribute[getters[k]](c));
        }
      }
    }
    return res;
  },
  /**
   * @param {Array<BufferGeometry>} geometry
   * @return {number}
   */
  estimateBytesUsed: function (geometry) {
    // Return the estimated memory used by this geometry in bytes
    // Calculate using itemSize, count, and BYTES_PER_ELEMENT to account
    // for InterleavedBufferAttributes.
    var mem = 0;
    for (var name in geometry.attributes) {
      var attr = geometry.getAttribute(name);
      mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;
    }
    var indices = geometry.getIndex();
    mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;
    return mem;
  },
  /**
   * @param {BufferGeometry} geometry
   * @param {number} tolerance
   * @return {BufferGeometry>}
   */
  mergeVertices: function (geometry, tolerance = 1e-4) {
    tolerance = Math.max(tolerance, Number.EPSILON);

    // Generate an index buffer if the geometry doesn't have one, or optimize it
    // if it's already available.
    var hashToIndex = {};
    var indices = geometry.getIndex();
    var positions = geometry.getAttribute('position');
    var vertexCount = indices ? indices.count : positions.count;

    // next value for triangle indices
    var nextIndex = 0;

    // attributes and new attribute arrays
    var attributeNames = Object.keys(geometry.attributes);
    var attrArrays = {};
    var morphAttrsArrays = {};
    var newIndices = [];
    var getters = ['getX', 'getY', 'getZ', 'getW'];

    // initialize the arrays
    for (var i = 0, l = attributeNames.length; i < l; i++) {
      var name = attributeNames[i];
      attrArrays[name] = [];
      var morphAttr = geometry.morphAttributes[name];
      if (morphAttr) {
        morphAttrsArrays[name] = new Array(morphAttr.length).fill().map(() => []);
      }
    }

    // convert the error tolerance to an amount of decimal places to truncate to
    var decimalShift = Math.log10(1 / tolerance);
    var shiftMultiplier = Math.pow(10, decimalShift);
    for (var i = 0; i < vertexCount; i++) {
      var index = indices ? indices.getX(i) : i;

      // Generate a hash for the vertex attributes at the current index 'i'
      var hash = '';
      for (var j = 0, l = attributeNames.length; j < l; j++) {
        var name = attributeNames[j];
        var attribute = geometry.getAttribute(name);
        var itemSize = attribute.itemSize;
        for (var k = 0; k < itemSize; k++) {
          // double tilde truncates the decimal value
          hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`;
        }
      }

      // Add another reference to the vertex if it's already
      // used by another index
      if (hash in hashToIndex) {
        newIndices.push(hashToIndex[hash]);
      } else {
        // copy data to the new index in the attribute arrays
        for (var j = 0, l = attributeNames.length; j < l; j++) {
          var name = attributeNames[j];
          var attribute = geometry.getAttribute(name);
          var morphAttr = geometry.morphAttributes[name];
          var itemSize = attribute.itemSize;
          var newarray = attrArrays[name];
          var newMorphArrays = morphAttrsArrays[name];
          for (var k = 0; k < itemSize; k++) {
            var getterFunc = getters[k];
            newarray.push(attribute[getterFunc](index));
            if (morphAttr) {
              for (var m = 0, ml = morphAttr.length; m < ml; m++) {
                newMorphArrays[m].push(morphAttr[m][getterFunc](index));
              }
            }
          }
        }
        hashToIndex[hash] = nextIndex;
        newIndices.push(nextIndex);
        nextIndex++;
      }
    }

    // Generate typed arrays from new attribute arrays and update
    // the attributeBuffers
    const result = geometry.clone();
    for (var i = 0, l = attributeNames.length; i < l; i++) {
      var name = attributeNames[i];
      var oldAttribute = geometry.getAttribute(name);
      var buffer = new oldAttribute.array.constructor(attrArrays[name]);
      var attribute = new _threeModule.BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);
      result.setAttribute(name, attribute);

      // Update the attribute arrays
      if (name in morphAttrsArrays) {
        for (var j = 0; j < morphAttrsArrays[name].length; j++) {
          var oldMorphAttribute = geometry.morphAttributes[name][j];
          var buffer = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);
          var morphAttribute = new _threeModule.BufferAttribute(buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);
          result.morphAttributes[name][j] = morphAttribute;
        }
      }
    }

    // indices

    result.setIndex(newIndices);
    return result;
  },
  /**
   * @param {BufferGeometry} geometry
   * @param {number} drawMode
   * @return {BufferGeometry>}
   */
  toTrianglesDrawMode: function (geometry, drawMode) {
    if (drawMode === _threeModule.TrianglesDrawMode) {
      console.warn('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.');
      return geometry;
    }
    if (drawMode === _threeModule.TriangleFanDrawMode || drawMode === _threeModule.TriangleStripDrawMode) {
      var index = geometry.getIndex();

      // generate index if not present

      if (index === null) {
        var indices = [];
        var position = geometry.getAttribute('position');
        if (position !== undefined) {
          for (var i = 0; i < position.count; i++) {
            indices.push(i);
          }
          geometry.setIndex(indices);
          index = geometry.getIndex();
        } else {
          console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');
          return geometry;
        }
      }

      //

      var numberOfTriangles = index.count - 2;
      var newIndices = [];
      if (drawMode === _threeModule.TriangleFanDrawMode) {
        // gl.TRIANGLE_FAN

        for (var i = 1; i <= numberOfTriangles; i++) {
          newIndices.push(index.getX(0));
          newIndices.push(index.getX(i));
          newIndices.push(index.getX(i + 1));
        }
      } else {
        // gl.TRIANGLE_STRIP

        for (var i = 0; i < numberOfTriangles; i++) {
          if (i % 2 === 0) {
            newIndices.push(index.getX(i));
            newIndices.push(index.getX(i + 1));
            newIndices.push(index.getX(i + 2));
          } else {
            newIndices.push(index.getX(i + 2));
            newIndices.push(index.getX(i + 1));
            newIndices.push(index.getX(i));
          }
        }
      }
      if (newIndices.length / 3 !== numberOfTriangles) {
        console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');
      }

      // build final geometry

      var newGeometry = geometry.clone();
      newGeometry.setIndex(newIndices);
      newGeometry.clearGroups();
      return newGeometry;
    } else {
      console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode);
      return geometry;
    }
  },
  /**
   * Calculates the morphed attributes of a morphed/skinned BufferGeometry.
   * Helpful for Raytracing or Decals.
   * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.
   * @return {Object} An Object with original position/normal attributes and morphed ones.
   */
  computeMorphedAttributes: function (object) {
    if (object.geometry.isBufferGeometry !== true) {
      console.error('THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.');
      return null;
    }
    var _vA = new _threeModule.Vector3();
    var _vB = new _threeModule.Vector3();
    var _vC = new _threeModule.Vector3();
    var _tempA = new _threeModule.Vector3();
    var _tempB = new _threeModule.Vector3();
    var _tempC = new _threeModule.Vector3();
    var _morphA = new _threeModule.Vector3();
    var _morphB = new _threeModule.Vector3();
    var _morphC = new _threeModule.Vector3();
    function _calculateMorphedAttributeData(object, material, attribute, morphAttribute, morphTargetsRelative, a, b, c, modifiedAttributeArray) {
      _vA.fromBufferAttribute(attribute, a);
      _vB.fromBufferAttribute(attribute, b);
      _vC.fromBufferAttribute(attribute, c);
      var morphInfluences = object.morphTargetInfluences;
      if (material.morphTargets && morphAttribute && morphInfluences) {
        _morphA.set(0, 0, 0);
        _morphB.set(0, 0, 0);
        _morphC.set(0, 0, 0);
        for (var i = 0, il = morphAttribute.length; i < il; i++) {
          var influence = morphInfluences[i];
          var morphAttribute = morphAttribute[i];
          if (influence === 0) continue;
          _tempA.fromBufferAttribute(morphAttribute, a);
          _tempB.fromBufferAttribute(morphAttribute, b);
          _tempC.fromBufferAttribute(morphAttribute, c);
          if (morphTargetsRelative) {
            _morphA.addScaledVector(_tempA, influence);
            _morphB.addScaledVector(_tempB, influence);
            _morphC.addScaledVector(_tempC, influence);
          } else {
            _morphA.addScaledVector(_tempA.sub(_vA), influence);
            _morphB.addScaledVector(_tempB.sub(_vB), influence);
            _morphC.addScaledVector(_tempC.sub(_vC), influence);
          }
        }
        _vA.add(_morphA);
        _vB.add(_morphB);
        _vC.add(_morphC);
      }
      if (object.isSkinnedMesh) {
        object.boneTransform(a, _vA);
        object.boneTransform(b, _vB);
        object.boneTransform(c, _vC);
      }
      modifiedAttributeArray[a * 3 + 0] = _vA.x;
      modifiedAttributeArray[a * 3 + 1] = _vA.y;
      modifiedAttributeArray[a * 3 + 2] = _vA.z;
      modifiedAttributeArray[b * 3 + 0] = _vB.x;
      modifiedAttributeArray[b * 3 + 1] = _vB.y;
      modifiedAttributeArray[b * 3 + 2] = _vB.z;
      modifiedAttributeArray[c * 3 + 0] = _vC.x;
      modifiedAttributeArray[c * 3 + 1] = _vC.y;
      modifiedAttributeArray[c * 3 + 2] = _vC.z;
    }
    var geometry = object.geometry;
    var material = object.material;
    var a, b, c;
    var index = geometry.index;
    var positionAttribute = geometry.attributes.position;
    var morphPosition = geometry.morphAttributes.position;
    var morphTargetsRelative = geometry.morphTargetsRelative;
    var normalAttribute = geometry.attributes.normal;
    var morphNormal = geometry.morphAttributes.position;
    var groups = geometry.groups;
    var drawRange = geometry.drawRange;
    var i, j, il, jl;
    var group, groupMaterial;
    var start, end;
    var modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);
    var modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);
    if (index !== null) {
      // indexed buffer geometry

      if (Array.isArray(material)) {
        for (i = 0, il = groups.length; i < il; i++) {
          group = groups[i];
          groupMaterial = material[group.materialIndex];
          start = Math.max(group.start, drawRange.start);
          end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
          for (j = start, jl = end; j < jl; j += 3) {
            a = index.getX(j);
            b = index.getX(j + 1);
            c = index.getX(j + 2);
            _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);
            _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);
          }
        }
      } else {
        start = Math.max(0, drawRange.start);
        end = Math.min(index.count, drawRange.start + drawRange.count);
        for (i = start, il = end; i < il; i += 3) {
          a = index.getX(i);
          b = index.getX(i + 1);
          c = index.getX(i + 2);
          _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);
          _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);
        }
      }
    } else if (positionAttribute !== undefined) {
      // non-indexed buffer geometry

      if (Array.isArray(material)) {
        for (i = 0, il = groups.length; i < il; i++) {
          group = groups[i];
          groupMaterial = material[group.materialIndex];
          start = Math.max(group.start, drawRange.start);
          end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
          for (j = start, jl = end; j < jl; j += 3) {
            a = j;
            b = j + 1;
            c = j + 2;
            _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);
            _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);
          }
        }
      } else {
        start = Math.max(0, drawRange.start);
        end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
        for (i = start, il = end; i < il; i += 3) {
          a = i;
          b = i + 1;
          c = i + 2;
          _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);
          _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);
        }
      }
    }
    var morphedPositionAttribute = new _threeModule.Float32BufferAttribute(modifiedPosition, 3);
    var morphedNormalAttribute = new _threeModule.Float32BufferAttribute(modifiedNormal, 3);
    return {
      positionAttribute: positionAttribute,
      normalAttribute: normalAttribute,
      morphedPositionAttribute: morphedPositionAttribute,
      morphedNormalAttribute: morphedNormalAttribute
    };
  }
};
exports.BufferGeometryUtils = BufferGeometryUtils;
},{"../../../build/three.module.js":"node_modules/three/build/three.module.js"}],"src/index.js":[function(require,module,exports) {
"use strict";

var THREE = _interopRequireWildcard(require("three"));
var _result = _interopRequireDefault(require("../result.json"));
var _OrbitControls = require("three/examples/jsm/controls/OrbitControls");
var _ConvexGeometry = require("three/examples/jsm/geometries/ConvexGeometry");
var BufferGeometryUtils = _interopRequireWildcard(require("three/examples/jsm/utils/BufferGeometryUtils"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var group, camera, scene, renderer;
init();
animate();
function RandomColor() {
  var r = Math.floor(Math.random() * 255);
  var g = Math.floor(Math.random() * 255);
  var b = Math.floor(Math.random() * 255);
  return "rgb(".concat(r, ",").concat(g, ",").concat(b, ")");
}
function init() {
  scene = new THREE.Scene();
  renderer = new THREE.WebGLRenderer({
    antialias: true
  });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.useLegacyLights = false;
  document.body.appendChild(renderer.domElement);

  // camera

  camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 1000);
  camera.position.set(15, 20, 30);
  scene.add(camera);

  // controls

  var controls = new _OrbitControls.OrbitControls(camera, renderer.domElement);
  controls.minDistance = 20;
  controls.maxDistance = 50;
  controls.maxPolarAngle = Math.PI / 2;

  // ambient light

  scene.add(new THREE.AmbientLight(0x666666));

  // point light

  var light = new THREE.PointLight(0xffffff, 3, 0, 0);
  camera.add(light);

  // helper
  scene.add(new THREE.AxesHelper(20));
  for (var i = 0; i < _result.default.data.length; i++) {
    var points = [];
    var x = _result.default.data[i][0] / 200;
    var y = _result.default.data[i][1] / 200;
    var z1 = _result.default.data[i][2] / 200;
    var z2 = _result.default.data[i][3] / 200;
    // 将数据保存到 points 中,不要将线和线之间的点连起来
    points.push(new THREE.Vector3(x, 0, y));
    points.push(new THREE.Vector3(x, z2 - z1, y));
    // material
    var material = new THREE.LineBasicMaterial({
      color: RandomColor()
    });
    // geometry
    var geometry = new THREE.BufferGeometry().setFromPoints(points);
    var line = new THREE.Line(geometry, material);
    scene.add(line);
  }
  window.addEventListener('resize', onWindowResize);
}
function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}
function animate() {
  requestAnimationFrame(animate);
  render();
}
function render() {
  renderer.render(scene, camera);
}
},{"three":"node_modules/three/build/three.module.js","../result.json":"result.json","three/examples/jsm/controls/OrbitControls":"node_modules/three/examples/jsm/controls/OrbitControls.js","three/examples/jsm/geometries/ConvexGeometry":"node_modules/three/examples/jsm/geometries/ConvexGeometry.js","three/examples/jsm/utils/BufferGeometryUtils":"node_modules/three/examples/jsm/utils/BufferGeometryUtils.js"}],"node_modules/parcel-bundler/src/builtins/hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}
module.bundle.Module = Module;
var checkedAssets, assetsToAccept;
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = "" || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + "7926" + '/');
  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    var data = JSON.parse(event.data);
    if (data.type === 'update') {
      var handled = false;
      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);
          if (didAccept) {
            handled = true;
          }
        }
      });

      // Enable HMR for CSS by default.
      handled = handled || data.assets.every(function (asset) {
        return asset.type === 'css' && asset.generated.js;
      });
      if (handled) {
        console.clear();
        data.assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });
        assetsToAccept.forEach(function (v) {
          hmrAcceptRun(v[0], v[1]);
        });
      } else if (location.reload) {
        // `location` global exists in a web worker context but lacks `.reload()` function.
        location.reload();
      }
    }
    if (data.type === 'reload') {
      ws.close();
      ws.onclose = function () {
        location.reload();
      };
    }
    if (data.type === 'error-resolved') {
      console.log('[parcel] ✨ Error resolved');
      removeErrorOverlay();
    }
    if (data.type === 'error') {
      console.error('[parcel] 🚨  ' + data.error.message + '\n' + data.error.stack);
      removeErrorOverlay();
      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}
function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);
  if (overlay) {
    overlay.remove();
  }
}
function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID;

  // html encode message and stack trace
  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;">🚨</span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';
  return overlay;
}
function getParents(bundle, id) {
  var modules = bundle.modules;
  if (!modules) {
    return [];
  }
  var parents = [];
  var k, d, dep;
  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];
      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }
  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }
  return parents;
}
function hmrApply(bundle, asset) {
  var modules = bundle.modules;
  if (!modules) {
    return;
  }
  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}
function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;
  if (!modules) {
    return;
  }
  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }
  if (checkedAssets[id]) {
    return;
  }
  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);
  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }
  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAcceptCheck(global.parcelRequire, id);
  });
}
function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};
  if (cached) {
    cached.hot.data = bundle.hotData;
  }
  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }
  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];
  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });
    return true;
  }
}
},{}]},{},["node_modules/parcel-bundler/src/builtins/hmr-runtime.js","src/index.js"], null)
//# sourceMappingURL=/src.a2b27638.js.map